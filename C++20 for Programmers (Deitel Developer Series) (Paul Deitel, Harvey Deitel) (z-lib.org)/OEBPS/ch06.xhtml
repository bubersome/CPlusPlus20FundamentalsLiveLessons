<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch06">Chapter 6. <code>array</code>s, <code>vector</code>s, C++20 Ranges and Functional-Style Programming</h2>&#13;
<div class="image"><img src="Images/f0195-01.jpg" alt="Images" width="414" height="524"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Use C++ standard library class template <code>array</code>—a fixed-size collection of related, indexable data items.</p>&#13;
<p class="squ"><span class="red">■</span> Declare <code>array</code>s, initialize <code>array</code>s and refer to the elements of <code>array</code>s.</p>&#13;
<p class="squ"><span class="red">■</span> Use the range-based <code>for</code> statement to reduce iteration errors.</p>&#13;
<p class="squ"><span class="red">■</span> Pass <code>array</code>s to functions.</p>&#13;
<p class="squ"><span class="red">■</span> Sort <code>array</code> elements in ascending or descending order.</p>&#13;
<p class="squ"><span class="red">■</span> Quickly locate an element in a sorted <code>array</code> using the high-performance <code>binary_search</code> function.</p>&#13;
<p class="squ"><span class="red">■</span> Declare and manipulate multidimensional <code>array</code>s.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++20’s ranges with functional-style programming.</p>&#13;
<p class="squ"><span class="red">■</span> Continue our objects-natural approach with a case study using the C++ standard library’s class template <code>vector—</code>a variable-size collection of related data items.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec1"><span class="violet"><strong>6.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec2"><span class="violet"><strong>6.2</strong></span> <code>array</code>s</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec3"><span class="violet"><strong>6.3</strong></span> Declaring <code>array</code>s</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec4"><span class="violet"><strong>6.4</strong></span> Initializing <code>array</code> Elements in a Loop</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec5"><span class="violet"><strong>6.5</strong></span> Initializing an <code>array</code> with an Initializer List</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec6"><span class="violet"><strong>6.6</strong></span> C++11 Range-Based <code>for</code> and C++20 Range-Based <code>for</code> with Initializer</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec7"><span class="violet"><strong>6.7</strong></span> Setting <code>array</code> Elements with Calculations; Introducing <code>constexpr</code></a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec8"><span class="violet"><strong>6.8</strong></span> Totaling <code>array</code> Elements</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec9"><span class="violet"><strong>6.9</strong></span> Using a Primitive Bar Chart to Display <code>array</code> Data Graphically</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec10"><span class="violet"><strong>6.10</strong></span> Using <code>array</code> Elements as Counters</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec11"><span class="violet"><strong>6.11</strong></span> Using <code>array</code>s to Summarize Survey Results</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec12"><span class="violet"><strong>6.12</strong></span> Sorting and Searching <code>array</code>s</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec13"><span class="violet"><strong>6.13</strong></span> Multidimensional <code>array</code>s</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec14"><span class="violet"><strong>6.14</strong></span> Intro to Functional-Style Programming</a></p>&#13;
<p class="chap-lev2"><a href="ch06.xhtml#ch06lev2sec1">6.14.1 What vs. How</a></p>&#13;
<p class="chap-lev2"><a href="ch06.xhtml#ch06lev2sec2">6.14.2 Passing Functions as Arguments to Other Functions—Introducing Lambda Expressions</a></p>&#13;
<p class="chap-lev2"><a href="ch06.xhtml#ch06lev2sec3">6.14.3 Filter, Map and Reduce: Intro to C++20’s Ranges Library</a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec15"><span class="violet"><strong>6.15</strong></span> Objects Natural Case Study: C++ Standard Library Class Template <code>vector</code></a></p>&#13;
<p class="chap-lev1"><a href="ch06.xhtml#ch06lev1sec16"><span class="violet"><strong>6.16</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec1"><span class="violet">6.1</span> Introduction</h3>&#13;
<p>This chapter introduces <span class="violet"><strong>data structures</strong></span>—collections of related data items. The C++ standard library refers to data structures as <span class="violet"><strong>containers.</strong></span> We discuss two containers consisting of data items of the same type:</p>&#13;
<p class="bull">• fixed-size <span class="violet"><strong><code>array</code>s</strong></span> and</p>&#13;
<p class="bull">• resizable <span class="violet"><strong><code>vector</code>s</strong></span> that can grow and shrink dynamically at execution time.</p>&#13;
<p>To use them, you must include the <code>&lt;array&gt;</code> and <code>&lt;vector&gt;</code> headers, respectively.</p>&#13;
<p>After discussing how <code>array</code>s are declared, created and initialized, we demonstrate various <code>array</code> manipulations. We show how to search <code>array</code>s to find particular items and sort <code>array</code>s to put their data in ascending or descending order. We show that attempting to access data that is not within an <code>array</code>’s or <code>vector</code>’s bounds causes an exception—a runtime indication that a problem occurred. Then we use exception handling to resolve (or handle) that exception. <a href="ch15.xhtml#ch15">Chapter 15</a> covers exceptions in more depth.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> Like many modern languages, C++ offers "functional-style" programming features. These can help you write more concise code that’s less likely to contain errors and easier to read, debug and modify. Functional-style programs also can be easier to parallelize to get better performance on today’s multi-core processors. We introduce functional-style programming with C++20’s new <code>&lt;ranges&gt;</code> library. Finally, we continue our objects natural presentation with a case study that creates and manipulates objects of the C++ standard library’s class template <code>vector.</code> After reading this chapter, you’ll be familiar with two array-like collections—<code>array</code>s and <code>vectors.</code></p>&#13;
<h3 class="h3" id="ch06lev1sec2"><span class="violet">6.2</span> <code>array</code>s</h3>&#13;
<p>An <code>array</code>’s <span class="violet"><strong>elements</strong></span> (data items) are arranged contiguously in memory. The following diagram shows an integer <code>array</code> called <code>c</code> that contains five elements:</p>&#13;
<div class="group">&#13;
<div class="images"><img src="Images/f0197-01.jpg" alt="Images" width="650" height="147"/></div>&#13;
</div>&#13;
<p>One way to refer to an <code>array</code> element is to specify the <code>array</code> <span class="violet"><strong>name</strong></span> followed by the element’s <span class="violet"><strong>position number</strong></span> in square brackets (<code>[]</code>). The position number is more formally called an <span class="violet"><strong>index</strong></span> or <span class="violet"><strong>subscript.</strong></span> The first element has the index <code>0</code> (zero). Thus, the elements of <code>array c</code> are <code>c[0]</code> (pronounced <code>"c</code> sub zero") through <code>c[4].</code> The <span class="violet"><strong>value</strong></span> of <code>c[0]</code> is <code>-45, c[2]</code> is <code>0</code> and <code>c[4]</code> is <code>1543.</code></p>&#13;
<p>The highest index (in this case, 4) is always one less than the <code>array</code>’s number of elements (in this case, 5). Each <code>array</code> knows its own size, which you can get via its <span class="violet"><strong><code>size</code></strong></span> member function, as in</p>&#13;
<pre class="pre">c.size()</pre>&#13;
<p>An index must be an integer or integer expression. An indexed <code>array</code> name is an <em>lvalue—</em>it can be used on the left side of an assignment, just as non<code>-array</code> variable names can. For example, the following statement replaces <code>c[4]</code>’s value:</p>&#13;
<pre class="pre">c[<span class="green">4</span>] = <span class="green">87</span>;</pre>&#13;
<p>The brackets that enclose an index are an operator with the same precedence as a function call’s parentheses. See <a href="app01.xhtml#app01">Appendix A</a> for the complete operator precedence chart.</p>&#13;
<h3 class="h3" id="ch06lev1sec3"><span class="violet">6.3</span> Declaring <code>array</code>s</h3>&#13;
<p><code>array</code>s occupy space in memory. To specify an <code>array</code>’s element type and number of elements, use a declaration of the form</p>&#13;
<p class="indent"><code>array</code>&lt;<em>type, arraySize&gt; arrayName;</em></p>&#13;
<p>The notation <em>&lt;type, arraySize&gt;</em> indicates that <code>array</code> is a <em>class template.</em> Like function templates, the compiler can use class templates to create many <strong>class template specializations</strong> for various types—such as an <code>array</code> of <code>int</code>s, an <code>array</code> of <code>double</code>s or an <code>array</code> of <code>Employee</code>s. You’ll begin creating custom types in <a href="ch10.xhtml#ch10">Chapter 10</a>. The compiler reserves the appropriate amount of memory, based on the <em>type</em> and <em>arraySize.</em> To tell the compiler to reserve five elements for integer array <code>c,</code> use the declaration:</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0161-01" id="f0161-01a">Click here to view code image</a></p>&#13;
<pre class="pre">array&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; c; <span class="pd_green">// c is an array of 5 int values</span></pre>&#13;
<h3 class="h3" id="ch06lev1sec4"><span class="violet">6.4</span> Initializing <code>array</code> Elements in a Loop</h3>&#13;
<p>The program in <a href="ch06.xhtml#fig6_1">Fig. 6.1</a> declares five-element integer <code>array n</code> (line 9). Line 5 includes the <code>&lt;array&gt;</code> header, which contains the definition of class template <code>array.</code></p>&#13;
<div class="group" id="fig6_1">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig01" id="aa06fig01">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>  <code><span class="pd_green">// fig06_01.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>  <code><span class="pd_green">// Initializing an array's elements to zeros and printing the array.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>  <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// C++20: This will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>4</strong></span>  <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>  <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>  <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>  <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>     <code>array&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; n; <span class="pd_green">// n is an array of 5 int values</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>     <code><span class="pd_green">// initialize elements of array n to 0</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>     <code><span class="yell"><span class="blue">for</span> (<span class="blue">size_t</span> i{<span class="green">0</span>}; i &lt; n.size(); ++i) {        </span></code>&#13;
<span class="cviolet"><strong>13</strong></span>     <span class="yell">   <code>n[i] = <span class="green">0</span>; <span class="pd_green">// set element at location i to 0</span></code></span>&#13;
<span class="cviolet"><strong>14</strong></span>     <span class="yell"><code>}</code>                                             </span>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>     <code>cout &lt;&lt; fmt::format(<span class="green">"{}{:&gt;10}\n"</span>, <span class="green">"Element"</span>, <span class="green">"Value"</span>);</code>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>     <code><span class="pd_green">// output each array element's value</span></code>&#13;
<span class="cviolet"><strong>19</strong></span>     <span class="yell"><code><span class="blue">for</span> (<span class="blue">size_t</span> i{<span class="green">0</span>}; i &lt; n.size(); ++i) {</code>        </span>&#13;
<span class="cviolet"><strong>20</strong></span>     <span class="yell"><code>cout &lt;&lt; fmt::format(<span class="green">"{:</span><span class="green">&gt;7}{:&gt;10}\n", i</span>, n[i]);</code></span>&#13;
<span class="cviolet"><strong>21</strong></span>     <span class="yell"><code>}</code>                                             </span>&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>     <code>cout &lt;&lt; <span class="green">"\nElement"</span> &lt;&lt; setw(<span class="green">10</span>) &lt;&lt; <span class="green">"Value"</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>     <code><span class="pd_green">// access elements via the at member function</span></code>&#13;
<span class="cviolet"><strong>26</strong></span>     <code><span class="blue">for</span> (size_t i{<span class="green">0</span>}; i &lt; n.size(); ++i) {</code>&#13;
<span class="cviolet"><strong>27</strong></span>     <code>   cout &lt;&lt; fmt::format("{:<span class="green">&gt;7}{:&gt;10}\n"</span>, i, <span class="yell">n.at(i)</span>);</code>&#13;
<span class="cviolet"><strong>28</strong></span>     <code>}</code>&#13;
<span class="cviolet"><strong>29</strong></span>&#13;
<span class="cviolet"><strong>30</strong></span>     <code><span class="pd_green">// accessing an element outside the array's bounds with at</span></code>&#13;
<span class="cviolet"><strong>31</strong></span>     <code>cout &lt;&lt; n.at(<span class="green">10</span>) &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>32</strong></span>  <code>}</code></pre>&#13;
<pre class="pre1"><code>Element Value</code>&#13;
<code>      0     0</code>&#13;
<code>      1     0</code>&#13;
<code>      2     0</code>&#13;
<code>      3     0</code>&#13;
<code>      4     0</code>&#13;
<code>Element Value</code>&#13;
<code>      0     0</code>&#13;
<code>      1     0</code>&#13;
<code>      2     0</code>&#13;
<code>      3     0</code>&#13;
<code>      4     0</code>&#13;
<code>terminate called after throwing an instance of 'std::out_of_range'</code>&#13;
<code>  what(): array::at: __n (which is 10) &gt;= _Nm (which is 5)</code>&#13;
<code>Aborted</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.1</strong></span> Initializing an <code>array</code>’s elements to zeros and printing the <code>array.</code></p>&#13;
</div>&#13;
<h5 class="h5" id="ch06lev3sec1">Assigning Values to <code>array</code> Elements in a Loop</h5>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> Lines 12—14 use a <code>for</code> statement to assign <code>0</code> to each <code>array</code> element. Like other non<code>-static</code> local variables, <code>array</code> elements are not implicitly initialized to zero <code>(static array</code>s are). In a loop that processes <code>array</code> elements, ensure that the loop-termination condition prevents accessing elements outside the array’s bounds. In <a href="ch06.xhtml#ch06lev1sec6">Section 6.6</a>, we present the range-based <code>for</code> statement, which provides a safer way to process every element of an <code>array.</code></p>&#13;
<h5 class="h5" id="ch06lev3sec2">Type <code>size_t</code></h5>&#13;
<p>Lines 12, 19 and 26 declare each loop’s control variable as type <span class="violet"><strong><code>size_t.</code></strong></span> The C++ standard specifies that <code>size_t</code> is an unsigned integral type. Use this type for any variable that represents an <code>array</code>’s size or subscripts. Type <code>size_t</code> is defined in the <code>std</code> namespace and is in header <code>&lt;cstddef&gt;,</code> which typically is included for you by other standard library headers that use <code>size_t.</code> If you compile a program that uses type <code>size_t</code> and receive errors indicating that it’s not defined, simply add <code>#include &lt;cstddef&gt;</code> to your program.</p>&#13;
<h5 class="h5" id="ch06lev3sec3">Displaying the <code>array</code> Elements</h5>&#13;
<p><span class="size">20</span> The first output statement<sup><a id="rch06fn1" href="ch06.xhtml#ch06fn1">1</a></sup> (line 16) displays the column headings for the columns printed in the subsequent <code>for</code> statement (lines 19-21). These output statements use C++20 textformatting features introduced in <a href="ch04.xhtml#ch04lev1sec15">Section 4.15</a> to output the <code>array</code> in tabular format.</p>&#13;
<p class="footnote"><a id="ch06fn1" href="ch06.xhtml#rch06fn1">1</a>. At the time of this writing, C++20’s <code>&lt;format&gt;</code> header is not implemented by the three compilers we use, so several of this chapter’s examples use the <code>{fmt}</code> library. Once the <code>&lt;format&gt;</code> header is available, you can replace <code>"fmt/format.h"</code> with <code>&lt;format&gt;</code> and remove the <code>fmt::</code> before each <code>format</code> call.</p>&#13;
<h5 class="h5" id="ch06lev3sec4">Avoiding a Security Vulnerability: Bounds Checking for <code>array</code> Subscripts</h5>&#13;
<p>When you use the <code>[]</code> operator to access an array element (as in lines 12-14 and 19-21), Security C++ provides no automatic array <span class="violet"><strong>bounds checking</strong></span> to prevent you from referring to an element that does not exist. Thus, an executing program can “walk off” either end of an <code>array</code> without warning. Class template <code>array</code>’s <span class="violet"><strong><code>at</code> member function</strong></span> performs bounds checking. Lines 26-28 demonstrate accessing elements’ values via the <code>at</code> member function. You also can assign to <code>array</code> elements by using <code>at</code> on the left side of an assignment, as in:</p>&#13;
<pre class="pre">n.at(<span class="green">0</span>) = <span class="green">10</span>;</pre>&#13;
<p>Line 31 demonstrates accessing an element outside the <code>array</code>’s bounds. When member function <code>at</code> encounters an out-of-bounds subscript, it generates a runtime error known as an <span class="violet"><strong>exception.</strong></span> In this program, which we compiled with GNU <code>g++</code> and ran on Linux, line 31 resulted in the runtime error message:</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0163-01" id="f0163-01a">Click here to view code image</a></p>&#13;
<pre class="pre">terminate called after throwing an instance of 'std::out_of_range'&#13;
  what(): array::at: __n (which is 10) &gt;= _Nm (which is 5)&#13;
Aborted</pre>&#13;
<p>then the program terminated. This error message indicates that the <code>at</code> member function <code>(array::at)</code> checks whether a variable named	<code>__n</code> (which is <code>10</code>) is greater than or equal to a variable named <code>_Nm</code> (which is <code>5</code>). In this case, the subscript is out of bounds. In GNU’s implementation of <code>array</code>’s <code>at</code> member function,	<code>__n</code> represents the element’s subscript, and <code>_Nm</code> represents the <code>array</code>’s size. <a href="ch06.xhtml#ch06lev1sec15">Section 6.15</a> introduces how to use exception handling to deal with such runtime errors. <a href="ch15.xhtml#ch15">Chapter 15</a> covers exception handing in depth.</p>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> Allowing programs to read from or write to <code>array</code> elements outside the bounds of <code>array</code>s are common security flaws. Reading from out-of-bounds <code>array</code> elements can cause a program to crash or even appear to execute correctly while using bad data. Writing to an out-of-bounds element (known as a buffer overflow<sup><a id="rch06fn2" href="ch06.xhtml#ch06fn2">2</a></sup>) can corrupt a program’s data in memory and crash a program. In some cases, attackers can exploit buffer overflows by overwriting the program’s executable code with malicious code.</p>&#13;
<p class="footnote"><a id="ch06fn2" href="ch06.xhtml#rch06fn2">2</a>. For more information on buffer overflows, see <code><a href="http://en.wikipedia.org/wiki/Buffer_overflow">http://en.wikipedia.org/wiki/Buffer_overflow</a></code>.</p>&#13;
<h3 class="h3" id="ch06lev1sec5"><span class="violet">6.5</span> Initializing an <code>array</code> with an Initializer List</h3>&#13;
<p>The elements of an <code>array</code> also can be initialized in the <code>array</code> declaration by following the <code>array</code> name with a brace-delimited comma-separated list of <span class="violet"><strong>initializers.</strong></span> The program in <a href="ch06.xhtml#fig6_2">Fig. 6.2</a> uses an <span class="violet"><strong>initializer list</strong></span> to initialize an integer <code>array</code> with five values (line 9) then displays the <code>array</code>’s contents.</p>&#13;
<div class="group" id="fig6_2">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig02" id="aa06fig02">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>   <code><span class="pd_green">// fig06_02.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>   <code><span class="pd_green">// Initializing an array in a declaration.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>   <code><span class="blue">#include</span> &lt;iomanip&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>   <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>   <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>      <span class="yell"><code>array&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; n{<span class="green">32</span>, <span class="green">27</span>, <span class="green">64</span>, <span class="green">18</span>, <span class="green">95</span>};</code></span> <code><span class="pd_green">// list initializer</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>     <code><span class="pd_green">// output each array element's value</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>     <code><span class="blue">for</span> (size_t i{<span class="green">0</span>}; i &lt; n.size(); ++i) {</code>&#13;
<span class="cviolet"><strong>13</strong></span>        <code>cout &lt;&lt; n.at(i) &lt;&lt; <span class="green">" "</span>;</code>&#13;
<span class="cviolet"><strong>14</strong></span>     <code>}</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>     <code>cout &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>17</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1"><code>32 27 64 18 95</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.2</strong></span> Initializing an <code>array</code> in a declaration.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch06lev3sec5">Fewer Initializers Than <code>array</code> Elements</h5>&#13;
<p>If there are fewer initializers than <code>array</code> elements, the remaining <code>array</code> elements are initialized to zero. For example, the following initializes an <code>array</code>’s elements to zero</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0164-01a" id="f0164-01aa">Click here to view code image</a></p>&#13;
<pre class="pre">array&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; n{}; <span class="pd_green">// initialize elements of array n to 0</span></pre>&#13;
<p>because there are fewer initializers (none in this case) than <code>array</code> elements. This technique can be used only in the <code>array</code>’s declaration, whereas the initialization technique shown in <a href="ch06.xhtml#fig6_1">Fig. 6.1</a> can be used repeatedly to “reinitialize” an <code>array</code>’s elements at execution time.</p>&#13;
<h5 class="h5" id="ch06lev3sec6">More Initializers Than <code>array</code> Elements</h5>&#13;
<p>The number of initializers in an <code>array</code>’s initializer list must be less than or equal to the <code>array</code> size. The <code>array</code> declaration</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0164-01" id="f0164-01a">Click here to view code image</a></p>&#13;
<pre class="pre">array&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; n{<span class="green">32</span>, <span class="green">27</span>, <span class="green">64</span>, <span class="green">18</span>, <span class="green">95</span>, <span class="green">14</span>};</pre>&#13;
<p>causes a compilation error, because there are six initializers and only five <code>array</code> elements.</p>&#13;
<h3 class="h3" id="ch06lev1sec6"><span class="violet">6.6</span> C++11 Range-Based <code>for</code> and C++20 Range-Based <code>for</code> with Initializer</h3>&#13;
<p><span class="size">11</span> It’s common to process all the elements of an <code>array.</code> The C++11 <span class="violet"><strong>range-based <code>for</code> statement</strong></span> allows you to do this without using a counter, avoiding the possibility of “stepping outside” the <code>array</code>’s bounds.</p>&#13;
<p><a href="ch06.xhtml#fig6_3">Figure 6.3</a> uses the range-based <code>for</code> to display an <code>array</code>’s contents (lines 12-14 and 23-25) and to multiply each of the <code>array</code>’s element values by 2 (lines 17-19). In general, when processing all elements of an <code>array,</code> use the range-based <code>for</code> statement, because it ensures that your code does not access elements outside the array’s bounds. At the end of this section, we’ll compare the counter-controlled <code>for</code> and range-based <code>for</code> statements.</p>&#13;
<div class="group" id="fig6_3">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig03" id="aa06fig03">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_03.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Using range-based for.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>8</strong></span>       <span class="yell"><code>array&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; items{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>};</code></span> <code><span class="pd_green">// list initializer</span></code>&#13;
 <span class="cviolet"><strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>       <code><span class="pd_green">// display items before modification</span></code>&#13;
<span class="cviolet"><strong>11</strong></span>       <code>cout &lt;&lt; <span class="green">"items before modification: "</span>;</code>&#13;
<span class="cviolet"><strong>12</strong></span>       <code><span class="yell"><span class="blue">for</span> (<span class="blue">const int</span> item : items)</span> {</code>&#13;
<span class="cviolet"><strong>13</strong></span>          <code>cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;</code>&#13;
<span class="cviolet"><strong>14</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>15</strong></span>       &#13;
<span class="cviolet"><strong>16</strong></span>       <code><span class="pd_green">// multiply the elements of items by 2</span></code>&#13;
<span class="cviolet"><strong>17</strong></span>       <code><span class="yell"><span class="blue">for</span> (<span class="blue">int</span>&amp; itemRef : items)</span> { <span class="pd_green">// itemRef is a reference to an int</span></code>&#13;
<span class="cviolet"><strong>18</strong></span>          <code>itemRef *= <span class="green">2</span>;</code>&#13;
<span class="cviolet"><strong>19</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>       <code><span class="pd_green">// display items after modification</span></code>&#13;
<span class="cviolet"><strong>22</strong></span>       <code>cout &lt;&lt; <span class="green">"\nitems after modification: "</span>;</code>&#13;
<span class="cviolet"><strong>23</strong></span>       <code><span class="blue">for</span> (<span class="blue">const int</span> item : items) {</code>&#13;
<span class="cviolet"><strong>24</strong></span>          <code>cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;</code>&#13;
<span class="cviolet"><strong>25</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>       <code><span class="pd_green">// total elements of items using range-based for with initialization</span></code>&#13;
<span class="cviolet"><strong>28</strong></span>       <code>cout &lt;&lt; <span class="green">"\n\ncalculating a running total of items' values: "</span>;</code>&#13;
<span class="cviolet"><strong>29</strong></span>       <code><span class="yell"><span class="blue">for</span> (<span class="blue">int</span> runningTotal{<span class="green">0</span>}; <span class="blue">const int</span> item : items)</span> {</code>&#13;
<span class="cviolet"><strong>30</strong></span>          <code>runningTotal += item;</code>&#13;
<span class="cviolet"><strong>31</strong></span>          <code>cout &lt;&lt; <span class="green">"\nitem: "</span> &lt;&lt; item &lt;&lt; <span class="green">"; running total: "</span> &lt;&lt; runningTotal;</code>&#13;
<span class="cviolet"><strong>32</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>       <code>cout &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>35</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>items before modification: 1 2 3 4 5</code>&#13;
<code>items after modification: 2 4 6 8 10</code>&#13;
<code>calculating a running total of items' values:</code>&#13;
<code>item: 2; running total: 2</code>&#13;
<code>item: 4; running total: 6</code>&#13;
<code>item: 6; running total: 12</code>&#13;
<code>item: 8; running total: 20</code>&#13;
<code>item: 10; running total: 30</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.3</strong></span> Using range-based <code>for.</code></p>&#13;
</div>&#13;
<h5 class="h5" id="ch06lev3sec7">Using the Range-Based <code>for</code> to Display an <code>array</code>’s Contents</h5>&#13;
<p>The range-based <code>for</code> statement simplifies the code for iterating through an <code>array.</code> Line 12 can be read as “for each iteration, assign the next element of <code>items</code> to <code>int</code> variable <code>item,</code> then execute the loop’s body” or simply as “for each <code>item</code> in <code>items."</code> In each iteration, <code>item</code> represents one element value (but not an index) in <code>items.</code> In the range-based <code>for</code>’s header, you declare a range variable to the left of the colon (<code>:</code>) and specify an array’s name to the right.<sup><a id="rch06fn3" href="ch06.xhtml#ch06fn3">3</a></sup></p>&#13;
<p class="footnote"><a id="ch06fn3" href="ch06.xhtml#rch06fn3">3</a>. You can use the range-based <code>for</code> statement with most of the C++ standard library’s containers, which we discuss in Chapter 17.</p>&#13;
<h5 class="h5" id="ch06lev3sec7a">Using the Range-Based <code>for</code> to Modify an <code>array</code>’s Contents</h5>&#13;
<p>Lines 17-19 use a range-based <code>for</code> statement to multiply each element of <code>items</code> by 2. In line 17, the range variable’s declaration indicates that <code>itemRef</code> is an <code>int&amp;</code>—that is, a reference to an <code>int.</code> Recall that a reference is an alias for another variable in memory—in this case, one of the <code>array</code>’s elements. Any change you make to <code>itemRef</code> changes the value of the corresponding <code>array</code> element.</p>&#13;
<h5 class="h5" id="ch06lev3sec8">C++20: Range-Based <code>for</code> with Initializer</h5>&#13;
<p><span class="size">20</span> If you have a variable needed only in the scope of a range-based <code>for</code> loop, C++20 adds the <span class="violet"><strong>range-based <code>for</code> with initializer</strong></span> statement. Like the <code>if</code> and <code>switch</code> statements with initializers, variables defined in the initializer of a range-based <code>for</code> exist only for the duration of the loop. The initializer in line 29 initializes the variable <code>runningTotal</code> to <code>0,</code> then lines 29-32 calculate the running total of <code>items’</code> elements.</p>&#13;
<h5 class="h5" id="ch06lev3sec9">Avoiding Subscripts</h5>&#13;
<p>The range-based <code>for</code> statement can be used in place of the counter-controlled <code>for</code> statement whenever code looping through an <code>array</code> does not require accessing the element’s subscript. For example, totaling the integers in an <code>array</code> requires access only to the element values. Their positions in the <code>array</code> are irrelevant.</p>&#13;
<h5 class="h5" id="ch06lev3sec10">External vs. Internal Iteration</h5>&#13;
<p>In this program, lines 12-14 are equivalent to the following counter-controlled iteration:</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0166-01" id="f0166-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">int</span> counter{<span class="green">0</span>}; counter &lt; items.size(); ++counter) {&#13;
   cout &lt;&lt; items[counter] &lt;&lt; <span class="green">" "</span>;&#13;
}</pre>&#13;
<p>This style of iteration is known as <span class="violet"><strong>external iteration</strong></span> and is error-prone. As implemented, this loop requires a control variable <code>(counter)</code> that the code <em>mutates</em> (modifies) during each loop iteration. Every time you write code that modifies a variable, it’s possible to introduce an error into your code. There are several opportunities for error in the preceding code. For example, you could:</p>&#13;
<p class="bull">• initialize the <code>for</code> loop’s control variable <code>counter</code> incorrectly</p>&#13;
<p class="bull">• use the wrong loop-continuation condition or</p>&#13;
<p class="bull">• increment control variable <code>counter</code> incorrectly.</p>&#13;
<p>The last two problems might result in accessing elements outside the <code>array</code> items’ bounds.</p>&#13;
<p>The range-based <code>for</code> statement, on the other hand, uses functional-style <span class="violet"><strong>internal iteration,</strong></span> which hides the counter-controlled iteration details. You specify what <code>array</code> the range-based <code>for</code> should process. It knows how to get each value from the <code>array</code> and how to stop iterating when there are no more values.</p>&#13;
<h3 class="h3" id="ch06lev1sec7"><span class="violet">6.7</span> Setting <code>array</code> Elements with Calculations; Introducing <code>constexpr</code></h3>&#13;
<p><a href="ch06.xhtml#fig6_4">Figure 6.4</a> sets the elements of a 5-element <code>array</code> named <code>values</code> to the even integers <code>2, 4, 6, 8</code> and <code>10</code> (lines 13-15) and prints the <code>array</code> (lines 18-20). These numbers are generated (line 14) by multiplying each successive value of the loop counter, <code>i,</code> by <code>2</code> and adding <code>2.</code></p>&#13;
<div class="group" id="fig6_4">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig04" id="aa06fig04">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>   <code><span class="pd_green">// fig06_04.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>   <code><span class="pd_green">// Set array s to the even integers from 2 to 10.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>   <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>   <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>8</strong></span>     <code><span class="pd_green">// constant can be used to specify array size</span></code>&#13;
 <span class="cviolet"><strong>9</strong></span>     <span class="yell"><code><span class="blue">constexpr</span> <span class="blue">size_t</span> arraySize{<span class="green">5</span>};</code></span> <code><span class="pd_green">// must initialize in declaration</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>      &#13;
<span class="cviolet"><strong>11</strong></span>     <span class="yell"><code>array&lt;<span class="blue">int</span>, arraySize&gt; values{};</code></span> <code><span class="pd_green">// array values has 5 elements</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>     <code><span class="blue">for</span> (<span class="blue">size_t</span> i{<span class="green">0</span>}; i &lt; values.size(); ++i) { <span class="pd_green">// set the values</span></code>&#13;
<span class="cviolet"><strong>14</strong></span>        <span class="yell"><code>values.at(i) = <span class="green">2</span> + <span class="green">2</span> * i;</code></span>&#13;
<span class="cviolet"><strong>15</strong></span>     <code>}</code>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>     <code><span class="pd_green">// output contents of array s in tabular format</span></code>&#13;
<span class="cviolet"><strong>18</strong></span>     <code><span class="blue">for</span> (<span class="blue">const int</span> value : values) {</code>&#13;
<span class="cviolet"><strong>19</strong></span>     <code>cout &lt;&lt; value &lt;&lt; <span class="green">" "</span>;</code>&#13;
<span class="cviolet"><strong>20</strong></span>     <code>}</code>&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>     <code>cout &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>23</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1"><code>2 4 6 8 10</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.4</strong></span> Set <code>array s</code> to the even integers from 2 to 10.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch06lev3sec11">Constants</h5>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> <span class="size">11</span> In <a href="ch05.xhtml#ch05">Chapter 5</a>, we introduced the <code>const</code> qualifier to indicate that a variable’s value does not change after it is initialized. C++11 introduced the <span class="violet"><strong><code>constexpr</code> qualifier</strong></span> to declare variables that can be evaluated at compile-time and result in a constant. This allows the compiler to perform additional optimizations and can improve application performance because there’s no runtime overhead.<sup><a id="rch06fn4" href="ch06.xhtml#ch06fn4">4</a></sup> A <code>constexpr</code> variable is implicitly <code>const.</code></p>&#13;
<p class="footnote"><a id="ch06fn4" href="ch06.xhtml#rch06fn4">4</a>. As you’ll see in later chapters, <code>constexpr</code> also can be applied to functions if they evaluate to a constant value at compile-time. This eliminates the overhead of runtime function calls, thus further improving application performance. In C++20, C++17 and C++14, many functions and member functions throughout the C++ standard library have been declared <code>constexpr</code>.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span></p>&#13;
<p>Line 9 uses <code>constexpr</code> to declare the constant <code>arraySize</code> with the value <code>5.</code> A variable declared <code>constexpr</code> or <code>const</code> must be initialized when it’s declared; otherwise, a compilation error occurs. Attempting to modify <code>arraySize</code> after it’s initialized, as in</p>&#13;
<pre class="pre">arraySize = <span class="green">7</span>;</pre>&#13;
<p>results in a compilation error.<sup><a id="rch06fn5" href="ch06.xhtml#ch06fn5">5</a></sup></p>&#13;
<p class="footnote"><a id="ch06fn5" href="ch06.xhtml#rch06fn5">5</a>. In error messages, some compilers refer to a <code>const</code> fundamental-type variable as a “<code>const object.</code>” The C++ standard defines an “object” as any “region of storage.” Like class objects, fundamental-type variables also occupy space in memory, so they’re often referred to as “objects” as well.</p>&#13;
<p>Defining the size of an array as a constant instead of a literal value makes programs clearer and easier to update. This technique eliminates <span class="violet"><strong>magic numbers</strong></span>—numeric literal values that do not provide you with any context that helps you understand their meaning. Using a constant allows you to provide a name for a literal value and can help explain that value’s purpose in the program.</p>&#13;
<h3 class="h3" id="ch06lev1sec8"><span class="violet">6.8</span> Totaling <code>array</code> Elements</h3>&#13;
<p>Often, the elements of an <code>array</code> represent a series of values to be used in a calculation. For example, if the elements of an <code>array</code> represent exam grades, a professor may wish to total the <code>array</code> elements and use that result to calculate the class average for the exam. Processing a collection of values into a single value is known as <span class="violet"><strong>reduction</strong></span>—one of the key operations in functional-style programming, which we’ll discuss in <a href="ch06.xhtml#ch06lev1sec14">Section 6.14</a>. <a href="ch06.xhtml#fig6_5">Figure 6.5</a> uses a range-based <code>for</code> statement (lines 13-15) to total the values in the four-element <code>array integers.</code> <a href="ch06.xhtml#ch06lev1sec14">Section 6.14</a> shows how to perform this calculation using the C++ standard library’s <code>accumulate</code> function.</p>&#13;
<div class="group" id="fig6_5">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig05" id="aa06fig05">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>   <code><span class="pd_green">// fig06_05.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>   <code><span class="pd_green">// Compute the sum of the elements of an array.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>   <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>   <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>8</strong></span>      <code><span class="blue">constexpr</span> size_t arraySize{<span class="green">4</span>};</code>&#13;
 <span class="cviolet"><strong>9</strong></span>      <code>array&lt;<span class="blue">int</span>, arraySize&gt; integers{<span class="green">10</span>, <span class="green">20</span>, <span class="green">30</span>, <span class="green">40</span>};</code>&#13;
<span class="cviolet"><strong>10</strong></span>      <code><span class="blue">int</span> total{<span class="green">0</span>};</code>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <code><span class="pd_green">// sum contents of array a</span></code>&#13;
<span class="cviolet"><strong>13</strong></span>      <code><span class="blue">for</span> (<span class="blue">const int</span> item : integers) {</code>&#13;
<span class="cviolet"><strong>14</strong></span>         <span class="yell"><code>total += item;</code></span>&#13;
<span class="cviolet"><strong>15</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>16</strong></span>      &#13;
<span class="cviolet"><strong>17</strong></span>      <code>cout &lt;&lt; <span class="green">"Total of array elements: "</span> &lt;&lt; total &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>18</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Total of array elements: 100</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.5</strong></span> Compute the sum of the elements of an <code>array.</code></p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec9"><span class="violet">6.9</span> Using a Primitive Bar Chart to Display <code>array</code> Data Graphically</h3>&#13;
<p>Many programs present data graphically. For example, numeric values are often displayed as bars in a bar chart, with longer bars representing proportionally larger values. One simple way to display numeric data graphically is with a bar chart that shows each numeric value as a bar of asterisks (<code>*</code>). This is a simple example of visualization using primitive techniques.</p>&#13;
<p>A professor might graph the number of exam grades in each of several categories to visualize the grade distribution. Suppose the grades were 87, 68, 94, 100, 83, 78, 85, 91, 76 and 87. There was one grade of 100, two grades in the 90s, four in the 80s, two in the 70s, one in the 60s and none below 60. Our next program (<a href="ch06.xhtml#fig6_6">Fig. 6.6</a>) stores this data in an <code>array</code> of 11 elements, each corresponding to a grade range. For example, element <code>0</code> contains the number of grades in the range 0-9, element <code>7</code> indicates the number of grades in the range 70-79, and element <code>10</code> indicates the number of grades of 100. Upcoming examples will calculate grade frequencies based on a set of grades. In this example, we initialize the array <code>n</code> with frequency values.</p>&#13;
<div class="group" id="fig6_6">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig06" id="aa06fig06">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_06.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Printing a student grade distribution as a primitive bar chart.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>8</strong></span>       <code><span class="blue">constexpr</span> size_t arraySize{<span class="green">11</span>};</code>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code>array&lt;<span class="blue">int</span>, arraySize&gt; n{<span class="green">0</span>, <span class="green">0</span>, <span class="green">0</span>, <span class="green">0</span>, <span class="green">0</span>, <span class="green">0</span>, <span class="green">1</span>, <span class="green">2</span>, <span class="green">4</span>, <span class="green">2</span>, <span class="green">1</span>};</code>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>       <code>cout &lt;&lt; <span class="green">"Grade distribution:"</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>       <code><span class="pd_green">// for each element of array n, output a bar of the chart</span></code>&#13;
<span class="cviolet"><strong>14</strong></span>       <code><span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">0</span>}; <span class="blue">const int</span> item : n) {</code>&#13;
<span class="cviolet"><strong>15</strong></span>          <code><span class="pd_green">// output bar labels ("0-9:", ..., "90-99:", "100:")</span></code>&#13;
<span class="cviolet"><strong>16</strong></span>          <code><span class="blue">if</span> (<span class="green">0</span> == i) {</code>&#13;
<span class="cviolet"><strong>17</strong></span>             <code>cout &lt;&lt; <span class="green">" 0-9: "</span>;</code>&#13;
<span class="cviolet"><strong>18</strong></span>          <code>}</code>&#13;
<span class="cviolet"><strong>19</strong></span>          <code><span class="blue">else</span> <span class="blue">if</span> (<span class="green">10</span> == i) {</code>&#13;
<span class="cviolet"><strong>20</strong></span>             <code>cout &lt;&lt; <span class="green">" 100: "</span>;</code>&#13;
<span class="cviolet"><strong>21</strong></span>          <code>}</code>&#13;
<span class="cviolet"><strong>22</strong></span>          <code><span class="blue">else</span> {</code>&#13;
<span class="cviolet"><strong>23</strong></span>             <code>cout &lt;&lt; i * <span class="green">10</span> &lt;&lt; <span class="green">"-"</span> &lt;&lt; (i * <span class="green">10</span>) + <span class="green">9</span> &lt;&lt; <span class="green">": "</span>;</code>&#13;
<span class="cviolet"><strong>24</strong></span>          <code>}</code>&#13;
<span class="cviolet"><strong>25</strong></span>          &#13;
<span class="cviolet"><strong>26</strong></span>          <code>++i;</code>&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>          <code><span class="pd_green">// print bar of asterisks</span></code>&#13;
<span class="cviolet"><strong>29</strong></span>          <span class="yell"><code><span class="blue">for</span> (<span class="blue">int</span> stars{<span class="green">0</span>}; stars &lt; item; ++stars)</code></span> <code>{</code>&#13;
<span class="cviolet"><strong>30</strong></span>             <code>cout &lt;&lt; <span class="green">'*'</span>;</code>&#13;
<span class="cviolet"><strong>31</strong></span>          <code>}</code>&#13;
<span class="cviolet"><strong>32</strong></span>&#13;
<span class="cviolet"><strong>33</strong></span>          <code>cout &lt;&lt; endl; <span class="pd_green">// start a new line of output</span></code>&#13;
<span class="cviolet"><strong>34</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>35</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Grade distribution:</code>&#13;
<code>  0-9:</code>&#13;
<code>10-19:</code>&#13;
<code>20-29:</code>&#13;
<code>30-39:</code>&#13;
<code>40-49:</code>&#13;
<code>50-59:</code>&#13;
<code>60-69: *</code>&#13;
<code>70-79: **</code>&#13;
<code>80-89: ****</code>&#13;
<code>90-99: **</code>&#13;
<code>  100: *</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.6</strong></span> Printing a student grade distribution as a primitive bar chart.</p>&#13;
</div>&#13;
<p><a href="ch06.xhtml#fig6_6">Figure 6.6</a> reads the numbers from the <code>array</code> and graphs the information as a bar chart, displaying each grade range followed by a bar of asterisks indicating the number of grades in that range. To label each bar, lines 16-24 output a grade range (e.g., <code>“70-79: ”</code>) based on the current value of <code>i</code>. The nested <code>for</code> statement (lines 29-31) outputs the current bar as the appropriate number of asterisks. Note the loop-continuation condition in line 29 <code>(stars &lt; item).</code> Each time the program reaches the inner <code>for,</code> the loop counts from <code>0</code> up to <code>item,</code> thus using a value in <code>array n</code> to determine the number of asterisks to display. In this example, elements <code>0-5</code> contain zeros because no students received a grade below 60. Thus, the program displays no asterisks next to the first six grade ranges.</p>&#13;
<h3 class="h3" id="ch06lev1sec10"><span class="violet">6.10</span> Using <code>array</code> Elements as Counters</h3>&#13;
<p><span class="size">11</span> Sometimes, programs use counter variables to summarize data, such as a survey’s results. <a href="ch05.xhtml#fig5_3">Figure 5.3</a>’s die-rolling simulation used separate counters to track the number of occurrences of each side of a die as the program rolled the die 60,000,000 times. <a href="ch06.xhtml#fig6_7">Figure 6.7</a> reimplements that simulation using an <code>array</code> of counters. This version also uses the C++11 random-number generation capabilities that were introduced in <a href="ch05.xhtml#ch05lev1sec10">Section 5.10</a>.</p>&#13;
<div class="group" id="fig6_7">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig07" id="aa06fig07">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_07.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Die-rolling program using an array instead of switch.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// C++20: This will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">#include</span> &lt;random&gt;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">#include</span> &lt;ctime&gt;</code>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">#include</span> <span class="green">"gsl/gsl"</span></code>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>12</strong></span>       <code><span class="pd_green">// use the default random-number generation engine to</span></code>&#13;
<span class="cviolet"><strong>13</strong></span>       <code><span class="pd_green">// produce uniformly distributed pseudorandom int values from 1 to 6</span></code>&#13;
<span class="cviolet"><strong>14</strong></span>       <code>default_random_engine engine(gsl::narrow_cast&lt;<span class="blue">unsigned int&gt;</span>(time(<span class="green">0</span>)));</code>&#13;
<span class="cviolet"><strong>15</strong></span>       <code>uniform_int_distribution&lt;<span class="blue">int&gt;</span> randomInt(<span class="green">1</span>, <span class="green">6</span>);</code>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>       <code><span class="blue">constexpr</span> size_t arraySize{<span class="green">7</span>}; <span class="pd_green">// ignore element zero</span></code>&#13;
<span class="cviolet"><strong>18</strong></span>       <code>array&lt;<span class="blue">int</span>, arraySize&gt; frequency{}; <span class="pd_green">// initialize to 0s</span></code>&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>       <code><span class="pd_green">// roll die 60,000,000 times; use die value as frequency index</span></code>&#13;
<span class="cviolet"><strong>21</strong></span>       <code><span class="blue">for</span> (<span class="blue">int</span> roll{<span class="green">1</span>}; roll &lt;= <span class="green">60'000'000</span>; ++roll) {</code>&#13;
<span class="cviolet"><strong>22</strong></span>          <span class="yell"><code>++frequency.at(randomInt(engine));</code></span>&#13;
<span class="cviolet"><strong>23</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>       <code>cout &lt;&lt; fmt::format(<span class="green">"{}{:&gt;13}\n"</span>, <span class="green">"Face"</span>, <span class="green">"Frequency"</span>);</code>&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>       <code><span class="pd_green">// output each array element's value</span></code>&#13;
<span class="cviolet"><strong>28</strong></span>       <code><span class="blue">for</span> (size_t face{<span class="green">1</span>}; face &lt; frequency.size(); ++face) {</code>&#13;
<span class="cviolet"><strong>29</strong></span>          <code>cout &lt;&lt; fmt::format("{:<span class="green">&gt;4}{:&gt;13}\n"</span>, face, frequency.at(face));</code>&#13;
<span class="cviolet"><strong>30</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>31</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Face   Frequency</code>&#13;
<code>   1     9997901</code>&#13;
<code>   2     9999110</code>&#13;
<code>   3    10001172</code>&#13;
<code>   4    10003619</code>&#13;
<code>   5     9997606</code>&#13;
<code>   6    10000592</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.7</strong></span> Die-rolling program using an <code>array</code> instead of <code>switch.</code></p>&#13;
</div>&#13;
<p><a href="ch06.xhtml#fig6_7">Figure 6.7</a> uses the <code>array frequency</code> (line 18) to count the occurrences of die values. Line 22 of this program replaces the entire <code>switch</code> statement in lines 19-40 of <a href="ch05.xhtml#fig5_3">Fig. 5.3</a>, by using a random value to determine which <code>frequency</code> element to increment for each die roll. The call <code>randomInt(engine)</code> produces a random subscript from 1 to 6, so <code>frequency</code> must be large enough to store six counters. We use a seven-element <code>array</code> in which we ignore element 0—it’s clearer to have the die value 1 increment <code>frequency.at(1)</code> rather than <code>frequency.at(0).</code> So, each face value is used directly as a <code>frequency</code> index. We also replace lines 44-49 of <a href="ch05.xhtml#fig5_3">Fig. 5.3</a> by looping through <code>array frequency</code> to output the results (<a href="ch06.xhtml#fig6_7">Fig. 6.7</a>, lines 28-30).</p>&#13;
<h3 class="h3" id="ch06lev1sec11"><span class="violet">6.11</span> Using <code>array</code>s to Summarize Survey Results</h3>&#13;
<p>Our next example uses <code>array</code>s to summarize the results of data collected in a survey. Consider the following problem statement:</p>&#13;
<p class="block1"><em>Twenty students were asked to rate on a scale of 1 to 5 the quality of the food in the student cafeteria, with 1 being “awful” and 5 being “excellent.” Place the 20 responses in an integer <code>array</code> and determine the frequency of each rating.</em></p>&#13;
<p>This is a popular type of <code>array</code>-processing application (<a href="ch06.xhtml#fig6_8">Fig. 6.8</a>). We wish to summarize the number of responses of each rating (that is, 1-5). The <code>array responses</code> (lines 14-15) is a 20-element integer <code>array</code> of the students’ responses to the survey. The <code>array responses</code> is declared <code>const,</code> as its values do not (and should not) change. We use a six- element <code>array frequency</code> (line 18) to count the number of occurrences of each response. Each element of the <code>array</code> is used as a counter for one of the survey responses and is initialized to zero. As in <a href="ch06.xhtml#fig6_7">Fig. 6.7</a>, we ignore element 0.</p>&#13;
<div class="group" id="fig6_8">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig08" id="aa06fig08">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_08.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Poll analysis program.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// C++20: This will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>      <code><span class="pd_green">// define array sizes</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>      <code><span class="blue">constexpr</span> size_t responseSize{<span class="green">20</span>}; <span class="pd_green">// size of array responses</span></code>&#13;
<span class="cviolet"><strong>11</strong></span>      <code><span class="blue">constexpr</span> size_t frequencySize{<span class="green">6</span>}; <span class="pd_green">// size of array frequency</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      <code><span class="pd_green">// place survey responses in array responses</span></code>&#13;
<span class="cviolet"><strong>14</strong></span>      <code><span class="blue">const</span> array&lt;<span class="blue">int</span>, responseSize&gt; responses{</code>&#13;
<span class="cviolet"><strong>15</strong></span>         <code><span class="green">1</span>, <span class="green">2</span>, <span class="green">5</span>, <span class="green">4</span>, <span class="green">3</span>, <span class="green">5</span>, <span class="green">2</span>, <span class="green">1</span>, <span class="green">3</span>, <span class="green">1</span>, <span class="green">4</span>, <span class="green">3</span>, <span class="green">3</span>, <span class="green">3</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">3</span>, <span class="green">2</span>, <span class="green">2</span>, <span class="green">5</span>};</code>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      <code><span class="pd_green">// initialize frequency counters to 0</span></code>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="yell"><code>array&lt;<span class="blue">int</span>, frequencySize&gt; frequency{};</code></span>&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>      <code><span class="pd_green">// for each answer, select responses element and use that value</span></code>&#13;
<span class="cviolet"><strong>21</strong></span>      <code><span class="pd_green">// as frequency index to determine element to increment</span></code>&#13;
<span class="cviolet"><strong>22</strong></span>      <code><span class="blue">for</span> (size_t answer{<span class="green">0</span>}; answer &lt; responses.size(); ++answer) {</code>&#13;
<span class="cviolet"><strong>23</strong></span>         <span class="yell"><code>++frequency.at(responses.at(answer));</code></span>&#13;
<span class="cviolet"><strong>24</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>      <code>cout &lt;&lt; fmt::format(<span class="green">"{}{:&gt;12}\n"</span>, <span class="green">"Rating"</span>, <span class="green">"Frequency"</span>);</code>&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>      <code><span class="pd_green">// output each array element's value</span></code>&#13;
<span class="cviolet"><strong>29</strong></span>      <code><span class="blue">for</span> (size_t rating{<span class="green">1</span>}; rating &lt; frequency.size(); ++rating) {</code>&#13;
<span class="cviolet"><strong>30</strong></span>         <code>cout &lt;&lt; fmt::format(<span class="green">"{:&gt;6}{:&gt;12}\n"</span>, rating, frequency.at(rating));</code>&#13;
<span class="cviolet"><strong>31</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>32</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Rating Frequency</code>&#13;
<code>     1         3</code>&#13;
<code>     2         5</code>&#13;
<code>     3         7</code>&#13;
<code>     4         2</code>&#13;
<code>     5         3</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.8</strong></span> Poll analysis program.</p>&#13;
</div>&#13;
<p>The first <code>for</code> statement (lines 22-24) takes one response at a time from the <code>array responses</code> and increments one of the counters <code>frequency.at(1)</code> to <code>frequency.at(5).</code> The key statement in the loop is line 23, which increments the appropriate counter, depending on the value of <code>responses.at(answer).</code></p>&#13;
<p>Let’s consider several iterations of the <code>for</code> loop. When control variable <code>answer</code> is <code>0,</code> the value of <code>responses.at(answer)</code> is the value of <code>responses.at(0)</code> (i.e., <code>1</code> in line 15), so the program interprets <code>++frequency.at(responses(answer))</code> as</p>&#13;
<pre class="pre">++frequency.at(<span class="green">1</span>)</pre>&#13;
<p>which increments the value in <code>array</code> element 1. To evaluate the expression in line 23, start with the value in the innermost set of square brackets <code>(answer).</code> Once you know <code>answer</code>’s value (which is the value of the control variable in line 22), plug it into the expression and evaluate the expression in the next outer set of square brackets—that is, <code>responses.at(answer),</code> which is a value selected from the <code>responses array</code> in lines 14–15. Then use the resulting value as the index for the <code>frequency array</code> to specify which counter to increment.</p>&#13;
<p>When <code>answer</code> is <code>1, responses.at(answer)</code> is the value of <code>responses.at(1),</code> which is <code>2,</code> so the program interprets <code>++frequency.at(responses(answer))</code> as</p>&#13;
<pre class="pre">++frequency.at(<span class="green">2</span>)</pre>&#13;
<p>which increments <code>array</code> element 2.</p>&#13;
<p>When <code>answer</code> is <code>2, responses[answer]</code> is the value of <code>responses.at(2),</code> which is <code>5,</code> so the program interprets <code>++frequency.at(responses(answer))</code> as</p>&#13;
<pre class="pre">++frequency.at(<span class="green">5</span>)</pre>&#13;
<p>which increments <code>array</code> element 5, and so on. Regardless of the number of responses processed in the survey, the program requires only a six-element <code>array</code> (ignoring element zero) to summarize the results, because all the response values are between 1 and 5 and the index values for a six-element <code>array</code> are 0 through 5.</p>&#13;
<h3 class="h3" id="ch06lev1sec12"><span class="violet">6.12</span> Sorting and Searching <code>array</code>s</h3>&#13;
<p>In this section, we use the built-in C++ standard library <span class="violet"><strong><code>sort</code></strong></span> function<sup><a id="rch06fn6" href="ch06.xhtml#ch06fn6">6</a></sup> to arrange the elements in an <code>array</code> into ascending order and the built-in <span class="violet"><strong><code>binary_search</code></strong></span> function to determine whether a value is in the <code>array.</code></p>&#13;
<p class="footnote"><a id="ch06fn6" href="ch06.xhtml#rch06fn6">6</a>. The C++ standard indicates that sort uses an <em>O</em>(<em>n</em> log <em>n</em>) algorithm, but does not specify which one.</p>&#13;
<p><span class="violet"><strong>Sorting</strong></span> data—placing it into ascending or descending order—is one of the most important computing applications. Virtually every organization must sort some data and, in many cases, massive amounts of it. Sorting is an intriguing problem that has attracted some of the most intense research efforts in the field of computer science.</p>&#13;
<p>Often it may be necessary to determine whether an <code>array</code> contains a value that matches a certain <span class="violet"><strong>key value.</strong></span> The process of finding a particular element of an <code>array</code> is called <span class="violet"><strong>searching.</strong></span></p>&#13;
<h5 class="h5" id="ch06lev3sec12">Demonstrating Functions <code>sort</code> and <code>binary_search</code></h5>&#13;
<p><a href="ch06.xhtml#fig6_9">Figure 6.9</a> begins by creating an unsorted <code>array</code> of <code>string</code>s (lines 11-12) and displaying the contents of the <code>array</code> (lines 16-18). Next, line 20 uses the C++ standard library function <code>sort</code> to sort the elements of the <code>array colors</code> into ascending order. The <code>sort</code> function’s arguments specify the range of elements that should be sorted—in this case, the entire <code>array.</code> The arguments <code>begin(colors),</code> and <code>end(colors)</code> return “iterators” that represent the <code>array</code>’s beginning and end, respectively. <a href="ch17.xhtml#ch17">Chapter 17</a> discusses iterators in depth. Functions <span class="violet"><strong><code>begin</code></strong></span> and <span class="violet"><strong><code>end</code></strong></span> are defined in <code>&lt;array&gt;.</code> As you’ll see, function <code>sort</code> can be used to sort the elements of several different types of data structures. Lines 24-26 display the contents of the sorted <code>array.</code></p>&#13;
<div class="group" id="fig6_9">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig09" id="aa06fig09">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_09.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Sorting and searching arrays.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">#include</span> &lt;algorithm&gt; <span class="pd_green">// contains sort and binary_search</span></code>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">using</span> <span class="blue">namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>8</strong></span>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code><span class="blue">constexpr</span> size_t arraySize{<span class="green">7</span>}; <span class="pd_green">// size of array colors</span></code>&#13;
<span class="cviolet"><strong>11</strong></span>       <code>array&lt;<span class="blue">string</span>, arraySize&gt; colors{<span class="green">"red"</span>, <span class="green">"orange"</span>, <span class="green">"yellow"</span>,</code>&#13;
<span class="cviolet"><strong>12</strong></span>          <code><span class="green">"green"</span>, <span class="green">"blue"</span>, <span class="green">"indigo"</span>, <span class="green">"violet"</span>};</code>&#13;
<span class="cviolet"><strong>13</strong></span>       &#13;
<span class="cviolet"><strong>14</strong></span>       <code><span class="pd_green">// output original array</span></code>&#13;
<span class="cviolet"><strong>15</strong></span>       <code>cout &lt;&lt; <span class="green">"Unsorted colors array:\n"</span>;</code>&#13;
<span class="cviolet"><strong>16</strong></span>       <code><span class="blue">for</span> (<span class="blue">string</span> color : colors) {</code>&#13;
<span class="cviolet"><strong>17</strong></span>          <code>cout &lt;&lt; color &lt;&lt; <span class="green">" ";</span></code>&#13;
<span class="cviolet"><strong>18</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>19</strong></span>       &#13;
<span class="cviolet"><strong>20</strong></span>       <span class="yell"><code>sort(begin(colors), end(colors)); <span class="pd_green">// sort contents of colors</span></code></span>&#13;
<span class="cviolet"><strong>21</strong></span>       &#13;
<span class="cviolet"><strong>22</strong></span>       <code><span class="pd_green">// output sorted array</span></code>&#13;
<span class="cviolet"><strong>23</strong></span>       <code>cout &lt;&lt; <span class="green">"\nSorted colors array:\n"</span>;</code>&#13;
<span class="cviolet"><strong>24</strong></span>       <code><span class="blue">for</span> (<span class="blue">string</span> item : colors) {</code>&#13;
<span class="cviolet"><strong>25</strong></span>          <code>cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;</code>&#13;
<span class="cviolet"><strong>26</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>       <code><span class="pd_green">// search for "indigo" in colors</span></code>&#13;
<span class="cviolet"><strong>29</strong></span>       <span class="yell"><code><span class="blue">bool</span> found{binary_search(begin(colors), end(colors), <span class="green">"indigo"</span>)};</code></span>&#13;
<span class="cviolet"><strong>30</strong></span>       <code>cout &lt;&lt; <span class="green">"\n\n\"indigo\" "</span> &lt;&lt; (found ? <span class="green">"was"</span> : <span class="green">"was not"</span>)</code>&#13;
<span class="cviolet"><strong>31</strong></span>          <code>&lt;&lt; <span class="green">" found in colors array"</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>32</strong></span>&#13;
<span class="cviolet"><strong>33</strong></span>       <code><span class="pd_green">// search for "cyan" in colors</span></code>&#13;
<span class="cviolet"><strong>34</strong></span>       <span class="yell"><code>found = binary_search(begin(colors), end(colors), <span class="green">"cyan"</span>);</code></span>&#13;
<span class="cviolet"><strong>35</strong></span>       <code>cout &lt;&lt; <span class="green">"\"cyan\" "</span> &lt;&lt; (found ? <span class="green">"was"</span> : <span class="green">"was not"</span>)</code>&#13;
<span class="cviolet"><strong>36</strong></span>          <code>&lt;&lt; <span class="green">" found in colors array"</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>37</strong></span>    <code>} <span class="pd_green"/></code></pre>&#13;
<pre class="pre1"><code>Unsorted colors array:</code>&#13;
<code>red orange yellow green blue indigo violet</code>&#13;
<code>Sorted colors array:</code>&#13;
<code>blue green indigo orange red violet yellow</code>&#13;
&#13;
<code>"indigo" was found in colors array</code>&#13;
<code>"cyan" was not found in colors array</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.9</strong></span> Sorting and searching <code>array</code>s.</p>&#13;
</div>&#13;
<p>Lines 29 and 34 use <code>binary_search</code> to determine whether a value is in the <code>array.</code> The sequence of values first must be sorted in ascending order—<code>binary_search</code> does not verify this for you. Performing a binary search on an unsorted array is a logic error that could lead to incorrect results. The function’s first two arguments represent the range of elements to search, and the third argument is the search key—the value to find in the <code>array.</code> The function returns a <code>bool</code> indicating whether the value was found. In <a href="ch18.xhtml#ch18">Chapter 18</a>, we’ll use the C++ Standard function <code>find</code> to obtain the location of a search key in an <code>array.</code></p>&#13;
<h3 class="h3" id="ch06lev1sec13"><span class="violet">6.13</span> Multidimensional <code>array</code>s</h3>&#13;
<p>You can use <code>array</code>s with two dimensions (i.e., indices) to represent <span class="violet"><strong>tables of values</strong></span> consisting of information arranged in <span class="violet"><strong>rows</strong></span> and <span class="violet"><strong>columns.</strong></span> To identify a particular table element, we must specify two indices—by convention, the first identifies the row and the second identifies the column. <code>array</code>s that require two indices to identify a particular element are called <span class="violet"><strong>two-dimensional <code>array</code>s</strong></span> or <span class="violet"><strong>2-D <code>array</code>s.</strong></span> <code>array</code>s with two or more dimensions are known as <span class="violet"><strong>multidimensional <code>array</code>s.</strong></span> The following diagram illustrates a two- dimensional <code>array, a:</code></p>&#13;
<div class="group">&#13;
<div class="images"><img src="Images/f0211-01.jpg" alt="Images" width="571" height="247"/></div>&#13;
</div>&#13;
<p>The <code>array</code> contains three rows and four columns, so it’s said to be a 3-by-4 <code>array.</code> In general, an <code>array</code> with <em>m</em> rows and <em>n</em> columns is called an <strong><em><span class="brown">m</span></em><span class="violet">-by-</span><em><span class="brown">n</span></em> <span class="violet"><code>array.</code></span></strong></p>&#13;
<p>We have identified every element in the diagram above with an element name of the form <em>a[row][column]</em>. Similarly, you can access each element with <code>at,</code> as in:</p>&#13;
<pre class="pre">a.at(i).at(j)</pre>&#13;
<p>The elements names in row 0 all have a first index of <code>0;</code> the elements names in column 3 all have a second index of <code>3.</code> Referencing a two-dimensional <code>array</code> element as <code>a[x, y]</code> or <code>a.at(x, y)</code> is an error. Actually, <code>a[x, y]</code> and <code>a.at(x, y)</code> are treated as <code>a[y]</code> and <code>a.at(y),</code> respectively, because C++ evaluates the expression <code>x, y</code> (containing a comma operator) simply as <code>y</code> (the last of the comma-separated expressions).</p>&#13;
<p><a href="ch06.xhtml#fig6_10">Figure 6.10</a> demonstrates initializing two-dimensional <code>array</code>s in declarations. Lines 12-13 each declare an <code>array</code> of <code>array</code>s with two rows and three columns.</p>&#13;
<div class="group" id="fig6_10">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig10" id="aa06fig10">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_10.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Initializing multidimensional arrays.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">constexpr</span> size_t rows{<span class="green">2</span>};</code>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">constexpr</span> size_t columns{<span class="green">3</span>};</code>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">void</span> printArray(<span class="blue">const</span> array&lt;array&lt;<span class="blue">int</span>, columns&gt;, rows&gt;&amp; a);</code>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="yell"><code><span class="blue">const</span> array&lt;array&lt;<span class="blue">int</span>, columns&gt;, rows&gt; array1{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>};</code></span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="yell"><code><span class="blue">const</span> array&lt;array&lt;<span class="blue">int</span>, columns&gt;, rows&gt; array2{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>};</code>   </span>&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>      <code>cout &lt;&lt; <span class="green">"Values in array1 by row are:"</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>16</strong></span>      <code>printArray(array1);</code>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>      <code>cout &lt;&lt; <span class="green">"\nValues in array2 by row are:"</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>19</strong></span>      <code>printArray(array2);</code>&#13;
<span class="cviolet"><strong>20</strong></span>    <code>}</code>&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>    <code><span class="pd_green">// output array with two rows and three columns</span></code>&#13;
<span class="cviolet"><strong>23</strong></span>    <code><span class="blue">void</span> printArray(<span class="blue">const</span> array&lt;array&lt;<span class="blue">int</span>, columns&gt;, rows&gt;&amp; a) {</code>&#13;
<span class="cviolet"><strong>24</strong></span>       <code><span class="pd_green">// loop through array's rows</span></code>&#13;
<span class="cviolet"><strong>25</strong></span>       <span class="yell"><code><span class="blue">for</span> (<span class="blue">auto const</span>&amp; row : a) {</code></span>&#13;
<span class="cviolet"><strong>26</strong></span>          <code><span class="pd_green">// loop through columns of current row</span></code>&#13;
<span class="cviolet"><strong>27</strong></span>          <span class="yell"><code><span class="blue">for</span> (<span class="blue">auto</span> <span class="blue">const</span>&amp; element : row) {</code></span>&#13;
<span class="cviolet"><strong>28</strong></span>             <code>cout &lt;&lt; element &lt;&lt; <span class="green">' '</span>;</code>&#13;
<span class="cviolet"><strong>29</strong></span>          <code>}</code>&#13;
<span class="cviolet"><strong>30</strong></span>      &#13;
<span class="cviolet"><strong>31</strong></span>          <code>cout &lt;&lt; endl; <span class="pd_green">// start new line of output</span></code>&#13;
<span class="cviolet"><strong>32</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>33</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Values in array1 by row are:</code>&#13;
<code>1 2 3</code>&#13;
<code>4 5 6</code>&#13;
&#13;
<code>Values in array2 by row are:</code>&#13;
<code>1 2 3</code>&#13;
<code>4 5 0</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.10</strong></span> Initializing multidimensional <code>array</code>s.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch06lev3sec13">Declaring an <code>array</code> of <code>array</code>s</h5>&#13;
<p>In the line 12 and line 13 declarations, notice the type:</p>&#13;
<pre class="pre">array&lt;array&lt;<span class="blue">int</span>, columns&gt;, rows&gt;</pre>&#13;
<p>The outer <code>array</code> type indicates that it has <code>rows (2)</code> elements of type</p>&#13;
<pre class="pre">array&lt;<span class="blue">int</span>, columns&gt;</pre>&#13;
<p>So, each of the outer <code>array</code>’s element is an <code>array</code> of <code>int</code>s containing <code>columns</code> (<code>3)</code> elements.</p>&#13;
<h5 class="h5" id="ch06lev3sec14">Initializing an <code>array</code> of <code>array</code>s</h5>&#13;
<p>Line 12’s <code>array1</code> declaration has six initializers. The compiler initializes row 0’s elements, followed by row 1’s elements. So, 1, 2 and 3 initialize row 0’s elements, and 4, 5 and 6 initialize row 1’s elements. Line 13’s <code>array2</code> declaration provides only five initializers. The initializers are assigned to row 0, then row 1. Any elements that do not have an explicit initializer are initialized to zero, so <code>array2[1][2]</code> is 0.</p>&#13;
<h5 class="h5" id="ch06lev3sec15">Displaying an <code>array</code> of <code>array</code>s</h5>&#13;
<p>The program calls function <code>printArray</code> to output each <code>array</code>’s elements. Notice that the function prototype (line 9) and definition (lines 23-33) specify that the function receives a two-row and three-column <code>array.</code> The parameter receives the <code>array</code> by reference and is declared <code>const</code> because the function does not modify the <code>array</code>’s elements.</p>&#13;
<h5 class="h5" id="ch06lev3sec16">Nested Range-Based <code>for</code> Statements</h5>&#13;
<p><span class="size">11</span>To process the elements of a two-dimensional <code>array,</code> we use a nested loop in which the outer loop iterates through the rows, and the inner loop iterates through the columns of a given row. Function <code>printArray</code>’s nested loop is implemented with range-based <code>for</code> statements. Lines 25 and 27 introduce the C++11 <span class="violet"><strong><code>auto</code></strong></span> keyword, which tells the compiler to infer (determine) a variable’s data type based on the variable’s initializer value. The outer loop’s range variable <code>row</code> is initialized with an element from the parameter <code>a.</code> Looking at the <code>array</code>’s declaration, you can see that it contains elements of type</p>&#13;
<pre class="pre">array&lt;<span class="blue">int</span>, columns&gt;</pre>&#13;
<p>so the compiler infers that <code>row</code> refers to a three-element <code>array</code> of <code>int</code> values (again, <code>columns</code> is 3). The <code>const&amp;</code> in <code>row</code>’s declaration indicates that the reference cannot be used to modify the rows and prevents each row from being copied into the range variable. The inner loop’s range variable <code>element</code> is initialized with one element of the <code>array</code> represented by <code>row,</code> so the compiler infers that <code>element</code> refers to an <code>int</code> because each row contains three <code>int</code> values. In many IDEs, hovering the mouse cursor over a variable declared with <code>auto</code> displays the variable’s inferred type. Line 28 displays the value from a given row and column.</p>&#13;
<h5 class="h5" id="ch06lev3sec17">Nested Counter-Controlled <code>for</code> Statements</h5>&#13;
<p>We could have implemented the nested loop with counter-controlled iteration as follows:</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0177-01" id="f0177-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">for</span> (size_t row{<span class="green">0</span>}; row &lt; a.size(); ++row) {&#13;
   <span class="blue">for</span> (size_t column{<span class="green">0</span>}; column &lt; a.at(row).size(); ++column) {&#13;
      cout &lt;&lt; a.at(row).at(column) &lt;&lt; <span class="green">' '</span>; <span class="pd_green">// a[row][column]</span>&#13;
   }&#13;
    cout &lt;&lt; endl;&#13;
}</pre>&#13;
<h5 class="h5" id="ch06lev3sec18">Initializing an <code>array</code> of <code>array</code>s with a Fully Braced Initializer List</h5>&#13;
<p>You may wish to initialize a two-dimensional array using separate initializer sublists for each row. For example, line 12 could be written as:</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0178-01" id="f0178-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">const</span> array&lt;array&lt;<span class="blue">int</span>, columns&gt;, rows&gt; array1{&#13;
   {{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>}, <span class="pd_green">// row 0</span>&#13;
    {<span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>}} <span class="pd_green">// row 1</span>&#13;
};</pre>&#13;
<p>If an initializer sublist has fewer elements than the row, the row’s remaining elements would be initialized to 0.</p>&#13;
<h5 class="h5" id="ch06lev3sec19">Common Two-Dimensional <code>array</code> Manipulations: Setting a Columns’ Values</h5>&#13;
<p>The following <code>for</code> statement sets all the elements in row 2 of <code>array a</code> (from the beginning of this section) to zero:</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0178-02" id="f0178-02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">for</span> (size_t column{<span class="green">0</span>}; column &lt; <span class="green">4</span>; ++column) {&#13;
   a.at(<span class="green">2</span>).at(column) = <span class="green">0</span>; <span class="pd_green">// a[2][column]</span>&#13;
}</pre>&#13;
<p>The <code>for</code> statement varies only the second index (i.e., the column index). The preceding <code>for</code> statement is equivalent to the following assignment statements:</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0178-02a" id="f0178-02aa">Click here to view code image</a></p>&#13;
<pre class="pre">a.at(<span class="green">2</span>)(<span class="green">0</span>)  = <span class="green">0</span>;  <span class="pd_green">// a[2][0]</span>&#13;
a.at(<span class="green">2</span>)(<span class="green">1</span>)  = <span class="green">0</span>;  <span class="pd_green">// a[2][1]</span>&#13;
a.at(<span class="green">2</span>)(<span class="green">2</span>)  = <span class="green">0</span>;  <span class="pd_green">// a[2][2]</span>&#13;
a.at(<span class="green">2</span>)(<span class="green">3</span>)  = <span class="green">0</span>;  <span class="pd_green">// a[2][3]</span></pre>&#13;
<h5 class="h5" id="ch06lev3sec20">Common Two-Dimensional <code>array</code> Manipulations: Totaling All the Elements with Nested Counter-Controlled <code>for</code> Loops</h5>&#13;
<p>The following nested counter-controlled <code>for</code> statement totals the elements in the <code>array a</code> (that we defined in <a href="ch06.xhtml#ch06lev1sec13">Section 6.13</a>’s introduction):</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0178-03" id="f0178-03a">Click here to view code image</a></p>&#13;
<pre class="pre">total = <span class="green">0</span>;&#13;
<span class="blue">for</span> (size_t row{<span class="green">0</span>}; row &lt; a.size(); ++row) {&#13;
   <span class="blue">for</span> (size_t column{<span class="green">0</span>}; column &lt; a.at(row).size(); ++column) {&#13;
      total += a.at(row).at(column); <span class="pd_green">// a[row][column]</span>&#13;
   }&#13;
}</pre>&#13;
<p>The <code>for</code> statement totals the <code>array</code>’s elements one row at a time. The outer loop begins by setting the <code>row</code> index to <code>0,</code> so the elements of row 0 may be totaled by the inner loop. The outer loop then increments <code>row</code> to <code>1,</code> so the elements of row 1 can be totaled. Then, the outer <code>for</code> statement increments <code>row</code> to <code>2,</code> so the elements of row 2 can be totaled.</p>&#13;
<h5 class="h5" id="ch06lev3sec21">Common Two-Dimensional <code>array</code> Manipulations: Totaling All the Elements with Nested Range-Based <code>for</code> Loops</h5>&#13;
<p>Nested range-based <code>for</code> statements are the preferred way to implement the preceding loop:</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0178-04" id="f0178-04a">Click here to view code image</a></p>&#13;
<pre class="pre">total = <span class="green">0</span>;&#13;
<span class="blue">for</span> (<span class="blue">auto</span> row : a) { <span class="pd_green">// for each row</span>&#13;
   <span class="blue">for</span> (<span class="blue">auto</span> column : row) { <span class="pd_green">// for each column in row</span>&#13;
      total += column;&#13;
   }&#13;
}</pre>&#13;
<h3 class="h3" id="ch06lev1sec14"><span class="violet">6.14</span> Intro to Functional-Style Programming</h3>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> Like other popular languages, such as Python, Java and C#, C++ supports several programming paradigms—procedural, object-oriented, generic (template-oriented) and “functional-style.” C++’s “functional-style” features help you write more concise code with fewer errors, and that’s easier to read, debug and modify. Functional-style programs also can be easier to parallelize to get better performance on today’s multi-core processors.</p>&#13;
<h4 class="h4" id="ch06lev2sec1">6.14.1 What vs. How</h4>&#13;
<p>As a program’s tasks get more complicated, the code can become harder to read, debug and modify, and more likely to contain errors. Specifying <em>how</em> the code works can become complex. With functional-style programming, you specify <em>what</em> you want to do, and library code typically handles “the how” for you. This can eliminate many errors.</p>&#13;
<p>Consider the following range-based <code>for</code> statement from <a href="ch06.xhtml#fig6_5">Fig. 6.5</a>, which totals the elements of the <code>array integers:</code></p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0179-01" id="f0179-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">const int</span> item : integers) {&#13;
   total += item;&#13;
}</pre>&#13;
<p>Though this procedural code hides the iteration details, we still have to specify how to total the elements by adding each <code>item</code> into the variable <code>total.</code> Each time you modify a variable, you can introduce errors. Functional-style programming emphasizes <span class="violet"><strong>immutability—</strong></span> it avoids operations that modify variables’ values. If this is your first exposure to functional-style programming, you might be wondering, “How can this be?” Read on.</p>&#13;
<h5 class="h5" id="ch06lev3sec22">Functional-Style Reduction with <code>accumulate</code></h5>&#13;
<p><a href="ch06.xhtml#fig6_11">Figure 6.11</a> replaces <a href="ch06.xhtml#fig6_5">Fig. 6.5</a>’s range-based <code>for</code> statement with a call to the C++ standard library <span class="violet"><strong><code>accumulate</code></strong></span> algorithm (from header <span class="violet"><strong><code>&lt;numeric&gt;).</code></strong></span> By default, this function knows <em>how</em> to reduce a container’s values to the sum of those values. As we’ve mentioned, reduction is a key functional-style programming concept. The next example shows that you can customize how <code>accumulate</code> performs its reduction.</p>&#13;
<div class="group" id="fig6_11">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig11" id="aa06fig11">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_11.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Compute the sum of the elements of an array.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;numeric&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code><span class="blue">constexpr</span> size_t arraySize{<span class="green">4</span>};</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code>array&lt;<span class="blue">int</span>, arraySize&gt; integers{<span class="green">10</span>, <span class="green">20</span>, <span class="green">30</span>, <span class="green">40</span>};</code>&#13;
<span class="cviolet"><strong>11</strong></span>       <code>cout &lt;&lt; <span class="green">"Total of array elements: "</span> &lt;&lt;</code>&#13;
<span class="cviolet"><strong>12</strong></span>          <span class="yell"><code>accumulate(begin(integers), end(integers), <span class="green">0</span>)</code></span> <code>&lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>13</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Total of array elements: 100</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.11</strong></span> Compute the sum of the elements of an <code>array</code>.</p>&#13;
</div>&#13;
<p>Like function <code>sort</code> in <a href="ch06.xhtml#ch06lev1sec12">Section 6.12</a>, function <code>accumulate</code>’s first two arguments specify the range of elements to total—in this case, all the elements from the beginning to the end of <code>integers.</code> The function <em>internally</em> increments the running total of the elements it processes, hiding those calculations. The third argument is that total’s initial value.</p>&#13;
<p>Function <code>accumulate</code> uses <span class="violet"><strong>internal iteration,</strong></span> which also is hidden from you. The function knows <em>how</em> to iterate through a range of elements and add each element to the running total. Stating <em>what</em> you want to do rather than programming <em>how</em> to do it is known as <span class="violet"><strong>declarative programming</strong></span>—a key aspect of functional programming.</p>&#13;
<h4 class="h4" id="ch06lev2sec2">6.14.2 Passing Functions as Arguments to Other Functions— Introducing Lambda Expressions</h4>&#13;
<p>Many standard library functions allow you to customize how they work by passing other functions as arguments. Functions that receive other functions as arguments are called <span class="violet"><strong>higher-order functions</strong></span>—a key aspect of functional programming. For example, function <code>accumulate</code> totals elements by default. It also has an overloaded version, which receives as its fourth argument a function that specifies how to perform the reduction. Rather than simply totaling the values, <a href="ch06.xhtml#fig6_12">Fig. 6.12</a> calculates the product of the values.</p>&#13;
<div class="group" id="fig6_12">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig12" id="aa06fig12">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_12.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Compute the product of an array's elements using accumulate.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;numeric&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int</span> multiply(<span class="blue">int</span> x, <span class="blue">int</span> y) {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code><span class="blue">return</span> x * y;</code>&#13;
<span class="cviolet"><strong>10</strong></span>    <code>}</code>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>13</strong></span>      <code><span class="blue">constexpr</span> size_t arraySize{<span class="green">5</span>};</code>&#13;
<span class="cviolet"><strong>14</strong></span>      <code>array&lt;<span class="blue">int</span>, arraySize&gt; integers{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>};</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <code>cout &lt;&lt; <span class="green">"Product of integers: "</span></code>&#13;
<span class="cviolet"><strong>17</strong></span>         <code>&lt;&lt; <span class="yell">accumulate(begin(integers), end(integers), <span class="green">1</span>, multiply)</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <code>cout &lt;&lt; <span class="green">"Product of integers with a lambda: "</span></code>&#13;
<span class="cviolet"><strong>20</strong></span>         <code>&lt;&lt;</code> <span class="yell"><code>accumulate(begin(integers), end(integers), <span class="green">1</span>,</code>      </span>&#13;
<span class="cviolet"><strong>21</strong></span>            <span class="yell">   <code>[](const aut<span class="blue">o&amp; x,</span> <span class="blue">const auto</span>&amp; y){<span class="blue">return</span> x * y;})</code></span> <code>&lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>22</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Product of integers: 120</code>&#13;
<code>Product of integers with a lambda: 120</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.12</strong></span> Lambda expressions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch06lev3sec23">Calling <code>accumulate</code> with a Named Function</h5>&#13;
<p>Line 17 calls <code>accumulate</code> for the <code>array integers</code> containing the values <code>1-5.</code> We’re calculating the product of the values, so the third argument (i.e., the initial value of the reduction) is <code>1,</code> rather than <code>0;</code> otherwise, the final product would be <code>0.</code> The fourth argument is the function to call for every <code>array</code> element—in this case, <code>multiply</code> (defined in lines 8–10). To calculate a product, this function must receive two arguments—the product so far and a value from the <code>array</code>—and must return a value, which becomes the new product. As <code>accumulate</code> iterates through the range of elements, it passes the current product and the next element as arguments. For this example, <code>accumulate</code> internally calls <code>multiply</code> five times:</p>&#13;
<p class="bull">• The first call passes the initial product <code>(1)</code> and the array’s first element <code>(1),</code> producing the product <code>1.</code></p>&#13;
<p class="bull">• The second call passes the current product <code>(1)</code> and the array’s second element <code>(2),</code> producing the product <code>2.</code></p>&#13;
<p class="bull">• The third call passes <code>2</code> and the array’s third element <code>(3),</code> producing the product <code>6.</code></p>&#13;
<p class="bull">• The fourth call passes <code>6</code> and the array’s fourth element <code>(4),</code> producing the product <code>24.</code></p>&#13;
<p class="bull">• The last call passes <code>24</code> and the array’s fifth element <code>(5),</code> producing the final result <code>120,</code> which <code>accumulate</code> returns to its caller.</p>&#13;
<h5 class="h5" id="ch06lev3sec24">Calling <code>accumulate</code> with a Lambda Expression</h5>&#13;
<p><span class="size">11</span> In some cases, you may not need to reuse a function. In such cases, you can define a function where it’s needed by using a C++11 <span class="violet"><strong>lambda expression</strong></span> (or simply <span class="violet"><strong>lambda</strong></span>). A lambda expression is an <em>anonymous function</em>—that is, a function without a name. The call to accumulate in lines 20-21 uses the following lambda expression to perform the same task as <code>multiply</code> (line 17):</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0181-01" id="f0181-01a">Click here to view code image</a></p>&#13;
<pre class="pre">[](<span class="blue">const auto</span>&amp; x, <span class="blue">const auto</span>&amp; y){<span class="blue">return</span> x * y;}</pre>&#13;
<p>Lambdas begin with the <span class="violet"><strong>lambda introducer</strong></span> (<code>[]</code>), followed by a comma-separated parameter list and a function body. This lambda receives two parameters, calculates their product and returns the result.</p>&#13;
<p><span class="size">14</span> You saw in <a href="ch06.xhtml#ch06lev1sec13">Section 6.13</a> that <code>auto</code> enables the compiler to infer a variable’s type based on its initial value. Specifying a lambda parameter’s type as <code>auto</code> enables the compiler to infer the parameter’s type, based on the context in which the lambda appears. In this example, <code>accumulate</code> calls the lambda once for each element of the <code>array,</code> passing the current product and the element’s value as the lambda’s arguments. Since the initial product <code>(1)</code> is an <code>int</code> and the <code>array</code> contains <code>int</code>s, the compiler infers the lambda parameters’ types as <code>int.</code> Using <code>auto</code> to infer each parameter’s type is a C++14 feature called <span class="violet"><strong>generic lambdas.</strong></span> The compiler also infers the lambda’s return type from the expression <code>x * y</code>—both <code>x</code> and <code>y</code> are <code>int</code>s, so this lambda returns an <code>int.</code></p>&#13;
<p>We declared the parameters as <code>const</code> references:</p>&#13;
<p class="bull">• They are <code>const</code> so the lambda’s body does not modify the caller’s variables.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span></p>&#13;
<p class="bull">• They are references for performance to ensure that the lambda does not copy large objects.</p>&#13;
<p>This lambda could be used with any numeric type that supports the multiplication operator. <a href="ch18.xhtml#ch18">Chapter 18</a> discusses lambda expressions in detail.</p>&#13;
<p><span class="size">20</span></p>&#13;
<h4 class="h4" id="ch06lev2sec3">6.14.3 Filter, Map and Reduce: Intro to C++20’s Ranges Library</h4>&#13;
<p>The C++ standard library has enabled functional-style programming for many years. C++20’s new <span class="violet"><strong>ranges library<sup><a id="rch06fn7" href="ch06.xhtml#ch06fn7">7</a></sup></strong></span> (header <span class="violet"><strong><code>&lt;ranges&gt;)</code></strong></span> makes functional-style programming more convenient. In this section, we introduce two key aspects of this library—ranges and views:</p>&#13;
<p class="footnote"><a id="ch06fn7" href="ch06.xhtml#rch06fn7">7</a>. At the time of this writing, only GNU C++ 10.1 implements the ranges library. We compiled and executed this example using the GNU GCC Docker container version 10.1 from <code><a href="https://hub.docker.com/_/gcc">https://hub.docker.com/_/gcc</a></code>. Refer to the Chapter 1 test-drives for details on compiling and executing programs with this Docker container.</p>&#13;
<p class="bull">• A <span class="violet"><strong>range</strong></span> is a collection of elements that you can iterate over, so an <code>array,</code> for example, is a range.</p>&#13;
<p class="bull">• A <span class="violet"><strong>view</strong></span> enables you to specify an operation that manipulates a range. Views are <span class="violet"><strong>composable</strong></span>—you can chain them together to process a range’s elements through multiple operations.</p>&#13;
<p>The program of <a href="ch06.xhtml#fig6_13">Fig. 6.13</a> demonstrates several functional-style operations using C++20 ranges. We’ll cover more features of this library in <a href="ch18.xhtml#ch18">Chapter 18</a>.</p>&#13;
<div class="group" id="fig6_13">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig13" id="aa06fig13">Click here to view code image</a></p>&#13;
<pre class="pre3"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_13.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Functional-style programming with C++20 ranges and views.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;numeric&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">#include</span> &lt;ranges&gt;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>8</strong></span>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code><span class="pd_green">// lambda to display results of range operations</span></code>&#13;
<span class="cviolet"><strong>11</strong></span>       <code><span class="blue">auto</span> showValues = [](<span class="blue">auto</span>&amp; values, <span class="blue">const</span> string&amp; message) {</code>&#13;
<span class="cviolet"><strong>12</strong></span>          <code>cout &lt;&lt; message &lt;&lt; <span class="green">": "</span>;</code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>          <code><span class="blue">for</span> (<span class="blue">auto</span> value : values) {</code>&#13;
<span class="cviolet"><strong>15</strong></span>             <code>cout &lt;&lt; value &lt;&lt; <span class="green">" "</span>;</code>&#13;
<span class="cviolet"><strong>16</strong></span>          <code>}</code>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>          <code>cout &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>19</strong></span>    <code>};</code>&#13;
<span class="cviolet"><strong>20</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.13</strong></span> Functional-style programming with C++20 ranges and views.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch06lev3sec25"><code>showValues</code> Lambda for Displaying This Application’s Results</h5>&#13;
<p><span class="size">17</span> Throughout this example, we display various range operations’ results using a range-based <code>for</code> statement. Rather than repeating that code, we could define a function that receives a range and displays its values. For flexibility, we could use a function template, so it will work with ranges of various types. Here, we chose to define a generic lambda and demonstrate that you can store a lambda in a local variable <code>(showValues;</code> lines 11-19). You can <code>17</code> use the variable’s name to call the lambda, as we do in lines 22, 27, 32, 38 and 49. C++17 made minor changes to the range-based <code>for</code> statement so that it eventually could be used with C++20 ranges, as we do in lines 14-16.</p>&#13;
<h5 class="h5" id="ch06lev3sec26">Generating a Sequential Range of Integers with <code>views::iota</code></h5>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> In many of this chapter’s examples, we creted an <code>array,</code> then processed its values. This required pre-allocating the array with the appropriate number of elements. In some cases, you can generate values <em>on demand,</em> rather than creating and storing the values in advance. Operations that generate values on demand use <span class="violet"><strong>lazy evaluation,</strong></span> which can reduce your program’s memory consumption and improve performance when all the values are not needed at once. Line 21 uses the <code>&lt;range&gt;</code> library’s <span class="violet"><strong><code>views::iota</code></strong></span> to generate a range of integers from its first argument <code>(1)</code> up to, but not including, its second argument <code>(11).</code> The values are not generated until the program iterates over the results, which occurs when we call <code>showValues</code> (line 22) to display the generated values.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0183-01" id="f0183-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">21</span></strong>    <span class="yell"><span class="blue">auto</span> values1 = views::iota(<span class="green">1</span>, <span class="green">11</span>);</span> <span class="pd_green">// generate integers 1-10</span>&#13;
<strong><span class="cviolet">22</span></strong>    showValues(values1, <span class="green">"Generate integers 1-10"</span>);&#13;
<strong><span class="cviolet">23</span></strong></pre>&#13;
<pre class="pre1">Generate integers 1-10: 1 2 3 4 5 6 7 8 9 10</pre>&#13;
<h5 class="h5" id="ch06lev3sec27">Filtering Items with <code>views::filter</code></h5>&#13;
<p>A common functional-style programming operation is <span class="violet"><strong>filtering</strong></span> elements to select only those that match a condition. This often produces fewer elements than the range being filtered. One way to implement filtering would be a loop that iterates over the elements, checks whether each element matches a condition, then do something with that element. That requires external iteration, which can be error-prone (as we discussed in <a href="ch06.xhtml#ch06lev1sec6">Section 6.6</a>).</p>&#13;
<p>With ranges and views, we can use <span class="violet"><strong><code>views::filter</code></strong></span> to focus on <em>what</em> we want to accomplish—get the even integers in the range 1-10. The expression</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0183-02" id="f0183-02a">Click here to view code image</a></p>&#13;
<pre class="pre">values1 | views::filter([](<span class="blue">const auto</span>&amp; x) {<span class="blue">return</span> x % <span class="green">2</span> == <span class="green">0</span>;});</pre>&#13;
<p>in line 26 uses the <span class="violet"><strong><code>|</code> operator</strong></span> to connect multiple operations. The first operation <code>(values1</code> from line 21) generates <code>1-10,</code> and the second filters those results. Together, these operations form a <span class="violet"><strong>pipeline.</strong></span> Each pipeline begins with a range, which is the data source (the values <code>1-10</code> produced by <code>values1),</code> followed by an arbitrary number of operations, each separated from the next by <code>|</code>.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0183-03" id="f0183-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">24</span></strong>    <span class="pd_green">// filter each value in values1, keeping only the even integers</span>&#13;
<strong><span class="cviolet">25</span></strong>    <span class="yell"><span class="blue">auto</span> values2 =                                                     </span>&#13;
<strong><span class="cviolet">26</span></strong>    <span class="yell">   values1 | views::filter([](<span class="blue">const auto</span>&amp; x) {<span class="blue">return</span> x % <span class="green">2</span> == <span class="green">0</span>;});</span>&#13;
<strong><span class="cviolet">27</span></strong>    showValues(values2, <span class="green">"Filtering even integers"</span>);&#13;
<strong><span class="cviolet">28</span></strong></pre>&#13;
<pre class="pre1">Filtering even integers: 2 4 6 8 10</pre>&#13;
<p>The argument to <code>views::filter</code> must be a function that receives one value to process and returns a <code>bool</code> indicating whether to keep the value. In this case, we passed a lambda that returns <code>true</code> if its argument is divisible by 2.</p>&#13;
<p>After lines 25-26 execute, <code>values2</code> represents a pipeline that can generate the integers 1-10 and filter those values, keeping only the even integers. The pipeline concisely represents <em>what</em> we want to do, but not <em>how</em> to implement it—<code>views::iota</code> knows <em>how</em> to generate integers, and <code>views::filter</code> knows <em>how</em> to use its function argument to determine whether to keep each value received from earlier in the pipeline.</p>&#13;
<p>When <code>showValues</code> iterates over <code>values2, views::iota</code> produces a value, then <code>views::filter</code> calls its argument to determine whether to keep the value. If so, the range- based <code>for</code> statement receives that value from the pipeline and displays it. Otherwise, the processing steps repeat with the next value generated by <code>views::iota.</code></p>&#13;
<h5 class="h5" id="ch06lev3sec28">Mapping Items with <code>views::transform</code></h5>&#13;
<p>Another common functional-style programming operation is <span class="violet"><strong>mapping</strong></span> elements to new values (possibly of different types). Mapping produces a result with the same number of elements as the original data being mapped. With C++20 ranges, <span class="violet"><strong><code>views::transform</code></strong></span> performs mapping operations. The pipeline in lines 30-31 adds another operation to the pipeline from lines 25-26, mapping the filtered results from <code>values2</code> to their squares with the lambda expression passed to <code>views::transform</code> in line 31.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0184-01" id="f0184-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">29</span></strong>    <span class="pd_green">// map each value in values2 to its square</span>&#13;
<strong><span class="cviolet">30</span></strong>    <span class="yell"><span class="blue">auto</span> values3 =                                                   </span>&#13;
<strong><span class="cviolet">31</span></strong>    <span class="yell">   values2 | views::transform([](<span class="blue">const</span> <span class="blue">auto</span>&amp; x) {<span class="blue">return</span> x * x;});</span>&#13;
<strong><span class="cviolet">32</span></strong>    showValues(values3, <span class="green">"Mapping even integers to squares"</span>);&#13;
<strong><span class="cviolet">33</span></strong></pre>&#13;
<pre class="pre1">Mapping even integers to squares: 4 16 36 64 100</pre>&#13;
<p>The argument to <code>views::transform</code> is a function that receives a value to process and returns the mapped value (possibly of a different type). When <code>showValues</code> iterates over the results of the <code>values3</code> pipeline:</p>&#13;
<p class="bull">• <code>views::iota</code> produces a value.</p>&#13;
<p class="bull">• <code>views::filter</code> determines whether the value is even and, if so, passes it to the next pipeline step; otherwise, processing proceeds with the next value generated by <code>views::iota.</code></p>&#13;
<p class="bull">• <code>views:transform</code> calculates the square of the even integer (as specified by line 31’s lambda), then the range-based <code>for</code> loop in <code>showValues</code> displays the value and processing proceeds with the next value generated by <code>views::iota.</code></p>&#13;
<h5 class="h5" id="ch06lev3sec29">Combining Filtering and Mapping Operations into a Pipeline</h5>&#13;
<p>A pipeline may contain an arbitrary number of operations separated by <code>|</code> operators. The pipeline in lines 35-37 combines all of the preceding operations into a single pipeline, and line 38 displays the results.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0184-02" id="f0184-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">34</span></strong>    <span class="pd_green">// combine filter and transform to get squares of the even integers</span>&#13;
<strong><span class="cviolet">35</span></strong>    <span class="yell"><span class="blue">auto</span> values4 =                                                    </span>&#13;
<strong><span class="cviolet">36</span></strong>    <span class="yell">   values1 | views::filter([](<span class="blue">const auto</span>&amp; x) {<span class="blue">return</span> x % <span class="green">2</span> == <span class="green">0</span>;})</span>&#13;
<strong><span class="cviolet">37</span></strong>    <span class="yell">           | views::transform([](<span class="blue">const auto</span>&amp; x) {<span class="blue">return</span> x * x;}); </span>&#13;
<strong><span class="cviolet">38</span></strong>    showValues(values4, <span class="green">"Squares of even integers"</span>);&#13;
<strong><span class="cviolet">39</span></strong></pre>&#13;
<pre class="pre1">Squares of even integers: 4 16 36 64 100</pre>&#13;
<h5 class="h5" id="ch06lev3sec30">Reducing a Range Pipeline with <code>accumulate</code></h5>&#13;
<p>C++ standard library functions like <code>accumulate</code> also work with range pipelines. Line 42 performs a reduction that sums the squares of the even integers produced by the pipeline in lines 35-37.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0185-01" id="f0185-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">40</span></strong>    <span class="pd_green">// total the squares of the even integers</span>&#13;
<strong><span class="cviolet">41</span></strong>    cout &lt;&lt; <span class="green">"Sum the squares of the even integers from 2-10: "</span> &lt;&lt;&#13;
<strong><span class="cviolet">42</span></strong>       accumulate(begin(values4), end(values4), <span class="green">0</span>) &lt;&lt; endl;&#13;
<strong><span class="cviolet">43</span></strong></pre>&#13;
<pre class="pre1">Sum the squares of the even integers from 2-10: 220</pre>&#13;
<h5 class="h5" id="ch06lev3sec31">Filtering and Mapping an Existing Container’s Elements</h5>&#13;
<p>Various C++ containers, including <code>array</code>s and <code>vector</code>s (<a href="ch06.xhtml#ch06lev1sec15">Section 6.15</a>), can be used as the data source in a range pipeline. Line 45 declares an <code>array</code> containing <code>1-10,</code> then uses it in a pipeline that calculates the squares of the even integers in the <code>array.</code></p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0185-02" id="f0185-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">44</span></strong>     <span class="pd_green">// process a container's elements</span>&#13;
<strong><span class="cviolet">45</span></strong>     array&lt;<span class="blue">int</span>, <span class="green">10</span>&gt; numbers{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>, <span class="green">7</span>, <span class="green">8</span>, <span class="green">9</span>, <span class="green">10</span>};&#13;
<strong><span class="cviolet">46</span></strong>     <span class="yell"><span class="blue">auto</span> values5 =                                                    </span>&#13;
<strong><span class="cviolet">47</span></strong>     <span class="yell">   numbers | views::filter([](<span class="blue">const auto</span>&amp; x) {<span class="blue">return</span> x % <span class="green">2</span> == <span class="green">0</span>;})</span>&#13;
<strong><span class="cviolet">48</span></strong>     <span class="yell">           | views::transform([](<span class="blue">const auto</span>&amp; x) {<span class="blue">return</span> x * x;}); </span>&#13;
<strong><span class="cviolet">49</span></strong>     showValues(values5, <span class="green">"Squares of even integers in array numbers"</span>);&#13;
<strong><span class="cviolet">50</span></strong>  }</pre>&#13;
<pre class="pre1">Squares of even integers in array numbers: 4 16 36 64 100</pre>&#13;
<h3 class="h3" id="ch06lev1sec15"><span class="violet">6.15</span> Objects Natural Case Study: C++ Standard Library Class Template <code>vector</code></h3>&#13;
<p>We now continue our objects natural presentation by taking objects of C++ standard library class template <span class="violet"><strong><code>vector<sup><a id="rch06fn8" href="ch06.xhtml#ch06fn8">8</a></sup></code></strong></span> “out for a spin.” A <code>vector</code> is similar to an <code>array,</code> but also supports dynamic resizing. <code>vector</code> is defined in header <code>&lt;vector&gt;</code> (<a href="ch06.xhtml#fig6_14">Fig. 6.14</a>, line 5) and belongs to namespace <code>std.</code> At the end of this section, we’ll demonstrate <code>vector</code>’s bounds checking capabilities (which <code>array</code> also has). There, we’ll introduce C++’s exception- handling mechanism, which can be used to detect and handle an out-of-bounds <code>vector</code> index. At that point, we’ll discuss the <code>&lt;stdexcept&gt;</code> header (line 6).</p>&#13;
<p class="footnote"><a id="ch06fn8" href="ch06.xhtml#rch06fn8">8</a>. Chapter 17 discusses more <code>vector</code> capabilities.</p>&#13;
<div class="group" id="fig6_14">&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#a06fig14" id="aa06fig14">Click here to view code image</a></p>&#13;
<pre class="pre3"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig06_14.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Demonstrating C++ standard library class template vector.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// C++20: This will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <span class="yell"><code><span class="blue">#include</span> &lt;vector&gt;</code>   </span>&#13;
 <span class="cviolet"><strong>6</strong></span>    <span class="yell"><code><span class="blue">#include</span> &lt;stdexcept&gt;</code></span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>8</strong></span>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">void</span> outputVector(<span class="yell"><span class="blue">const</span> vector&lt;<span class="blue">int</span>&gt;&amp; items</span>); <span class="pd_green">// display the vector</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>    <code><span class="blue">void</span> inputVector(<span class="yell">vector&lt;<span class="blue">int</span>&gt;&amp; items</span>); <span class="pd_green">// input values into the vector</span></code>&#13;
<span class="cviolet"><strong>11</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 6.14</strong></span> Demonstrating C++ standard library class template <code>vector.</code></p>&#13;
</div>&#13;
<h5 class="h5" id="ch06lev3sec32">Creating <code>vector</code> Objects</h5>&#13;
<p>Lines 13-14 create two <code>vector</code> objects that store values of type <code>int—integers1</code> contains seven elements, and <code>integers2</code> contains 10 elements. By default, all the elements of each <code>vector</code> object are set to <code>0.</code> Like <code>array</code>s, <code>vector</code>s can be defined to store most data types, by replacing <code>int</code> in <code>vector&lt;int&gt;</code> with the appropriate type.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0186-01" id="f0186-01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">12</span></strong>   <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">13</span></strong>      <span class="yell">vector&lt;<span class="blue">int</span>&gt; integers1(<span class="green">7</span>); <span class="pd_green">// 7-element vector&lt;int&gt;</span></span>&#13;
<strong><span class="cviolet">14</span></strong>      <span class="yell">vector&lt;<span class="blue">int</span>&gt; integers2(<span class="green">10</span>); <span class="pd_green">// 10-element vector&lt;int&gt;</span></span>&#13;
<strong><span class="cviolet">15</span></strong></pre>&#13;
<p>Notice that we used parentheses rather than braces to pass the size argument to each <code>vector</code> object’s constructor. When creating a <code>vector,</code> if the braces contain one value of the <code>vector</code>’s element type, the compiler treats the braces as a one-element initializer list, rather than the <code>vector</code>’s size. So the following declaration actually creates a one-element <code>vector&lt;int&gt;</code> containing the <code>int</code> value <code>7,</code> not a 7-element <code>vector:</code></p>&#13;
<pre class="pre">vector&lt;<span class="blue">int</span>&gt; integers1{<span class="green">7</span>};</pre>&#13;
<h5 class="h5" id="ch06lev3sec33"><code>vector</code> Member Function <code>size;</code> Function <code>outputVector</code></h5>&#13;
<p>Line 17 uses <code>vector</code> member function <span class="violet"><strong><code>size</code></strong></span> to obtain <code>integers1</code>’s size (i.e., the number of elements). Line 19 passes <code>integers1</code> to function <code>outputVector</code> (lines 95-101), which displays the <code>vector</code>’s elements using a range-based <code>for.</code> Lines 22 and 24 perform the same tasks for <code>integers2.</code></p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0186-02" id="f0186-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">16</span></strong>    <span class="pd_green">// print integers1 size and contents</span>&#13;
<strong><span class="cviolet">17</span></strong>    cout &lt;&lt; <span class="green">"Size of vector integers1 is "</span> &lt;&lt; <span class="yell">integers1.size()</span>&#13;
<strong><span class="cviolet">18</span></strong>       &lt;&lt; <span class="green">"\nvector after initialization:"</span>;&#13;
<strong><span class="cviolet">19</span></strong>    outputVector(integers1);&#13;
<strong><span class="cviolet">20</span></strong>&#13;
<strong><span class="cviolet">21</span></strong>    <span class="pd_green">// print integers2 size and contents</span>&#13;
<strong><span class="cviolet">22</span></strong>    cout &lt;&lt; <span class="green">"\nSize of vector integers2 is "</span> &lt;&lt; <span class="yell">integers2.size()</span>&#13;
<strong><span class="cviolet">23</span></strong>       &lt;&lt; <span class="green">"\nvector after initialization:"</span>;&#13;
<strong><span class="cviolet">24</span></strong>    outputVector(integers2);&#13;
<strong><span class="cviolet">25</span></strong></pre>&#13;
<pre class="pre1">Size of vector integers1 is 7&#13;
vector after initialization: 0 0 0 0 0 0 0&#13;
&#13;
Size of vector integers2 is 10&#13;
vector after initialization: 0 0 0 0 0 0 0 0 0 0</pre>&#13;
<h5 class="h5" id="ch06lev3sec34">Function <code>inputVector</code></h5>&#13;
<p>Lines 28-29 pass <code>integers1</code> and <code>integers2</code> to function <code>inputVector</code> (lines 104-108) to read values for each <code>vector</code>’s elements from the user.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0187-01" id="f0187-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">26</span></strong>    <span class="pd_green">// input and print integers1 and integers2</span>&#13;
<strong><span class="cviolet">27</span></strong>    cout &lt;&lt; <span class="green">"\nEnter 17 integers:"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">28</span></strong>    inputVector(integers1);&#13;
<strong><span class="cviolet">29</span></strong>    inputVector(integers2);&#13;
<strong><span class="cviolet">30</span></strong>&#13;
<strong><span class="cviolet">31</span></strong>    cout &lt;&lt; <span class="green">"\nAfter input, the vectors contain:\n"</span>&#13;
<strong><span class="cviolet">32</span></strong>       &lt;&lt; <span class="green">"integers1:"</span>;&#13;
<strong><span class="cviolet">33</span></strong>    outputVector(integers1);&#13;
<strong><span class="cviolet">34</span></strong>    cout &lt;&lt; <span class="green">"integers2:"</span>;&#13;
<strong><span class="cviolet">35</span></strong>    outputVector(integers2);&#13;
<strong><span class="cviolet">36</span></strong></pre>&#13;
<pre class="pre1">Enter 17 integers:&#13;
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17&#13;
&#13;
After input, the vectors contain:&#13;
integers1: 1 2 3 4 5 6 7&#13;
integers2: 8 9 10 11 12 13 14 15 16 17</pre>&#13;
<h5 class="h5" id="ch06lev3sec35">Comparing <code>vector</code> Objects for Inequality</h5>&#13;
<p>In <a href="ch05.xhtml#ch05">Chapter 5</a>, we introduced function overloading. A similar concept is operator overloading, which allows you to define how a built-in operator works for a custom type. The C++ standard library already defines overloaded operators <code>==</code> and <code>!=</code> for <code>array</code>s and <code>vector</code>s, so you can compare two <code>array</code>s or two <code>vector</code>s for equality or inequality, respectively. Line 40 compares two <code>vector</code> objects using the <code>!=</code> operator. This operator returns <code>true</code> if the contents of two <code>vector</code>s are not equal—that is, they have different lengths or the elements at the same index in both <code>vector</code>s are not equal. Otherwise, <code>!=</code> returns <code>false.</code></p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0187-02" id="f0187-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">37</span></strong>    <span class="pd_green">// use inequality (!=) operator with vector objects</span>&#13;
<strong><span class="cviolet">38</span></strong>    cout &lt;&lt; <span class="green">"\nEvaluating: integers1 != integers2"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">39</span></strong>&#13;
<strong><span class="cviolet">40</span></strong>    if (<span class="yell">integers1 != integers2</span>) {&#13;
<strong><span class="cviolet">41</span></strong>       cout &lt;&lt; <span class="green">"integers1 and integers2 are not equal"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">42</span></strong>    }&#13;
<strong><span class="cviolet">43</span></strong></pre>&#13;
<pre class="pre1">Evaluating: integers1 != integers2&#13;
integers1 and integers2 are not equal</pre>&#13;
<h5 class="h5" id="ch06lev3sec36">Initializing One <code>vector</code> with the Contents of Another</h5>&#13;
<p>A new <code>vector</code> can be initialized with the contents of an existing <code>vector.</code> Line 46 creates a <code>vector</code> object <code>integers3</code> and initializes it with a copy of <code>integers1.</code> This invokes class template <code>vector</code>’s copy constructor to perform the copy operation. You’ll learn about copy constructors in detail in <a href="ch14.xhtml#ch14">Chapter 14</a>. Lines 48-50 output the size and contents of <code>integers3</code> to demonstrate that it was initialized correctly.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0188-01" id="f0188-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">44</span></strong>    <span class="pd_green">// create vector integers3 using integers1 as an</span>&#13;
<strong><span class="cviolet">45</span></strong>    <span class="pd_green">// initializer; print size and contents</span>&#13;
<strong><span class="cviolet">46</span></strong>    <span class="yell">vector&lt;<span class="blue">int</span>&gt; integers3{integers1}; <span class="pd_green">// copy constructor</span></span>&#13;
<strong><span class="cviolet">47</span></strong>&#13;
<strong><span class="cviolet">48</span></strong>    cout &lt;&lt; <span class="green">"\nSize of vector integers3 is "</span> &lt;&lt; <span class="yell">integers3.size()</span>&#13;
<strong><span class="cviolet">49</span></strong>       &lt;&lt; <span class="green">"\nvector after initialization: "</span>;&#13;
<strong><span class="cviolet">50</span></strong>    outputVector(integers3);&#13;
<strong><span class="cviolet">51</span></strong></pre>&#13;
<pre class="pre1">Size of vector integers3 is 7&#13;
vector after initialization: 1 2 3 4 5 6 7</pre>&#13;
<h5 class="h5" id="ch06lev3sec37">Assigning <code>vector</code>s and Comparing <code>vector</code>s for Equality</h5>&#13;
<p>Line 54 assigns <code>integers2</code> to <code>integers1,</code> demonstrating that the assignment (<code>=</code>) operator is overloaded to work with <code>vector</code> objects. Lines 56-59 output the contents of both objects to show that they now contain identical values. Line 64 then compares <code>integers1</code> to <code>integers2</code> with the equality (<code>==</code>) operator to determine whether the contents of the two objects are equal after the assignment (which they are).</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0188-02" id="f0188-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">52</span></strong>    <span class="pd_green">// use overloaded assignment (=) operator</span>&#13;
<strong><span class="cviolet">53</span></strong>    <span class="yell">cout &lt;&lt; <span class="green">"\nAssigning integers2 to integers1:"</span> &lt;&lt; endl;</span>&#13;
<strong><span class="cviolet">54</span></strong>    <span class="yell">integers1 = integers2; <span class="pd_green">// assign integers2 to integers1</span></span>&#13;
<strong><span class="cviolet">55</span></strong>&#13;
<strong><span class="cviolet">56</span></strong>    cout &lt;&lt; <span class="green">"integers1: "</span>;&#13;
<strong><span class="cviolet">57</span></strong>    outputVector(integers1);&#13;
<strong><span class="cviolet">58</span></strong>    cout &lt;&lt; <span class="green">"integers2: "</span>;&#13;
<strong><span class="cviolet">59</span></strong>    outputVector(integers2);&#13;
<strong><span class="cviolet">60</span></strong>&#13;
<strong><span class="cviolet">61</span></strong>    <span class="pd_green">// use equality (==) operator with vector objects</span>&#13;
<strong><span class="cviolet">62</span></strong>    cout &lt;&lt; <span class="green">"\nEvaluating: integers1 == integers2"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">63</span></strong>&#13;
<strong><span class="cviolet">64</span></strong>    if (<span class="yell">integers1 == integers2</span>) {&#13;
<strong><span class="cviolet">65</span></strong>       cout &lt;&lt; <span class="green">"integers1 and integers2 are equal"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">66</span></strong>    }&#13;
<strong><span class="cviolet">67</span></strong></pre>&#13;
<pre class="pre1">Assigning integers2 to integers1:&#13;
integers1: 8 9 10 11 12 13 14 15 16 17&#13;
integers2: 8 9 10 11 12 13 14 15 16 17&#13;
&#13;
Evaluating: integers1 == integers2&#13;
integers1 and integers2 are equal</pre>&#13;
<h5 class="h5" id="ch06lev3sec38">Using the <code>at</code> Member Function to Access and Modify <code>vector</code> Elements</h5>&#13;
<p>Lines 69 and 73 use <code>vector</code> member function <span class="violet"><strong><code>at</code></strong></span> to obtain an element and use it as an <em>rvalue</em> and as an <em>lvalue,</em> respectively. Recall from <a href="ch04.xhtml#ch04lev1sec12">Section 4.12</a> that an <em>rvalue</em> cannot be modified, but an <em>lvalue</em> can. If the index is valid, member function <code>at</code> returns either</p>&#13;
<p class="bull">• a reference to the element at that location—this is a modifiable <em>lvalue</em> that can be used to change the value of the corresponding <code>vector</code> element, or</p>&#13;
<p class="bull">• a <code>const</code> reference to the element at that location—this is a nonmodifiable <em>lvalue</em> that cannot be used to change the value of the corresponding <code>vector</code> element.</p>&#13;
<p>A nonmodifiable <em>lvalue</em> is treated as a <code>const</code> object. If <code>at</code> is called on a <code>const array</code> or via a reference that’s declared <code>const,</code> the function returns a <code>const</code> reference.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0189-01" id="f0189-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">68</span></strong>     <span class="pd_green">// use square brackets to use the value at location 5 as an rvalue</span>&#13;
<strong><span class="cviolet">69</span></strong>     cout &lt;&lt; <span class="green">"\nintegers1.at(5) is "</span> &lt;&lt; integers1.at(<span class="green">5</span>);&#13;
<strong><span class="cviolet">70</span></strong>&#13;
<strong><span class="cviolet">71</span></strong>     <span class="pd_green">// use square brackets to create lvalue</span>&#13;
<strong><span class="cviolet">72</span></strong>     cout &lt;&lt; <span class="green">"\n\nAssigning 1000 to integers1.at(5)"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">73</span></strong>     <span class="yell">integers1.at(<span class="green">5</span>) = <span class="green">1000</span>;</span>&#13;
<strong><span class="cviolet">74</span></strong>     cout &lt;&lt; <span class="green">"integers1: "</span>;&#13;
<strong><span class="cviolet">75</span></strong>     outputVector(integers1);&#13;
<strong><span class="cviolet">76</span></strong></pre>&#13;
<pre class="pre1">integers1.at(5) is 13&#13;
&#13;
Assigning 1000 to integers1.at(5)&#13;
integers1: 8 9 10 11 12 1000 14 15 16 17</pre>&#13;
<p>As is the case with <code>array</code>s, vectors also have a <code>[]</code> operator. C++ is not required to perform bounds checking when vector elements are accessed with square brackets. Therefore, you must ensure that operations using <code>[]</code> do not accidentally attempt to manipulate elements outside the bounds of the <code>vector.</code></p>&#13;
<h5 class="h5" id="ch06lev3sec39">Exception Handling: Processing an Out-of-Range Index</h5>&#13;
<p>Line 80 attempts to output the value in <code>integers1.at(15).</code> The index <code>15</code> is outside the vector’s bounds. Member function <code>at</code>’s bounds checking recognizes the invalid index and <span class="violet"><strong>throws</strong></span> an <span class="violet"><strong>exception,</strong></span> which indicates a runtime problem. The name “exception” suggests that the problem occurs infrequently. <span class="violet"><strong>Exception handling</strong></span> enables you to create <span class="violet"><strong>fault-tolerant programs</strong></span> that can process (or handle) exceptions. In many cases, this allows a program to continue executing as if no problems were encountered. For example, <a href="ch06.xhtml#fig6_14">Fig. 6.14</a> still runs to completion, even though we attempt to access an out-of-range index. More severe problems might prevent a program from continuing normal execution, instead requiring the program to notify the user of the problem, then terminate. Here we introduce exception handling briefly. You’ll throw exceptions from your own custom functions in <a href="ch11.xhtml#ch11">Chapter 11</a>. We’ll discuss exception handling in detail in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0189-02" id="f0189-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">77</span></strong>     <span class="pd_green">// attempt to use out-of-range index</span>&#13;
<strong><span class="cviolet">78</span></strong>     <span class="yell"><span class="blue">try</span> {                                                      </span>&#13;
<strong><span class="cviolet">79</span></strong>     <span class="yell">   cout &lt;&lt; <span class="green">"\nAttempt to display integers1.at(15)"</span> &lt;&lt; endl;</span>&#13;
<strong><span class="cviolet">80</span></strong>     <span class="yell">   cout &lt;&lt; integers1.at(<span class="green">15</span>) &lt;&lt; endl; <span class="pd_green">// ERROR: out of range</span></span>&#13;
<strong><span class="cviolet">81</span></strong>     <span class="yell">}                                                          </span>&#13;
<strong><span class="cviolet">82</span></strong>     <span class="yell"><span class="blue">catch</span> (<span class="blue">const</span> out_of_range&amp; ex) {                           </span>&#13;
<strong><span class="cviolet">83</span></strong>     <span class="yell">   cerr &lt;&lt; <span class="green">"An exception occurred: "</span> &lt;&lt; ex.what() &lt;&lt; endl; </span>&#13;
<strong><span class="cviolet">84</span></strong>     <span class="yell">}                                                          </span>&#13;
<strong><span class="cviolet">85</span></strong></pre>&#13;
<pre class="pre1">Attempt to display integers1.at(15)&#13;
An exception occurred: invalid vector&lt;T&gt; subscript</pre>&#13;
<h5 class="h5" id="ch06lev3sec40">The <code>try</code> Statement</h5>&#13;
<p>By default, an exception causes a C++ program to terminate. To handle an exception and possibly enable the program to continue executing, place any code that might throw an exception in a <span class="violet"><strong><code>try</code> statement</strong></span> (lines 78-84). The <span class="violet"><strong><code>try</code> block</strong></span> (lines 78-81) contains the code that might throw an exception, and the <span class="violet"><strong><code>catch</code> block</strong></span> (lines 82-84) contains the code that handles the exception if one occurs. As you’ll see in <a href="ch15.xhtml#ch15">Chapter 15</a>, you can have many <code>catch</code> blocks to handle different types of exceptions that might be thrown in the corresponding <code>try</code> block. If the code in the <code>try</code> block executes successfully, lines 82-84 are ignored. The braces that delimit <code>try</code> and <code>catch</code> blocks’ bodies are required.</p>&#13;
<h5 class="h5" id="ch06lev3sec41">Executing the <code>catch</code> Block</h5>&#13;
<p>When the program calls <code>vector</code> member function at with the argument <code>15</code> (line 80), the function attempts to access the element at location 15, which is outside the <code>vector</code>’s bounds—<code>integers1</code> has only 10 elements at this point. Because bounds checking is performed at execution time, <code>vector</code> member function at generates an exception—specifically line 80 throws an <span class="violet"><strong><code>out_of_range</code></strong></span> exception (from header <code>&lt;stdexcept&gt;</code>) to notify the program of this problem. At this point, the <code>try</code> block terminates immediately, and the <code>catch</code> block begins executing—if you declared any variables in the <code>try</code> block, they’re now out of scope and are not accessible in the <code>catch</code> block.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> The <code>catch</code> block declares a type (<code>out_of_range</code>) and an exception parameter (<code>ex</code>) that it receives as a reference. The <code>catch</code> block can handle exceptions of the specified type. Inside the block, you can use the parameter’s identifier to interact with a caught exception object. Catching an exception by reference increases performance by preventing the exception object from being copied when it’s caught.</p>&#13;
<h5 class="h5" id="ch06lev3sec42"><code>what</code> Member Function of the Exception Parameter</h5>&#13;
<p>When lines 82-84 catch the exception, the program displays a message indicating the problem that occurred. Line 83 calls the exception object’s <span class="violet"><strong><code>what</code></strong></span> member function to get the exception object’s error message and display it. Once the message is displayed in this example, the exception is considered handled, and the program continues with the next statement after the <code>catch</code> block’s closing brace. In this example, lines 87-91 execute next. We use exception handling again in <a href="ch11.xhtml#ch11">Chapters 11</a>-<a href="ch13.xhtml#ch13">13</a>, and <a href="ch15.xhtml#ch15">Chapter 15</a> presents a deeper look.</p>&#13;
<h5 class="h5" id="ch06lev3sec43">Changing the Size of a vector</h5>&#13;
<p>One key difference between a <code>vector</code> and an <code>array</code> is that a <code>vector</code> can dynamically grow and shrink as the number of elements it needs to accommodate varies. To demonstrate this, line 87 shows the current size of <code>integers3</code>, line 88 calls the <code>vector</code>’s <span class="violet"><strong><code>push_back</code></strong></span> member function to add a new element containing 1000 to the end of the <code>vector</code>, and line 89 shows the new size of <code>integers3</code>. Line 91 then displays <code>integers3</code>’s new contents.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0190-01" id="f0190-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">86</span></strong>     <span class="pd_green">// changing the size of a vector</span>&#13;
<strong><span class="cviolet">87</span></strong>     cout &lt;&lt; <span class="green">"\nCurrent integers3 size is: "</span> &lt;&lt; integers3.size() &lt;&lt; endl;&#13;
<strong><span class="cviolet">88</span></strong>     integers3.push_back(<span class="green">1000</span>); <span class="pd_green">// add 1000 to the end of the vector</span>&#13;
<strong><span class="cviolet">89</span></strong>     cout &lt;&lt; <span class="green">"New integers3 size is: "</span> &lt;&lt; integers3.size() &lt;&lt; endl;&#13;
<strong><span class="cviolet">90</span></strong>     cout &lt;&lt; <span class="green">"integers3 now contains: "</span>;&#13;
<strong><span class="cviolet">91</span></strong>     outputVector(integers3);&#13;
<strong><span class="cviolet">92</span></strong> }&#13;
<strong><span class="cviolet">93</span></strong></pre>&#13;
<pre class="pre1">Current integers3 size is: 7&#13;
New integers3 size is: 8&#13;
integers3 now contains: 1 2 3 4 5 6 7 1000</pre>&#13;
<h5 class="h5" id="ch06lev3sec44">Functions <code>outputVector</code> and <code>inputVector</code></h5>&#13;
<p>Function <code>outputVector</code> uses a range-based for statement to obtain the value in each element of the <code>vector</code> for output. As with class template <code>array</code>, you could also do this using a counter-controlled loop and the <code>[]</code> operator, but the range-based <code>for</code> is recommended. Function <code>inputVector</code> uses a range-based <code>for</code> statement with an <code>int&amp;</code> range variable, so it can be used to store an input value in the corresponding <code>vector</code> element.</p>&#13;
<p class="codelink"><a href="Images/ch06_images.xhtml#f0191-02" id="f0191-02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">94</span></strong>    <span class="pd_green">// output vector contents</span>&#13;
<strong><span class="cviolet">95</span></strong>    <span class="blue">void</span> outputVector(<span class="yell"><span class="blue">const</span> vector&lt;<span class="blue">int</span>&gt;&amp; items</span>) {&#13;
<strong><span class="cviolet">96</span></strong>       <span class="blue">for</span> (<span class="blue">const int</span> item : items) {&#13;
<strong><span class="cviolet">97</span></strong>          cout &lt;&lt; item &lt;&lt; <span class="blue">" "</span>;&#13;
<strong><span class="cviolet">98</span></strong>       }&#13;
<strong><span class="cviolet">99</span></strong>&#13;
<strong><span class="cviolet">100</span></strong>       cout &lt;&lt; endl;&#13;
<strong><span class="cviolet">101</span></strong>   }&#13;
<strong><span class="cviolet">102</span></strong>&#13;
<strong><span class="cviolet">103</span></strong>   <span class="pd_green">// input vector contents</span>&#13;
<strong><span class="cviolet">104</span></strong>   <span class="blue">void</span> inputVector(<span class="yell">vector&lt;int&gt;&amp; items</span>) {&#13;
<strong><span class="cviolet">105</span></strong>      <span class="blue">for</span> (<span class="blue">int</span>&amp; item : items) {&#13;
<strong><span class="cviolet">106</span></strong>         cin &gt;&gt; item;&#13;
<strong><span class="cviolet">107</span></strong>      }&#13;
<strong><span class="cviolet">108</span></strong>   }</pre>&#13;
<h5 class="h5" id="ch06lev3sec45">C++11: List Initializing a <code>vector</code></h5>&#13;
<p>Many of the <code>array</code> examples in this chapter used list initializers to specify the initial <code>array</code> element values. C++11 also allows this for <code>vector</code>s (and other C++ standard library data structures).</p>&#13;
<h5 class="h5" id="ch06lev3sec46">Straight-Line Code</h5>&#13;
<p>As you worked through this chapter’s examples, you saw lots of <code>for</code> loops. But one thing you may have noticed in the first objects natural sections is that much of the code for creating and using objects is straight-line sequential code. Working with objects often flattens the coding process into lots of sequential member-function calls.</p>&#13;
<h3 class="h3" id="ch06lev1sec16"><span class="violet">6.16</span> Wrap-Up</h3>&#13;
<p>This chapter began our introduction to data structures, exploring the use of C++ standard library class templates <code>array</code> and <code>vector</code> to store data in and retrieve data from lists and tables of values. The chapter examples demonstrated how to declare an <code>array</code>, initialize an <code>array</code> and refer to individual elements of an <code>array</code>. We passed <code>array</code>s to functions by reference and used the <code>const</code> qualifier to prevent the called function from modifying the <code>array</code>’s elements, thus enforcing the principle of least privilege. You learned how to use C++11’s range-based <code>for</code> statement to manipulate all the elements of an <code>array</code>. We also showed how to use C++ standard library functions <code>sort</code> and <code>binary_search</code> to sort and search an <code>array,</code> respectively. You learned how to declare and manipulate multidimensional <code>array</code>s of <code>array</code>s. We used nested counter-controlled and nested range-based <code>for</code> statements to iterate through all the rows and columns of a two-dimensional <code>array.</code> We also showed how to use <code>auto</code> to infer a variable’s type based on its initializer value. We introduced functional-style programming in C++ using C++20’s new ranges. In later chapters, we’ll continue our coverage of data structures. In our first objects natural case study, we demonstrated the capabilities of the C++ standard library class template <code>vector.</code> In that example, we discussed how to access <code>array</code> and <code>vector</code> elements with bounds checking and demonstrated basic exception-handling concepts.</p>&#13;
<p>We’ve now introduced the basic concepts of classes, objects, control statements, functions, <code>array</code> objects and <code>vector</code> objects. In <a href="ch07.xhtml#ch07">Chapter 7</a>, we present one of C++’s most powerful features—the pointer. Pointers keep track of where data and functions are stored in memory, which allows us to manipulate those items in interesting ways. As you’ll see, C++ also provides a language element called an array (different from the class template <code>array)</code> that’s closely related to pointers. In contemporary C++ code, its considered better practice to use C++11’s <code>array</code> class template rather than traditional arrays.</p>&#13;
</div></body>
</html>