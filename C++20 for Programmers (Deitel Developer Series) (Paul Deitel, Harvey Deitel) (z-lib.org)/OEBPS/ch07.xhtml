<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch07">Chapter 7. (Downplaying) Pointers in Modern C++</h2>&#13;
<div class="image"><img src="Images/f0237-01.jpg" alt="Images" width="369" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Learn what pointers are, and declare and initialize them.</p>&#13;
<p class="squ"><span class="red">■</span> Use the address (<code>&amp;</code>) and indirection (<code>*</code>) pointer operators.</p>&#13;
<p class="squ"><span class="red">■</span> Compare the capabilities of pointers and references.</p>&#13;
<p class="squ"><span class="red">■</span> Use pointers to pass arguments to functions by reference.</p>&#13;
<p class="squ"><span class="red">■</span> Use pointer-based arrays and strings mostly in legacy code.</p>&#13;
<p class="squ"><span class="red">■</span> Use <code>const</code> with pointers and the data they point to.</p>&#13;
<p class="squ"><span class="red">■</span> Use operator <code>sizeof</code> to determine the number of bytes that store a value of a particular type.</p>&#13;
<p class="squ"><span class="red">■</span> Understand pointer expressions and pointer arithmetic that you’ll see in legacy code.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++11’s <code>nullptr</code> to represent pointers to nothing.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++11’s <code>begin</code> and <code>end</code> library functions with pointer-based arrays.</p>&#13;
<p class="squ"><span class="red">■</span> Learn various C++ Core Guidelines for avoiding pointers and pointer-based arrays to create safer, more robust programs.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++20’s <code>to_array</code> function to convert built-in arrays and initializer lists to <code>std::array</code>s.</p>&#13;
<p class="squ"><span class="red">■</span> Continue our objects-natural approach by using C++20’s class template <code>span</code> to create objects that are views into built-in arrays, <code>std::array</code>s and <code>std::vector</code>s.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec1"><span class="violet"><strong>7.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec2"><span class="violet"><strong>7.2</strong></span> Pointer Variable Declarations and Initialization</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec1">7.2.1 Declaring Pointers</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec2">7.2.2 Initializing Pointers</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec3">7.2.3 Null Pointers Prior to C++11</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec3"><span class="violet"><strong>7.3</strong></span> Pointer Operators</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec4">7.3.1 Address (<code>&amp;</code>) Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec5">7.3.2 Indirection (<code>*</code>) Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec6">7.3.3 Using the Address (<code>&amp;</code>) and Indirection (<code>*</code>) Operators</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec4"><span class="violet"><strong>7.4</strong></span> Pass-by-Reference with Pointers</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec5"><span class="violet"><strong>7.5</strong></span> Built-In Arrays</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec7">7.5.1 Declaring and Accessing a Built-In Array</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec8">7.5.2 Initializing Built-In Arrays</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec9">7.5.3 Passing Built-In Arrays to Functions</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec10">7.5.4 Declaring Built-In Array Parameters</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec11">7.5.5 C++11: Standard Library Functions <code>begin</code> and <code>end</code></a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec12">7.5.6 Built-In Array Limitations</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec6"><span class="violet"><strong>7.6</strong></span> C++20: Using <code>to_array</code> to convert a Built-in Array to a <code>std::array</code></a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec7"><span class="violet"><strong>7.7</strong></span> Using <code>const</code> with Pointers and the Data They Point To</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec13">7.7.1 Using a Nonconstant Pointer to Nonconstant Data</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec14">7.7.2 Using a Nonconstant Pointer to Constant Data</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec15">7.7.3 Using a Constant Pointer to Nonconstant Data</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec16">7.7.4 Using a Constant Pointer to Constant Data</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec8"><span class="violet"><strong>7.8</strong></span> <code>sizeof</code> Operator</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec9"><span class="violet"><strong>7.9</strong></span> Pointer Expressions and Pointer Arithmetic</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec17">7.9.1 Adding Integers to and Subtracting Integers from Pointers</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec18">7.9.2 Subtracting One Pointer from Another</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec19">7.9.3 Pointer Assignment</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec20">7.9.4 Cannot Dereference a <code>void*</code></a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec21">7.9.5 Comparing Pointers</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec10"><span class="violet"><strong>7.10</strong></span> Objects Natural Case Study: C++20 <code>span</code>s—Views of Contiguous Container Elements</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec11"><span class="violet"><strong>7.11</strong></span> A Brief Intro to Pointer-Based Strings</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec22">7.11.1 Command-Line Arguments</a></p>&#13;
<p class="chap-lev2"><a href="ch07.xhtml#ch07lev2sec23">7.11.2 Revisiting C++20’s <code>to_array</code> Function</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec12"><span class="violet"><strong>7.12</strong></span> Looking Ahead to Other Pointer Topics</a></p>&#13;
<p class="chap-lev1"><a href="ch07.xhtml#ch07lev1sec13"><span class="violet"><strong>7.13</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev1sec1"><span class="violet">7.1</span> Introduction</h3>&#13;
<p>This chapter discusses pointers, built-in pointer-based arrays and pointer-based strings (also called C-strings), each of which C++ inherited from the C programming language.</p>&#13;
<h5 class="h5" id="ch07lev3sec1">Downplaying Pointers in Modern C++</h5>&#13;
<p>Pointers are powerful but challenging to work with and error-prone. So, Modern C++ (C++20, C++17, C++14 and C++11) has added features that eliminate the need for most pointers. New software-development projects generally should prefer:</p>&#13;
<p class="bull">• using references to using pointers,</p>&#13;
<p class="bull">• using <code>std::array</code><sup><a id="rch07fn1" href="ch07.xhtml#ch07fn1">1</a></sup> and <code>std::vector</code> objects (<a href="ch06.xhtml#ch06">Chapter 6</a>) to using built-in pointer-based arrays, and</p>&#13;
<p class="footnote"><a id="ch07fn1" href="ch07.xhtml#rch07fn1">1</a>. We pronounce “<code>std::</code>” as “standard,” so throughout this chapter we say “a <code>std::array”</code> rather than “an <code>std::array</code>,” which assumes “<code>std::</code>” is pronounced as its individual letters <code>s</code>, <code>t</code> and <code>d</code>.</p>&#13;
<p class="bull">• using <code>std::string</code> objects (<a href="ch02.xhtml#ch02">Chapters 2</a> and <a href="ch08.xhtml#ch08">8</a>) to pointer-based C-strings.</p>&#13;
<h5 class="h5" id="ch07lev3sec2">Sometimes Pointers Are Still Required</h5>&#13;
<p>You’ll encounter pointers, pointer-based arrays and pointer-based strings frequently in the massive installed base of legacy C++ code. Pointers are required to:</p>&#13;
<p class="bull">• create and manipulate dynamic data structures, like linked lists, queues, stacks and trees that can grow and shrink at execution time—though most programmers will use the C++ standard library’s existing dynamic containers like vector and the containers we discuss in <a href="ch17.xhtml#ch17">Chapter 17</a>,</p>&#13;
<p class="bull">• process command-line arguments, which a program receives as a pointer-based array of pointer-based C-strings, and</p>&#13;
<p class="bull">• pass arguments by reference if there’s a possibility of a <code>nullptr</code><sup><a id="rch07fn2" href="ch07.xhtml#ch07fn2">2</a></sup> (i.e., a pointer to nothing; <a href="ch07.xhtml#ch07lev2sec2">Section 7.2.2</a>)—a reference must refer to an actual object.</p>&#13;
<p class="footnote"><a id="ch07fn2" href="ch07.xhtml#rch07fn2">2</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-ptr-ref">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-ptr-ref</a></code>.</p>&#13;
<h5 class="h5" id="ch07lev3sec3">Pointer-Related C++ Core Guidelines</h5>&#13;
<p><span class="size">CG</span> We mention C++ Core Guidelines that encourage you to make your code safer and more robust by recommending you use techniques that avoid pointers, pointer-based arrays and pointer-based strings. For example, several guidelines recommend implementing pass-by-reference using references, rather than pointers.<sup><a id="rch07fn3" href="ch07.xhtml#ch07fn3">3</a></sup></p>&#13;
<p class="footnote"><a id="ch07fn3" href="ch07.xhtml#rch07fn3">3</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-functions">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-functions</a></code>.</p>&#13;
<h5 class="h5" id="ch07lev3sec4">C++20 Features for Avoiding Pointers</h5>&#13;
<p><span class="size">20</span> For programs that still require pointer-based arrays (e.g., command-line arguments), C++20 adds two new features that help make your programs safer and more robust:</p>&#13;
<p class="bull">• Function <code>to_array</code> converts a pointer-based array to a <code>std::array</code>, so you can take advantage of the features we demonstrated in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>&#13;
<p class="bull">• <code>span</code>s offer a safer way to pass built-in arrays to functions. They’re iterable, so you can use them with range-based <code>for</code> statements to conveniently process elements without risking out-of-bounds array accesses. Also, because <code>span</code>s are iterable, you can use them with standard library container-processing algorithms, such as <code>accumulate</code> and <code>sort</code>. We’ll cover <code>span</code>s in this chapter’s objects natural case study where you’ll see that they also work with <code>std::array</code> and <code>std::vector</code>.</p>&#13;
<p>The key takeaway from reading this chapter is to avoid using pointers, pointer-based arrays and pointer-based strings whenever possible. If you must use them, take advantage of <code>to_array</code> and <code>span</code>s.</p>&#13;
<h5 class="h5" id="ch07lev3sec5">Other Concepts Presented in This Chapter</h5>&#13;
<p>We declare and initialize pointers and demonstrate the pointer operators <code>&amp;</code> and <code>*</code>. In <a href="ch05.xhtml#ch05">Chapter 5</a>, we performed pass-by-reference with references. Here, we show that pointers also enable pass-by-reference. We demonstrate built-in, pointer-based arrays and their intimate relationship with pointers.</p>&#13;
<p>We show how to use <code>const</code> with pointers and the data they point to, and we introduce the <code>sizeof</code> operator to determine the number of bytes that store values of particular fundamental types and pointers. We demonstrate pointer expressions and pointer arithmetic.</p>&#13;
<p>C-strings were used widely in older C++ software. This chapter briefly introduces C-strings. You’ll see how to process command-line arguments—a simple task for which C++ still requires you to use both pointer-based C-strings and pointer-based arrays.</p>&#13;
<h3 class="h3" id="ch07lev1sec2"><span class="violet">7.2</span> Pointer Variable Declarations and Initialization</h3>&#13;
<p>Pointer variables contain memory addresses as their values. Usually, a variable directly contains a specific value. A pointer contains the memory address of a variable that, in turn, contains a specific value. In this sense, a variable name <span class="violet"><strong>directly references a value</strong></span>, and a pointer <span class="violet"><strong>indirectly references a value</strong></span> as shown in the following diagram:</p>&#13;
<div class="image"><img src="Images/f0240-01.jpg" alt="Images" width="434" height="155"/></div>&#13;
<p>Referencing a value through a pointer as in this diagram is called <span class="violet"><strong>indirection</strong></span>.</p>&#13;
<h4 class="h4" id="ch07lev2sec1">7.2.1 Declaring Pointers</h4>&#13;
<p>The following declaration declares the variable <code>countPtr</code> to be of type <code>int*</code> (i.e., a pointer to an <code>int</code> value) and is read (right-to-left), “<code>countPtr</code> is a pointer to an <code>int</code>”:</p>&#13;
<pre class="pre"><span class="blue">int</span>* countPtr;</pre>&#13;
<p>This <code>*</code> is not an operator; rather, it indicates that the variable to its right is a pointer. We like to include the letters <code>Ptr</code> in each pointer variable name to make it clear that the variable is a pointer and must be handled accordingly.</p>&#13;
<h4 class="h4" id="ch07lev2sec2">7.2.2 Initializing Pointers</h4>&#13;
<p><span class="size">11</span> <img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> Initialize each pointer to <code><span class="violet"><strong>nullptr</strong></span></code> (from C++11) or a memory address. A pointer with the value <code>nullptr</code> “points to nothing” and is known as a <span class="violet"><strong>null pointer</strong></span>. From this point forward, when we refer to a “null pointer,” we mean a pointer with the value <code>nullptr</code>. Initialize all pointers to prevent pointing to unknown or uninitialized areas of memory.</p>&#13;
<h4 class="h4" id="ch07lev2sec3">7.2.3 Null Pointers Prior to C++11</h4>&#13;
<p>In earlier C++ versions, the value specified for a null pointer was <code>0</code> or <code>NULL</code>. <code>NULL</code> is defined in several standard library headers to represent the value <code>0</code>. Initializing a pointer to <code>NULL</code> is equivalent to initializing it to <code>0</code>, but prior to C++11, <code>0</code> was used by convention. The value <code>0</code> is the only integer value that can be assigned directly to a pointer variable without first casting the integer to a pointer type (generally via a <code>reinterpret_cast</code>; Section 9.8).</p>&#13;
<h3 class="h3" id="ch07lev1sec3"><span class="violet">7.3</span> Pointer Operators</h3>&#13;
<p>The unary operators <code>&amp;</code> and <code>*</code> create pointer values and “dereference” pointers, respectively. We show how to use these operators in the following sections.</p>&#13;
<h4 class="h4" id="ch07lev2sec4">7.3.1 Address (<code>&amp;</code>) Operator</h4>&#13;
<p>The <span class="violet"><strong>address operator (</strong></span><code><span class="violet"><strong>&amp;</strong></span></code><span class="violet"><strong>)</strong></span> is a unary operator that obtains the memory address of its oper- and. For example, assuming the declarations</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0197-01a" id="f0197-01aa">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> y{<span class="green">5</span>}; <span class="pd_green">// declare variable y</span>&#13;
<span class="blue">int</span>* yPtr{<span class="blue">nullptr</span>}; <span class="pd_green">// declare pointer variable yPtr</span></pre>&#13;
<p>the following statement assigns the address of the variable <code>y</code> to pointer variable <code>yPtr</code>:</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0197-02" id="f0197-02a">Click here to view code image</a></p>&#13;
<pre class="pre">yPtr = &amp;y; <span class="pd_green">// assign address of y to yPtr</span></pre>&#13;
<p>Variable <code>yPtr</code> is said to “point to” <code>y</code>—<code>yPtr</code> indirectly references the variable <code>y</code>’s value (5).</p>&#13;
<p>The <code>&amp;</code> in the preceding statement is not a reference variable declaration, where <code>&amp;</code> is always preceded by a type name. When declaring a reference, the <code>&amp;</code> is part of the type. In an expression like <code>&amp;y</code>, the <code>&amp;</code> is the address operator.</p>&#13;
<p>The following diagram shows a memory representation after the previous assignment:</p>&#13;
<div class="image"><img src="Images/f0241-01.jpg" alt="Images" width="144" height="64"/></div>&#13;
<p>The “pointing relationship” is indicated by drawing an arrow from the box that represents the pointer <code>yPtr</code> in memory to the box that represents the variable <code>y</code> in memory.</p>&#13;
<p>The following diagram shows another pointer memory representation with <code>int</code> variable <code>y</code> stored at memory location <code>600000</code> and pointer variable <code>yPtr</code> at location <code>500000</code></p>&#13;
<div class="image"><img src="Images/f0241-02.jpg" alt="Images" width="507" height="64"/></div>&#13;
<p>The address operator’s operand must be an <em>lvalue</em>—the address operator cannot be applied to literals or to expressions that result in temporary values (like the results of calculations).</p>&#13;
<h4 class="h4" id="ch07lev2sec5">7.3.2 Indirection (<code>*</code>) Operator</h4>&#13;
<p>Applying the unary<span class="violet"><strong/></span> <code><span class="violet"><strong>*</strong></span></code> <span class="violet"><strong>operator</strong></span> to a pointer results in an <em>lvalue</em> representing the object to which its pointer operand points. This operator is commonly referred to as the <span class="violet"><strong>indirection operator</strong></span> or <span class="violet"><strong>dereferencing operator</strong></span>. If <code>yPtr</code> points to <code>y</code> and <code>y</code> contains <code>5</code> (as in the preceding diagrams), the statement</p>&#13;
<pre class="pre">cout &lt;&lt; *yPtr &lt;&lt; endl;</pre>&#13;
<p>displays <code>y</code>’s value (<code>5</code>), as would the statement</p>&#13;
<pre class="pre">cout &lt;&lt; y &lt;&lt; endl;</pre>&#13;
<p>Using <code>*</code> in this manner is called <span class="violet"><strong>dereferencing a pointer</strong></span>. A dereferenced pointer also can be used as an <em>lvalue</em> in an assignment. The following assigns <code>9</code> to <code>y</code>:</p>&#13;
<pre class="pre">*yPtr = <span class="green">9</span>;</pre>&#13;
<p>In this statement, <code>*yPtr</code> is an alias for <code>y</code>. The dereferenced pointer may also be used to receive an input value as in</p>&#13;
<pre class="pre">cin &gt;&gt; *yPtr;</pre>&#13;
<p>which places the input value in <code>y</code>.</p>&#13;
<h5 class="h5" id="ch07lev3sec6">Undefined Behaviors</h5>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> Dereferencing an uninitialized pointer results in undefined behavior that could cause a fatal execution-time error. This also could lead to accidentally modifying important data, allowing the program to run to completion, possibly with incorrect results. This is a potential security flaw that an attacker might be able to exploit to access data, overwrite data or even execute malicious code.<sup><a id="rch07fn4" href="ch07.xhtml#ch07fn4">4</a>,<a id="rch07fn5" href="ch07.xhtml#ch07fn5">5</a>,<a id="rch07fn6" href="ch07.xhtml#ch07fn6">6</a></sup> Dereferencing a null pointer results in undefined behavior and typically causes a fatal execution-time error. In industrial-strength code, ensure that a pointer is not <code>nullptr</code> before dereferencing it.<sup><a id="rch07fn7" href="ch07.xhtml#ch07fn7">7</a></sup></p>&#13;
<p class="footnote"><a id="ch07fn4" href="ch07.xhtml#rch07fn4">4</a>. “Undefined Behavior.” Wikipedia. Wikimedia Foundation, May 30, 2020. <code><a href="https://en.wikipedia.org/wiki/Undefined_behavior">https://en.wikipedia.org/wiki/Undefined_behavior</a></code>.</p>&#13;
<p class="footnote"><a id="ch07fn5" href="ch07.xhtml#rch07fn5">5</a>. “Common Weakness Enumeration.” CWE. Accessed June 14, 2020. <code><a href="https://cwe.mitre.org/data/definitions/824.html">https://cwe.mitre.org/data/definitions/824.html</a></code>.</p>&#13;
<p class="footnote"><a id="ch07fn6" href="ch07.xhtml#rch07fn6">6</a>. “Dangling Pointer.” Wikipedia. Wikimedia Foundation, June 8, 2020. <code><a href="https://en.wikipedia.org/wiki/Dangling_pointer">https://en.wikipedia.org/wiki/Dangling_pointer</a></code>.</p>&#13;
<p class="footnote"><a id="ch07fn7" href="ch07.xhtml#rch07fn7">7</a>. The C++ Core Guidelines recommend using the <code><span class="violet"><strong>gsl::not_null</strong></span></code> class template from the Guidelines Support Library (GSL) to declare pointers that should not have the value <code>nullptr</code>. Throughout this book, we adhere to the C++ Core Guidelines as appropriate. At the time of this writing, the Guidelines Support Library’s <code>gsl::not_null</code> implementation did not produce helpful error messages in our compilers, so we chose not to use <code>gsl::not_null</code> in our code.</p>&#13;
<h4 class="h4" id="ch07lev2sec6">7.3.3 Using the Address (<code>&amp;</code>) and Indirection (<code>*</code>) Operators</h4>&#13;
<p><a href="ch07.xhtml#fig7_1">Figure 7.1</a> demonstrates the <code>&amp;</code> and <code>*</code> pointer operators, which have the third-highest level of precedence (see the <a href="app01.xhtml#app01">Appendix A</a> for the complete operator-precedence chart). Memory locations are output by <code>&lt;&lt;</code> in this example as hexadecimal (i.e., base-16) integers. (See <a href="app04.xhtml#app04">Appendix D</a>, Number Systems, for more information on hexadecimal integers.) The output shows that variable <code>a</code>’s address (line 10) and <code>aPtr</code>’s value (line 11) are identical, confirming that <code>a</code>’s address was indeed assigned to <code>aPtr</code> (line 8). The outputs from lines 12–13 confirm that <code>*aPtr</code> has the same value as <code>a</code>. The memory addresses output by this program with <code>cout</code> and <code>&lt;&lt;</code> are compiler- and platform-dependent, and typically change with each program execution, so you’ll likely see different addresses.</p>&#13;
<div class="group" id="fig7_1">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig01" id="aa07fig01">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_01.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Pointer operators &amp; and *.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>7</strong></span>       <code><span class="blue">constexpr int</span> a{<span class="green">7</span>}; <span class="pd_green">// initialize a with 7</span></code>&#13;
 <span class="cviolet"><strong>8</strong></span>       <span class="yell"><code><span class="blue">const int</span>* aPtr = &amp;a; <span class="pd_green">// initialize aPtr with address of int variable a</span></code></span>&#13;
 <span class="cviolet"><strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>      <code>cout &lt;&lt; <span class="green">"The address of a is "</span> &lt;&lt; <span class="yell">&amp;a</span></code>&#13;
<span class="cviolet"><strong>11</strong></span>         <code>&lt;&lt; <span class="green">"\nThe value of aPtr is "</span> &lt;&lt; <span class="yell">aPtr;</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>      <code>cout &lt;&lt; <span class="green">"\n\nThe value of a is "</span> &lt;&lt; a</code>&#13;
<span class="cviolet"><strong>13</strong></span>         <code>&lt;&lt; <span class="green">"\nThe value of *aPtr is "</span> &lt;&lt; <span class="yell">*aPtr</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>14</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>The address of a is 002DFD80</code>&#13;
<code>The value of aPtr is 002DFD80</code>&#13;
&#13;
<code>The value of a is 7</code>&#13;
<code>The value of *aPtr is 7</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.1</strong></span> Pointer operators <code>&amp;</code> and <code>*</code>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev1sec4"><span class="violet">7.4</span> Pass-by-Reference with Pointers</h3>&#13;
<p>There are three ways in C++ to pass arguments to a function:</p>&#13;
<p class="bull">• pass-by-value</p>&#13;
<p class="bull">• pass-by-reference with a reference argument</p>&#13;
<p class="bull">• <span class="violet"><strong>pass-by-reference with a pointer argument</strong></span>.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> <a href="ch05.xhtml#ch05">Chapter 5</a> showed the first two. Here, we explain pass-by-reference with a pointer. Pointers, like references, can be used to modify variables in the caller or to pass large data objects by reference to avoid the overhead of copying objects.<strong/> You accomplish pass-by-reference via pointers and the indirection operator (<code>*</code>). When calling a function that receives a pointer, pass a variable’s address by applying the address operator (<code>&amp;</code>) to the variable’s name.</p>&#13;
<h5 class="h5" id="ch07lev3sec7">An Example of Pass-By-Value</h5>&#13;
<p><a href="ch07.xhtml#fig7_2">Figures 7.2</a> and <a href="ch07.xhtml#fig7_3">7.3</a> present two functions that each cube an integer. <a href="ch07.xhtml#fig7_2">Figure 7.2</a> passes variable <code>number</code> by value (line 12) to function <code>cubeByValue</code> (lines 17–19), which cubes its argument and passes the result back to <code>main</code> using a <code>return</code> statement (line 18). We stored the new value in <code>number</code> (line 12), though that is not required. For instance, the calling function might want to examine the function call’s result before modifying variable <code>number</code>.</p>&#13;
<div class="group" id="fig7_2">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig02" id="aa07fig02">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_02.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Pass-by-value used to cube a variable’s value.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>&#13;
 <span class="cviolet"><strong>6</strong></span>    <span class="yell"><code><span class="blue">int</span> cubeByValue(<span class="blue">int</span> n); <span class="pd_green">// prototype</span></code></span>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code><span class="blue">int</span> number{<span class="green">5</span>};</code>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>       <code>cout &lt;&lt; <span class="green">"The original value of number is "</span> &lt;&lt; number;</code>&#13;
<span class="cviolet"><strong>12</strong></span>       <span class="yell"><code>number = cubeByValue(number); <span class="pd_green">// pass number by value to cubeByValue</span></code></span>&#13;
<span class="cviolet"><strong>13</strong></span>       <code>cout &lt;&lt; <span class="green">"\nThe new value of number is "</span> &lt;&lt; number &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>14</strong></span>     <code>}</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>     <span class="yell"><code><span class="pd_green">// calculate and return cube of integer argument</span></code>               </span>&#13;
<span class="cviolet"><strong>17</strong></span>     <span class="yell"><code><span class="blue">int</span> cubeByValue(<span class="blue">int</span> n) {</code>                                       </span>&#13;
<span class="cviolet"><strong>18</strong></span>     <span class="yell">   <code><span class="blue">return</span> n * n * n; <span class="pd_green">// cube local variable n and return result</span></code></span>&#13;
<span class="cviolet"><strong>19</strong></span>     <span class="yell"><code>} <span class="pd_green"/></code>                                                             </span></pre>&#13;
<pre class="pre1"><code>The original value of number is 5</code>&#13;
<code>The new value of number is 125</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.2</strong></span> Pass-by-value used to cube a variable’s value.</p>&#13;
</div>&#13;
<div class="group" id="fig7_3">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig03" id="aa07fig03">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_03.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Pass-by-reference with a pointer argument used to cube a</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="pd_green">// variable’s value.</span></code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <span class="yell"><code><span class="blue">void</span> cubeByReference(<span class="blue">int</span>* nPtr); <span class="pd_green">// prototype</span></code></span>&#13;
 <span class="cviolet"><strong>8</strong></span>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code><span class="blue">int</span> number{<span class="green">5</span>};</code>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>       <code>cout &lt;&lt; <span class="green">"The original value of number is "</span> &lt;&lt; number;</code>&#13;
<span class="cviolet"><strong>13</strong></span>       <span class="yell"><code>cubeByReference(&amp;number); <span class="pd_green">// pass number address to cubeByReference</span></code></span>&#13;
<span class="cviolet"><strong>14</strong></span>       <code>cout &lt;&lt; <span class="green">"\nThe new value of number is "</span> &lt;&lt; number &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>15</strong></span>    <code>}</code>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>    <span class="yell"><code><span class="pd_green">// calculate cube of *nPtr; modifies variable number in main</span></code></span>&#13;
<span class="cviolet"><strong>18</strong></span>    <span class="yell"><code><span class="blue">void</span> cubeByReference(<span class="blue">int</span>* nPtr) {</code>                           </span>&#13;
<span class="cviolet"><strong>19</strong></span>    <span class="yell">   <code>*nPtr = *nPtr * *nPtr * *nPtr; <span class="pd_green">// cube *nPtr</span></code>             </span>&#13;
<span class="cviolet"><strong>20</strong></span>    <span class="yell"><code>} <span class="pd_green"/></code>                                                          </span></pre>&#13;
<pre class="pre1"><code>The original value of number is 5</code>&#13;
<code>The new value of number is 125</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.3</strong></span> Pass-by-reference with a pointer argument used to cube a variable’s value.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch07lev3sec8">An Example of Pass-By-Reference with Pointers</h5>&#13;
<p><a href="ch07.xhtml#fig7_3">Figure 7.3</a> passes the variable <code>number</code> to function <code>cubeByReference</code> using pass-by-reference with a pointer argument (line 13)—the address of <code>number</code> is passed to the function. Function <code>cubeByReference</code> (lines 18–20) specifies parameter <code>nPtr</code> (a pointer to <code>int</code>) to receive its argument. The function uses the dereferenced pointer<em>—</em><code>*nPtr</code>, an alias for <code>number</code> in <code>main</code>—to cube the value to which <code>nPtr</code> points (line 19). This directly changes the value of <code>number</code> in <code>main</code> (line 10). Line 19 can be made clearer with redundant parentheses:</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0197-02a" id="f0197-02aa">Click here to view code image</a></p>&#13;
<pre class="pre">*nPtr = (*nPtr) * (*nPtr) * (*nPtr); <span class="pd_green">// cube *nPtr</span></pre>&#13;
<p>A function receiving an address as an argument must define a pointer parameter to receive the address. For example, function <code>cubeByReference</code>’s header (line 18) specifies that the function receives a pointer to an <code>int</code> as an argument, stores the address in <code>nPtr</code> and does not return a value.</p>&#13;
<h5 class="h5" id="ch07lev3sec9">Insight: Pass-By-Reference with a Pointer Actually Passes the Pointer By Value</h5>&#13;
<p>Passing a variable by reference with a pointer does not actually pass anything by reference. Rather, a pointer to that variable is passed by value. That pointer value is copied into the function’s corresponding pointer parameter. The called function can then access the caller’s variable by dereferencing the pointer, thus accomplishing pass-by-reference.</p>&#13;
<h5 class="h5" id="ch07lev3sec10">Graphical Analysis of Pass-By-Value and Pass-By-Reference</h5>&#13;
<p><a href="ch07.xhtml#fig7_4">Figures 7.4</a>–<a href="ch07.xhtml#fig7_5">7.5</a> graphically analyze the execution of <a href="ch07.xhtml#fig7_2">Fig. 7.2</a> and <a href="ch07.xhtml#fig7_3">Fig. 7.3</a>, respectively. The rectangle above a given expression or variable contains the value being produced by a step in the diagram. Each diagram’s right column shows functions <code>cubeByValue</code> (<a href="ch07.xhtml#fig7_2">Fig. 7.2</a>) and <code>cubeByReference</code> (<a href="ch07.xhtml#fig7_3">Fig. 7.3</a>) only when they’re executing.</p>&#13;
<div class="group" id="fig7_4">&#13;
<div class="images"><img src="Images/07fig04.jpg" alt="Images" width="751" height="1083"/></div>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.4</strong></span> Pass-by-value analysis of the program of <a href="ch07.xhtml#fig7_2">Fig. 7.2</a>.</p>&#13;
</div>&#13;
<div class="group" id="fig7_5">&#13;
<div class="images"><img src="Images/07fig05.jpg" alt="Images" width="751" height="1085"/></div>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.5</strong></span> Pass-by-reference analysis of the program of <a href="ch07.xhtml#fig7_3">Fig. 7.3</a>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev1sec5"><span class="violet">7.5</span> Built-In Arrays</h3>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> <strong>Here we present built-in arrays, which like</strong> <code><strong>std::array</strong></code><strong>s are also fixed-size data structures. We include this presentation mostly because you’ll see built-in arrays in legacy C++ code. New applications should use</strong> <code><strong>std::array</strong></code> <strong>and</strong> <code><strong>std::vector</strong></code> <strong>to create safer, more robust applications.</strong></p>&#13;
<p><span class="size">20</span> <span class="size">20</span> In particular, <code>std::array</code> and <code>std::vector</code> objects always know their own size—even when passed to other functions, which is not the case for built-in arrays. If you work on applications containing built-in arrays, you can use C++20’s <code>to_array</code> function to convert them to <code>std::array</code>s (<a href="ch07.xhtml#ch07lev1sec6">Section 7.6</a>), or you can process them more safely using C++20’s <code>span</code>s (<a href="ch07.xhtml#ch07lev1sec10">Section 7.10</a>). There are some cases in which built-in arrays are required, such as receiving command-line arguments, which we demonstrate in <a href="ch07.xhtml#ch07lev1sec11">Section 7.11</a>.</p>&#13;
<h4 class="h4" id="ch07lev2sec7">7.5.1 Declaring and Accessing a Built-In Array</h4>&#13;
<p>As with <code>std::array</code>, you must specify a built-in array’s element type and number of elements, but the syntax is different. For example, to reserve five elements for a built-in array of <code>int</code>s named <code>c</code>, use</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0203-01" id="f0203-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> c[<span class="green">5</span>]; <span class="pd_green">// c is a built-in array of 5 integers</span></pre>&#13;
<p>You use the subscript (<code>[]</code>) operator to access a built-in array’s elements. Recall from <a href="ch06.xhtml#ch06">Chapter 6</a> that the subscript (<code>[]</code>) operator does not provide bounds checking for <code>std::array</code>s—this is also true for built-in arrays. Of course, you can use <code>std::array</code>’s <code>at</code> member function to do bounds checking.</p>&#13;
<h4 class="h4" id="ch07lev2sec8">7.5.2 Initializing Built-In Arrays</h4>&#13;
<p>You can initialize the elements of a built-in array using an initializer list. For example,</p>&#13;
<pre class="pre"><span class="blue">int</span> n[<span class="green">5</span>]{<span class="green">50</span>, <span class="green">20</span>, <span class="green">30</span>, <span class="green">10</span>, <span class="green">40</span>};</pre>&#13;
<p>creates and initializes a built-in array of five <code>int</code>s. If you provide fewer initializers than the number of elements, the remaining elements are <span class="violet"><strong>value initialized</strong></span>—fundamental numeric types are set to <code>0</code>, <code>bool</code>s are set to <code>false</code>, pointers are set to <code>nullptr</code> and, as we’ll see in <a href="ch10.xhtml#ch10">Chapter 10</a>, objects receive the default initialization specified by their class definitions. If you provide too many initializers, a compilation error occurs.</p>&#13;
<p>The compiler can size a built-in array by counting an initializer list’s elements. For example, the following creates a five-element <code>array</code>:</p>&#13;
<pre class="pre"><span class="blue">int</span> n[]{<span class="green">50</span>, <span class="green">20</span>, <span class="green">30</span>, <span class="green">10</span>, <span class="green">40</span>};</pre>&#13;
<h4 class="h4" id="ch07lev2sec9">7.5.3 Passing Built-In Arrays to Functions</h4>&#13;
<p>The value of a built-in array’s name is implicitly convertible to a <code>const</code> or non-<code>const</code> pointer to the built-in array’s first element—this is known as <span class="violet"><strong>decaying to a pointer</strong></span>. So the array name <code>n</code> above is equivalent to <code>&amp;n[0]</code>, which is a pointer to the element containing <code>50</code>. You don’t need to take the address (<code>&amp;</code>) of a built-in array to pass it to a function—you simply pass its name. As you saw in <a href="ch07.xhtml#ch07lev1sec4">Section 7.4</a>, a function that receives a pointer to a variable in the caller can modify that variable in the caller. For built-in arrays, the called function can modify all the elements in the caller—unless the parameter is declared <code>const</code>. Applying <code>const</code> to a built-in array parameter to prevent the argument array in the caller from being modified in the called function is another example of the principle of least privilege.</p>&#13;
<h4 class="h4" id="ch07lev2sec10">7.5.4 Declaring Built-In Array Parameters</h4>&#13;
<p>You can declare a built-in array parameter in a function header, as follows:</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0204-01" id="f0204-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> sumElements(<span class="blue">const int</span> values[], size_t numberOfElements)</pre>&#13;
<p>which indicates that the function’s first argument should be a one-dimensional built-in array of <code>int</code>s that should not be modified by the function. Unlike <code>std::array</code>s and <code>std::vector</code>s, built-in arrays don’t know their own size, so a function that processes a built-in array should also receive the built-in array’s size.</p>&#13;
<p>The preceding header also can be written as</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0204-02" id="f0204-02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> sumElements(<span class="blue">const int</span>* values, size_t numberOfElements)</pre>&#13;
<p>The compiler does not differentiate between a function that receives a pointer and a function that receives a built-in array. In fact, the compiler converts <code>const int values[]</code> to <code>const int* values</code> under the hood. This means the function must “know” when it’s receiving a built-in array vs. a single variable that’s being passed by reference.</p>&#13;
<p><span class="size">CG</span> <span class="size">20</span> The C++ Core Guidelines specifically say not to pass built-in arrays to functions;<sup><a id="rch07fn8" href="ch07.xhtml#ch07fn8">8</a></sup> rather, you should pass C++20 <code>span</code>s because they maintain a pointer to the array’s first element and the array’s size. In <a href="ch07.xhtml#ch07lev1sec10">Section 7.10</a>, we’ll demonstrate <code>span</code>s and you’ll see that passing a <code>span</code> is superior to passing a built-in array and its size to a function.</p>&#13;
<p class="footnote"><a id="ch07fn8" href="ch07.xhtml#rch07fn8">8</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-array">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-array</a></code>.</p>&#13;
<h4 class="h4" id="ch07lev2sec11">7.5.5 C++11: Standard Library Functions <code>begin</code> and <code>end</code></h4>&#13;
<p><span class="size">11</span> In <a href="ch06.xhtml#ch06lev1sec12">Section 6.12</a>, we sorted a <code>std::array</code> of <code>string</code>s called <code>colors</code> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0204-03" id="f0204-03a">Click here to view code image</a></p>&#13;
<pre class="pre">sort(begin(colors), end(colors)); <span class="pd_green">// sort contents of colors</span></pre>&#13;
<p>Functions <code>begin</code> and <code>end</code> specified that the entire <code>std::array</code> should be sorted. Function <code>sort</code> (and many other C++ Standard Library functions) also can be applied to built-in arrays. For example, to sort the built-in array <code>n</code> (<a href="ch07.xhtml#ch07lev2sec8">Section 7.5.2</a>), you can write</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0204-04" id="f0204-04a">Click here to view code image</a></p>&#13;
<pre class="pre">sort(begin(n), end(n)); <span class="pd_green">// sort contents of built-in array n</span></pre>&#13;
<p><span class="size">20</span> For a built-in array, <code>begin</code> and <code>end</code> work only in the scope that originally defines the array, which is where the compiler knows the array’s size. Again, you should pass built-in arrays to other functions using C++20 <code>span</code>s, which we demonstrate in <a href="ch07.xhtml#ch07lev1sec10">Section 7.10</a>.</p>&#13;
<h4 class="h4" id="ch07lev2sec12">7.5.6 Built-In Array Limitations</h4>&#13;
<p>Built-in arrays have several limitations:</p>&#13;
<p class="bull">• They cannot be compared using the relational and equality operators—you must use a loop to compare two built-in arrays element by element. If you had two <code>int</code> arrays named <code>array1</code> and <code>array2</code>, the condition <code>array1 == array2</code> would always be false, even if the arrays’ contents are identical. Remember, array names decay to <code>const</code> pointers to the arrays’ first elements. And, of course, for separate arrays, those elements reside at different memory locations.</p>&#13;
<p class="bull">• They cannot be assigned to one another—an array name is effectively a <code>const</code> pointer, so it can’t be changed by assignment.</p>&#13;
<p class="bull">• They don’t know their own size—a function that processes a built-in array typically receives both the built-in array’s name and its size as arguments.</p>&#13;
<p class="bull">• They don’t provide automatic bounds checking—you must ensure that array-access expressions use subscripts within the built-in array’s bounds.</p>&#13;
<h3 class="h3" id="ch07lev1sec6"><span class="violet">7.6</span> C++20: Using <code>to_array</code> to Convert a Built-in Array to a <code>std::array</code></h3>&#13;
<p><span class="size">20</span> <span class="size">CG</span> <img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> In industry, you’ll encounter C++ legacy code that uses built-in arrays. The C++ Core Guidelines say you should prefer <code>std::array</code>s and <code>std::vector</code>s to built-in arrays because they’re safer, and they do not become pointers when you pass them to functions.<sup><a id="rch07fn9" href="ch07.xhtml#ch07fn9">9</a></sup> C++20’s new <code><span class="violet"><strong>to_array</strong></span></code> function<sup><a id="rch07fn10" href="ch07.xhtml#ch07fn10">10</a></sup> (header <code>&lt;array&gt;</code>) makes it convenient to create a <code>std::array</code> from a built-in array or an initializer list. <a href="ch07.xhtml#fig7_6">Figure 7.6</a> demonstrates <code>to_array</code>. We use a generic lambda expression (lines 9–13) to display each <code>std::array</code>’s contents. Again, specifying a lambda parameter’s type as <code>auto</code> enables the compiler to infer the parameter’s type, based on the context in which the lambda appears. In this program, the generic lambda automatically determines the type of the <code>std::array</code> over which it iterates.</p>&#13;
<p class="footnote"><a id="ch07fn9" href="ch07.xhtml#rch07fn9">9</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-arrays">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-arrays</a></code>.</p>&#13;
<p class="footnote"><a id="ch07fn10" href="ch07.xhtml#rch07fn10">10</a>. “<code>to_array</code> From LFTS with Updates.” <code>to_array</code> from LFTS with updates—HackMD. Accessed June 14, 2020. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0325r4.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0325r4.html</a></code>.</p>&#13;
<div class="group" id="fig7_6">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig06" id="aa07fig06">Click here to view code image</a></p>&#13;
<pre class="pre3"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_06.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// C++20: Creating std::arrays with to_array.</span></code>          <span class="size">20</span>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>8</strong></span>       <code><span class="pd_green">// lambda to display a collection of items</span></code>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code><span class="blue">const auto</span> display = [](<span class="blue">const auto</span>&amp; items) {</code>&#13;
<span class="cviolet"><strong>10</strong></span>          <code><span class="blue">for</span> (<span class="blue">const auto</span>&amp; item : items) {</code>&#13;
<span class="cviolet"><strong>11</strong></span>             <code>cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;</code>&#13;
<span class="cviolet"><strong>12</strong></span>          <code>}</code>&#13;
<span class="cviolet"><strong>13</strong></span>       <code>};</code>&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.6</strong></span> C++20: Creating <code>std::array</code>s with <code>to_array</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch07lev3sec11">Using <code>to_array</code> to create a <code>std::array</code> from a Built-In Array</h5>&#13;
<p>Line 18 creates a three-element <code>std::array</code> of <code>int</code>s by copying the contents of built-in array <code>values1</code>. We use <code>auto</code> to infer the <code>std::array</code> variable’s type and size. If we declare the array’s type and size explicitly and it does not match <code>to_array</code>’s return value, a compilation error occurs. We assign the result to the variable <code>array1</code>. Lines 20 and 21 display the <code>std::array</code>’s size and contents to confirm that it was created correctly.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0206-01" id="f0206-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">15</span></strong>   <span class="blue">const int</span> values1[<span class="green">3</span>]{<span class="green">10</span>, <span class="green">20</span>, <span class="green">30</span>};&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>   <span class="pd_green">// creating a std::array from a built-in array</span>&#13;
<strong><span class="cviolet">18</span></strong>   <span class="blue">const auto</span> array1 = <span class="yell">to_array(values1)</span>;&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>   cout &lt;&lt; <span class="green">"array1.size() = "</span> &lt;&lt; array1.size() &lt;&lt; "<span class="green">\narray1: ";</span>&#13;
<strong><span class="cviolet">21</span></strong>   display(array4); <span class="pd_green">// use lambda to display contents</span>&#13;
<strong><span class="cviolet">22</span></strong></pre>&#13;
<pre class="pre1">array1.size() = 3&#13;
array1: 10 20 30</pre>&#13;
<h5 class="h5" id="ch07lev3sec12">Using <code>to_array</code> to create a <code>std::array</code> from an Initializer List</h5>&#13;
<p>Line 24 shows that <code>to_array</code> can create a <code>std::array</code> from an initializer list. Lines 25 and 26 display the <code>array</code>’s size and contents to confirm that it was created correctly.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0206-02" id="f0206-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">23</span></strong>     <span class="pd_green">// creating a std::array from an initializer list</span>&#13;
<strong><span class="cviolet">24</span></strong>     <span class="blue">const auto</span> array2 = <span class="yell">to_array({<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>})</span>;&#13;
<strong><span class="cviolet">25</span></strong>     cout &lt;&lt; <span class="green">"\n\narray2.size() = "</span> &lt;&lt; array2.size() &lt;&lt; <span class="green">"\narray2: "</span>;&#13;
<strong><span class="cviolet">26</span></strong>     display(array2); <span class="pd_green">// use lambda to display contents</span>&#13;
<strong><span class="cviolet">27</span></strong>&#13;
<strong><span class="cviolet">28</span></strong>     cout &lt;&lt; endl;&#13;
<strong><span class="cviolet">29</span></strong></pre>&#13;
<pre class="pre1">array2.size() = 4&#13;
array2: 1 2 3 4</pre>&#13;
<h3 class="h3" id="ch07lev1sec7"><span class="violet">7.7</span> Using <code>const</code> with Pointers and the Data Pointed To</h3>&#13;
<p>This section discusses how to combine <code>const</code> with pointer declarations to enforce the principle of least privilege. <a href="ch05.xhtml#ch05">Chapter 5</a> explained that pass-by-value copies an argument’s value into a function’s parameter. If the copy is modified in the called function, the original value in the caller does not change. In some instances, even the copy of the argument’s value should not be altered in the called function.</p>&#13;
<p>If a value does not (or should not) change in the body of a function to which it’s passed, declare the parameter <code>const</code>. Before using a function, check its function prototype to determine the parameters that it can and cannot modify.</p>&#13;
<p>There are four ways to pass a pointer to a function:</p>&#13;
<p class="bull">• a nonconstant pointer to nonconstant data,</p>&#13;
<p class="bull">• a nonconstant pointer to constant data (<a href="ch07.xhtml#fig7_7">Fig. 7.7</a>),</p>&#13;
<p class="bull">• a constant pointer to nonconstant data (<a href="ch07.xhtml#fig7_8">Fig. 7.8</a>) and</p>&#13;
<p class="bull">• a constant pointer to constant data (<a href="ch07.xhtml#fig7_9">Fig. 7.9</a>).</p>&#13;
<p>Each combination provides a different level of access privilege.</p>&#13;
<h4 class="h4" id="ch07lev2sec13">7.7.1 Using a Nonconstant Pointer to Nonconstant Data</h4>&#13;
<p>The highest privileges are granted by a <span class="violet"><strong>nonconstant pointer to nonconstant data</strong></span>:</p>&#13;
<p class="bull">• the data can be modified through the dereferenced pointer, and</p>&#13;
<p class="bull">• the pointer can be modified to point to other data.</p>&#13;
<p>Such a pointer’s declaration (e.g., <code>int* countPtr</code>) does not include <code>const</code>.</p>&#13;
<h4 class="h4" id="ch07lev2sec14">7.7.2 Using a Nonconstant Pointer to Constant Data</h4>&#13;
<p>A <span class="violet"><strong>nonconstant pointer to constant data</strong></span> is</p>&#13;
<p class="bull">• a pointer that can be modified to point to any data of the appropriate type, but</p>&#13;
<p class="bull">• the data to which it points cannot be modified through that pointer.</p>&#13;
<p>The declaration for such a pointer places <code>const</code> to the left of the pointer’s type, as in<sup><a id="rch07fn11" href="ch07.xhtml#ch07fn11">11</a></sup></p>&#13;
<p class="footnote"><a id="ch07fn11" href="ch07.xhtml#rch07fn11">11</a>. Some programmers prefer to write this as <code>int const* countPtr;</code>. They’d read this declaration from right to left as “<code>countPtr</code> is a pointer to a constant integer.”</p>&#13;
<pre class="pre"><span class="blue">const int</span>* countPtr;</pre>&#13;
<p>The declaration is read from right to left as “<code>countPtr</code> is a pointer to an integer constant” or, more precisely, “<code>countPtr</code> is a nonconstant pointer to an integer constant<em>.</em>”</p>&#13;
<p><a href="ch07.xhtml#fig7_7">Figure 7.7</a> demonstrates the GNU C++ compilation error produced when you try to modify data via a nonconstant pointer to constant data.</p>&#13;
<div class="group" id="fig7_7">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig07" id="aa07fig07">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_07.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Attempting to modify data through a</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="pd_green">// nonconstant pointer to constant data.</span></code>&#13;
 <span class="cviolet"><strong>4</strong></span>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>6</strong></span>       <code><span class="blue">int</span> y{<span class="green">0</span>};</code>&#13;
 <span class="cviolet"><strong>7</strong></span>       <code>const int* yPtr{&amp;y};</code>&#13;
 <span class="cviolet"><strong>8</strong></span>       <code><span class="yell">*yPtr = <span class="green">100</span>;</span> <span class="pd_green">// error: cannot modify a const object</span></code>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code>}</code>&#13;
&#13;
<span class="non_code"><em>GNU C++ compiler error message:</em></span></pre>&#13;
<pre class="pre1"><code><strong>fig07_07.cpp</strong>: In function <strong>'int main()'</strong>:</code>&#13;
<code><strong>fig07_07.cpp:8:10:</strong> <span class="red"><strong>error</strong></span>: assignment of read-only location <strong>'* yPtr'</strong></code>&#13;
    <code>8 |    <span class="red"><strong>*yPtr = 100</strong></span>; // error: cannot modify a const object</code>&#13;
      <code>|    <span class="red"><strong>~~~~~~^~~~~</strong></span></code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.7</strong></span> Attempting to modify data through a nonconstant pointer to <code>const</code> data.</p>&#13;
</div>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> <img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> Use pass-by-value to pass fundamental-type arguments (e.g., <code>int</code>s, <code>double</code>s, etc.) unless the called function must directly modify the value in the caller. This is another example of the principle of least privilege. If large objects do not need to be modified by a called function, pass them using references to constant data or using pointers to constant data—though references are preferred. This gives the performance benefits of pass-by-reference and avoids the copy overhead of pass-by-value. Passing large objects using references to constant data or pointers to constant data also offers the security of pass-by-value.</p>&#13;
<h4 class="h4" id="ch07lev2sec15">7.7.3 Using a Constant Pointer to Nonconstant Data</h4>&#13;
<p>A <span class="violet"><strong>constant pointer to nonconstant data</strong></span> is a pointer that</p>&#13;
<p class="bull">• always points to the same memory location, and</p>&#13;
<p class="bull">• the data at that location can be modified through the pointer.</p>&#13;
<p>Pointers that are declared <code>const</code> must be initialized when they’re declared, but if the pointer is a function parameter, it’s initialized with the pointer that’s passed to the function. Each successive call to the function reinitializes that function parameter.</p>&#13;
<p><a href="ch07.xhtml#fig7_8">Figure 7.8</a> attempts to modify a constant pointer. Line 9 declares pointer <code>ptr</code> to be of type <code>int* const</code>. The declaration is read from right to left as “<code>ptr</code> is a constant pointer to a nonconstant integer.” The pointer is initialized with the address of integer variable <code>x</code>. Line 12 attempts to assign the address of <code>y</code> to <code>ptr</code>, but the compiler generates an error message. No error occurs when line 11 assigns the value <code>7</code> to <code>*ptr</code>. The nonconstant value to which <code>ptr</code> points can be modified using the dereferenced <code>ptr</code>, even though <code>ptr</code> itself has been declared <code>const</code>.</p>&#13;
<div class="group" id="fig7_8">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig08" id="aa07fig08">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_08.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Attempting to modify a constant pointer to nonconstant data.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>5</strong></span>       <code><span class="blue">int</span> x, y;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>       <span class="yell"><code><span class="pd_green">// ptr is a constant pointer to an integer that can be modified</span></code>   </span>&#13;
 <span class="cviolet"><strong>8</strong></span>       <span class="yell"><code><span class="pd_green">// through ptr, but ptr always points to the same memory location.</span></code></span>&#13;
 <span class="cviolet"><strong>9</strong></span>       <span class="yell"><code><span class="blue">int</span>* <span class="blue">const</span> ptr{&amp;x}; <span class="pd_green">// const pointer must be initialized</span></code>          </span>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>       <code>*ptr = <span class="green">7</span>; <span class="pd_green">// allowed: *ptr is not const</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>       <span class="yell"><code><span class="red">ptr = &amp;y; // error: ptr is const; cannot assign to it a new address</span></code></span>&#13;
<span class="cviolet"><strong>13</strong></span>    <code>}</code>&#13;
&#13;
<span class="non_code"><em>Microsoft Visual C++ compiler error message:</em></span></pre>&#13;
<pre class="pre1"><code>error C3892: 'ptr': you cannot assign to a variable that is const</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.8</strong></span> Attempting to modify a constant pointer to nonconstant data.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch07lev2sec16">7.7.4 Using a Constant Pointer to Constant Data</h4>&#13;
<p>The minimum access privileges are granted by a <span class="violet"><strong>constant pointer to constant data</strong></span>:</p>&#13;
<p class="bull">• such a pointer always points to the same memory location, and</p>&#13;
<p class="bull">• the data at that location cannot be modified via the pointer.</p>&#13;
<p><a href="ch07.xhtml#fig7_9">Figure 7.9</a> declares pointer variable <code>ptr</code> to be of type <code>const int* const</code> (line 12). This declaration is read from right to left as “<code>ptr</code> is a constant pointer to an integer constant.” The figure shows the Apple Clang compiler’s error messages for attempting to modify the data to which <code>ptr</code> points (line 16) and attempting to modify the address stored in the pointer variable (line 17). In line 14, no errors occur, because <em>neither</em> the pointer <em>nor</em> the data it points to is being modified.</p>&#13;
<div class="group" id="fig7_9">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig09" id="aa07fig09">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_09.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Attempting to modify a constant pointer to constant data.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>7</strong></span>       <code><span class="blue">int</span> x{<span class="green">5</span>}, y;</code>&#13;
 <span class="cviolet"><strong>8</strong></span>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code><span class="pd_green">// ptr is a constant pointer to a constant integer.</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code><span class="pd_green">// ptr always points to the same location; the integer</span></code>&#13;
<span class="cviolet"><strong>11</strong></span>       <code><span class="pd_green">// at that location cannot be modified.</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>       <span class="yell"><code><span class="blue">const</span> <span class="blue">int</span>* <span class="blue">const</span> ptr{&amp;x};</code></span>&#13;
<span class="cviolet"><strong>13</strong></span>         &#13;
<span class="cviolet"><strong>14</strong></span>       <code>cout &lt;&lt; *ptr &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>       <span class="yell"><code><span class="red">*ptr = 7; // error: *ptr is const; cannot assign new value</span></code> </span>&#13;
<span class="cviolet"><strong>17</strong></span>       <span class="yell"><code><span class="red">ptr = &amp;y; // error: ptr is const; cannot assign new address</span></code></span>&#13;
<span class="cviolet"><strong>18</strong></span>    <code>}</code>&#13;
&#13;
<span class="non_code"><em>Apple Clang compiler error messages:</em></span></pre>&#13;
<pre class="pre1"><code>fig07_09.cpp:16:9: error: read-only variable is not assignable</code>&#13;
   <code>*ptr = 7; // error: *ptr is const; cannot assign new value</code>&#13;
   <code>~~~~ ^</code>&#13;
<code>fig07_09.cpp:17:8: error: cannot assign to variable 'ptr' with const-qualified type 'const int *const'</code>&#13;
   <code>ptr = &amp;y; // error: ptr is const; cannot assign new address</code>&#13;
   <code>~~~ ^</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.9</strong></span> Attempting to modify a constant pointer to constant data.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev1sec8"><span class="violet">7.8</span> <code>sizeof</code> Operator</h3>&#13;
<p>The compile-time unary operator <code><span class="violet"><strong>sizeof</strong></span></code> determines the size in bytes of a built-in array or of any other data type, variable or constant <em>during program compilation</em>. When applied to a built-in array’s name, as in <a href="ch07.xhtml#fig7_10">Fig. 7.10</a><sup><a id="rch07fn12" href="ch07.xhtml#ch07fn12">12</a></sup> (line 12), <code>sizeof</code> returns the total number of bytes in the built-in array as a value of type <code>size_t</code>. The computer we used to compile this program stores <code>double</code> variables in 8 bytes of memory. <code>numbers</code> is declared to have 20 elements (line 10), so it uses 160 bytes in memory. Applying <code>sizeof</code> to a pointer parameter (line 20) in a function that receives a built-in array, returns the size of the pointer in bytes (4 on the system we used), not the built-in array’s size. Using the <code>sizeof</code> operator in a function to find the size in bytes of a built-in array parameter returns the size in bytes of a pointer, not the size in bytes of the built-in array<em>.</em></p>&#13;
<p class="footnote"><a id="ch07fn12" href="ch07.xhtml#rch07fn12">12</a>. This is a mechanical example to demonstrate how <code>sizeof</code> works. If you use static code-analysis tools, such as the C++ Core Guidelines checker in Microsoft Visual Studio, you’ll receive warnings because you should not pass built-in arrays to functions.</p>&#13;
<div class="group" id="fig7_10">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig10" id="aa07fig10">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_10.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Sizeof operator when used on a built-in array's name</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="pd_green">// returns the number of bytes in the built-in array.</span></code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code>size_t getSize(<span class="yell"><span class="blue">doubl</span>e* ptr</span>); <span class="pd_green">// prototype</span></code>&#13;
 <span class="cviolet"><strong>8</strong></span>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="yell"><code><span class="blue">double</span> numbers[<span class="green">20</span>]; <span class="pd_green">// 20 doubles; occupies 160 bytes on our system</span></code></span>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <code>cout &lt;&lt; <span class="green">"The number of bytes in the array is "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span>(numbers);</span></code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      <code>cout &lt;&lt; <span class="green">"\nThe number of bytes returned by getSize is "</span></code>&#13;
<span class="cviolet"><strong>15</strong></span>         <code>&lt;&lt; <span class="yell">getSize(numbers)</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>16</strong></span>    <code>}</code>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>    <span class="yell"><code><span class="pd_green">// return size of ptr</span></code>        </span>&#13;
<span class="cviolet"><strong>19</strong></span>    <span class="yell"><code>size_t getSize<span class="blue">(doubl</span>e* ptr) {</code></span>&#13;
<span class="cviolet"><strong>20</strong></span>    <span class="yell"><code><span class="blue">return</span> <span class="blue">sizeof</span>(ptr);</code>          </span>&#13;
<span class="cviolet"><strong>21</strong></span>    <span class="yell"><code>} <span class="pd_green"/></code>                           </span></pre>&#13;
<pre class="pre1"><code>The number of bytes in the array is 160</code>&#13;
<code>The number of bytes returned by getSize is 4</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.10</strong></span> <code>sizeof</code> operator when applied to a built-in array’s name returns the number of bytes in the built-in array.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch07lev3sec13">Determining the Sizes of the Fundamental Types, a Built-In Array and a Pointer</h5>&#13;
<p><span class="size">11</span> <a href="ch07.xhtml#fig7_11">Figure 7.11</a> uses <code>sizeof</code> to calculate the number of bytes used to store various standard data types. The output was produced using the Apple Clang compiler in Xcode. Type sizes are platform dependent. When we run this program on our Windows system, for example, <code>long</code> is 4 bytes and <code>long long</code> is 8 bytes, whereas on our Mac, they’re both 8 bytes. In this example<sup><a id="rch07fn13" href="ch07.xhtml#ch07fn13">13</a></sup>, lines 7–15 implicitly initialize each variable to 0 using a C++11 empty initializer list, <code>{}</code>.</p>&#13;
<p class="footnote"><a id="ch07fn13" href="ch07.xhtml#rch07fn13">13</a>. Line 16 uses <code>const</code> rather than <code>constexpr</code> to prevent a type mismatch compilation error. The name of the built-in array of <code>int</code>s (line 15) decays to a <code>const int*</code>, so we must declare <code>ptr</code> with that type.</p>&#13;
<div class="group" id="fig7_11">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig11" id="aa07fig11">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_11.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// sizeof operator used to determine standard data type sizes.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>7</strong></span>       <code><span class="blue">constexpr char</span> c{}; <span class="pd_green">// variable of type char</span></code>&#13;
 <span class="cviolet"><strong>8</strong></span>       <code><span class="blue">constexpr short</span> s{}; <span class="pd_green">// variable of type short</span></code>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code><span class="blue">constexpr int</span> i{}; <span class="pd_green">// variable of type int</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code><span class="blue">constexpr long</span> l{}; <span class="pd_green">// variable of type long</span></code>&#13;
<span class="cviolet"><strong>11</strong></span>       <code><span class="blue">constexpr long long</span> ll{}; <span class="pd_green">// variable of type long long</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>       <code><span class="blue">constexpr float</span> f{}; <span class="pd_green">// variable of type float</span></code>&#13;
<span class="cviolet"><strong>13</strong></span>       <code><span class="blue">constexpr double</span> d{}; <span class="pd_green">// variable of type double</span></code>&#13;
<span class="cviolet"><strong>14</strong></span>       <code><span class="blue">constexpr long</span> <span class="blue">double</span> ld{}; <span class="pd_green">// variable of type long double</span></code>&#13;
<span class="cviolet"><strong>15</strong></span>       <code><span class="blue">constexpr int</span> array[<span class="green">20</span>]{}; <span class="pd_green">// built-in array of int</span></code>&#13;
<span class="cviolet"><strong>16</strong></span>       <code><span class="blue">const int</span>* <span class="blue">const</span> ptr{array}; <span class="pd_green">// variable of type int*</span></code>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>       <code>cout &lt;&lt; <span class="green">"sizeof c = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> c</span></code>&#13;
<span class="cviolet"><strong>19</strong></span>          <code>&lt;&lt; <span class="green">"\tsizeof(char) = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span>(<span class="blue">char</span>)</span></code>&#13;
<span class="cviolet"><strong>20</strong></span>          <code>&lt;&lt; <span class="green">"\nsizeof s = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> s</span></code>&#13;
<span class="cviolet"><strong>21</strong></span>          <code>&lt;&lt; <span class="green">"\tsizeof(short) = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span>(<span class="blue">short</span>)</span></code>&#13;
<span class="cviolet"><strong>22</strong></span>          <code>&lt;&lt; <span class="green">"\nsizeof i = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> i</span></code>&#13;
<span class="cviolet"><strong>23</strong></span>          <code>&lt;&lt; <span class="green">"\tsizeof(int) = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span>(<span class="blue">int</span>)</span></code>&#13;
<span class="cviolet"><strong>24</strong></span>          <code>&lt;&lt; <span class="green">"\nsizeof l = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> l</span></code>&#13;
<span class="cviolet"><strong>25</strong></span>          <code>&lt;&lt; <span class="green">"\tsizeof(long) = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span>(<span class="blue">long</span>)</span></code>&#13;
<span class="cviolet"><strong>26</strong></span>          <code>&lt;&lt; <span class="green">"\nsizeof ll = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> ll</span></code>&#13;
<span class="cviolet"><strong>27</strong></span>          <code>&lt;&lt; <span class="green">"\tsizeof(long long) = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span>(<span class="blue">long long</span>)</span></code>&#13;
<span class="cviolet"><strong>28</strong></span>          <code>&lt;&lt; <span class="green">"\nsizeof f = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> f</span></code>&#13;
<span class="cviolet"><strong>29</strong></span>          <code>&lt;&lt; <span class="green">"\tsizeof(float) = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span>(<span class="blue">float</span>)</span></code>&#13;
<span class="cviolet"><strong>30</strong></span>          <code>&lt;&lt; <span class="green">"\nsizeof d = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> d</span></code>&#13;
<span class="cviolet"><strong>31</strong></span>          <code>&lt;&lt; <span class="green">"\tsizeof(double) = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span>(<span class="blue">double</span>)</span></code>&#13;
<span class="cviolet"><strong>32</strong></span>          <code>&lt;&lt; <span class="green">"\nsizeof ld = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> ld</span></code>&#13;
<span class="cviolet"><strong>33</strong></span>          <code>&lt;&lt; <span class="green">"\tsizeof(long double) = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span>(<span class="blue">long double</span>)</span></code>&#13;
<span class="cviolet"><strong>34</strong></span>          <code>&lt;&lt; <span class="green">"\nsizeof array = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> array</span></code>&#13;
<span class="cviolet"><strong>35</strong></span>          <code>&lt;&lt; <span class="green">"\nsizeof ptr = "</span> &lt;&lt; <span class="yell"><span class="blue">sizeof</span> ptr &lt;&lt; endl;</span></code>&#13;
<span class="cviolet"><strong>36</strong></span>    <code>} <span class="pd_green"/></code></pre>&#13;
<pre class="pre1"><code>sizeof c = 1    sizeof(char) = 1</code>&#13;
<code>sizeof s = 2    sizeof(short) = 2</code>&#13;
<code>sizeof i = 4    sizeof(int) = 4</code>&#13;
<code>sizeof l = 8    sizeof(long) = 8</code>&#13;
<code>sizeof ll = 8   sizeof(long long) = 8</code>&#13;
<code>sizeof f = 4    sizeof(float) = 4</code>&#13;
<code>sizeof d = 8    sizeof(double) = 8</code>&#13;
<code>sizeof ld = 16  sizeof(long double) = 16</code>&#13;
<code>sizeof array = 80</code>&#13;
<code>sizeof ptr = 8</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.11</strong></span> <code>sizeof</code> operator used to determine standard data type sizes.</p>&#13;
</div>&#13;
<p>The number of bytes used to store a particular data type may vary among systems and compilers. When writing programs that depend on data type sizes, always use <code>sizeof</code> to determine the number of bytes used to store the data types.</p>&#13;
<p>Operator <code>sizeof</code> can be applied to any expression or type name. When applied to a variable name (which is not a built-in array’s name) or other expression, the number of bytes used to store the corresponding type is returned. The parentheses used with <code>sizeof</code> are required only if a type name (e.g., <code>int</code>) is supplied as its operand. The parentheses used with <code>sizeof</code> are not required when <code>sizeof</code>’s operand is an expression. Remember that <code>sizeof</code> is a compile-time operator, so its operand is not evaluated at runtime.</p>&#13;
<h3 class="h3" id="ch07lev1sec9"><span class="violet">7.9</span> Pointer Expressions and Pointer Arithmetic</h3>&#13;
<p>C++ enables <span class="violet"><strong>pointer arithmetic</strong></span>—arithmetic operations that may be performed on pointers. This section describes the operators that have pointer operands and how these operators are used with pointers.</p>&#13;
<p><span class="size">CG</span> Pointer arithmetic is appropriate only for pointers that point to built-in array elements. You’re likely to encounter pointer arithmetic in legacy code. However, <strong>the C++ Core Guidelines indicate that a pointer should refer only to a single object (not an array),</strong><sup><a id="rch07fn14" href="ch07.xhtml#ch07fn14">14</a></sup> <strong>and that you should not use pointer arithmetic because it’s highly error prone.</strong><sup><a id="rch07fn15" href="ch07.xhtml#ch07fn15">15</a></sup> <strong>If you need to process built-in arrays, use C++20</strong> <code><strong>span</strong></code><strong>s instead (<a href="ch07.xhtml#ch07lev1sec10">Section 7.10</a>).</strong></p>&#13;
<p class="footnote"><a id="ch07fn14" href="ch07.xhtml#rch07fn14">14</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-ptr">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-ptr</a></code>.</p>&#13;
<p class="footnote"><a id="ch07fn15" href="ch07.xhtml#rch07fn15">15</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-bounds">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-bounds</a></code>.</p>&#13;
<p>Valid pointer arithmetic operations are:</p>&#13;
<p class="bull">• incrementing (<code>++</code>) or decrementing (<code>--</code>),</p>&#13;
<p class="bull">• adding an integer to a pointer (<code>+</code> or <code>+=</code>) or subtracting an integer from a pointer (<code>-</code> or <code>-=</code>), and</p>&#13;
<p class="bull">• subtracting one pointer from another of the same type</p>&#13;
<p>Subtracting pointers is appropriate only for two pointers that point to elements of the same built-in array.</p>&#13;
<p>Most computers today have four-byte (32-bit) or eight-byte (64-bit) integers, though some of the billions of resource-constrained Internet of Things (IoT) devices are built using 8-bit or 16-bit hardware. Integer sizes typically are based on the hardware architecture, so such hardware might use one- or two-byte integers, respectively. The results of pointer arithmetic depend on the size of the memory objects a pointer points to, so pointer arithmetic is machine-dependent.</p>&#13;
<p>Assume that <code>int v[5]</code> has been declared and that its first element is at memory location <code>3000</code>. Assume that pointer <code>vPtr</code> has been initialized to point to <code>v[0]</code> (i.e., the value of <code>vPtr</code> is <code>3000</code>). The following diagram illustrates this situation for a machine with four-byte integers:</p>&#13;
<div class="image"><img src="Images/f0256-01.jpg" alt="Images" width="424" height="200"/></div>&#13;
<p>Variable <code>vPtr</code> can be initialized to point to <code>v</code> with either of the following statements (because a built-in array’s name implicitly converts to the address of its zeroth element):</p>&#13;
<pre class="pre"><span class="blue">int</span>* vPtr{v};&#13;
<span class="blue">int</span>* vPtr{&amp;v[<span class="green">0</span>]};</pre>&#13;
<h4 class="h4" id="ch07lev2sec17">7.9.1 Adding Integers to and Subtracting Integers from Pointers</h4>&#13;
<p>In conventional arithmetic, the addition <code>3000 + 2</code> yields the value <code>3002</code>. This is normally not the case with pointer arithmetic. Adding an integer to or subtracting an integer from a pointer increments or decrements the pointer by that integer times the size of the type to which the pointer refers. The number of bytes depends on the memory object’s data type. For example, the statement</p>&#13;
<pre class="pre">vPtr += <span class="green">2</span>;</pre>&#13;
<p>would produce <code>3008</code> (from the calculation <code>3000 + 2 * 4</code>), assuming that an <code>int</code> is stored in four bytes of memory. In the built-in array <code>v</code>, <code>vPtr</code> would now point to <code>v[2]</code> as in the diagram below:</p>&#13;
<div class="image"><img src="Images/f0257-01.jpg" alt="Images" width="424" height="200"/></div>&#13;
<p>If <code>vPtr</code> had been incremented to <code>3016</code>, which points to <code>v[4]</code>, the statement</p>&#13;
<pre class="pre">vPtr -= <span class="green">4</span>;</pre>&#13;
<p>would set <code>vPtr</code> back to <code>3000</code>—the beginning of the built-in array. If a pointer is being incremented or decremented by one, the increment (<code>++</code>) and decrement (<code>--</code>) operators can be used. Each of the statements</p>&#13;
<pre class="pre">++vPtr;&#13;
vPtr++;</pre>&#13;
<p>increments the pointer to point to the built-in array’s next element. Each of the statements</p>&#13;
<pre class="pre">--vPtr;&#13;
vPtr--;</pre>&#13;
<p>decrements the pointer to point to the built-in array’s previous element.</p>&#13;
<p><span class="size">CG</span> <strong>There’s no bounds checking on pointer arithmetic, so the C++ Core Guidelines recommend using</strong> <code><strong>std::span</strong></code><strong>s instead, which we demonstrate in <a href="ch07.xhtml#ch07lev1sec10">Section 7.10</a>.</strong> You must ensure that every pointer arithmetic operation that adds an integer to or subtracts an integer from a pointer results in a pointer that references an element within the built-in array’s bounds. As you’ll see, <code><strong>std::span</strong></code><strong>s have bounds checking, which helps you avoid errors.</strong></p>&#13;
<h4 class="h4" id="ch07lev2sec18">7.9.2 Subtracting One Pointer from Another</h4>&#13;
<p>Pointer variables pointing to the same built-in array may be subtracted from one another. For example, if <code>vPtr</code> contains the address <code>3000</code> and <code>v2Ptr</code> contains the address <code>3008</code>, the statement</p>&#13;
<pre class="pre">x = v2Ptr - vPtr;</pre>&#13;
<p>would assign to <code>x</code> the number of built-in array elements from <code>vPtr</code> to <code>v2Ptr</code>—in this case, <code>2</code>. Pointer arithmetic is meaningful only on a pointer that points to a built-in array<em>.</em> We cannot assume that two variables of the same type are stored contiguously in memory unless they’re adjacent elements of a built-in array. Subtracting or comparing two pointers that do not refer to elements of the same built-in array is a logic error.</p>&#13;
<h4 class="h4" id="ch07lev2sec19">7.9.3 Pointer Assignment</h4>&#13;
<p>A pointer can be assigned to another pointer if both pointers are of the same type.<sup><a id="rch07fn16" href="ch07.xhtml#ch07fn16">16</a></sup> The exception to this rule is the <span class="violet"><strong>pointer to</strong></span> <code><span class="violet"><strong>void</strong></span></code> (i.e., <code><span class="violet"><strong>void*</strong></span></code>), which is a pointer capable of representing any pointer type. Any pointer to a fundamental type or class type can be assigned to a pointer of type <code>void*</code> without casting. However, a pointer of type <code>void*</code> cannot be assigned directly to a pointer of another type—the pointer of type <code>void*</code> must first be cast to the proper pointer type (generally via a <code>reinterpret_cast</code>; discussed in Section 9.8).</p>&#13;
<p class="footnote"><a id="ch07fn16" href="ch07.xhtml#rch07fn16">16</a>. Of course, <code>const</code> pointers cannot be modified.</p>&#13;
<h4 class="h4" id="ch07lev2sec20">7.9.4 Cannot Dereference a <code>void*</code></h4>&#13;
<p>A <code>void*</code> pointer cannot be dereferenced. For example, the compiler “knows” that an <code>int*</code> points to four bytes of memory on a machine with four-byte integers. Dereferencing an <code>int*</code> creates an <em>lvalue</em> that is an alias for the <code>int</code>’s four bytes in memory. A <code>void*</code>, however, simply contains a memory address for an unknown data type. You cannot dereference a <code>void*</code> because the compiler does not know the type of the data to which the pointer refers and thus not the number of bytes.</p>&#13;
<p>The allowed operations on <code>void*</code> pointers are:</p>&#13;
<p class="bull">• comparing <code>void*</code> pointers with other pointers,</p>&#13;
<p class="bull">• casting <code>void*</code> pointers to other pointer types and</p>&#13;
<p class="bull">• assigning addresses to <code>void*</code> pointers.</p>&#13;
<p>All other operations on <code>void*</code> pointers are compilation errors.</p>&#13;
<h4 class="h4" id="ch07lev2sec21">7.9.5 Comparing Pointers</h4>&#13;
<p>Pointers can be compared using equality and relational operators. Relational comparisons using are meaningless unless the pointers point to elements of the same built-in array. Pointer comparisons compare the addresses stored in the pointers. Comparing two pointers pointing to the same built-in array could show, for example, that one pointer points to a higher-numbered element than the other. A common use of pointer comparison is determining whether a pointer has the value <code>nullptr</code> (i.e., a pointer to nothing).</p>&#13;
<h3 class="h3" id="ch07lev1sec10"><span class="violet">7.10</span> Objects Natural Case Study: C++20 <code>span</code>s—Views of Contiguous Container Elements</h3>&#13;
<p><span class="size">20</span> We now continue our objects natural approach by taking C++20 <code>span</code> objects for a spin. A <code><span class="violet"><strong>span</strong></span></code> (header <code><span class="violet"><strong>&lt;span&gt;</strong></span></code>) enables programs to view contiguous elements of a container, such as a built-in array, a <code>std::array</code> or a <code>std::vector</code>. A <code>span</code> is a “view” into a container— it “sees” the container’s contents, but does not have its own copy of the container’s data.</p>&#13;
<p><span class="size">CG</span> Earlier, we discussed how C++ built-in arrays decay to pointers when passed to functions. In particular, the function’s parameter loses the size information that was provided when you declared the array. You saw this in our <code>sizeof</code> demonstration in <a href="ch07.xhtml#fig7_10">Fig. 7.10</a>. <strong>The C++ Core Guidelines recommend passing built-in arrays to functions as</strong> <code><strong>span</strong></code><strong>s</strong><sup><a id="rch07fn17" href="ch07.xhtml#ch07fn17">17</a></sup><strong>, which represent both a pointer to the array’s first element and the array’s size.</strong> <a href="ch07.xhtml#fig7_12">Figure 7.12</a> demonstrates some key <code>span</code> capabilities.</p>&#13;
<p class="footnote"><a id="ch07fn17" href="ch07.xhtml#rch07fn17">17</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ap">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ap</a></code>.</p>&#13;
<div class="group" id="fig7_12">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig12" id="aa07fig12">Click here to view code image</a></p>&#13;
<pre class="pre3"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_12.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// C++20 spans: Creating views into containers.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;numeric&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">#include</span> &lt;span&gt;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">#include</span> &lt;vector&gt;</code>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>9</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.12</strong></span> C++20 <code>span</code>s: Creating views into containers.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch07lev3sec14">Function <code>displayArray</code></h5>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> <span class="size">CG</span> Passing a built-in array to a function typically requires both the array’s name and the array’s size. The parameter <code>items</code> (line 12), though declared with <code>[]</code>, is simply a pointer to an <code>int</code>—the pointer does not “know” how many elements the function’s argument contains. There are various problems with this approach. For instance, the code that calls <code>displayArray</code> could pass the wrong value for <code>size</code>. In this case, the function might not process all of <code>items</code>’ elements, or the function might access an element outside <code>items</code>’ bounds—a logic error and a potential security issue. In addition, we previously discussed the disadvantages of external iteration, as used in lines 13–15. The C++ Core Guidelines checker in Visual Studio issues several warnings about <code>displayArray</code> and passing built-in arrays to functions. We include function <code>displayArray</code> in this example only for comparison with passing <code>span</code>s in function <code>displaySpan</code>, which is the recommended approach.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0215-01" id="f0215-01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">10</span></strong>   <span class="pd_green">// items parameter is treated as a const int* so we also need the size to</span>&#13;
<strong><span class="cviolet">11</span></strong>   <span class="pd_green">// know how to iterate over items with counter-controlled iteration</span>&#13;
<strong><span class="cviolet">12</span></strong>   <span class="blue">void</span> displayArray(<span class="yell"><span class="blue">const int</span> items[], size_t size</span>) {&#13;
<strong><span class="cviolet">13</span></strong>      <span class="yell"><span class="blue">for</span> (size_t i{<span class="green">0</span>}; i &lt; size; ++i)</span> {&#13;
<strong><span class="cviolet">14</span></strong>         cout &lt;&lt; <span class="yell">items[i]</span> &lt;&lt; <span class="green">" "</span>;&#13;
<strong><span class="cviolet">15</span></strong>      }&#13;
<strong><span class="cviolet">16</span></strong>   }&#13;
<strong><span class="cviolet">17</span></strong></pre>&#13;
<h5 class="h5" id="ch07lev3sec15">Function <code>displaySpan</code></h5>&#13;
<p><span class="size">CG</span> The C++ Core Guidelines indicate that a pointer should point only to one object, not an array<sup><a id="rch07fn18" href="ch07.xhtml#ch07fn18">18</a></sup> and that functions like <code>displayArray</code>, which receive a pointer and a size, are error-prone.<sup><a id="rch07fn19" href="ch07.xhtml#ch07fn19">19</a></sup> To fix these issues, you should pass arrays to functions using <code>span</code>s, as in <code>displaySpan</code> (lines 20–24), which receives a <code>span</code> containing <code>const int</code>s because the function does not need to modify the data to display it.</p>&#13;
<p class="footnote"><a id="ch07fn18" href="ch07.xhtml#rch07fn18">18</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-ptr">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-ptr</a></code>.</p>&#13;
<p class="footnote"><a id="ch07fn19" href="ch07.xhtml#rch07fn19">19</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-array">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-array</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0216-01" id="f0216-01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">18</span></strong>  <span class="pd_green">// span parameter contains both the location of the first item</span>&#13;
<strong><span class="cviolet">19</span></strong>  <span class="pd_green">// and the number of elements, so we can iterate using range-based for</span>&#13;
<strong><span class="cviolet">20</span></strong>  <span class="blue">void</span> displaySpan(<span class="yell">span&lt;<span class="blue">const int</span>&gt; items</span>) {&#13;
<strong><span class="cviolet">21</span></strong>     <span class="yell"><span class="blue">for</span> (<span class="blue">const auto</span>&amp; item : items)</span> { <span class="pd_green">// spans are iterable</span>&#13;
<strong><span class="cviolet">22</span></strong>        cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;&#13;
<strong><span class="cviolet">23</span></strong>     }&#13;
<strong><span class="cviolet">24</span></strong>  }&#13;
<strong><span class="cviolet">25</span></strong></pre>&#13;
<p><span class="size">CG</span> <img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> A <code>span</code> encapsulates both a pointer and a count of the number of contiguous elements. When you pass a built-in array to <code>displaySpan</code>, C++ implicitly creates a <code>span</code> containing a pointer to the array’s first element and the array’s size, which the compiler can determine from the array’s declaration. This <code>span</code> is a view of the data in the original array that you pass as an argument. The C++ Core Guidelines indicate that you can pass a <code>span</code> by value because it’s just as efficient as passing the pointer and size separately<sup><a id="rch07fn20" href="ch07.xhtml#ch07fn20">20</a></sup>, as we did in <code>displayArray</code>.</p>&#13;
<p class="footnote"><a id="ch07fn20" href="ch07.xhtml#rch07fn20">20</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-range">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-range</a>.</code></p>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> A <code>span</code> has many capabilities similar to <code>array</code>s and <code>vector</code>s, such as iteration via the range-based <code>for</code> statement. Because a <code>span</code> is created based on the array’s original size as determined by the compiler, the range-based <code>for</code> guarantees that we cannot access an element outside the bounds of the array that the <code>span</code> views, thus fixing the various problems associated with <code>displayArray</code> and helping prevent security issues like buffer overflows.</p>&#13;
<h5 class="h5" id="ch07lev3sec16">Function <code>times2</code></h5>&#13;
<p>A <code>span</code> is a view into an existing container, so changing the <code>span</code>’s elements changes the container’s original data. Function <code>times2</code> multiplies every item in its <code>span&lt;int&gt;</code> by 2. Note that we use a non-<code>const</code> reference to modify each element that the <code>span</code> views.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0216-02" id="f0216-02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">26</span></strong>  <span class="pd_green">// spans can be used to modify elements in the original data structure</span>&#13;
<strong><span class="cviolet">27</span></strong>  <span class="blue">void</span> times2(<span class="yell">span&lt;<span class="blue">int</span>&gt; items</span>) {&#13;
<strong><span class="cviolet">28</span></strong>     <span class="yell"><span class="blue">for</span> (<span class="blue">int</span>&amp; item : items)</span> {&#13;
<strong><span class="cviolet">29</span></strong>        item *= <span class="green">2</span>;&#13;
<strong><span class="cviolet">30</span></strong>     }&#13;
<strong><span class="cviolet">31</span></strong>  }&#13;
<strong><span class="cviolet">32</span></strong></pre>&#13;
<h5 class="h5" id="ch07lev3sec17">Passing an Array to a Function to Display the Contents</h5>&#13;
<p>Lines 34–36 create the <code>int</code> built-in array <code>values1</code>, the <code>std::array values2</code> and the <code>std::vector values3</code>. Each has five elements and stores its elements contiguously in memory. Line 41 calls <code>displayArray</code> to display <code>values1</code>’s contents. The <code>displayArray</code> function’s first parameter is a pointer to an <code>int</code>, so we cannot use a <code>std::array</code>’s or <code>std::vector</code>’s name to pass these objects to <code>displayArray</code>.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0217-01" id="f0217-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">33</span></strong> <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">34</span></strong>    <span class="blue">int</span> values1[<span class="green">5</span>]{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>};&#13;
<strong><span class="cviolet">35</span></strong>    array&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; values2{<span class="green">6</span>, <span class="green">7</span>, <span class="green">8</span>, <span class="green">9</span>, <span class="green">10</span>};&#13;
<strong><span class="cviolet">36</span></strong>    vector&lt;<span class="blue">int</span>&gt; values3{<span class="green">11</span>, <span class="green">12</span>, <span class="green">13</span>, <span class="green">14</span>, <span class="green">15</span>};&#13;
<strong><span class="cviolet">37</span></strong>&#13;
<strong><span class="cviolet">38</span></strong>    <span class="pd_green">// must specify size because the compiler treats displayArray's items</span>&#13;
<strong><span class="cviolet">39</span></strong>    <span class="pd_green">// parameter as a pointer to the first element of the argument</span>&#13;
<strong><span class="cviolet">40</span></strong>    cout &lt;&lt; <span class="green">"values1 via displayArray: "</span>;&#13;
<strong><span class="cviolet">41</span></strong>    displayArray(values1, <span class="green">5</span>);&#13;
<strong><span class="cviolet">42</span></strong></pre>&#13;
<pre class="pre1">values1 via displayArray: 1 2 3 4 5</pre>&#13;
<h5 class="h5" id="ch07lev3sec18">Implicitly Creating <code>span</code>s and Passing Them to Functions</h5>&#13;
<p>Line 46 calls <code>displaySpan</code> with <code>values1</code> as an argument. The function’s parameter was declared as</p>&#13;
<pre class="pre">span&lt;<span class="blue">const int</span>&gt;</pre>&#13;
<p>so C++ creates a span containing a <code>const int*</code> that points to the array’s first element and the array’s size, which the compiler gets from the declaration of <code>values1</code> (line 34). Because spans can view any contiguous sequence of elements, you may also pass a <code>std::array</code> or <code>std::vector</code> of <code>int</code> to <code>displaySpan</code>, and C++ will create an appropriate <code>span</code> representing a pointer to the container’s first element and the container’s size. This makes function <code>displaySpan</code> more flexible than <code>displayArray</code>, which could receive only the built-in array in this example.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0217-02" id="f0217-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">43</span></strong>    <span class="pd_green">// compiler knows values' size and automatically creates a span</span>&#13;
<strong><span class="cviolet">44</span></strong>    <span class="pd_green">// representing &amp;values1[0] and the array's length</span>&#13;
<strong><span class="cviolet">45</span></strong>    cout &lt;&lt; <span class="green">"\nvalues1 via displaySpan: "</span>;&#13;
<strong><span class="cviolet">46</span></strong>    displaySpan(values1);&#13;
<strong><span class="cviolet">47</span></strong>&#13;
<strong><span class="cviolet">48</span></strong>    <span class="pd_green">// compiler also can create spans from std::arrays and std::vectors</span>&#13;
<strong><span class="cviolet">49</span></strong>    cout &lt;&lt; <span class="green">"\nvalues2 via displaySpan: "</span>;&#13;
<strong><span class="cviolet">50</span></strong>    displaySpan(values2);&#13;
<strong><span class="cviolet">51</span></strong>    cout &lt;&lt; <span class="green">"\nvalues3 via displaySpan: "</span>;&#13;
<strong><span class="cviolet">52</span></strong>    displaySpan(values3);&#13;
<strong><span class="cviolet">53</span></strong></pre>&#13;
<pre class="pre1">values1   via   displayArray: 1 2 3 4 5&#13;
values1   via   displaySpan: 1 2 3 4 5&#13;
values2   via   displaySpan: 6 7 8 9 10&#13;
values3   via   displaySpan: 11 12 13 14 15</pre>&#13;
<h5 class="h5" id="ch07lev3sec19">Changing a <code>span</code>’s Elements Modifies the Original Data</h5>&#13;
<p>As we mentioned, function <code>times2</code> multiplies its <code>span</code>’s elements by 2. Line 55 calls <code>times2</code> with <code>values1</code> as an argument. The function’s parameter was declared as</p>&#13;
<pre class="pre">span&lt;<span class="blue">int</span>&gt;</pre>&#13;
<p>so C++ creates a <code>span</code> containing an <code>int*</code> that points to the array’s first element and the array’s size, which the compiler gets from the declaration of <code>values1</code> (line 34). To prove that <code>times2</code> modified the original array’s data, line 57 displays <code>values1</code>’s updated values. Like <code>displaySpan</code>, <code>times2</code> can be called with this program’s <code>std::array</code> or <code>std::vector</code> as well.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0218-01" id="f0218-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">54</span></strong>     <span class="pd_green">// changing a span's contents modifies the original data</span>&#13;
<strong><span class="cviolet">55</span></strong>     times2(values1);&#13;
<strong><span class="cviolet">56</span></strong>     cout &lt;&lt; <span class="green">"\n\nvalues1 after times2 modifies its span argument: "</span>;&#13;
<strong><span class="cviolet">57</span></strong>     displaySpan(values1);&#13;
<strong><span class="cviolet">58</span></strong></pre>&#13;
<pre class="pre1">values1 after times2 modifies its span argument: 2 4 6 8 10</pre>&#13;
<h5 class="h5" id="ch07lev3sec20">Manually Creating a Span and Interacting with It</h5>&#13;
<p>You can explicitly create <code>span</code>s and interact with them. Line 60 creates a <code>span&lt;int&gt;</code> that views the data in <code>values1</code>. Lines 61–62 demonstrate the span’s <code><span class="violet"><strong>front</strong></span></code> and <code><span class="violet"><strong>back</strong></span></code> member functions, which return the first and last element of the view, and thus, the first and last element of the built-in array <code>values1</code>, respectively.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0218-02" id="f0218-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">59</span></strong>     <span class="pd_green">// spans have various array-and-vector-like capabilities</span>&#13;
<strong><span class="cviolet">60</span></strong>     <span class="yell">span&lt;<span class="blue">int</span>&gt; mySpan{values1};</span>&#13;
<strong><span class="cviolet">61</span></strong>     cout &lt;&lt; <span class="green">"\n\nmySpan's first element: "</span> &lt;&lt; <span class="yell">mySpan.front()</span>&#13;
<strong><span class="cviolet">62</span></strong>        &lt;&lt; <span class="green">"\nmySpan's last element: "</span> &lt;&lt; <span class="yell">mySpan.back();</span>&#13;
<strong><span class="cviolet">63</span></strong></pre>&#13;
<pre class="pre1">mySpan's first element: 2&#13;
mySpan's last element: 10</pre>&#13;
<p><span class="size">CG</span> <strong>An essential philosophy of the C++ Core Guidelines is to “prefer compile-time checking to runtime checking.”</strong><sup><a id="rch07fn21" href="ch07.xhtml#ch07fn21">21</a></sup> This enables the compiler to find and report errors at compile-time, rather than you having to write code to help prevent runtime errors. In line 60, the compiler determines the <code>span</code>’s size (<code>5</code>) from the <code>values1</code> declaration in line 34. You can state the <code>span</code>’s size, as in</p>&#13;
<p class="footnote"><a id="ch07fn21" href="ch07.xhtml#rch07fn21">21</a>. C++ Core Guidelines. Accessed June 14, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-compile-time">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-compile-time</a></code>.</p>&#13;
<pre class="pre">span&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; mySpan{values1};</pre>&#13;
<p>In this case, the compiler ensures that the <code>span</code>’s declared size matches <code>values1</code>’s size; otherwise, a compilation error occurs.</p>&#13;
<h5 class="h5" id="ch07lev3sec21">Using a <code>span</code> with the Standard Library’s <code>accumulate</code> Algorithm</h5>&#13;
<p>As you’ve seen in this example, <code>span</code>s are iterable. This means you also can use the <code>begin</code> and <code>end</code> functions with <code>span</code>s to pass them to C++ standard library algorithms, such as <code>accumulate</code> (line 66) or <code>sort</code>. We cover standard library algorithms in depth in <a href="ch18.xhtml#ch18">Chapter 18</a>.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0219-01" id="f0219-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">64</span></strong>    <span class="pd_green">// spans can be used with standard library algorithms</span>&#13;
<strong><span class="cviolet">65</span></strong>    cout &lt;&lt; <span class="green">"\n\nSum of mySpan's elements: "</span>&#13;
<strong><span class="cviolet">66</span></strong>       &lt;&lt; <span class="yell">accumulate(begin(mySpan), end(mySpan), <span class="green">0</span>)</span>;&#13;
<strong><span class="cviolet">67</span></strong></pre>&#13;
<pre class="pre1">Sum of mySpan's elements: 30</pre>&#13;
<h5 class="h5" id="ch07lev3sec22">Creating Subviews</h5>&#13;
<p>Sometimes, you might want to process subsets of the data a <code>span</code> views. A <code>span</code>’s <code>first</code>, <code>last</code> and <code>subspan</code> member functions create subviews, which are themselves views. Lines 70 and 72 use <code><span class="violet"><strong>first</strong></span></code> and <code><span class="violet"><strong>last</strong></span></code> to get <code>span</code>s representing the first three and last three elements of <code>values1</code>, respectively. Line 74 uses <code><span class="violet"><strong>subspan</strong></span></code> to get a <code>span</code> that views the <code>3</code> elements starting from index <code>1</code>. In each case, we pass the subview’s <code>span</code> to <code>displaySpan</code> to confirm what the span represents.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0219-02" id="f0219-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">68</span></strong>    <span class="pd_green">// spans can be used to create subviews of a container</span>&#13;
<strong><span class="cviolet">69</span></strong>    cout &lt;&lt; <span class="green">"\n\nFirst three elements of mySpan: "</span>;&#13;
<strong><span class="cviolet">70</span></strong>    displaySpan(<span class="yell">mySpan.first(<span class="green">3</span>)</span>);&#13;
<strong><span class="cviolet">71</span></strong>    cout &lt;&lt; <span class="green">"\nLast three elements of mySpan: "</span>;&#13;
<strong><span class="cviolet">72</span></strong>    displaySpan(<span class="yell">mySpan.last(<span class="green">3</span>)</span>);&#13;
<strong><span class="cviolet">73</span></strong>    cout &lt;&lt; <span class="green">"\nMiddle three elements of mySpan: "</span>;&#13;
<strong><span class="cviolet">74</span></strong>    displaySpan(<span class="yell">mySpan.subspan(<span class="green">1</span>, <span class="green">3</span>)</span>);&#13;
<strong><span class="cviolet">75</span></strong></pre>&#13;
<pre class="pre1">First three elements of mySpan: 2 4 6&#13;
Last three elements of mySpan: 6 8 10&#13;
Middle three elements of mySpan: 4 6 8</pre>&#13;
<h5 class="h5" id="ch07lev3sec23">Changing a Subview’s Elements Modifies the Original Data</h5>&#13;
<p>A subview of non-<code>const</code> data can modify that data. Line 77 passes to function <code>times2</code> a <code>span</code> that views the <code>3</code> elements starting from index <code>1</code> of <code>values1</code>. Line 79 displays the updated <code>values1</code> elements to confirm the results.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0219-03" id="f0219-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">76</span></strong>    <span class="pd_green">// changing a subview's contents modifies the original data</span>&#13;
<strong><span class="cviolet">77</span></strong>    times2(<span class="yell">mySpan.subspan(<span class="green">1</span>, <span class="green">3</span>)</span>);&#13;
<strong><span class="cviolet">78</span></strong>    cout &lt;&lt; <span class="green">"\n\nvalues1 after modifying middle three elements via span: "</span>;&#13;
<strong><span class="cviolet">79</span></strong>    displaySpan(values1);&#13;
<strong><span class="cviolet">80</span></strong></pre>&#13;
<pre class="pre1">values1 after modifying middle three elements via span: 2 8 12 16 10</pre>&#13;
<h5 class="h5" id="ch07lev3sec24">Accessing a View’s Elements Via the <code>[]</code> Operator</h5>&#13;
<p>Like built-in arrays, <code>std::array</code>s and <code>std::vector</code>s, you can access and modify span elements via the <code>[]</code> operator. Line 82 displays the element at index <code>2</code>. Line 85 attempts to access an element that does not exist. On the Microsoft Visual C++ compiler, this results in an exception that displays the message,<sup><a id="rch07fn22" href="ch07.xhtml#ch07fn22">22</a></sup> <code>"Expression: span index out of range"</code>.</p>&#13;
<p class="footnote"><a id="ch07fn22" href="ch07.xhtml#rch07fn22">22</a>. At the time of this writing, the draft C++20 standard document makes no mention of the <code>[]</code> operator throwing an exception. Neither GNU C++ nor the Apple Clang C++ throw exceptions on line 85. They simply display whatever is in that memory location.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0220-01" id="f0220-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">81</span></strong>     <span class="pd_green">// access a span element via []</span>&#13;
<strong><span class="cviolet">82</span></strong>     cout &lt;&lt; <span class="green">"\n\nThe element at index 2 is: "</span> &lt;&lt; mySpan[<span class="green">2</span>];&#13;
<strong><span class="cviolet">83</span></strong>&#13;
<strong><span class="cviolet">84</span></strong>     <span class="pd_green">// attempt to access an element outside the bounds</span>&#13;
<strong><span class="cviolet">85</span></strong>     cout &lt;&lt; <span class="green">"\n\nThe element at index 10 is: "</span> &lt;&lt; mySpan[<span class="green">10</span>] &lt;&lt; endl;&#13;
<strong><span class="cviolet">86</span></strong> }</pre>&#13;
<pre class="pre1">The element at index 2 is: 12</pre>&#13;
<h3 class="h3" id="ch07lev1sec11"><span class="violet">7.11</span> A Brief Intro to Pointer-Based Strings</h3>&#13;
<p>We’ve already used the C++ Standard Library <code>string</code> class to represent strings as full-fledged objects. <a href="ch08.xhtml#ch08">Chapter 8</a> presents class <code>std::string</code> in detail. This section introduces C-style, pointer-based strings (as defined by the C programming language). Here. we’ll refer to these as <span class="violet"><strong>C-strings</strong></span> or strings and use <code>std::string</code> when referring to the C++ standard library’s <code>string</code> class.</p>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> <code>std::string</code> is preferred because it eliminates many of the security problems and bugs that can be caused by manipulating C-strings. However, there are some cases in which C-strings are required, such as reading in command-line arguments. Also, if you work with legacy C and C++ programs, you’re likely to encounter pointer-based strings. We cover C-strings in detail in Appendix F.</p>&#13;
<h5 class="h5" id="ch07lev3sec25">Characters and Character Constants</h5>&#13;
<p>Characters are the fundamental building blocks of C++ source programs. Every program is composed of characters that—when grouped meaningfully—are interpreted by the compiler as instructions and data used to accomplish a task. A program may contain <span class="violet"><strong>character constants</strong></span>, each of which is an integer value represented as a character in single quotes. The value of a character constant is the integer value of the character in the machine’s character set. For example, <code>'z'</code> represents the integer value of <code>z</code> (122 in the ASCII character set; see Appendix B), and <code>'\n'</code> represents the integer value of newline (10 in the ASCII character set).</p>&#13;
<h5 class="h5" id="ch07lev3sec26">Pointer-Based Strings</h5>&#13;
<p>A C-string (also called a pointer-based string) is a built-in array of characters ending with a <span class="violet"><strong>null character</strong></span> <span class="violet"><strong>(</strong></span><code><span class="violet"><strong>'\0'</strong></span></code><span class="violet"><strong>)</strong></span>, which marks where the string terminates in memory. A C-string is accessed via a pointer to its first character (no matter how long the string is). The result of <code>sizeof</code> for a string literal (which is a C-string) is the length of the string, including the terminating null character.</p>&#13;
<h5 class="h5" id="ch07lev3sec27">String Literals as Initializers</h5>&#13;
<p>A string literal may be used as an initializer in the declaration of either a built-in array of <code>char</code>s or a variable of type <code>const char*</code>. The declarations</p>&#13;
<pre class="pre"><span class="blue">char</span> color[]{<span class="green">"blue"</span>};&#13;
<span class="blue">const char</span>* colorPtr{<span class="green">"blue"</span>};</pre>&#13;
<p>each initialize a variable to the string <code>"blue"</code>. The first declaration creates a five-element built-in array <code>color</code> containing the characters <code>'b'</code>, <code>'l'</code>, <code>'u'</code>, <code>'e'</code> and <code>'\0'</code>. The second declaration creates pointer variable <code>colorPtr</code> that points to the letter <code>b</code> in the string <code>"blue"</code> (which ends in <code>'\0'</code>) somewhere in memory. The first declaration above also may be implemented using an initializer list of individual characters, as in:</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0221-01" id="f0221-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">char</span> color[]{<span class="green">'b'</span>, <span class="green">'l'</span>, <span class="green">'u'</span>, <span class="green">'e'</span>, <span class="green">'\0'</span>};</pre>&#13;
<p>String literals exist for the duration of the program. They may be shared if the same string literal is referenced from multiple locations in a program. String literals are immutable—they cannot be modified.</p>&#13;
<h5 class="h5" id="ch07lev3sec28">Problems with C-Strings</h5>&#13;
<p>Not allocating sufficient space in a built-in array of <code>char</code>s to store the null character that terminates a string is a logic error. Creating or using a C-string that does not contain a terminating null character can lead to logic errors.</p>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> When storing a string of characters in a built-in array of <code>char</code>s, be sure that the builtin array is large enough to hold the largest string that will be stored. C++ allows strings of any length. If a string is longer than the built-in array of <code>char</code>s in which it’s to be stored, characters beyond the end of the built-in array will overwrite subsequent memory locations. This could lead to logic errors, program crashes or security breaches.</p>&#13;
<h5 class="h5" id="ch07lev3sec29">Displaying C-Strings</h5>&#13;
<p>A built-in array of <code>char</code>s representing a null-terminated string can be output with <code>cout</code> and <code>&lt;&lt;</code>. The statement</p>&#13;
<pre class="pre">cout &lt;&lt; sentence;</pre>&#13;
<p>displays the built-in array <code>sentence</code>. <code>cout</code> does not care how large the built-in array of <code>char</code>s is. The characters are output until a terminating null character is encountered; the null character is not displayed. <code>cin</code> and <code>cout</code> assume that built-in arrays of <code>char</code>s should be processed as strings terminated by null characters. <code>cin</code> and <code>cout</code> do not provide similar input and output processing capabilities for other built-in array types.</p>&#13;
<h4 class="h4" id="ch07lev2sec22">7.11.1 Command-Line Arguments</h4>&#13;
<p>There are cases in which built-in arrays and C-strings must be used, such as processing a program’s <span class="violet"><strong>command-line arguments</strong></span>, which are often passed to applications to specify configuration options, file names to process and more.</p>&#13;
<p>You supply command-line arguments to a program by placing them after the program’s name when executing it from the command line. Such arguments typically pass options to a program. For example, on a Windows system, the command</p>&#13;
<pre class="pre">dir /p</pre>&#13;
<p>uses the <code>/p</code> argument to list the contents of the current directory, pausing after each screen of information. Similarly, on Linux or macOS, the following command uses the <code>-la</code> argument to list the contents of the current directory with details about each file and directory:</p>&#13;
<pre class="pre">ls -la</pre>&#13;
<p>Command-line arguments are passed into a C++ program as C-strings, and the application name is treated as the first command line argument. To use the arguments as <code>std::string</code>s or other data types (<code>int</code>, <code>double</code>, etc.), you must convert the arguments to those types. <a href="ch07.xhtml#fig7_13">Figure 7.13</a> displays the number of command-line arguments passed to the program, then displays each argument on a separate line of output.</p>&#13;
<div class="group" id="fig7_13">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig13" id="aa07fig13">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_13.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Reading in command-line arguments.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">int</span> main(<span class="yell"><span class="blue">int</span> argc, <span class="blue">char</span>* argv[]</span>) {</code>&#13;
 <span class="cviolet"><strong>7</strong></span>       <code>cout &lt;&lt; <span class="green">"There were "</span> &lt;&lt; <span class="yell">argc</span> &lt;&lt; <span class="green">" command-line arguments:\n"</span>;</code>&#13;
 <span class="cviolet"><strong>8</strong></span>       <code><span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">0</span>}; i &lt; <span class="yell">argc</span>; ++i) {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>          <code>cout &lt;&lt; <span class="yell">argv[i]</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>11</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code><strong>fig07_13 Amanda Green 97</strong></code>&#13;
<code>There were 4 command-line arguments</code>&#13;
<code>fig07_13</code>&#13;
<code>Amanda</code>&#13;
<code>Green</code>&#13;
<code>97</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.13</strong></span> Reading in command-line arguments.</p>&#13;
</div>&#13;
<p>To receive command-line arguments, declare <code>main</code> with two parameters (line 6), which by convention are named <code>argc</code> and <code>argv</code>, respectively. The first is an <code>int</code> representing the number of arguments. The second is a <code>char*</code> built-in array. The first element of the array is a C-string for the application name. The remaining elements are C-strings for the other command-line arguments.</p>&#13;
<p>The command</p>&#13;
<pre class="pre">fig07_13 Amanda Green 97</pre>&#13;
<p>passes <code>"Amanda"</code>, <code>"Green"</code> and <code>97"</code> to the application <code>fig07_13</code> (on macOS and Linux you’d run this program with <code>"./fig07_13"</code>). Command-line arguments are separated by white space, <em>not</em> commas. When this command executes, <code>fig07_13</code>’s <code>main</code> function receives the argument count <code>4</code> and a four-element array of C-strings:</p>&#13;
<p class="bull">• <code>argv[0]</code> contains the application’s name <code>"fig07_13"</code> (or <code>"./fig07_13"</code> on macOS or Linux), and</p>&#13;
<p class="bull">• <code>argv[1]</code> through <code>argv[3]</code> contain <code>"Amanda"</code>, <code>"Green"</code> and <code>"97"</code>, respectively.</p>&#13;
<p>You determine how to use these arguments in your program.</p>&#13;
<h4 class="h4" id="ch07lev2sec23">7.11.2 Revisiting C++20’s <code>to_array</code> Function</h4>&#13;
<p><span class="size">20</span> <a href="ch07.xhtml#ch07lev1sec6">Section 7.6</a> demonstrated converting built-in arrays to <code>std::array</code>s with <code>to_array</code>. <a href="ch07.xhtml#fig7_14">Figure 7.14</a> shows another purpose of <code>to_array</code>. We use the same lambda expression (lines 9–13) as in <a href="ch07.xhtml#fig7_6">Fig. 7.6</a> to display the <code>std::array</code> contents after each <code>to_array</code> call.</p>&#13;
<div class="group" id="fig7_14">&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#a07fig14" id="aa07fig14">Click here to view code image</a></p>&#13;
<pre class="pre3"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig07_14.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// C++20: Creating std::arrays from string literals with to_array.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="pd_green">// lambda to display a collection of items</span></code>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">const auto</span> display = [](<span class="blue">const auto</span>&amp; items) {</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code><span class="blue">for</span> (<span class="blue">const auto</span>&amp; item : items) {</code>&#13;
<span class="cviolet"><strong>11</strong></span>          <code>cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;</code>&#13;
<span class="cviolet"><strong>12</strong></span>       <code>}</code>&#13;
<span class="cviolet"><strong>13</strong></span>    <code>};</code>&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 7.14</strong></span> C++20: Creating <code>std::array</code>s from string literals with <code>to_array</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch07lev3sec30">Initializing a <code>std::array</code> from a String Literal Creates a One-Element <code>array</code></h5>&#13;
<p>Function <code>to_array</code> fixes an issue with initializing a <code>std::array</code> from a string literal. Rather than creating a <code>std::array</code> of the individual characters in the string literal, line 17 creates a one-element <code>array</code> containing a <code>const char*</code> pointing to the C-string <code>"abc"</code>.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0223-01" id="f0223-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">15</span></strong>     <span class="pd_green">// initializing an array with a string literal</span>&#13;
<strong><span class="cviolet">16</span></strong>     <span class="pd_green">// creates a one-element array&lt;const char*&gt;</span>&#13;
<strong><span class="cviolet">17</span></strong>     <span class="blue">const auto</span> array1 = <span class="yell">array{<span class="green">"abc"</span>}</span>;&#13;
<strong><span class="cviolet">18</span></strong>     cout &lt;&lt; <span class="green">"\n\narray1.size() = "</span> &lt;&lt; array1.size() &lt;&lt; <span class="green">"\narray1: "</span>;&#13;
<strong><span class="cviolet">19</span></strong>     display(array1); <span class="pd_green">// use lambda to display contents</span>&#13;
<strong><span class="cviolet">20</span></strong></pre>&#13;
<pre class="pre1">array1.size() = 1&#13;
array1: abc</pre>&#13;
<h5 class="h5" id="ch07lev3sec31">Passing a String Literal to <code>to_array</code> Creates a <code>std::array</code> of <code>char</code></h5>&#13;
<p>On the other hand, passing a string literal to <code>to_array</code> (line 22) creates a <code>std::array</code> of <code>char</code>s containing elements for each character and the terminating null character. Line 23 confirms that the <code>array</code>’s size is 6. Line 24 confirms the <code>array</code>’s contents. The null character does not have a visual representation, so it does not appear in the output.</p>&#13;
<p class="codelink"><a href="Images/ch07_images.xhtml#f0223-02" id="f0223-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">21</span></strong>     <span class="pd_green">// creating std::array of characters from a string literal</span>&#13;
<strong><span class="cviolet">22</span></strong>     <span class="green">const auto</span> array2 = <span class="yell">to_array(<span class="green">"C++20"</span>)</span>;&#13;
<strong><span class="cviolet">23</span></strong>     cout &lt;&lt; <span class="green">"\n\narray2.size() = "</span> &lt;&lt; array2.size() &lt;&lt; <span class="green">"\narray2: "</span>;&#13;
<strong><span class="cviolet">24</span></strong>     display(array2); <span class="pd_green">// use lambda to display contents</span>&#13;
<strong><span class="cviolet">25</span></strong>&#13;
<strong><span class="cviolet">26</span></strong>     cout &lt;&lt; endl;&#13;
<strong><span class="cviolet">27</span></strong> }</pre>&#13;
<pre class="pre1">array2.size() = 6&#13;
array2: C + + 2 0</pre>&#13;
<h3 class="h3" id="ch07lev1sec12"><span class="violet">7.12</span> Looking Ahead to Other Pointer Topics</h3>&#13;
<p>In later chapters, we’ll introduce additional pointer topics:</p>&#13;
<p class="bull">• In <a href="ch13.xhtml#ch13">Chapter 13</a>, Object-Oriented Programming: Polymorphism, we’ll use pointers with class objects to show that the “runtime polymorphic processing” associated with object-oriented programming can be performed with references or pointers—you should favor references.</p>&#13;
<p class="bull">• In <a href="ch14.xhtml#ch14">Chapter 14</a>, Operator Overloading, we introduce dynamic memory management with pointers, which allows you at execution time to create and destroy objects as needed. Improperly managing this process is a source of subtle errors, such as “memory leaks.” We’ll show how “smart pointers” can automatically manage memory and other resources that should be returned to the operating system when they’re no longer needed.</p>&#13;
<p class="bull">• In <a href="ch18.xhtml#ch18">Chapter 18</a>, Standard Library Algorithms, we show that a function’s name is also a pointer to its implementation in memory, and that functions can be passed into other functions via function pointers—exactly as lambda expressions are.</p>&#13;
<h3 class="h3" id="ch07lev1sec13"><span class="violet">7.13</span> Wrap-Up</h3>&#13;
<p>This chapter discussed pointers, built-in pointer-based arrays and pointer-based strings (C-strings). <strong>We pointed out Modern C++ guidelines that recommend avoiding most pointers—preferring references to pointers,</strong> <code><strong>std::array</strong></code><sup><a id="rch07fn23" href="ch07.xhtml#ch07fn23">23</a></sup> <strong>and</strong> <code><strong>std::vector</strong></code> <strong>objects to built-in arrays, and</strong> <code><strong>std::string</strong></code> <strong>objects to C-strings.</strong></p>&#13;
<p class="footnote"><a id="ch07fn23" href="ch07.xhtml#rch07fn23">23</a>. We pronounce “<code>std::</code>” as “standard,” so throughout this chapter we say “a <code>std::array”</code> rather than “an <code>std::array</code>,” which assumes “<code>std::</code>” is pronounced as its individual letters <code>s</code>, <code>t</code> and <code>d</code>.</p>&#13;
<p>We declared and initialized pointers and demonstrated the pointer operators <code>&amp;</code> and <code>*</code>. We showed that pointers enable pass-by-reference, but you should generally prefer references for that purpose. We used built-in, pointer-based arrays and showed their intimate relationship with pointers.</p>&#13;
<p>We discussed various combinations of <code>const</code> with pointers and the data they point to and used the <code>sizeof</code> operator to determine the number of bytes that store values of particular fundamental types and pointers. We demonstrated pointer expressions and pointer arithmetic.</p>&#13;
<p>We briefly discussed C-strings then showed how to process command-line arguments—a simple task for which C++ still requires you to use both pointer-based C-strings and pointer-based arrays.</p>&#13;
<p><strong>As a reminder, the key takeaway from reading this chapter is that you should avoid using pointers, pointer-based arrays and pointer-based strings whenever possible. For programs that still use pointer-based arrays, you can use C++20’s</strong> <code><strong>to_array</strong></code> <strong>function to convert built-in arrays to</strong> <code><strong>std::array</strong></code><strong>s and C++20’s</strong> <code><strong>span</strong></code><strong>s as a safer way to process built-in pointer-based arrays.</strong> In the next chapter, we discuss typical string-manipulation operations provided by <code>std::string</code> and introduce file-processing capabilities.</p>&#13;
</div></body>
</html>