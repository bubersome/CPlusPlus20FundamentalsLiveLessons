<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch15">Chapter 15. Templates, C++20 Concepts and Metaprogramming</h2>&#13;
<div class="image"><img src="Images/common.jpg" alt="Images" width="370" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Appreciate the rising importance of generic programming.</p>&#13;
<p class="squ"><span class="red">■</span> Use class templates to create related custom classes.</p>&#13;
<p class="squ"><span class="red">■</span> Understand compile-time vs. runtime polymorphism.</p>&#13;
<p class="squ"><span class="red">■</span> Distinguish between templates and template specializations.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++20 abbreviated function templates and templated lambdas.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++20 concepts to constrain template parameters and to overload function templates based on their type requirements.</p>&#13;
<p class="squ"><span class="red">■</span> Use type traits and see how they relate to C++20 concepts.</p>&#13;
<p class="squ"><span class="red">■</span> Test concepts at compile-time with <code>static_assert</code>.</p>&#13;
<p class="squ"><span class="red">■</span> Create a custom concept-constrained algorithm.</p>&#13;
<p class="squ"><span class="red">■</span> Rebuild our class <code>MyArray</code> as a custom container class template with custom iterators.</p>&#13;
<p class="squ"><span class="red">■</span> Use non-type template parameters to pass compile-time constants to templates, and use default template arguments.</p>&#13;
<p class="squ"><span class="red">■</span> Use variadic templates that receive any number of parameters and apply binary operators to them via fold expressions.</p>&#13;
<p class="squ"><span class="red">■</span> Use compile-time template metaprogramming capabilities to compute values, manipulate types and generate code to improve runtime performance.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_1"><span class="violet"><strong>15.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_2"><span class="violet"><strong>15.2</strong></span> Custom Class Templates and Compile-Time Polymorphism</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_3"><span class="violet"><strong>15.3</strong></span> C++20 Function Template Enhancements</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_3_1">15.3.1 C++20 Abbreviated Function Templates</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_3_2">15.3.2 C++20 Templated Lambdas</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_4"><span class="violet"><strong>15.4</strong></span> C++20 Concepts: A First Look</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_4_1">15.4.1 Function Template <code>multiply</code></a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_4_2">15.4.2 Constrained Function Template with a C++20 Concepts <code>requires</code> Clause</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_4_3">15.4.3 C++20 Predefined Concepts</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_5"><span class="violet"><strong>15.5</strong></span> Type Traits</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_6"><span class="violet"><strong>15.6</strong></span> C++20 Concepts: A Deeper Look</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_6_1">15.6.1 Creating a Custom Concept</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_6_2">15.6.2 Using a Concept</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_6_3">15.6.3 Using Concepts in Abbreviated Function Templates</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_6_4">15.6.4 Concept-Based Overloading</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_6_5">15.6.5  <code>requires</code> Expressions</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_6_6">15.6.6 C++20 Exposition-Only Concepts</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_6_7">15.6.7 Techniques Before C++20 Concepts: SFINAE and Tag Dispatch</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_7"><span class="violet"><strong>15.7</strong></span> Testing C++20 Concepts with <code>static_assert</code></a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_8"><span class="violet"><strong>15.8</strong></span> Creating a Custom Algorithm</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_9"><span class="violet"><strong>15.9</strong></span> Creating a Custom Container and Iterators</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_9_1">15.9.1 Class Template <code>ConstIterator</code></a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_9_2">15.9.2 Class Template <code>Iterator</code></a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_9_3">15.9.3 Class Template <code>MyArray</code></a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_9_4">15.9.4 MyArray Deduction Guide for Braced Initialization</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_9_5">15.9.5 Using <code>MyArray</code> and Its Custom Iterators with <code>std::ranges</code> Algorithms</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_10"><span class="violet"><strong>15.10</strong></span> Default Arguments for Template Type Parameters</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_11"><span class="violet"><strong>15.11</strong></span> Variable Templates</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_12"><span class="violet"><strong>15.12</strong></span> Variadic Templates and Fold Expressions</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_12_1">15.12.1  <code>tuple</code> Variadic Class Template</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_12_2">15.12.2 Variadic Function Templates and an Intro to C++17 Fold Expressions</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_12_3">15.12.3 Types of Fold Expressions</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_12_4">15.12.4 How Unary Fold Expressions Apply Their Operators</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_12_5">15.12.5 How Binary-Fold Expressions Apply Their Operators</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_12_6">15.12.6 Using the Comma Operator to Repeatedly Perform an Operation</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_12_7">15.12.7 Constraining Parameter Pack Elements to the Same Type</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_13"><span class="violet"><strong>15.13</strong></span> Template Metaprogramming</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_13_1">15.13.1 C++ Templates Are Turing Complete</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_13_2">15.13.2 Computing Values at Compile Time</a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_13_3">15.13.3 Conditional Compilation with Template Metaprogramming and <code>constexpr if</code></a></p>&#13;
<p class="chap-lev2"><a href="ch15.xhtml#sec15_13_4">15.13.4 Type Metafunctions</a></p>&#13;
<p class="chap-lev1"><a href="ch15.xhtml#sec15_14"><span class="violet"><strong>15.14</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="sec15_1"><span class="violet">15.1</span> Introduction</h3>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> Generic programming with templates has been in C++ since the 1998 C++ standard was released,<sup><a id="ch15fn1a" href="ch15.xhtml#ch15fn1">1</a></sup> and has risen in importance with each new C++ release. A modern C++ theme is to do more at compile time for better type-checking and better runtime performance.<sup><a id="ch15fn2a" href="ch15.xhtml#ch15fn2">2</a>,<a id="ch15fn3a" href="ch15.xhtml#ch15fn3">3</a>,<a id="ch15fn4a" href="ch15.xhtml#ch15fn4">4</a></sup> You’ve already used templates extensively. As you’ll see, templates and especially template metaprogramming are the keys to powerful compile-time operations. In this chapter, we’ll take a deeper look templates, as we explain how to develop custom class templates, explore concepts—C++20’s most significant new feature—and introduce template metaprogramming. The following table summarizes the book’s templates coverage across all 19 chapters.</p>&#13;
<p class="footnote"><a id="ch15fn1" href="ch15.xhtml#ch15fn1a">1</a>. “History of C++.” Accessed June 24, 2021. <code><a href="https://www.cplusplus.com/info/history/">https://www.cplusplus.com/info/history/</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn2" href="ch15.xhtml#ch15fn2a">2</a>. “C++ Core Guidelines—Per: Performance.” Accessed February 8, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-performance">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-performance</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn3" href="ch15.xhtml#ch15fn3a">3</a>. “Big Picture Issues—What’s the big deal with generic programming?” Accessed February 8, 2021. <code><a href="https://isocpp.org/wiki/faq/big-picture#generic-paradigm">https://isocpp.org/wiki/faq/big-picture#generic-paradigm</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn4" href="ch15.xhtml#ch15fn4a">4</a>. “Compile time vs run time polymorphism in C++ advantages/disadvantages.” Accessed January 31, 2021. <code><a href="https://stackoverflow.com/questions/16875989/compile-time-vs-run-time-polymorphism-in-c-advantages-disadvantages">https://stackoverflow.com/questions/16875989/compile-time-vs-run-time-polymorphism-in-c-advantages-disadvantages</a></code>.</p>&#13;
<div class="image"><img src="Images/829tab01.jpg" alt="Images" width="803" height="989"/></div>&#13;
<h5 class="h5" id="ch15lev3sec1">Custom Templates</h5>&#13;
<p><a href="ch05.xhtml#ch05lev1sec17">Section 5.17</a> showed that the compiler uses function templates to generate overloaded functions. The generated functions are called <strong><span class="violet">function-template specializations</span></strong>. Similarly, the compiler uses class templates to generate related classes called <strong><span class="violet">class-template specializations</span></strong>. Specializing templates enables <strong><span class="violet">compile-time (static) polymorphism</span></strong>. In this chapter, you’ll create custom class templates and study key template-related technologies.</p>&#13;
<h5 class="h5" id="ch15lev3sec2">C++20 Template Features</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> We discuss C++20’s new template capabilities, including <strong>abbreviated function templates</strong>, <strong>templated lambdas</strong> and <strong>concepts</strong>—a C++20 “big four” feature that makes generic programming with templates even more convenient and powerful. When invoking C++20’s <strong>range-based algorithms</strong>, you saw that you must pass container or iterator arguments that meet the algorithms’ requirements. This chapter takes a template developer’s viewpoint as we develop custom templates that <strong>specify their requirements</strong> using predefined and custom C++20 concepts.<sup><a id="ch15fn5a" href="ch15.xhtml#ch15fn5">5</a>,<a id="ch15fn6a" href="ch15.xhtml#ch15fn6">6</a>,<a id="ch15fn7a" href="ch15.xhtml#ch15fn7">7</a>,<a id="ch15fn8a" href="ch15.xhtml#ch15fn8">8</a></sup> The compiler checks concepts <em>before</em> specializing templates, often resulting in fewer, clearer and more-precise error messages.</p>&#13;
<p class="footnote"><a id="ch15fn5" href="ch15.xhtml#ch15fn5a">5</a>. Marius Bancila. “Concepts versus SFINAE-based constraints.” Accessed February 4, 2021. <code><a href="https://mariusbancila.ro/blog/2019/10/04/concepts-versus-sfinae-based-constraints/">https://mariusbancila.ro/blog/2019/10/04/concepts-versus-sfinae-based-constraints/</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn6" href="ch15.xhtml#ch15fn6a">6</a>. Saar Raz. “C++20 Concepts: A Day in the Life,” YouTube video, October 17, 2019, <code><a href="https://www.youtube.com/watch?v=qawSiMIXtE4">https://www.youtube.com/watch?v=qawSiMIXtE4</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn7" href="ch15.xhtml#ch15fn7a">7</a>. “Constraints and concepts.” Accessed February 4, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/constraints">https://en.cppreference.com/w/cpp/language/constraints</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn8" href="ch15.xhtml#ch15fn8a">8</a>. “Concepts library.” Accessed February 4, 2021. <code><a href="https://en.cppreference.com/w/cpp/concepts">https://en.cppreference.com/w/cpp/concepts</a></code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec3">Type Traits</h5>&#13;
<p>We’ll introduce <strong>type traits</strong> for testing attributes of built-in and custom class types at compile time. You’ll see that many C++20 concepts are implemented in terms of type traits. Concepts simplify using type traits to constrain template parameters.</p>&#13;
<h5 class="h5" id="ch15lev3sec4">Building Custom Containers, Iterators and Algorithms</h5>&#13;
<p><a href="ch11.xhtml#ch11">Chapter 11</a>’s <code>MyArray</code> class stored only <code>int</code> values. We’ll create a <code>MyArray</code> class template that can be specialized to store elements of various types (e.g., <code>MyArray</code> of <code>float</code> or <code>MyArray</code> of <code>Employee</code>). We’ll make <code>MyArray</code> objects compatible with many standard library algorithms by defining <strong>custom iterators</strong>. We’ll also define a <strong>custom algorithm</strong> that can process elements of <code>MyArray</code>s and standard library container class objects.</p>&#13;
<h5 class="h5" id="ch15lev3sec5">Variadic Templates and Fold Expressions</h5>&#13;
<p><span class="size">17</span> We’ll build a <strong>variadic function template</strong> that receives one or more parameters. We’ll also introduce <strong>C++17 fold expressions</strong>, which enable you to conveniently apply an operation to all the items passed to a variadic template.</p>&#13;
<h5 class="h5" id="ch15lev3sec6">Template Metaprogramming</h5>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> The C++ Core Guidelines define template metaprogramming (TMP) as <strong>“creating programs that write code at compile time.”</strong><sup><a id="ch15fn9a" href="ch15.xhtml#ch15fn9">9</a></sup> The compiler also can use them to perform <strong>compile-time calculations</strong> and <strong>type manipulations</strong>. Compile-time calculations enable you to improve a program’s execution-time performance, possibly reducing execution time and memory consumption. You’ll see that <strong>type traits</strong> are used extensively in template metaprogramming for generating code based on template-argument attributes. We’ll also write a function template that generates different code at compile-time, based on whether its container argument supports <strong>random-access iterators</strong> or <strong>lesser iterators</strong>. You’ll see how this enables us to <strong>optimize the program’s runtime performance</strong>.</p>&#13;
<p class="footnote"><a id="ch15fn9" href="ch15.xhtml#ch15fn9a">9</a>. “C++ Core Guidelines—T: Templates and generic programming.” Accessed June 24, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-templates">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-templates</a></code>.</p>&#13;
<p><span class="size">20</span> <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> Before C++20, many C++ programmers viewed template metaprogramming as too complex to use. C++20 concepts make aspects of it friendlier and more accessible. Google’s C++ Style Guide nevertheless says to “avoid complicated template programming.”<sup><a id="ch15fn10a" href="ch15.xhtml#ch15fn10">10</a></sup> Similarly, the C++ Core Guidelines indicate that you should “use template metaprogramming only when you really need to” and that it’s “hard to get right, ... and is often hard to maintain.”<sup><a id="ch15fn11a" href="ch15.xhtml#ch15fn11">11</a></sup> These guidelines could be updated when developers gain more experience using C++20 concepts and enhancements possibly coming in C++23.</p>&#13;
<p class="footnote"><a id="ch15fn10" href="ch15.xhtml#ch15fn10a">10</a>. “Google C++ Style Guide—Template Metaprogramming.” Accessed June 27, 2021. <code><a href="https://google.github.io/styleguide/cppguide.html#Template_metaprogramming">https://google.github.io/styleguide/cppguide.html#Template_metaprogramming</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn11" href="ch15.xhtml#ch15fn11a">11</a>. “T.120: Use template metaprogramming only when you really need to.” Accessed June 27, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-metameta">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-metameta</a></code>.</p>&#13;
<h3 class="h3" id="sec15_2"><span class="violet">15.2</span> Custom Class Templates and Compile-Time Polymorphism</h3>&#13;
<p>A template enables <strong>compile-time polymorphism</strong> (also called <strong>static polymorphism</strong>)<sup><a id="ch15fn12a" href="ch15.xhtml#ch15fn12">12</a>,<a id="ch15fn13a" href="ch15.xhtml#ch15fn13">13</a></sup> by specifying capabilities generically, then letting the compiler specialize the template, generating type-specific code versions on demand.</p>&#13;
<p class="footnote"><a id="ch15fn12" href="ch15.xhtml#ch15fn12a">12</a>. “C++ — Static Polymorphism.” Accessed January 31, 2021. <code><a href="https://en.wikipedia.org/wiki/C%2B%2B#Static_polymorphism">https://en.wikipedia.org/wiki/C%2B%2B#Static_polymorphism</a></code>.</p>&#13;
<p>Class templates are called <strong><span class="violet">parameterized types</span></strong> because they require one or more <strong>type parameters</strong> to tell the compiler how to customize a generic class template to form a <strong>class-template specialization</strong> from which objects can be instantiated. You write one class-template definition. <strong>When you need particular specializations, you use concise, simple notations, and the compiler writes only those specializations for you.</strong> One <code>Stack</code> class template, for example, could become the basis for creating many <code>Stack</code> class-template specializations, such as “<code>Stack</code> of <code>double</code>s,” “<code>Stack</code> of <code>int</code>s,” “<code>Stack</code> of <code>Employee</code>s,” “<code>Stack</code> of <code>Bill</code>s,” or “<code>Stack</code> of <code>ActivationRecord</code>s.”</p>&#13;
<p>To use a type with a template, the type must meet the template’s requirements. For example, a template might require objects of a specified type to</p>&#13;
<p class="bull">• be <strong>initializable with a default constructor</strong>,</p>&#13;
<p class="bull">• be <strong>copyable</strong> or <strong>movable</strong>,</p>&#13;
<p class="bull">• be <strong>comparable with operator <code>&lt;</code></strong> to determine their sort order,</p>&#13;
<p class="bull">• have <strong>specific member functions</strong>, and more.</p>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <strong>Compilation errors occur when you specialize a template with a type that does not meet the template’s requirements</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec7">Creating Class Template <code>Stack&lt;T&gt;</code></h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Let’s jump into coding a custom <code>Stack</code> class template. It’s possible to understand the notion of a stack <strong>independently of the kinds of items you place onto or remove from it—</strong> stacks are simply <strong>last-in, first-out (LIFO) data structures</strong>. <strong>Class templates encourage software reusability by enabling the compiler to instantiate many type-specific class-template specializations from a single class template</strong>—as you saw with the <strong><code>stack</code> container adapter</strong> in <a href="ch13.xhtml#sec13_10_1">Section 13.10.1</a>. Here (<a href="ch15.xhtml#fig15_1">Fig. 15.1</a>), we define a stack generically then instantiate and use type-specific stacks (<a href="ch15.xhtml#fig15_2">Fig. 15.2</a>). <a href="ch15.xhtml#fig15_1">Fig. 15.1</a>’s <code>Stack</code> class-template definition looks like a conventional class definition, with a few key differences.</p>&#13;
<p class="footnote"><a id="ch15fn13" href="ch15.xhtml#ch15fn13a">13</a>. Bondarenko, Kateryna. “Static Polymorphism in C++.” May 6, 2019. Accessed January 31, 2021. <code><a href="https://medium.com/@kateolenya/static-polymorphism-in-c-9e1ae27a945b">https://medium.com/@kateolenya/static-polymorphism-in-c-9e1ae27a945b</a></code>.</p>&#13;
<div class="group" id="fig15_1">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro01" id="p15pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 15.1: Stack.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Stack class template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;deque&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">templat</span>e<span class="blue">&lt;typename</span> T&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">class</span> Stack {&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// return the top element of the Stack</span>&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">const</span> T&amp; top() {&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="blue">return</span> stack.front();&#13;
<span class="cviolet"><strong>12</strong></span>      }&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="lgreen">// push an element onto the Stack</span>&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="blue">void</span> push(<span class="blue">const</span> T&amp; pushValue) {&#13;
<span class="cviolet"><strong>16</strong></span>         stack.push_front(pushValue);&#13;
<span class="cviolet"><strong>17</strong></span>      }&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="lgreen">// pop an element from the stack</span>&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">void</span> pop() {&#13;
<span class="cviolet"><strong>21</strong></span>         stack.pop_front();&#13;
<span class="cviolet"><strong>22</strong></span>      }&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="lgreen">// determine whether Stack is empty</span>&#13;
<span class="cviolet"><strong>25</strong></span>      <span class="blue">bool</span> isEmpty() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>26</strong></span>         <span class="blue">return</span> stack.empty();&#13;
<span class="cviolet"><strong>27</strong></span>      }&#13;
<span class="cviolet"><strong>28</strong></span>&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="lgreen">// return size of Stack</span>&#13;
<span class="cviolet"><strong>30</strong></span>      size_t size() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>31</strong></span>         <span class="blue">return</span> stack.size();&#13;
<span class="cviolet"><strong>32</strong></span>      }&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>35</strong></span>      std::deque&lt;T&gt; stack{}; <span class="lgreen">// internal representation of the Stack</span>&#13;
<span class="cviolet"><strong>36</strong></span>   }; <span class="lgreen"/></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.1</strong></span> | <code>Stack</code> class template.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec8"><code>template</code> Header</h5>&#13;
<p>The first key difference is the <span class="violet"><strong><code>template</code></strong></span><strong><span class="violet"> header</span></strong> (line 6):</p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;<span class="blue">typename</span> T&gt;</pre>&#13;
<p>which begins with the <span class="violet"><strong><code>template</code></strong></span> keyword, followed by a comma-separated list of <strong><span class="violet">template parameters</span></strong> enclosed in <strong><span class="violet">angle brackets</span></strong> (&lt; and &gt;). Each template parameter that represents a type must be preceded by one of the interchangeable keywords <span class="violet"><strong><code>typename</code></strong></span> or <code>class</code>. Some programmers prefer <code>typename</code> because a template’s <strong>type arguments</strong> might not be class types.<sup><a id="ch15fn14a" href="ch15.xhtml#ch15fn14">14</a></sup> The <strong>type parameter</strong> <code>T</code> acts as a <strong>placeholder</strong> for the <strong><code>Stack</code>’s element type</strong>. Type parameter names can be any valid identifier but must be unique inside a template definition. The element type <code>T</code> is mentioned throughout the <code>Stack</code> class template wherever we need access to the <code>Stack</code>’s element type:</p>&#13;
<p class="footnote"><a id="ch15fn14" href="ch15.xhtml#ch15fn14a">14</a>. Scott Meyers, “Item 42: Understand the Meanings of <code>typename</code>,” <em>Effective C++, Third Edition</em>. Pearson Education, Inc., 2005.</p>&#13;
<p class="bull">• declaring a member function return type (line 10),</p>&#13;
<p class="bull">• declaring a member function parameter (line 15), and</p>&#13;
<p class="bull">• declaring a variable (line 35).</p>&#13;
<p>The compiler associates the <strong>type parameter</strong> with a <strong>type argument</strong> when you specialize the class template. At that point, the compiler generates a copy of the class template in which all occurrences of the <strong>type parameter</strong> are replaced with the specified type. <strong>Compilers generate definitions only for the portions of a template used in your code.</strong><sup><a id="ch15fn15a" href="ch15.xhtml#ch15fn15">15</a></sup>,<sup><a id="ch15fn16a" href="ch15.xhtml#ch15fn16">16</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn15" href="ch15.xhtml#ch15fn15a">15</a>. Andreas Fertig, “Back to Basics: Templates (Part 1 of 2),” September 25, 2020. Accessed June 14, 2020. <code><a href="https://www.youtube.com/watch?v=VNJ4wiuxJM4">https://www.youtube.com/watch?v=VNJ4wiuxJM4</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn16" href="ch15.xhtml#ch15fn16a">16</a>. “13.9.2 Implicit instantiation [temp.inst].” Accessed June 20, 2021. <code><a href="https://eel.is/c++draft/temp.inst#4">https://eel.is/c++draft/temp.inst#4</a></code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Another key difference between class template <code>Stack</code> and other classes we’ve defined is that <strong>we did not separate the class template’s interface from its implementation</strong>. You define templates in headers, then <strong><code>#include</code></strong> them in client-code files. <strong>The compiler needs the full template definition each time the template is specialized with new type arguments, so it can generate the appropriate code.</strong> For class templates, this means that the member functions also are defined in the header—typically inside the class definition’s body, as in <a href="ch15.xhtml#fig15_1">Fig. 15.1</a>.</p>&#13;
<h5 class="h5" id="ch15lev3sec9">Class Template <code>Stack&lt;T&gt;</code>’s Data Representation</h5>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <a href="ch13.xhtml#sec13_10_1">Section 13.10.1</a> showed that the standard library’s <strong><code>stack</code> adapter class</strong> can use various containers to store its elements. A <strong><code>stack</code></strong> requires insertions and deletions only at its <strong>top</strong>, so a <strong><code>vector</code></strong> or a <strong><code>deque</code></strong> could be used to store the <strong><code>stack</code></strong>’s elements. A <strong><code>vector</code></strong> supports fast insertions and deletions at its <em>back</em>. A <strong><code>deque</code></strong> supports fast insertions and deletions at its <em>front</em> and its <em>back</em>. A <strong><code>deque</code></strong> is the default representation for the standard library’s <strong><code>stack</code> adapter</strong><sup><a id="ch15fn17a" href="ch15.xhtml#ch15fn17">17</a></sup> because a <strong><code>deque</code> grows more efficiently than a <code>vector</code></strong>:</p>&#13;
<p class="footnote"><a id="ch15fn17" href="ch15.xhtml#ch15fn17a">17</a>. “<code>std::stack</code>.” Accessed May 14, 2021. <code><a href="https://en.cppreference.com/w/cpp/container/stack">https://en.cppreference.com/w/cpp/container/stack</a></code>.</p>&#13;
<p class="bull">• A <strong><code>vector</code></strong>’s elements are stored in a <strong>contiguous block of memory</strong>. When that block is full and you add a new element, the <strong><code>vector</code></strong> performs the expensive operation of allocating a larger <strong>contiguous block of memory</strong> and <strong>copying</strong> the old elements into that new block.</p>&#13;
<p class="bull">• A <strong><code>deque</code></strong>, on the other hand, is typically implemented as a <strong>list of fixed-size, builtin arrays</strong>—with new ones added as necessary. <strong>No existing elements are copied when new items are added to a <code>deque</code>’s front or back</strong>.</p>&#13;
<p>For these reasons, we use a <strong><code>deque</code></strong> (line 35) as our <code>Stack</code> class’s underlying container.</p>&#13;
<h5 class="h5" id="ch15lev3sec10">Class Template <code>Stack&lt;T&gt;</code>’s Member Function Templates</h5>&#13;
<p>A class template’s member-function definitions are function templates. When you define them within the class template’s body, you do <strong>not precede them with a <code>template</code> header</strong>. However, they do use the <strong>template parameter <code>T</code></strong> to represent the element type. Our <code>Stack</code> class template does not define its own constructors—the class’s default constructor invokes the <strong><code>deque</code> data member’s default constructor</strong>.</p>&#13;
<p>Our <code>Stack</code> class (<a href="ch15.xhtml#fig15_1">Fig. 15.1</a>) provides the following member functions:</p>&#13;
<p class="bull">• <strong><code>top</code></strong> (lines 10–12) returns a <code>const</code> reference to the <code>Stack</code>’s <strong>top</strong> element—it does not remove that element from the stack.</p>&#13;
<p class="bull">• <strong><code>push</code></strong> (lines 15–17) places a new element on the <strong>top</strong> of the <code>Stack</code>.</p>&#13;
<p class="bull">• <strong><code>pop</code></strong> (lines 20–22) removes the <code>Stack</code>’s <strong>top</strong> element.</p>&#13;
<p class="bull">• <strong><code>isEmpty</code></strong> (lines 25–27) returns the <code>bool</code> value <strong><code>true</code></strong> if the <code>Stack</code> is <strong>empty</strong>; otherwise, it returns <strong><code>false</code></strong>.</p>&#13;
<p class="bull">• <strong><code>size</code></strong> (lines 30–32) returns the number of elements in the <code>Stack</code>.</p>&#13;
<p>Each calls a <strong><code>deque</code></strong> member function to perform its task—this is known as <strong><span class="violet">delegation</span></strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec11">Testing Class Template <code>Stack&lt;T&gt;</code></h5>&#13;
<p><a href="ch15.xhtml#fig15_2">Figure 15.2</a> tests the <strong><code>Stack</code> class template</strong>. Line 8 instantiates <strong><code>doubleStack</code></strong>. This variable is declared as type <strong><code>Stack&lt;double&gt;</code></strong>—pronounced “<code>Stack</code> of <code>double</code>.” The compiler associates type <code>double</code> with <strong>type parameter <code>T</code></strong> in the class template to produce the source code for a <strong><code>Stack</code> class</strong> with <code>double</code> elements that stores its elements in a <strong><code>deque&lt;double&gt;</code></strong>. Lines 15–19 invoke <strong><code>push</code></strong> (line 16) to place the <code>double</code> values 1.1, 2.2, 3.3, 4.4 and 5.5 onto <code>doubleStack</code>. Next, lines 24–27 invoke <strong><code>isEmpty</code></strong>, <strong><code>top</code></strong> and <strong><code>pop</code></strong> in a <code>while</code> loop to remove all of the stack’s elements. Notice in the output of <a href="ch15.xhtml#fig15_2">Fig. 15.2</a> that the values indeed <strong><code>pop</code></strong> off in <strong>last-in, first-out order</strong>. When <code>doubleStack</code> is empty, the <strong><code>pop</code></strong> loop terminates.</p>&#13;
<div class="group" id="fig15_2">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro02" id="p15pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_02.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Stack class template test program.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"Stack.h"</span> <span class="lgreen">// Stack class template definition</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>8</strong></span>      Stack&lt;<span class="blue">double</span>&gt; doubleStack{}; <span class="lgreen">// create a Stack of double</span>&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">constexpr</span> size_t doubleStackSize{<span class="green">5</span>}; <span class="lgreen">// stack size</span>&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">double</span> doubleValue{<span class="green">1.1</span>}; <span class="lgreen">// first value to push</span>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      cout &lt;&lt; <span class="green">"Pushing elements onto doubleStack\n"</span>;&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="lgreen">// push 5 doubles onto doubleStack</span>&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="blue">for</span> (size_t i{<span class="green">0</span>}; i &lt; doubleStackSize; ++i) {&#13;
<span class="cviolet"><strong>16</strong></span>         doubleStack.push(doubleValue);&#13;
<span class="cviolet"><strong>17</strong></span>         cout &lt;&lt; doubleValue &lt;&lt; <span class="green">' '</span>;&#13;
<span class="cviolet"><strong>18</strong></span>         doubleValue += <span class="green">1.1</span>;&#13;
<span class="cviolet"><strong>19</strong></span>      }&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      cout &lt;&lt; <span class="green">"\n\nPopping elements from doubleStack\n"</span>;&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="lgreen">// pop elements from doubleStack</span>&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="blue">while</span> (!doubleStack.isEmpty()) { <span class="lgreen">// loop while Stack is not empty</span>&#13;
<span class="cviolet"><strong>25</strong></span>         cout &lt;&lt; doubleStack.top() &lt;&lt; <span class="green">' '</span>; <span class="lgreen">// display top element</span>&#13;
<span class="cviolet"><strong>26</strong></span>         doubleStack.pop(); <span class="lgreen">// remove top element</span>&#13;
<span class="cviolet"><strong>27</strong></span>      }&#13;
<span class="cviolet"><strong>28</strong></span>&#13;
<span class="cviolet"><strong>29</strong></span>      cout &lt;&lt; <span class="green">"\nStack is empty, cannot pop.\n"</span>;&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>      Stack&lt;<span class="blue">int</span>&gt; intStack{}; <span class="lgreen">// create a Stack of int</span>&#13;
<span class="cviolet"><strong>32</strong></span>      <span class="blue">constexpr</span> size_t intStackSize{<span class="green">10</span>}; <span class="lgreen">// stack size</span>&#13;
<span class="cviolet"><strong>33</strong></span>      <span class="blue">int</span> intValue{<span class="green">1</span>}; <span class="lgreen">// first value to push</span>&#13;
<span class="cviolet"><strong>34</strong></span>&#13;
<span class="cviolet"><strong>35</strong></span>      cout &lt;&lt; <span class="green">"\nPushing elements onto intStack\n"</span>;&#13;
<span class="cviolet"><strong>36</strong></span>&#13;
<span class="cviolet"><strong>37</strong></span>      <span class="lgreen">// push 10 integers onto intStack</span>&#13;
<span class="cviolet"><strong>38</strong></span>      <span class="blue">for</span> (size_t i{<span class="green">0</span>}; i &lt; intStackSize; ++i) {&#13;
<span class="cviolet"><strong>39</strong></span>         intStack.push(intValue);&#13;
<span class="cviolet"><strong>40</strong></span>         cout &lt;&lt; intValue++ &lt;&lt; <span class="green">' '</span>;&#13;
<span class="cviolet"><strong>41</strong></span>      }&#13;
<span class="cviolet"><strong>42</strong></span>&#13;
<span class="cviolet"><strong>43</strong></span>      cout &lt;&lt; <span class="green">"\n\nPopping elements from intStack\n"</span>;&#13;
<span class="cviolet"><strong>44</strong></span>&#13;
<span class="cviolet"><strong>45</strong></span>      <span class="lgreen">// pop elements from intStack</span>&#13;
<span class="cviolet"><strong>46</strong></span>      <span class="blue">while</span> (!intStack.isEmpty()) { <span class="lgreen">// loop while Stack is not empty</span>&#13;
<span class="cviolet"><strong>47</strong></span>         cout &lt;&lt; intStack.top() &lt;&lt; <span class="green">' '</span>; <span class="lgreen">// display top element</span>&#13;
<span class="cviolet"><strong>48</strong></span>         intStack.pop(); <span class="lgreen">// remove top element</span>&#13;
<span class="cviolet"><strong>49</strong></span>      }&#13;
<span class="cviolet"><strong>50</strong></span>&#13;
<span class="cviolet"><strong>51</strong></span>      cout &lt;&lt; <span class="green">"\nStack is empty, cannot pop.\n"</span>;&#13;
<span class="cviolet"><strong>52</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Pushing elements onto doubleStack&#13;
1.1 2.2 3.3 4.4 5.5&#13;
&#13;
Popping elements from doubleStack&#13;
5.5 4.4 3.3 2.2 1.1&#13;
Stack is empty, cannot pop.&#13;
&#13;
Pushing elements onto intStack&#13;
1 2 3 4 5 6 7 8 9 10&#13;
&#13;
Popping elements from intStack&#13;
10 9 8 7 6 5 4 3 2 1&#13;
Stack is empty, cannot pop.</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.2</strong></span> | Stack class template <code>test</code> program. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>Line 31 instantiates <strong><code>intStack</code></strong>. This variable is declared as type <strong><code>Stack&lt;int&gt;</code></strong>—pronounced “<code>Stack</code> of <code>int</code>.” Lines 38–41 repeatedly invoke <strong><code>push</code></strong> (line 39) to place values onto <code>intStack</code>, then lines 46–49 repeatedly invoke <strong><code>isEmpty</code></strong>, <strong><code>top</code></strong> and <strong><code>pop</code></strong> to remove values from <code>intStack</code> until it’s empty. Once again, the output confirms the <strong>last-in, first-out order</strong> in which the elements are removed.</p>&#13;
<p>Though the compiler does not show you the generated code for <code>Stack&lt;double&gt;</code> and <code>Stack&lt;int&gt;</code>, you can see sample generated code by using the website:</p>&#13;
<pre class="pre">https://cppinsights.io</pre>&#13;
<p>This site shows the template specializations generated by the Clang compiler. (The site requires all the code to be pasted into its code pane. To try this with our example, you’ll need to remove the <code>#include</code> for <code>stack.h</code> in the <code>main</code> program and paste class template <code>Stack</code>’s code above <code>main</code>.)</p>&#13;
<h5 class="h5" id="ch15lev3sec12">Defining Class Template Member Functions Outside a Class Template</h5>&#13;
<p><strong>Member-function definitions</strong> can be defined outside a <strong>class template definition</strong>. In this case, each member-function definition must begin with the same <strong><code>template</code> header</strong> as the class template. Also, you must <strong>qualify each member function with the class name and scope resolution operator</strong>. For example, you’d define the <code>pop</code> function outside the class-template definition as:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p836pro01" id="p836pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;<span class="blue">typename</span> T&gt;&#13;
<span class="blue">inline void</span> Stack&lt;T&gt;::pop() {&#13;
   stack.pop_front();&#13;
}</pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong><code>Stack&lt;T&gt;::</code></strong> indicates that <strong><code>pop</code> is in class template <code>Stack&lt;T&gt;</code>’s scope</strong>. The standard library generally defines all container-class member functions inside their class definitions.</p>&#13;
<h3 class="h3" id="sec15_3"><span class="size">20</span> <span class="violet">15.3</span> C++20 Function Template Enhancements</h3>&#13;
<p>In addition to concepts, C++20 added <strong>abbreviated function templates</strong> and <strong>templated lambda expressions</strong>.</p>&#13;
<h4 class="h4" id="sec15_3_1"><span class="size">20</span> 15.3.1 C++20 Abbreviated Function Templates</h4>&#13;
<p>Using traditional function-template syntax, we could define a <code>printContainer</code> function template with a <code>template</code> header as follows:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p836pro02" id="p836pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt;&#13;
<span class="blue">void</span> printContainer(<span class="blue">const</span> T&amp; items) {&#13;
   <span class="blue">for</span> (<span class="blue">const auto</span>&amp; item : items) {&#13;
      std::cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;&#13;
   }&#13;
}</pre>&#13;
<p><span class="size">20</span> The function template receives a reference to a container (<code>items</code>) and uses a range-based <code>for</code> statement to display the elements. C++20 <strong><span class="violet">abbreviated function templates</span></strong> (<a href="ch15.xhtml#fig15_3">Fig. 15.3</a>) enable you to <strong>define a function template without the <code>template</code> header</strong> (lines 10–14). Line 10 uses the <strong><code>auto</code> keyword</strong> to infer the parameter type.</p>&#13;
<div class="group" id="fig15_3">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro03" id="p15pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_03.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Abbreviated function template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// abbreviated function template printContainer displays a</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="lgreen">// container, such as an array or a vector</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">void</span> printContainer(<span class="blue">const auto</span>&amp; items) {&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">for</span> (<span class="blue">const auto</span>&amp; item : items) {&#13;
<span class="cviolet"><strong>12</strong></span>         std::cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;&#13;
<span class="cviolet"><strong>13</strong></span>      }&#13;
<span class="cviolet"><strong>14</strong></span>   }&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">using</span> <span class="blue">namespace</span> std::string_literals; <span class="lgreen">// for string object literals</span>&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      std::array ints{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>};&#13;
<span class="cviolet"><strong>20</strong></span>      std::vector strings{<span class="green">"red"</span>s, <span class="green">"green"</span>s, <span class="green">"blue"</span>s};&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>      std::cout &lt;&lt; <span class="green">"ints: "</span>;&#13;
<span class="cviolet"><strong>23</strong></span>      printContainer(ints);&#13;
<span class="cviolet"><strong>24</strong></span>      std::cout &lt;&lt; <span class="green">"\nstrings: "</span>;&#13;
<span class="cviolet"><strong>25</strong></span>      printContainer(strings);&#13;
<span class="cviolet"><strong>26</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>27</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">ints: 1 2 3 4 5&#13;
strings: red green blue</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.3</strong></span> | Abbreviated function template.</p>&#13;
</div>&#13;
<p>Recall that a string literal like <code>"red"</code> has the type <code>const char*</code>. Rather than string literals, line 20 uses <strong><code>string</code> object literals</strong> denoted by the <strong><code>s</code></strong> that follows each string literal’s closing quote. This enables the compiler to <strong>deduce from the initializer list</strong> that the <code>vector</code>’s element type is <code>std::string</code> rather than <code>const char*</code>. To use <strong><code>string</code> object literals</strong>, include the <code>&lt;string&gt;</code> header. Line 17’s specifies that the program uses <strong>namespace <code>std::string_literals</code></strong>, which contains features that support <strong><code>string</code> object literals</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec13">Sometimes Traditional Function Template Syntax Is Required</h5>&#13;
<p>The abbreviated function template syntax is similar to that of regular function definitions, but <strong>is not always appropriate</strong>. Consider the first two lines of <a href="ch05.xhtml#ch05lev1sec17">Section 5.17</a>’s function template <code>maximum</code>, which received three parameters of the <strong>same type</strong>:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p837pro01" id="p837pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt;&#13;
T maximum(T value1, T value2, T value3) {</pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> These lines show the correct way to <strong>ensure that all three parameters have the same type</strong>.</p>&#13;
<p>If we write <code>maximum</code> as an <strong>abbreviated function template</strong>:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p837pro02" id="p837pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">auto</span> maximum(<span class="blue">auto</span> value1, <span class="blue">auto</span> value2, <span class="blue">auto</span> value3) {</pre>&#13;
<p><strong>the compiler independently infers each <code>auto</code> parameter’s type</strong> based on the corresponding argument. So, <code>maximum</code> could receive arguments of three different types.</p>&#13;
<h5 class="h5" id="ch15lev3sec14">Specializing <code>printContainer</code> with an Incompatible Type</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> When the compiler attempts to specialize <code>printContainer</code>, errors will occur if:</p>&#13;
<p class="bull">• we pass an <strong>object that is incompatible with a range-based <code>for</code> statement</strong> or</p>&#13;
<p class="bull">• objects of the <strong>container’s element type cannot be output with the <code>&lt;&lt;</code> operator</strong>,</p>&#13;
<p>In <a href="ch15.xhtml#sec15_4">Sections 15.4</a> and <a href="ch15.xhtml#sec15_6">15.6</a>, we’ll show how <strong>C++20 concepts can be used to constrain the types passed to a function template and prevent the compiler from attempting to specialize the template</strong>.</p>&#13;
<h4 class="h4" id="sec15_3_2"><span class="size">20</span> 15.3.2 C++20 Templated Lambdas</h4>&#13;
<p>In C++20, lambdas can specify template parameters. Consider the following lambda from <a href="ch14.xhtml#fig14_16">Fig. 14.16</a>, which we used to calculate the sum of the squares of an <code>array</code>’s integers:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p838pro01" id="p838pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">[](<span class="blue">auto</span> total, <span class="blue">auto</span> value) {<span class="blue">return</span> total + value * value;}</pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The compiler independently infers <code>total</code>’s and <code>value</code>’s (possibly different) types from their arguments. <strong>You can force the lambda to require the same type for both</strong> by using a <strong><span class="violet">templated lambda</span></strong>:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p838pro02" id="p838pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">[]&lt;<span class="blue">typename</span> T&gt;(T total, T value) {<span class="blue">return</span> total + value * value;}</pre>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> The template parameter list is placed between the <strong>lambda’s introducer</strong> and lambda’s parameter list. <strong>When you use one template type parameter (<code>T</code>) to declare both lambda parameters, the compiler requires both arguments to have the same type</strong>; otherwise, a compilation error occurs.</p>&#13;
<h3 class="h3" id="sec15_4"><span class="size">20</span> <span class="violet">15.4</span> C++20 Concepts: A First Look</h3>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <strong>Concepts</strong> (briefly introduced in <a href="ch14.xhtml#sec14_2">Section 14.2</a>) simplify C++ template metaprogramming. C++ experts say that “Concepts are a revolutionary approach for writing templates”<sup><a id="ch15fn18a" href="ch15.xhtml#ch15fn18">18</a></sup> and that “C++20 creates a paradigm shift in the way we use metaprogramming.”<sup><a id="ch15fn19a" href="ch15.xhtml#ch15fn19">19</a></sup> C++’s creator, Bjarne Stroustrup, says, “Concepts complete C++ templates as originally envisioned” and that they’ll “dramatically improve your generic programming and make the current workarounds (e.g., traits classes) and low-level techniques (e.g., <code>enable_if</code>-based overloading) feel like error-prone and tedious assembly programming.”<sup><a id="ch15fn20a" href="ch15.xhtml#ch15fn20">20</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn18" href="ch15.xhtml#ch15fn18a">18</a>. Bartlomiej Filipek, “C++20 Concepts — a Quick Introduction,” May 5 2021. Accessed May 29, 2021. <code><a href="https://www.cppstories.com/2021/concepts-intro/">https://www.cppstories.com/2021/concepts-intro/</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn19" href="ch15.xhtml#ch15fn19a">19</a>. Inbal Levi, “Exploration of C++20 Meta Programming,” September 29, 2020. Accessed May 29, 2021. <code><a href="https://www.youtube.com/watch?v=XgrjybKaIV8">https://www.youtube.com/watch?v=XgrjybKaIV8</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn20" href="ch15.xhtml#ch15fn20a">20</a>. Bjarne Stroustrup, “Concepts: The Future of Generic Programming—3.1 Specifying template interfaces,” January 31, 2017. Accessed May 8, 2021. <code><a href="http://wg21.link/p0557r0">http://wg21.link/p0557r0</a></code>.</p>&#13;
<p>As you’ll see, concepts explicitly constrain the arguments specified for a template’s parameters. You’ll use <strong><code>requires</code> clauses</strong> and <strong><code>requires</code> expressions</strong> to specify constraints, which can</p>&#13;
<p class="bull">• <strong>test attributes of types</strong>—such as, “Is the type an integer type?”—and</p>&#13;
<p class="bull">• <strong>test whether types support various operations</strong>—such as, “Does a type support the comparison operations?”</p>&#13;
<p>The C++ standard provides <strong>74 predefined concepts</strong> (see <a href="ch15.xhtml#sec15_4_3">Section 15.4.3</a>) and you can create custom concepts. Each concept defines a type’s requirements or a relationship between types.<sup><a id="ch15fn21a" href="ch15.xhtml#ch15fn21">21</a></sup> <strong>Concepts can be applied to any parameter of any template and to any use of <code>auto</code></strong>.<sup><a id="ch15fn22a" href="ch15.xhtml#ch15fn22">22</a></sup> We’ll discuss concepts in more depth in <a href="ch15.xhtml#sec15_6">Section 15.6</a>. Initially, we’ll focus on using concepts to restrict a function template’s type parameters.</p>&#13;
<p class="footnote"><a id="ch15fn21" href="ch15.xhtml#ch15fn21a">21</a>. Bjarne Stroustrup, “Concepts: The Future of Generic Programming—3.1 Specifying template interfaces,” January 31, 2017. Accessed May 8, 2021. <code><a href="http://wg21.link/p0557r0">http://wg21.link/p0557r0</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn22" href="ch15.xhtml#ch15fn22a">22</a>. “Placeholder type specifiers.” Accessed June 14, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/auto">https://en.cppreference.com/w/cpp/language/auto</a></code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec15">Motivation and Goals of Concepts</h5>&#13;
<p>Stroustrup says, “Concepts enable overloading and eliminate the need for a lot of ad-hoc metaprogramming and much metaprogramming scaffolding code, thus significantly simplifying metaprogramming as well as generic programming.”<sup><a id="ch15fn23a" href="ch15.xhtml#ch15fn23">23</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn23" href="ch15.xhtml#ch15fn23a">23</a>. Bjarne Stroustrup, “Concepts: The Future of Generic Programming—3 Using Concepts,” January 31, 2017. Accessed June 14, 2021. <code><a href="http://wg21.link/p0557r0">http://wg21.link/p0557r0</a></code>.</p>&#13;
<p>Traditionally, template requirements were <strong>implicit</strong> in how the template used its arguments in operator expressions, function calls, etc.<sup><a id="ch15fn24a" href="ch15.xhtml#ch15fn24">24</a></sup> Though such requirements typically would be documented in program comments, <strong>the compiler cannot enforce comments</strong>. To determine that a type was incompatible with a template, the compiler first had to attempt a specialization to “see” that a type did not support the template’s implicit requirements. This often lead to significant (if not vast) numbers of compilation errors.</p>&#13;
<p class="footnote"><a id="ch15fn24" href="ch15.xhtml#ch15fn24a">24</a>. Hendrik Niemeyer, “An Introduction to C++20’s Concepts,” July 25, 2020. Accessed June 1, 2021. <code><a href="https://www.youtube.com/watch?v=N_kPd2OK1L8">https://www.youtube.com/watch?v=N_kPd2OK1L8</a></code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Concepts specify template requirements explicitly in code (</strong>e.g., in a function template’s signature or a class template’s <code>template</code> header)<strong>. They enable the compiler to determine that a type is not compatible with a template <em>before</em> specializing it</strong>—leading to fewer, more precise error messages.<sup><a id="ch15fn25a" href="ch15.xhtml#ch15fn25">25</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn25" href="ch15.xhtml#ch15fn25a">25</a>. The error-messages’ quality and quantity still varies considerably among compilers.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Concepts also enable you to overload function templates with the same signature based on each function template’s requirements.</strong> For example, we’ll define two different overloads of a function template with the same signature:</p>&#13;
<p class="bull">• one will <strong>support any container with input iterators</strong>, and</p>&#13;
<p class="bull">• the other will be <strong>optimized for containers with random-access iterators</strong>.</p>&#13;
<h4 class="h4" id="sec15_4_1">15.4.1 Unconstrained Function Template <code>multiply</code></h4>&#13;
<p>When you call a function, the compiler uses its <strong>overload-resolution rules</strong><sup><a id="ch15fn26a" href="ch15.xhtml#ch15fn26">26</a></sup> and a technique called <strong>argument-dependent lookup (ADL)</strong><sup><a id="ch15fn27a" href="ch15.xhtml#ch15fn27">27</a>,<a id="ch15fn28a" href="ch15.xhtml#ch15fn28">28</a>,<a id="ch15fn29a" href="ch15.xhtml#ch15fn29">29</a></sup> to locate all the function definitions—known as the <strong><span class="violet">overload set</span></strong>—that might satisfy the function call. This process often includes <strong>specializing function templates</strong> based on a function call’s argument types. The compiler then chooses the best match from the overload set. <strong>An unconstrained function template does not explicitly specify any requirements.</strong> So, the compiler must attempt to specialize the template to check if the function call’s arguments support the operations in that template’s definition.</p>&#13;
<p class="footnote"><a id="ch15fn26" href="ch15.xhtml#ch15fn26a">26</a>. “Overload resolution.” Accessed May 30, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/overload_resolution">https://en.cppreference.com/w/cpp/language/overload_resolution</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn27" href="ch15.xhtml#ch15fn27a">27</a>. “Working Draft, Standard for Programming Language C++—6.5.4 Argument-dependent name lookup [basic.lookup.argdep],” Accessed June 18, 2021. <code><a href="https://eel.is/c++draft/basic.look-up.argdep#:lookup,argument-dependent">https://eel.is/c++draft/basic.look-up.argdep#:lookup,argument-dependent</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn28" href="ch15.xhtml#ch15fn28a">28</a>. “Argument-dependent lookup.” June 14, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/adl">https://en.cppreference.com/w/cpp/language/adl</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn29" href="ch15.xhtml#ch15fn29a">29</a>. Inbal Levi. “Exploration of C++20 Metaprogramming.” September 29, 2020. Accessed June 14, 2021. <code><a href="https://www.youtube.com/watch?v=XgrjybKaIV8">https://www.youtube.com/watch?v=XgrjybKaIV8</a></code>.</p>&#13;
<p>Consider the <strong>unconstrained function template</strong> <code>multiply</code> (lines 5–8 of <a href="ch15.xhtml#fig15_4">Fig. 15.4</a>), which receives <strong>two values of the same type</strong> (<code>T</code>) and returns their product.</p>&#13;
<div class="group" id="fig15_4">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro04" id="p15pro04a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_04.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Simple unconstrained multiply function template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">templat</span>e<span class="blue">&lt;typename</span> T&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   T multiply(T first, T second) {&#13;
<span class="cviolet"> <strong>7</strong></span>      <span class="blue">return</span> first * second;&#13;
<span class="cviolet"> <strong>8</strong></span>   }&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>11</strong></span>      std::cout &lt;&lt; <span class="green">"Product of 5 and 3: "</span> &lt;&lt; multiply(<span class="green">5</span>, <span class="green">3</span>)&#13;
<span class="cviolet"><strong>12</strong></span>         &lt;&lt; <span class="green">"\nProduct of 7.25 and 2.0: "</span> &lt;&lt; multiply(<span class="green">7.25</span>, <span class="green">2.0</span>) &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>13</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Product of 5 and 3: 15&#13;
Product of 7.25 and 2.0: 14.5</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.4</strong></span> | Simple unconstrained <code>multiply</code> function template.</p>&#13;
</div>&#13;
<p>This template has <strong>implicit requirements</strong> that you can infer from the code:</p>&#13;
<p class="bull">• The parameter types are not pointers or references, so the <strong>arguments are received by value</strong>. Similarly, the return type is not a pointer or a reference, so the result is returned by value (line 6). So, <strong>the arguments’ type must support copying</strong>.</p>&#13;
<p class="bull">• The arguments are multiplied (line 7), so <strong>the arguments’ type must support the binary <code>*</code> operator</strong>—either natively (as with built-in types like <code>int</code> and <code>double</code>) or via operator overloading.</p>&#13;
<p>When the compiler specializes <code>multiply</code> for a given type and determines that the arguments are not compatible with the template’s implicit requirements, <strong>it eliminates the function from the overload set.</strong> In this example, lines 11 and 12 call <code>multiply</code> with two <code>int</code> values and two <code>double</code> values, respectively. Of course, <strong>all numeric types in C++ are copyable and support the <code>*</code> operator</strong>, so the compiler can specialize <code>multiply</code> for each type. Interestingly, <strong>you cannot call <code>multiply</code> with arguments of different types,</strong> even if one argument’s type can be implicitly converted to the other’s. There’s one type parameter, so both arguments must have identical types.</p>&#13;
<h5 class="h5" id="ch15lev3sec16">Using Incompatible Types with <code>multiply</code></h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> What if we pass to <code>multiply</code> arguments that <strong>do not support copying or do not support the <code>*</code> operator</strong> and there is no other function definition that matches the function call? The compiler will generate error messages. For example, the following code attempts to calculate the product of two <code>string</code>s:<sup><a id="ch15fn30a" href="ch15.xhtml#ch15fn30">30</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn30" href="ch15.xhtml#ch15fn30a">30</a>. For your convenience, this code is provided in the source-code file as comments at the end of <code>main</code>.</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p841pro01" id="p841pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">std::string s1{<span class="green">"hi"</span>};&#13;
std::string s2{<span class="green">"bye"</span>};&#13;
<span class="blue">auto</span> result{multiply(s1, s2)}; <span class="lgreen">// error: string does not support *</span></pre>&#13;
<p>Class <code>string</code> supports copying but does not support the <code>*</code> operator. If we add these lines to <a href="ch15.xhtml#fig15_4">Fig. 15.4</a>’s <code>main</code> and recompile, we get the following error messages from our preferred compilers—we added vertical spacing for readability. <strong>Clang</strong> produces:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p841pro02" id="p841pro02a">Click here to view code image</a></p>&#13;
<pre class="pre1">fig15_04.cpp:7:17: error: invalid operands to binary expression (&lt;char&gt;&#13;
   return first * second;&#13;
          ~~~~~ ^ ~~~~~~&#13;
fig15_04.cpp:16:16: note: in instantiation of function template&#13;
specialization&#13;
   auto result{multiply(s1, s2)}; // error: string does not support *&#13;
               ^&#13;
1 error generated.</pre>&#13;
<p><strong>Visual <code>C++</code> produces:</strong></p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p841pro03" id="p841pro03a">Click here to view code image</a></p>&#13;
<pre class="pre1">fig15_04.cpp&#13;
C:\Users\pauldeitel\examples\ch15\multiply\fig15_04.cpp(7,17): error C2676:&#13;
binary acceptable to the predefined operator&#13;
       with&#13;
       [&#13;
           T=std::string&#13;
       ]&#13;
C:\Users\pauldeitel\examples\ch15\multiply\fig15_04.cpp(16): message : see&#13;
reference to function template instantiation being compiled&#13;
       with&#13;
       [&#13;
           T=std::string&#13;
       ]</pre>&#13;
<p><strong>GNU <code>g++</code> produces:</strong></p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p841pro04" id="p841pro04a">Click here to view code image</a></p>&#13;
<pre class="pre1">fig15_04.cpp: In instantiation of ‘T multiply(T, T) [with T =&#13;
std::__cxx11::basic_string&lt;char&gt;]’:&#13;
&#13;
fig15_04.cpp:16:31:   required from here&#13;
&#13;
fig15_04.cpp:7:17: error: no match for ‘operator*’ (operand types are&#13;
‘std::__cxx11::basic_string&lt;char&gt;’ and ‘std::__cxx11::basic_string&lt;char&gt;’)&#13;
    7 |    return first * second;&#13;
      |           ~~~~~~^~~~~~~~</pre>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> The preceding errors are relatively small and straightforward, but this is not typical. More complex templates tend to result in lengthy lists of error messages. For example, passing the wrong kinds of iterators to a standard library algorithm that’s not constrained with concepts can yield hundreds of lines of error messages. We tried to compile a program in which <code>main</code> contained only the following two simple statements:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p842pro01" id="p842pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">std::list integers{<span class="green">10</span>, <span class="green">2</span>, <span class="green">33</span>, <span class="green">4</span>, <span class="green">7</span>, <span class="green">1</span>, <span class="green">80</span>};&#13;
std::sort(integers.begin(), integers.end());</pre>&#13;
<p>We’d like to sort a <code>std::list</code>, which has <strong>bidirectional iterators</strong>. However, the <code>std::sort</code> algorithm requires <strong>random-access iterators</strong>. One popular compiler generated more than 1000 lines of error messages for the preceding code! Simply switching to the concept-constrained <strong><code>std::ranges::sort</code></strong> algorithm produces far fewer messages and indicates that <strong>random-access iterators</strong> are required.</p>&#13;
<h4 class="h4" id="sec15_4_2"><span class="size">20</span> 15.4.2 Constrained Function Template with a C++20 Concepts <code>requires</code> Clause</h4>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <strong>C++20 concepts</strong> enable you to specify <strong><span class="violet">constraints</span></strong>. Each constraint is a <strong>compile-time predicate</strong>—an expression that evaluates to <code>true</code> or <code>false</code>.<sup><a id="ch15fn31a" href="ch15.xhtml#ch15fn31">31</a></sup> The compiler uses constraints to check type requirements <strong>before specializing templates</strong>. For example, with predefined concepts, we can specify constraints that require a template’s arguments to be numeric values of the same type. The C++ Core Guidelines recommend:</p>&#13;
<p class="footnote"><a id="ch15fn31" href="ch15.xhtml#ch15fn31a">31</a>. “Working Draft, Standard for Programming Language C++—13.5 Template Constraints.” Accessed June 12, 2021. <code><a href="https://eel.is/c++draft/temp.constr">https://eel.is/c++draft/temp.constr</a></code>.</p>&#13;
<p class="bull">• <strong>specifying concepts for every template parameter</strong><sup><a id="ch15fn32a" href="ch15.xhtml#ch15fn32">32</a></sup> and</p>&#13;
<p class="footnote"><a id="ch15fn32" href="ch15.xhtml#ch15fn32a">32</a>. “T.10: Specify concepts for all template arguments.” Accessed June 9, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts</a></code>.</p>&#13;
<p class="bull">• <strong>using the standard’s predefined concepts if possible</strong>.<sup><a id="ch15fn33a" href="ch15.xhtml#ch15fn33">33</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn33" href="ch15.xhtml#ch15fn33a">33</a>. “T.11: Whenever possible use standard concepts.” Accessed June 9, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts</a></code>.</p>&#13;
<p>You can apply concepts to a function template parameter to explicitly state the requirements for the corresponding type arguments. If a type argument satisfies the requirements, the compiler specializes the template; otherwise, the template is ignored. When compilers do not find a match for a function call, <strong>a benefit of concepts over previous techniques they either partially or wholly replace is that compilers typically produce (possibly far) fewer, clearer and more precise error messages.</strong></p>&#13;
<h5 class="h5" id="ch15lev3sec17"><code>requires</code> Clause</h5>&#13;
<p><span class="size">20</span> <a href="ch15.xhtml#fig15_5">Figure 15.5</a> uses a C++20 <span class="violet"><strong><code>requires</code></strong></span> <strong><span class="violet">clause</span></strong> (line 8) to constrain <code>multiply</code>’s template parameter <code>T</code>. The keyword <code>requires</code> is followed by a <strong><span class="violet">constraint expression</span></strong>, consisting of one or more compile-time <code>bool</code> expressions, which you can combine with the logical <code>&amp;&amp;</code>, <code>||</code> and <code>!</code> operators.</p>&#13;
<div class="group" id="fig15_5">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro05" id="p15pro05a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_05.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Constrained multiply function template that allows</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// only integers and floating-point values.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;concepts&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">templat</span>e<span class="blue">&lt;typename</span> T&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">requires</span> std::integral&lt;T&gt; || std::floating_point&lt;T&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   T multiply(T first, T second) {&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">return</span> first * second;&#13;
<span class="cviolet"><strong>11</strong></span>   }&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>14</strong></span>      std::cout &lt;&lt; <span class="green">"Product of 5 and 3: "</span> &lt;&lt; multiply(<span class="green">5</span>, <span class="green">3</span>)&#13;
<span class="cviolet"><strong>15</strong></span>         &lt;&lt; <span class="green">"\nProduct of 7.25 and 2.0: "</span> &lt;&lt; multiply(<span class="green">7.25</span>, <span class="green">2.0</span>) &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      std::string s1{<span class="green">"hi"</span>};&#13;
<span class="cviolet"><strong>18</strong></span>      std::string s2{<span class="green">"bye"</span>};&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">auto</span> result{multiply(s1, s2)};&#13;
<span class="cviolet"><strong>20</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">fig15_05.cpp: In function 'int main()':&#13;
fig15_05.cpp:19:31: error: use of function 'T multiply(T, T) [with T =&#13;
std::__cxx11::basic_string&lt;char&gt;]' with <strong>unsatisfied constraints</strong>&#13;
   19 | auto result{multiply(s1, s2)};&#13;
      |                            ^&#13;
&#13;
fig15_05.cpp:9:3: note: declared here&#13;
    9 | T multiply(T first, T second) {&#13;
      |   ^~~~~~~~&#13;
&#13;
<strong>fig15_05.cpp:9:3: note: constraints not satisfied</strong>&#13;
&#13;
fig15_05.cpp: In instantiation of 'T multiply(T, T) [with T =&#13;
std::__cxx11::basic_string&lt;char&gt;]':&#13;
fig15_05.cpp:19:31:   required from here&#13;
fig15_05.cpp:9:3:   required by the constraints of 'template&lt;class T&gt;&#13;
requires (integral&lt;T&gt;) || (floating_point&lt;T&gt;) T multiply(T, T)'&#13;
&#13;
<strong>fig15_05.cpp:8:30: note: no operand of the disjunction is satisfied</strong>&#13;
   <strong>8  |    requires std::integral&lt;T&gt; || std::floating_point&lt;T&gt;</strong>&#13;
      |             <strong>~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~</strong></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.5</strong></span> | Constrained <code>multiply</code> function template that allows only integers and floating-point values. These error messages are from the <code>g++</code> compiler.</p>&#13;
</div>&#13;
<p>Line 8 specifies that valid <code>multiply</code> type arguments must satisfy either of the following concepts, each of which is a <strong>constraint on the type parameter <code>T</code></strong>:</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>std::integral</code></strong></span><code>&lt;T&gt;</code> indicates that <strong><code>T</code> can be any integer data type</strong>, and</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>std::floating_point</code></strong></span><code>&lt;T&gt;</code> indicates that <strong><code>T</code> can be any floating-point data type</strong>.</p>&#13;
<p>All integral and floating-point types support the arithmetic operators, so we know that values of these types all will work with line 10 in the template’s body. If neither of the preceding constraints is satisfied, then the type arguments are incompatible with function template <code>multiply</code>, and the compiler will not instantiate the template. If no other functions match the call, the compiler generates error messages.</p>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> You’ll soon see that <strong>some concepts specify many individual constraints</strong>. The preceding concepts (from header <span class="violet"><strong><code>&lt;concepts&gt;</code></strong></span>) are two of <strong>C++20’s 74 predefined concepts</strong>.<sup><a id="ch15fn34a" href="ch15.xhtml#ch15fn34">34</a></sup> <a href="ch15.xhtml#sec15_4_3">Section 15.4.3</a> lists the predefined-concept categories, the concepts in each and the headers that define them.</p>&#13;
<p class="footnote"><a id="ch15fn34" href="ch15.xhtml#ch15fn34a">34</a>. “Index of library concepts.” Accessed May 10, 2021. <code><a href="https://eel.is/c++draft/conceptindex">https://eel.is/c++draft/conceptindex</a></code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec18">Disjunctions and Conjunctions</h5>&#13;
<p>In line 8, the <strong>logical OR (<code>||</code>) operator</strong> forms a <strong><span class="violet">disjunction</span></strong>—either or both operands must be <code>true</code> for the compiler to specialize the template. If both are <code>false</code>, the compiler ignores the template as a potential match for a call to <code>multiply</code>. Function <code>multiply</code> defines only one type parameter, so <strong>both operands must have the same type</strong>. Thus, only one concept in line 8 can be <code>true</code> for each <code>multiply</code> call in this example.</p>&#13;
<p>You may form a <strong><span class="violet">conjunction</span></strong> with the <strong>logical AND (<code>&amp;&amp;</code>)</strong> operator to indicate that both operands must be <code>true</code> for the compiler to specialize the template. Disjunctions and conjunctions use <strong>short-circuit evaluation</strong> (<a href="ch04.xhtml#ch04lev2sec3">Section 4.11.3</a>). They also may contain the <strong>logical NOT operator (<code>!</code>)</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec19">Calling <code>multiply</code> with Arguments That Satisfy Its Constraints</h5>&#13;
<p>Lines 14 and 15 call <code>multiply</code> with two <code>int</code> values and two <code>double</code> values, respectively. When the compiler looks for function definitions that match these calls, it will encounter only the <code>multiply</code> function template in lines 7–11. It will check the arguments’ types to determine whether they satisfy either of the concepts listed in line 8’s <strong><code>requires</code> clause</strong>. Both arguments in each call satisfy one of the <strong>disjunction</strong>’s requirements, so the compiler will specialize the template for type <code>int</code> in line 14 and type <code>double</code> in line 15. Again, <strong><code>multiply</code> has only one type parameter, so both arguments must be the same type</strong>. Otherwise, the compiler will not know which type to use to specialize the template and will generate errors.</p>&#13;
<h5 class="h5" id="ch15lev3sec20">Calling <code>multiply</code> with Arguments That Do Not Satisfy Its Constraints</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Line 19 calls <code>multiply</code> with two <code>string</code> arguments. Again, when the compiler looks for function definitions that match this call, it will encounter only the <code>multiply</code> function template in lines 7–11. Next, it will check the arguments’ types to determine whether they satisfy either of the concepts listed in line 8’s <code>requires</code> clause. <strong>The <code>string</code> type does not satisfy either of the concepts</strong>. Also, no other <code>multiply</code> functions can receive two <code>string</code> arguments, so the compiler generates error messages. <a href="ch15.xhtml#fig15_5">Figure 15.5</a> shows <code>g++</code>’s messages— we highlighted several messages in bold and added vertical spacing for readability. Note the last few lines of this output where the compiler indicated that <code>"</code><strong><code>no operand of the disjunction is satisfied</code></strong><code>"</code> and pointed to the <strong><code>requires</code> clause</strong> in line 8.</p>&#13;
<h4 class="h4" id="sec15_4_3"><span class="size">20</span> 15.4.3 C++20 Predefined Concepts</h4>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The C++ standard’s “Index of library concepts”<sup><a id="ch15fn35a" href="ch15.xhtml#ch15fn35">35</a></sup> alphabetically lists the concepts defined in the standard. In the following table, we’ve listed all the standard concepts by header—<strong><code>&lt;concepts&gt;</code></strong>, <strong><code>&lt;iterator&gt;</code></strong>, <strong><code>&lt;ranges&gt;</code></strong>, <strong><code>&lt;compare&gt;</code></strong> and <strong><code>&lt;random&gt;</code></strong>. Also, we’ve divided the <code>&lt;concepts&gt;</code> header’s 31 concepts into the subcategories <strong>core language concepts</strong>, <strong>comparison concepts</strong>, <strong>object concepts</strong> and <strong>callable concepts</strong>. Many concepts have self-explanatory names. For details on each, see the corresponding header’s page at <code>cppreference.com</code>.</p>&#13;
<p class="footnote"><a id="ch15fn35" href="ch15.xhtml#ch15fn35a">35</a>. “Working Draft, Standard for Programming Language C++—Index of library concepts.” Accessed May 15, 2021. <code><a href="https://eel.is/c++draft/conceptindex">https://eel.is/c++draft/conceptindex</a></code>.</p>&#13;
<div class="image"><img src="Images/845tab01.jpg" alt="Images" width="825" height="1043"/></div>&#13;
<h3 class="h3" id="sec15_5"><span class="violet">15.5</span> Type Traits</h3>&#13;
<p><span class="size">11</span> C++11 introduced the <strong><code>&lt;type_traits&gt;</code> header</strong><sup><a id="ch15fn36a" href="ch15.xhtml#ch15fn36">36</a></sup> for</p>&#13;
<p class="footnote"><a id="ch15fn36" href="ch15.xhtml#ch15fn36a">36</a>. “Standard library header <code>&lt;type_traits&gt;</code>.” Accessed June 14, 2021. <code><a href="https://en.cppreference.com/w/cpp/header/type_traits">https://en.cppreference.com/w/cpp/header/type_traits</a></code>.</p>&#13;
<p class="bull">• testing at compile time whether types have various traits, and</p>&#13;
<p class="bull">• generating template code based on those traits.</p>&#13;
<p>For example, you could check whether a type is</p>&#13;
<p class="bull">• a <strong>fundamental type like <code>int</code></strong> (using the type trait <strong><code>std::is_fundamental</code></strong>) vs.</p>&#13;
<p class="bull">• a <strong>class type</strong> (using the type trait <strong><code>std::is_class</code></strong>)</p>&#13;
<p><span class="size">20</span> and use different template code to handle each case. Each subsequent C++ version has added more type traits—a few have been deprecated or removed (which we do not include in our table at the end of this section). Most recently, <strong>C++20 added 10 type traits</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec21">Using Type Traits Before C++20</h5>&#13;
<p>Before concepts, you’d use type traits in unconstrained template definitions to check whether type arguments satisfied a template’s requirements. As with concepts, these checks were performed at compile-time <strong>but <em>during</em> template specialization</strong>, often leading to large numbers of difficult-to-decipher error messages. On the other hand, <strong>the compiler tests concepts <em>before</em> performing template specialization</strong>, typically resulting in fewer, clearer and more focused error messages than when you use type traits in unconstrained templates.</p>&#13;
<h5 class="h5" id="ch15lev3sec22"><span class="size">20</span> C++20 Predefined Concepts Often Use Type Traits</h5>&#13;
<p>Interestingly, C++20 concepts are often implemented in terms of type traits, for example:</p>&#13;
<p class="bull">• the <strong>concept <code>std::integral</code></strong> is implemented in terms of the <strong>type trait <code>std::is_integral</code></strong>,</p>&#13;
<p class="bull">• the <strong>concept <code>std::floating_point</code></strong> is implemented in terms of the <strong>type trait <code>std::is_floating_point</code></strong> and</p>&#13;
<p class="bull">• the <strong>concept <code>std::destructible</code></strong> is implemented in terms of the <strong>type trait <code>std::is_nothrow_destructible</code></strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec23">Demonstrating Type Traits</h5>&#13;
<p><a href="ch15.xhtml#fig15_6">Figure 15.6</a> shows <strong>type traits</strong> that correspond to the concepts in <a href="ch15.xhtml#fig15_5">Fig. 15.5</a>.</p>&#13;
<div class="group" id="fig15_6">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro06" id="p15pro06a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_06.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Using type traits to test whether types are</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// integral types, floating-point types or arithmetic types.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;type_traits&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"{}\n{}{}\n{}{}\n{}{}\n{}{}\n{}{}\n\n"</span>,&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="green">"CHECK WITH TYPE TRAITS WHETHER TYPES ARE INTEGRAL"</span>,&#13;
<span class="cviolet"><strong>12</strong></span>         <span class="green">"std::is_integral&lt;int&gt;::value: "</span>, std::is_integral&lt;<span class="blue">int</span>&gt;::value,&#13;
<span class="cviolet"><strong>13</strong></span>         <span class="green">"std::is_integral_v&lt;int&gt;: "</span>, std::is_integral_v&lt;<span class="blue">int</span>&gt;,&#13;
<span class="cviolet"><strong>14</strong></span>         <span class="green">"std::is_integral_v&lt;long&gt;: "</span>, std::is_integral_v&lt;<span class="blue">long</span>&gt;,&#13;
<span class="cviolet"><strong>15</strong></span>         <span class="green">"std::is_integral_v&lt;float&gt;: "</span>, std::is_integral_v&lt;<span class="blue">float</span>&gt;,&#13;
<span class="cviolet"><strong>16</strong></span>         <span class="green">"std::is_integral_v&lt;std::string&gt;: "</span>,&#13;
<span class="cviolet"><strong>17</strong></span>         std::is_integral_v&lt;std::string&gt;);&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"{}\n{}{}\n{}{}\n{}{}\n{}{}\n{}{}\n\n"</span>,&#13;
<span class="cviolet"><strong>20</strong></span>         <span class="green">"CHECK WITH TYPE TRAITS WHETHER TYPES ARE FLOATING POINT"</span>,&#13;
<span class="cviolet"><strong>21</strong></span>         <span class="green">"std::is_floating_point&lt;float&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>22</strong></span>         std::is_floating_point&lt;flo<span class="blue">at&gt;::</span>value,&#13;
<span class="cviolet"><strong>23</strong></span>         <span class="green">"std::is_floating_point_v&lt;float&gt;: "</span>,&#13;
<span class="cviolet"><strong>24</strong></span>         std::is_floating_point_v&lt;flo<span class="blue">at&gt;,</span>&#13;
<span class="cviolet"><strong>25</strong></span>         <span class="green">"std::is_floating_point_v&lt;double&gt;: "</span>,&#13;
<span class="cviolet"><strong>26</strong></span>         std::is_floating_point_v&lt;dou<span class="blue">ble&gt;,</span>&#13;
<span class="cviolet"><strong>27</strong></span>         <span class="green">"std::is_floating_point_v&lt;int&gt;: "</span>,&#13;
<span class="cviolet"><strong>28</strong></span>         std::is_floating_point_v&lt;int<span class="blue">&gt;,</span>&#13;
<span class="cviolet"><strong>29</strong></span>         <span class="green">"std::is_floating_point_v&lt;std::string&gt;: "</span>,&#13;
<span class="cviolet"><strong>30</strong></span>         std::is_floating_point_v&lt;std::string&gt;);&#13;
<span class="cviolet"><strong>31</strong></span>&#13;
<span class="cviolet"><strong>32</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"{}\n{}{}\n{}{}\n{}{}\n{}{}\n"</span>,&#13;
<span class="cviolet"><strong>33</strong></span>         <span class="green">"CHECK WITH TYPE TRAITS WHETHER TYPES CAN BE USED IN ARITHMETIC"</span>,&#13;
<span class="cviolet"><strong>34</strong></span>         <span class="green">"std::is_arithmetic&lt;int&gt;::value: "</span>, std::is_arithmetic&lt;<span class="blue">int</span>&gt;::value,&#13;
<span class="cviolet"><strong>35</strong></span>         <span class="green">"std::is_arithmetic_v&lt;int&gt;: "</span>, std::is_arithmetic_v&lt;<span class="blue">int</span>&gt;,&#13;
<span class="cviolet"><strong>36</strong></span>         <span class="green">"std::is_arithmetic_v&lt;double&gt;: "</span>, std::is_arithmetic_v&lt;<span class="blue">double</span>&gt;,&#13;
<span class="cviolet"><strong>37</strong></span>         <span class="green">"std::is_arithmetic_v&lt;std::string&gt;: "</span>,&#13;
<span class="cviolet"><strong>38</strong></span>         std::is_arithmetic_v&lt;std::string&gt;);&#13;
<span class="cviolet"><strong>39</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">CHECK WHETHER TYPES ARE INTEGRAL&#13;
std::is_integral&lt;int&gt;::value: true&#13;
std::is_integral_v&lt;int&gt;: true&#13;
std::is_integral_v&lt;long&gt;: true&#13;
std::is_integral_v&lt;float&gt;: false&#13;
std::is_integral_v&lt;std::string&gt;: false&#13;
&#13;
CHECK WHETHER TYPES ARE FLOATING POINT&#13;
std::is_floating_point&lt;float&gt;::value: true&#13;
std::is_floating_point_v&lt;float&gt;: true&#13;
std::is_floating_point_v&lt;double&gt;: true&#13;
std::is_floating_point_v&lt;int&gt;: false&#13;
std::is_floating_point_v&lt;std::string&gt;: false&#13;
&#13;
CHECK WHETHER TYPES CAN BE USED IN ARITHMETIC&#13;
std::is_arithmetic&lt;int&gt;::value: true&#13;
std::is_arithmetic_v&lt;int&gt;: true&#13;
std::is_arithmetic_v&lt;double&gt;: true&#13;
std::is_arithmetic_v&lt;std::string&gt;: false</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.6</strong></span> | Using type traits to test whether types are integral types, floating-point types or arithmetic types. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p><strong>Each type-trait class has a <code>static bool</code> member named <code>value</code></strong>. An expression like</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p848pro01" id="p848pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">std::is_integral&lt;<span class="blue">int</span>&gt;::value</pre>&#13;
<p><span class="size">17</span> <span class="size">14</span> (line 12) returns <code>true</code> at compile time if the type in angle brackets (<code>int</code>) is an integral type. Otherwise, it returns <code>false</code>. Since the notation <strong><code>::value</code></strong> is used with every type-trait class to access its <code>true</code> or <code>false</code> value, <strong>C++17 added convenient shorthands for using type trait values</strong>. These are defined as <strong><span class="violet">variable templates</span></strong> (a C++14 feature) with <strong>names ending in <code>_v</code></strong>.<sup><a id="ch15fn37a" href="ch15.xhtml#ch15fn37">37</a></sup> Just like function templates specify groups of related functions and class templates specify groups of related classes, variable templates specify groups of related variables. You specialize a variable template to use it. The <strong>variable template</strong> corresponding to</p>&#13;
<p class="footnote"><a id="ch15fn37" href="ch15.xhtml#ch15fn37a">37</a>. “T.142: Use template variables to simplify notation.” Accessed June 18, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-var">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-var</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p848pro02" id="p848pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">std::is_integral&lt;<span class="blue">int</span>&gt;::value</pre>&#13;
<p>is defined in the C++ standard as<sup><a id="ch15fn38a" href="ch15.xhtml#ch15fn38">38</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn38" href="ch15.xhtml#ch15fn38a">38</a>. “Working Draft, Standard for Programming Language C++—20.15.3 Header <code>&lt;type_traits&gt;</code> synopsis [meta.type.synop],” Accessed June 18, 2021. <code><a href="https://eel.is/c++draft/meta#type.synop">https://eel.is/c++draft/meta#type.synop</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p848pro03" id="p848pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;<span class="blue">class</span> T&gt;&#13;
<span class="blue">inline constexpr bool</span> is_integral_v = is_integral&lt;T&gt;::value;</pre>&#13;
<p>So, the expression <strong><code>std::is_integral&lt;int&gt;::value</code></strong> is equivalent to</p>&#13;
<pre class="pre"><strong>std::is_integral_v&lt;<span class="blue">int</span>&gt;</strong></pre>&#13;
<p>which, depending on whether the type is <code>int</code>, simply becomes the value <code>true</code> or <code>false</code> in the generated code.</p>&#13;
<p>Lines 12, 22 and 34 tests several type traits and display their <code>value</code> members to show the results. The program’s other tests are performed using the more convenient <strong><code>_v</code> variable templates</strong>:</p>&#13;
<p class="bull">• Lines 13, 14, 15 and 17 use the variable template <strong><code>std::is_integral</code></strong> to check whether various types are <strong>integer types</strong>.</p>&#13;
<p class="bull">• Lines 24, 26, 28 and 30 use the variable template <strong><code>std::is_floating_point</code></strong> to check whether various types are <strong>floating-point types</strong>.</p>&#13;
<p class="bull">• Lines 35, 36 and 38 use the variable template <strong><code>std::is_arithmetic_v</code></strong> to check whether various types are <strong>arithmetic types</strong> that could be used in arithmetic expressions.</p>&#13;
<p>The following table lists the <code>&lt;type_traits&gt;</code> header’s type traits and supporting functions by category. The new features added in C++14 (two new items), 17 (14 new items) and 20 (10 new items) are indicated with superscript version numbers. For details on each, see:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p848pro04" id="p848pro04a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/header/type_traits</pre>&#13;
<div class="image"><img src="Images/848tab01.jpg" alt="Images" width="801" height="926"/></div>&#13;
<div class="image"><img src="Images/848tab01a.jpg" alt="Images" width="801" height="874"/></div>&#13;
<h3 class="h3" id="sec15_6"><span class="size">20</span> <span class="violet">15.6</span> C++20 Concepts: A Deeper Look</h3>&#13;
<p>Now that we’ve introduced how to constrain a template parameter via the <strong><code>requires</code> clause</strong> and <strong>predefined concepts</strong>, we’ll create a <strong>custom concept</strong> that aggregates two predefined ones, then present additional concepts features.</p>&#13;
<h4 class="h4" id="sec15_6_1"><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> 15.6.1 Creating a Custom Concept</h4>&#13;
<p>C++20’s <strong>predefined concepts often aggregate multiple constraints, sometimes including those from other predefined concepts</strong>, effectively creating what some developers refer to as a <strong>type category</strong>.<sup><a id="ch15fn39a" href="ch15.xhtml#ch15fn39">39</a></sup> You also can use templates to define your own custom concepts. Let’s create a <strong>custom concept</strong> that aggregates the predefined concepts <strong><code>std::integral</code></strong> and <strong><code>std::floating_point</code></strong>, we used in <a href="ch15.xhtml#fig15_5">Fig. 15.5</a> to constrain the <code>multiply</code> function template:</p>&#13;
<p class="footnote"><a id="ch15fn39" href="ch15.xhtml#ch15fn39a">39</a>. Inbal Levi. “Exploration of C++20 Metaprogramming.” September 29, 2020. Accessed June 14, 2021. <code><a href="https://www.youtube.com/watch?v=XgrjybKaIV8">https://www.youtube.com/watch?v=XgrjybKaIV8</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p850pro01" id="p850pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;<span class="blue">typename</span> T&gt;&#13;
<span class="blue">concept</span> Numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;</pre>&#13;
<p>A concept begins with a <code>template</code> header followed by:</p>&#13;
<p class="bull">• <span class="size">20</span> the keyword <span class="violet"><strong><code>concept</code></strong></span>,</p>&#13;
<p class="bull">• the <strong>concept name</strong> (<code>Numeric</code>), which uses CamelCase naming by convention,</p>&#13;
<p class="bull">• an <strong>equal sign (<code>=</code>)</strong> and</p>&#13;
<p class="bull">• the <strong>constraint expression</strong> (<code>std::integral&lt;T&gt; || std::floating_point&lt;T&gt;</code>).</p>&#13;
<p>The <strong>constraint expression</strong> is a compile-time logical expression that determines whether a template argument satisfies a particular set of <strong>requirements</strong>—in this case, whether it’s an integer or floating-point number. These commonly include <strong>predefined concepts</strong>, <strong>type traits</strong> and, as you’ll see shortly, <strong><code>requires</code> expressions</strong> that enable you to specify other requirements. The <code>Numeric</code> concept’s <code>template</code> header has one type parameter, representing the type to test.</p>&#13;
<p>Concepts with multiple template parameters also can specify relationships between types.<sup><a id="ch15fn40a" href="ch15.xhtml#ch15fn40">40</a></sup> For example, if a template has two type parameters, you can <strong>use the predefined concept</strong> <span class="violet"><strong><code>std::same_as</code></strong></span> <strong>to ensure two type arguments have the same type</strong>, as in:</p>&#13;
<p class="footnote"><a id="ch15fn40" href="ch15.xhtml#ch15fn40a">40</a>. Bjarne Stroustrup, “Concepts: The Future of Generic Programming—3.1 Specifying template interfaces,” January 31, 2017. Accessed May 8, 2021. <code><a href="http://wg21.link/p0557r0">http://wg21.link/p0557r0</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p851pro01" id="p851pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;<span class="blue">typename</span> T, <span class="blue">typename</span> U&gt;&#13;
   <span class="blue">requires</span> std::same_as&lt;T, U&gt;&#13;
<span class="lgreen">// rest of template definition</span></pre>&#13;
<p>In <a href="ch15.xhtml#sec15_12">Section 15.12</a>, we introduce <strong>variadic templates</strong> that can have any number of (type or non-type) template arguments. There, we’ll use <strong><code>std::same_as</code></strong> in a variadic function template that requires all its arguments to have the same type.</p>&#13;
<h4 class="h4" id="sec15_6_2">15.6.2 Using a Concept</h4>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Once you define a concept, you can use it to <strong>constrain a template parameter</strong> in one of four ways—we show the first three here and the fourth in <a href="ch15.xhtml#sec15_6_3">Section 15.6.3</a>.</p>&#13;
<h5 class="h5" id="ch15lev3sec24"><code>requires</code> Clause Following the <strong><code>template</code></strong> Header</h5>&#13;
<p>Any concept can be placed in a <code>requires</code> clause <strong>following the <code>template</code> header</strong>, as we did in <a href="ch15.xhtml#fig15_5">Fig. 15.5</a>. We can use our <strong>custom concept <code>Numeric&lt;T&gt;</code></strong> in a <code>requires</code> clause as follows:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p851pro02" id="p851pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;<span class="blue">typename</span> T&gt;&#13;
   <span class="blue">requires</span> Numeric&lt;T&gt;&#13;
T multiply(T first, T second) {&#13;
   <span class="blue">return</span> first * second;&#13;
}</pre>&#13;
<h5 class="h5" id="ch15lev3sec25"><code>requires</code> Clause Following a Function Template’s Signature</h5>&#13;
<p>You also can place the <strong><code>requires</code> clause after a function template’s signature and before the function template’s body</strong>, as in:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p851pro03" id="p851pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;<span class="blue">typename</span> T&gt;&#13;
T multiply(T first, T second) <span class="blue">requires</span> Numeric&lt;T&gt; {&#13;
   <span class="blue">return</span> first * second;&#13;
}</pre>&#13;
<p>Such a <strong><span class="violet">trailing</span></strong> <span class="violet"><strong><code>requires</code></strong></span><strong><span class="violet"> clause</span></strong> must be used in two scenarios:<sup><a id="ch15fn41a" href="ch15.xhtml#ch15fn41">41</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn41" href="ch15.xhtml#ch15fn41a">41</a>. “What is the difference between the three ways of applying constraints to a template?” Accessed June 12, 2021. <code><a href="https://stackoverflow.com/a/61875483">https://stackoverflow.com/a/61875483</a></code>. [Note: The original <code>stackoverflow.com</code> question mentioned three ways of applying constraints to a template, but there are four and each is mentioned in the cited answer.]</p>&#13;
<p class="bull">• A member function defined in a class template’s body does not have a <code>template</code> header, so you must use a trailing <code>requires</code> clause.</p>&#13;
<p class="bull">• To use a function template’s parameter names in a constraint, you must use a trailing <code>requires</code> clause so the parameter names are in scope.</p>&#13;
<h5 class="h5" id="ch15lev3sec26">Concept as a Type in the <code>template</code> Header</h5>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> When you have a single concept-constrained type parameter, the C++ Core Guidelines recommend using the concept name in place of <code>typename</code> in the <code>template</code> header.<sup><a id="ch15fn42a" href="ch15.xhtml#ch15fn42">42</a></sup> Doing so simplifies the template definition by <strong>eliminating the <code>requires</code> clause</strong>:</p>&#13;
<p class="footnote"><a id="ch15fn42" href="ch15.xhtml#ch15fn42a">42</a>. “T.13: Prefer the shorthand notation for simple, single-type argument concepts.” Accessed June 10, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-shorthand">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-shorthand</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p852pro01" id="p852pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;Numeric Number&gt;&#13;
Number multiply(Number first, Number second) {&#13;
   <span class="blue">return</span> first * second;&#13;
}</pre>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> In this case, we also <strong>replaced the generic type-parameter name <code>T</code> with the more descriptive type-parameter name <code>Number</code></strong>. Now, each parameter clearly indicates that it’s required to satisfy the requirements of <strong>concept <code>Numeric</code></strong>. The function template still has only one type parameter (<code>Number</code>), so the functions arguments must have the same type; otherwise, a compilation error occurs.</p>&#13;
<h4 class="h4" id="sec15_6_3">15.6.3 Using Concepts in Abbreviated Function Templates</h4>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <a href="ch15.xhtml#fig15_3">Figure 15.3</a> introduced <strong>abbreviated function templates</strong> with the parameters declared <strong><code>auto</code></strong> so the compiler can infer the function’s parameter types. <strong>Anywhere you can use <code>auto</code> in your code, you can precede it with a concept name to constrain the allowed types</strong>.<sup><a id="ch15fn43a" href="ch15.xhtml#ch15fn43">43</a></sup> This includes</p>&#13;
<p class="footnote"><a id="ch15fn43" href="ch15.xhtml#ch15fn43a">43</a>. “Placeholder type specifiers.” Accessed June 14, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/auto">https://en.cppreference.com/w/cpp/language/auto</a></code>.</p>&#13;
<p class="bull">• abbreviated function template return types and parameter lists,</p>&#13;
<p class="bull">• <code>auto</code> local-variable definitions that infer a variable’s type from an initializer, and</p>&#13;
<p class="bull">• generic lambda expressions.</p>&#13;
<p><a href="ch15.xhtml#fig15_7">Figure 15.7</a> reimplements <code>multiply</code> as an <strong>abbreviated function template</strong>. In this case, we used <strong><span class="violet">constrained</span></strong> <span class="violet"><strong><code>auto</code></strong></span> for each parameter, using our <strong><code>Numeric</code> concept</strong> to restrict the types we can pass as arguments. We also <strong>used <code>auto</code> as the return type</strong>, so the compiler will infer it from the type of the expression in line 12.</p>&#13;
<div class="group" id="fig15_7">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro07" id="p15pro07a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_07.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Constrained multiply abbreviated function template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;concepts&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="lgreen">// Numeric concept aggregates std::integral and std::floating_point</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">templat</span>e<span class="blue">&lt;typename</span> T&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">concept</span> Numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="lgreen">// abbreviated function template with constrained auto</span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">auto</span> multiply(Numeric <span class="blue">auto</span> first, Numeric <span class="blue">auto</span> second) {&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">return</span> first * second;&#13;
<span class="cviolet"><strong>13</strong></span>   }&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>16</strong></span>      std::cout &lt;&lt; <span class="green">"Product of 5 and 3: "</span> &lt;&lt; multiply(<span class="green">5</span>, <span class="green">3</span>)&#13;
<span class="cviolet"><strong>17</strong></span>         &lt;&lt; <span class="green">"\nProduct of 7.25 and 2.0: "</span> &lt;&lt; multiply(<span class="green">7.25</span>, <span class="green">2.0</span>)&#13;
<span class="cviolet"><strong>18</strong></span>         &lt;&lt; <span class="green">"\nProduct of 5 and 7.25: "</span> &lt;&lt; multiply(<span class="green">5, 7.25</span>) &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>19</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Product of 5 and 3: 15&#13;
Product of 7.25 and 2.0: 14.5&#13;
Product of 5 and 7.25: 36.25</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.7</strong></span> | Constrained <code>multiply</code> abbreviated function template.</p>&#13;
</div>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> The key difference between this <strong>abbreviated function template</strong> and the constrained <code>multiply</code> function templates in <a href="ch15.xhtml#sec15_6_2">Section 15.6.2</a> is that the compiler treats each <strong><code>auto</code></strong> in line 11 as a <strong>separate template type parameter</strong>. Thus, <code>first</code> and <code>second</code> <strong>can have different data types</strong>, as in line 18, which passes an <code>int</code> and a <code>double</code>. Our previous <strong>concept-constrained version</strong> of <code>multiply</code> would generate compilation errors for arguments of different types. Lines 11–13 are actually equivalent to a template with <strong>two type parameters</strong>:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p853pro01" id="p853pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;Numeric Number1, Numeric Number2&gt;&#13;
<span class="blue">auto</span> multiply(Number1 first, Number2 second) {&#13;
   <span class="blue">return</span> first * second;&#13;
}</pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> If you require the same type for two or more parameters,</p>&#13;
<p class="bull">• use a regular function template rather than an abbreviated function template, and</p>&#13;
<p class="bull">• use the same type parameter name for every function parameter that must have the same type.</p>&#13;
<h4 class="h4" id="sec15_6_4">15.6.4 Concept-Based Overloading</h4>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Function templates and overloading are intimately related. <strong>When overloaded functions perform identical operations on different types, they can be expressed more compactly and conveniently using function templates</strong>. You can then write function calls with different argument types and let the compiler generate separate <strong>specializations</strong> to handle each function call appropriately. The specializations all have the same name, so the compiler uses <strong>overload resolution</strong> to invoke the proper function.</p>&#13;
<h5 class="h5" id="ch15lev3sec27">Matching Process for Overloaded Functions</h5>&#13;
<p>When determining what function to call, the compiler looks at functions and function templates to locate an existing function or generate a function-template specialization that matches the call:</p>&#13;
<p class="bull">• <strong>If there are no matches</strong>, the compiler issues an <strong>error message</strong>.</p>&#13;
<p class="bull">• <strong>If there are multiple matches</strong> for the function call, the compiler attempts to determine the <strong>best match</strong>.</p>&#13;
<p class="bull">• <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> If there’s <strong>more than one best match</strong>, the call is <strong>ambiguous</strong>, and the compiler issues an <strong>error message</strong>.<sup><a id="ch15fn44a" href="ch15.xhtml#ch15fn44">44</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn44" href="ch15.xhtml#ch15fn44a">44</a>. The compiler’s process for resolving function calls is complex. The complete details are discussed in “Working Draft, Standard for Programming Language C++—12.2 Overload Resolution.” Accessed June 12, 2021. <code><a href="https://eel.is/c++draft/over.match">https://eel.is/c++draft/over.match</a></code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec28">Overloading Function Templates</h5>&#13;
<p>You also may <strong>overload function templates</strong>. For example, you can provide other function templates with different signatures. A function template also can be overloaded by providing non-template functions with the same function name but different parameters.</p>&#13;
<h5 class="h5" id="ch15lev3sec29">Overloading Function Templates Using Concepts</h5>&#13;
<p><span class="size">20</span> <strong>With C++20, you can use concepts in function templates to select overloads based on type requirements.</strong><sup><a id="ch15fn45a" href="ch15.xhtml#ch15fn45">45</a></sup> Consider the standard functions <strong><code>std::distance</code></strong> and <strong><code>std::advance</code></strong> from the <strong><code>&lt;iterator&gt;</code> header</strong>:</p>&#13;
<p class="footnote"><a id="ch15fn45" href="ch15.xhtml#ch15fn45a">45</a>. Bjarne Stroustrup, “Concepts: The Future of Generic Programming—6 Concept Overloading,” January 31, 2017. Accessed June 14, 2021. <code><a href="http://wg21.link/p0557r0">http://wg21.link/p0557r0</a></code>.</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>std::distance</code></strong></span> calculates the number of container elements between two iterators.<sup><a id="ch15fn46a" href="ch15.xhtml#ch15fn46">46</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn46" href="ch15.xhtml#ch15fn46a">46</a>. “<code>std::distance</code>.” Accessed June 14, 2021. <code><a href="https://en.cppreference.com/w/cpp/iterator/distance">https://en.cppreference.com/w/cpp/iterator/distance</a></code>.</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>std::advance</code></strong></span> advances an iterator <em>n</em> positions from its current location in a container.<sup><a id="ch15fn47a" href="ch15.xhtml#ch15fn47">47</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn47" href="ch15.xhtml#ch15fn47a">47</a>. “<code>std::advance</code>.” Accessed June 14, 2021. <code><a href="https://en.cppreference.com/w/cpp/iterator/advance">https://en.cppreference.com/w/cpp/iterator/advance</a></code>.</p>&#13;
<p>Each of these can be implemented as <strong><em>O</em>(<em>n</em>)</strong> operations:</p>&#13;
<p class="bull">• <strong><code>std::distance</code></strong> can use <code>++</code> to iterate from a <strong>begin iterator</strong> up to but not including an <strong>end iterator</strong> and count the number of increments (<em>n</em>).</p>&#13;
<p class="bull">• <strong><code>std::advance</code></strong> can loop <em>n</em> times, incrementing the iterator once per iteration of the loop.</p>&#13;
<p>Some algorithms can be optimized for specific iterator types—both <strong><code>std::distance</code></strong> and <strong><code>std::advance</code></strong> can be implemented as <strong><em>O</em>(1)</strong> operations for <strong>random-access iterators</strong>:</p>&#13;
<p class="bull">• <strong><code>std::distance</code></strong> can use <strong><code>operator-</code></strong> to subtract a <strong>begin iterator</strong> from an <strong>end iterator</strong> to calculate the number of items between the iterators in one operation.</p>&#13;
<p class="bull">• <strong><code>std::advance</code></strong> can use <strong><code>operator+</code></strong> to add an integer <em>n</em> to an iterator, advancing the iterator <em>n</em> positions in one operation.</p>&#13;
<p><a href="ch15.xhtml#fig15_8">Figure 15.8</a> implements overloaded <code>customDistance</code> <strong>abbreviated function templates</strong>. Each requires two iterator arguments and calculates the number of elements between them. We use <strong><span class="violet">concept-based overloading</span></strong> (also called <strong><span class="violet">concept overloading</span></strong>) to enable the compiler to choose the correct overload. <strong>The compiler chooses between the overloads based on the concepts we use to constrain each template’s parameters.</strong> To distinguish between the function templates, we use the <strong>predefined <code>&lt;iterator&gt;</code> header concepts <code>std::random_access_iterator</code></strong> and <strong><code>std::input_iterator</code></strong>:</p>&#13;
<p class="bull">• The <strong><em>O</em>(<em>n</em>) <code>customDistance</code> function</strong> in lines 11–22 requires two arguments that satisfy the <strong><code>std::input_iterator</code></strong> concept.</p>&#13;
<p class="bull">• The <strong><em>O</em>(1) <code>customDistance</code> function</strong> in lines 26–30 requires two arguments that satisfy the <strong><code>std::random_access_iterator</code></strong> concept.</p>&#13;
<div class="group" id="fig15_8">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro08" id="p15pro08a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_08.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Using concepts to select overloads.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;list&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// calculate the distance (number of items) between two iterators</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="lgreen">// using input iterators; requires incrementing between iterators,</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="lgreen">// so this is an O(n) operation</span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">auto</span> customDistance(std::input_iterator <span class="blue">auto</span> begin,&#13;
<span class="cviolet"><strong>12</strong></span>      std::input_iterator <span class="blue">auto</span> end) {&#13;
<span class="cviolet"><strong>13</strong></span>      std::cout &lt;&lt; <span class="green">"Called customDistance with bidirectional iterators\n"</span>;&#13;
<span class="cviolet"><strong>14</strong></span>      std::ptrdiff_t count{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="lgreen">// increment from begin to end and count number of iterations</span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">for</span> (<span class="blue">auto</span>&amp; iter{begin}; iter != end; ++iter) {&#13;
<span class="cviolet"><strong>18</strong></span>         ++count;&#13;
<span class="cviolet"><strong>19</strong></span>      }&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">return</span> count;&#13;
<span class="cviolet"><strong>22</strong></span>   }&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>   <span class="lgreen">// calculate the distance (number of items) between two iterators</span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="lgreen">// using random-access iterators and an O(1) operation</span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="blue">auto</span> customDistance(std::random_access_iterator <span class="blue">auto</span> begin,&#13;
<span class="cviolet"><strong>27</strong></span>      std::random_access_iterator <span class="blue">auto</span> end) {&#13;
<span class="cviolet"><strong>28</strong></span>      std::cout &lt;&lt; <span class="green">"Called customDistance with random-access iterators\n"</span>;&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="blue">return</span> end - begin;&#13;
<span class="cviolet"><strong>30</strong></span>   }&#13;
<span class="cviolet"><strong>31</strong></span>&#13;
<span class="cviolet"><strong>32</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>33</strong></span>      std::array ints1{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>}; <span class="lgreen">// has random-access iterators</span>&#13;
<span class="cviolet"><strong>34</strong></span>      std::list ints2{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>}; <span class="lgreen">// has bidirectional iterators</span>&#13;
<span class="cviolet"><strong>35</strong></span>&#13;
<span class="cviolet"><strong>36</strong></span>      <span class="blue">auto</span> result1{customDistance(ints1.begin(), ints1.end())};&#13;
<span class="cviolet"><strong>37</strong></span>      std::cout &lt;&lt; <span class="green">"ints1 number of elements: "</span> &lt;&lt; result1 &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>38</strong></span>      <span class="blue">auto</span> result2{customDistance(ints2.begin(), ints2.end())};&#13;
<span class="cviolet"><strong>39</strong></span>      std::cout &lt;&lt; <span class="green">"ints2 number of elements: "</span> &lt;&lt; result2 &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>40</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Called customDistance with random-access iterators&#13;
ints1 number of elements: 5&#13;
Called customDistance with bidirectional iterators&#13;
ints2 number of elements: 3</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.8</strong></span> | Using concepts to select overloads.</p>&#13;
</div>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Lines 33–34 define an <code>array</code> and a <code>list</code>. Line 36 calls <code>customDistance</code> for the <code>array ints1</code>, which has <strong>random-access iterators</strong>. Of course, our function that requires input iterators also could receive random-access iterators. However, <strong>when multiple function templates satisfy a given function call, as in this example, the compiler calls the most constrained version</strong>,<sup><a id="ch15fn48a" href="ch15.xhtml#ch15fn48">48</a>,<a id="ch15fn49a" href="ch15.xhtml#ch15fn49">49</a></sup> so line 36 calls the <strong><em>O</em>(1) version of <code>customDistance</code></strong> in lines 26– 30. For the call in line 38, a <code>list</code>’s <strong>bidirectional iterators</strong> do not satisfy the constraints of the function template in lines 26–30. So, that version is eliminated from consideration, and the slower <em>O</em>(<em>n</em>) <code>customDistance</code> in lines 11–22 is called.</p>&#13;
<p class="footnote"><a id="ch15fn48" href="ch15.xhtml#ch15fn48a">48</a>. Hendrik Niemeyer, “An Introduction to C++20’s Concepts,” July 25, 2020. Accessed June 1, 2021. <code><a href="https://www.youtube.com/watch?v=N_kPd2OK1L8">https://www.youtube.com/watch?v=N_kPd2OK1L8</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn49" href="ch15.xhtml#ch15fn49a">49</a>. “Working Draft, Standard for Programming Language C++—13.5 Template Constraints.” Accessed June 12, 2021. <code><a href="https://eel.is/c++draft/temp.constr">https://eel.is/c++draft/temp.constr</a></code>.</p>&#13;
<h4 class="h4" id="sec15_6_5">15.6.5 <code>requires</code> Expressions</h4>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The <strong>C++ Core Guidelines recommend using standard concepts</strong>.<sup><a id="ch15fn50a" href="ch15.xhtml#ch15fn50">50</a></sup> For custom requirements that cannot be expressed via the standard ones, you can use a <span class="violet"><strong><code>requires</code></strong></span> <strong><span class="violet">expression</span></strong>, which has two forms:</p>&#13;
<p class="footnote"><a id="ch15fn50" href="ch15.xhtml#ch15fn50a">50</a>. “T.11: Whenever possible use standard concepts.” Accessed June 7, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts</a></code>.</p>&#13;
<pre class="pre">requires {&#13;
   <span class="nor"><em>requirements-definitions</em></span>&#13;
}</pre>&#13;
<p>or</p>&#13;
<pre class="pre">requires (<span class="nor"><em>parameter-list</em></span>) {&#13;
   <span class="nor"><em>requirements-definitions that optionally use the parameters</em></span>&#13;
}</pre>&#13;
<p>The <em>parameter-list</em> looks like a function’s parameter list but <strong>cannot have default arguments</strong>. The compiler uses a <code>requires</code> expression’s parameters only to check whether types satisfy the requirements defined in the expression’s braces. The braces may contain any combination of the four requirement types described below—<strong>simple</strong>, <strong>type</strong>, <strong>compound</strong> and <strong>nested</strong>. Each requirement ends with a semicolon (<code>;</code>).</p>&#13;
<h5 class="h5" id="ch15lev3sec30">Simple Requirements</h5>&#13;
<p><span class="size">20</span> A <strong><span class="violet">simple requirement</span></strong> checks whether an expression is valid. Consider the definition of the <code>&lt;ranges&gt;</code> header’s <strong><code>range</code> concept</strong>, which checks whether an object’s type represents a <strong>C++20 range</strong> with a <strong>begin iterator</strong> and an <strong>end sentinel</strong>:<sup><a id="ch15fn51a" href="ch15.xhtml#ch15fn51">51</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn51" href="ch15.xhtml#ch15fn51a">51</a>. “Working Draft, Standard for Programming Language C++—24.4.2 Ranges.” Accessed June 10, 2021. <code><a href="https://eel.is/c++draft/ranges#range.range">https://eel.is/c++draft/ranges#range.range</a></code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p857pro01" id="p857pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="blue">templat</span>e<span class="blue">&lt;class</span> T&gt;&#13;
<span class="cviolet"> <strong>2</strong></span>      <span class="blue">concept</span> range =&#13;
<span class="cviolet"> <strong>3</strong></span>         <span class="blue">requires</span>(T&amp; t) {&#13;
<span class="cviolet"> <strong>4</strong></span>            std::ranges::begin(t);&#13;
<span class="cviolet"> <strong>5</strong></span>            std::ranges::end(t);&#13;
<span class="cviolet"> <strong>6</strong></span>         <code>};</code></pre>&#13;
</div>&#13;
<p>The requirements in a <strong><code>requires</code> expression</strong> can reference the expression’s parameters and any template parameters from the <code>template</code> header. This <strong><code>range</code> concept</strong> defines a parameter <code>t</code> of type <code>T&amp;</code>. Lines 4 and 5 define <strong>simple requirements</strong> indicating that <code>t</code> is a <code>range</code> only if we can get <code>t</code>’s <strong>begin iterator</strong> and <strong>end sentinel</strong>, respectively, by passing <code>t</code> to the functions <strong><code>std::ranges::begin</code></strong> and <strong><code>std::ranges::end</code></strong>. If either of these <strong>simple requirements</strong> evaluates to <code>false</code> at compile time, then <code>t</code> is not a <code>range</code>.</p>&#13;
<p>Simple requirements can specify operator expressions. The following concept specifies operations that would be expected of any integer or floating-point arithmetic type:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p857pro02" id="p857pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;class T&gt;&#13;
   <span class="blue">concept</span> ArithmeticType =&#13;
      <span class="blue">requires</span>(T a, T b) {&#13;
         a + b;&#13;
         a - b;&#13;
         a * b;&#13;
         a / b;&#13;
         a += b;&#13;
         a -= b;&#13;
         a *= b;&#13;
         a /= b;&#13;
      };</pre>&#13;
<p><strong>We did not include the modulus (<code>%</code>) operator because it requires integer operands.</strong> Of course, built-in arithmetic types support more operations, such as implicit conversions between types, so a “real” <strong><code>ArithmeticType</code> concept</strong> would be more elaborate than this. In addition, C++ already has the <strong>type trait <code>is_arithmetic</code></strong> to test for arithmetic types.</p>&#13;
<h5 class="h5" id="ch15lev3sec31">Type Requirements</h5>&#13;
<p>A <strong><span class="violet">type requirement</span></strong> starts with <code>typename</code> followed by a type and determines whether the specified type is valid. For example, if your code requires that a template type parameter be used to specialize a <code>vector</code>, you might define a concept with a type requirement like:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p857pro03" id="p857pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;typename T&gt;&#13;
<span class="blue">concept</span> WorksWithVector = <span class="blue">requires</span> {&#13;
   <span class="blue">typename</span> std::vector&lt;T&gt;;&#13;
};</pre>&#13;
<p>A type <code>T</code> would satisfy <code>WorksWithVector</code> only if <strong><code>std::vector&lt;T&gt;</code></strong> is a valid type. If the compiler cannot specialize <code>vector</code> for type <code>T</code>, this requirement would evaluate to <code>false</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec32">Compound Requirements</h5>&#13;
<p>A <strong><span class="violet">compound requirement</span></strong> allows you to specify an expression that also has requirements on its return value. Such requirements have the form</p>&#13;
<p class="pren"><code>{</code> <em>expression</em> <code>} -&gt;</code> <em>return-type-requirement</em></p>&#13;
<p>For example, the standard library <code>&lt;iterator&gt;</code> header’s <strong><code>incrementable</code> concept</strong> contains the following <code>requires</code> expression:<sup><a id="ch15fn52a" href="ch15.xhtml#ch15fn52">52</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn52" href="ch15.xhtml#ch15fn52a">52</a>. “Working Draft, Standard for Programming Language C++—23.3.4.5 Concept <code>incrementable</code>.” Accessed June 10, 2021. <code><a href="https://eel.is/c++draft/iterator.concepts#iterator.concept.inc">https://eel.is/c++draft/iterator.concepts#iterator.concept.inc</a></code>.</p>&#13;
<pre class="pre"><span class="blue">requires</span>(I i) {&#13;
   { i++ } -&gt; same_as&lt;I&gt;;&#13;
}</pre>&#13;
<p>This requirement indicates that an <code>incrementable</code> iterator must support the postincrement operator (<code>++</code>). <strong>The <code>-&gt;</code> notation indicates a requirement on the <code>i++</code> expression’s result</strong>. In this case, the result must have the same type (<code>I</code>) as the object specified in the <code>requires</code> expression’s parameter list. The right brace in a compound requirement optionally may be followed by <code>noexcept</code> to indicate that the expression is not allowed to throw exceptions.</p>&#13;
<p>An <strong><code>incrementable</code></strong> object also must support the <strong>concept <code>weakly_incrementable</code></strong>, which among its other requirements contains the following <strong>compound requirement</strong>:</p>&#13;
<pre class="pre">{ ++i } -&gt; same_as&lt;I&gt;;</pre>&#13;
<p>So, <strong><code>incrementable</code> objects also must support pre-incrementing and the expression’s result must have the same type as the type parameter <code>I</code></strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec33">Nested Requirement</h5>&#13;
<p>A <strong><span class="violet">nested requirement</span></strong> is a <strong><code>requires</code> clause nested in a <code>requires</code> expression</strong>. You’d use these to apply existing concepts and type traits to the <code>requires</code> expression’s parameters.</p>&#13;
<h5 class="h5" id="ch15lev3sec34"><code>requires</code> <strong><code>requires</code></strong>—Ad-Hoc Constraints</h5>&#13;
<p>A <strong><code>requires</code> expression placed directly in a <code>requires</code> clause</strong> is an <strong><span class="violet">ad-hoc constraint</span></strong>. In the following <code>printRange</code> function template, we copied the <code>std::range</code> concept’s <code>requires</code> expression and placed it directly in a <code>requires</code> clause:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p858pro01" id="p858pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;<span class="blue">typename</span> T&gt;&#13;
   <span class="blue">requires</span> <span class="blue">requires</span>(T&amp; t) {&#13;
      std::ranges::begin(t);&#13;
      std::ranges::end(t);&#13;
   }&#13;
<span class="blue">void</span> printRange(<span class="blue">const</span> T&amp; range) {&#13;
   <span class="blue">for</span> (<span class="blue">const</span> <span class="blue">auto</span>&amp; item : range) {&#13;
      std::cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;&#13;
   }&#13;
}</pre>&#13;
<p>The notation <code>requires requires</code> is correct:</p>&#13;
<p class="bull">• The first <code>requires</code> introduces the <strong><code>requires</code> clause</strong> and</p>&#13;
<p class="bull">• the second <code>requires</code> introduces the <strong><code>requires</code> expression</strong>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The benefit of an ad-hoc constraint is that if you need it only once, you can define it where it’s used. <strong>Named concepts are preferred for reuse</strong>.</p>&#13;
<h4 class="h4" id="sec15_6_6"><span class="size">20</span> 15.6.6 C++20 Exposition-Only Concepts</h4>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Throughout the C++ standard document, the phrases “<strong>for the sake of exposition</strong>” or “<strong>exposition only</strong>” appear over 400 times. These are displayed in <em>italics</em> and indicate <strong>items used only for discussion purposes</strong><sup><a id="ch15fn53a" href="ch15.xhtml#ch15fn53">53</a></sup>—often to show how something can be implemented. For example, the standard uses the following <strong>exposition-only</strong> <em><strong>has-arrow</strong></em> <strong>concept</strong> in the ranges library to describe an iterator type that supports the operator <code>-&gt;</code>:<sup><a id="ch15fn54a" href="ch15.xhtml#ch15fn54">54</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn53" href="ch15.xhtml#ch15fn53a">53</a>. “Exposition-only in the C++ standard?” Answered December 28, 2015. Accessed May 10, 2021. <code><a href="https://stackoverflow.com/questions/34493104/exposition-only-in-the-c-standard">https://stackoverflow.com/questions/34493104/exposition-only-in-the-c-standard</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn54" href="ch15.xhtml#ch15fn54a">54</a>. “24.5.2 Helper concepts [range.utility.helpers].” Accessed June 25, 2021. <code><a href="https://eel.is/c++draft/range.utility">https://eel.is/c++draft/range.utility</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p859pro01" id="p859pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">template&lt;class I&gt;&#13;
   concept <em>has-arrow</em> =&#13;
      input_iterator&lt;I&gt; &amp;&amp; (is_pointer_v&lt;I&gt; ||&#13;
         requires(I i) { i.operator-&gt;(); });</pre>&#13;
<p>Similarly, the standard uses the following <strong>exposition-only</strong> <em><strong>decrementable</strong></em> <strong>concept</strong> in the ranges library to describe iterator types that support the <code>--</code> operator:<sup><a id="ch15fn55a" href="ch15.xhtml#ch15fn55">55</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn55" href="ch15.xhtml#ch15fn55a">55</a>. “24.6.4.2 Class template <code>iota_view</code> [range.iota.view].” Accessed June 25, 2021. <code><a href="https://eel.is/c++draft/range.factories#range.iota.view-2">https://eel.is/c++draft/range.factories#range.iota.view-2</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p859pro02" id="p859pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">template&lt;class I&gt;&#13;
   concept <em>decrementable</em> =&#13;
      incrementable&lt;I&gt; &amp;&amp; requires(I i) {&#13;
         { --i } -&gt; same_as&lt;I&amp;&gt;;&#13;
         { i-- } -&gt; same_as&lt;I&gt;;&#13;
      };</pre>&#13;
<p>You may wonder why <code><b><em>decrementable</em></b></code> requires <code><em>incrementable</em></code>. Recall that all iterators support <code>++</code>, so a <code><em>decrementable</em></code> iterator also must be <code><em>incrementable</em></code>.</p>&#13;
<p><span class="size">20</span> In addition to the <strong>74 predefined C++20 concepts</strong>, the standard uses <strong>31 exposition-only concepts</strong> shown in the following table. You can find each through the standard’s “Index of library concepts.”<sup><a id="ch15fn56a" href="ch15.xhtml#ch15fn56">56</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn56" href="ch15.xhtml#ch15fn56a">56</a>. “Working Draft, Standard for Programming Language C++—Index of library concepts.” Accessed May 15, 2021. <code><a href="https://eel.is/c++draft/conceptindex">https://eel.is/c++draft/conceptindex</a></code>.</p>&#13;
<div class="image"><img src="Images/859tab01.jpg" alt="Images" width="807" height="544"/></div>&#13;
<h4 class="h4" id="sec15_6_7">15.6.7 Techniques Before C++20 Concepts: SFINAE and Tag Dispatch</h4>&#13;
<p>With each new version of C++, metaprogramming gets more powerful and convenient. There’s a history of several technologies that led to C++20 concepts, including <strong>SFINAE</strong>, <strong>tag dispatch</strong> and <strong><code>constexpr if</code></strong>. (We show an example with <code>constexpr if</code> in <a href="ch15.xhtml#sec15_13_3">Section 15.13.3</a>.) For an overview of the progression through these technologies and how C++20 concepts simplify your code, see the blog post, “Notes on C++ SFINAE, Modern C++ and C++20 Concepts.”<sup><a id="ch15fn57a" href="ch15.xhtml#ch15fn57">57</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn57" href="ch15.xhtml#ch15fn57a">57</a>. Bartek Filipek, “Notes on C++ SFINAE, Modern C++ and C++20 Concepts,” April 20, 2020. Accessed June 27, 2021. <code><a href="https://www.bfilipek.com/2016/02/notes-on-c-sfinae.html">https://www.bfilipek.com/2016/02/notes-on-c-sfinae.html</a></code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec35">SFINAE—Substitution Failure Is Not an Error</h5>&#13;
<p>Earlier we mentioned that when you call a function, the compiler locates all the functions that might satisfy the function call—known as the <strong>overload set</strong>. From these overloads, the compiler chooses the best match. This process often includes <strong>specializing function templates</strong> based on a function call’s argument types.</p>&#13;
<p>Before concepts, template metaprogramming techniques involving <strong><code>std::enable_if</code></strong> were commonly used with <strong>type traits</strong> to check if a function-template argument satisfied a template’s requirements. If not, the compiler would generate an invalid function-template specialization. It would then ignore that specialization, removing it from the overload set. <strong><span class="violet">SFINAE (substitution failure is not an error)</span></strong><sup><a id="ch15fn58a" href="ch15.xhtml#ch15fn58">58</a>,<a id="ch15fn59a" href="ch15.xhtml#ch15fn59">59</a>,<a id="ch15fn60a" href="ch15.xhtml#ch15fn60">60</a></sup> describes how the compiler discards invalid template specialization code as it tries to determine the correct function to call. This technique prevents the compiler from immediately generating (potentially) lengthy lists of error messages when first specializing a template. The compiler generates error messages only if it cannot find a match for the function call in the overload set.</p>&#13;
<p class="footnote"><a id="ch15fn58" href="ch15.xhtml#ch15fn58a">58</a>. “Substitution failure is not an error.” Accessed February 4, 2021. <code><a href="https://w.wiki/yFe">https://w.wiki/yFe</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn59" href="ch15.xhtml#ch15fn59a">59</a>. Bartlomiej Filipek. “Notes on C++ SFINAE, Modern C++ and C++20 Concepts.” Accessed February 4, 2021. <code><a href="https://www.bfilipek.com/2016/02/notes-on-c-sfinae.html">https://www.bfilipek.com/2016/02/notes-on-c-sfinae.html</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn60" href="ch15.xhtml#ch15fn60a">60</a>. David Vandevoorde and Nicolai M. Josuttis (2002). <em>C++ Templates: The Complete Guide</em>. Addison-Wesley Professional.</p>&#13;
<h5 class="h5" id="ch15lev3sec36">Tag Dispatch</h5>&#13;
<p><span class="size">20</span> You can tell the compiler the version of an overloaded function to call based not only on template type parameters but also on properties of those types using the <strong><span class="violet">tag-dispatch</span></strong><sup><a id="ch15fn61a" href="ch15.xhtml#ch15fn61">61</a></sup> technique. Bjarne Stroustrup—in his paper “Concepts: The Future of Generic Program-ming”—refers to properties of types as “concepts” and calls the tag-dispatching technique <strong>concept overloading</strong> or <strong>concept-based overloading</strong>.<sup><a id="ch15fn62a" href="ch15.xhtml#ch15fn62">62</a></sup> He then discusses how C++20 concept-based overloading (<a href="ch15.xhtml#sec15_6_4">Section 15.6.4</a>) can replace tag dispatch.</p>&#13;
<p class="footnote"><a id="ch15fn61" href="ch15.xhtml#ch15fn61a">61</a>. “Generic Programming—Tag Dispatching.” Accessed January 31, 2021. <code><a href="https://www.boost.org/community/generic_programming.html#tag_dispatching">https://www.boost.org/community/generic_programming.html#tag_dispatching</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn62" href="ch15.xhtml#ch15fn62a">62</a>. Bjarne Stroustrup. “Concepts: The Future of Generic Programming (Section 6).” Accessed January 31, 2021. <code><a href="https://www.stroustrup.com/good_concepts.pdf">https://www.stroustrup.com/good_concepts.pdf</a></code>.</p>&#13;
<h3 class="h3" id="sec15_7"><span class="size">20</span> <span class="violet">15.7</span> Testing C++20 Concepts with <code>static_assert</code></h3>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">11</span> Concepts produce compile-time <code>bool</code> values, which you can test at compile-time with a C++11 <span class="violet"><strong><code>static_assert</code></strong></span> <strong><span class="violet">declaration</span></strong>.<sup><a id="ch15fn63a" href="ch15.xhtml#ch15fn63">63</a></sup> <strong><code>static_assert</code></strong> was developed to add compile-time assertion support for <strong>reporting incorrect usage of template libraries</strong>.<sup><a id="ch15fn64a" href="ch15.xhtml#ch15fn64">64</a></sup> <a href="ch15.xhtml#fig15_9">Figure 15.9</a> tests our custom <code>Numeric</code> concept from <a href="ch15.xhtml#sec15_6_1">Section 15.6.1</a>.</p>&#13;
<p class="footnote"><a id="ch15fn63" href="ch15.xhtml#ch15fn63a">63</a>. “T.150: Check that a class matches a concept using <code>static_assert</code>.” Accessed June 18, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-check-class">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-check-class</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn64" href="ch15.xhtml#ch15fn64a">64</a>. Robert Klarer, Dr. John Maddock, Brian Dawes and Howard Hinnant, “Proposal to Add Static Assertions to the Core Language (Revision 3),” October 20, 2004. Accessed July 1, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html</a></code>.</p>&#13;
<div class="group" id="fig15_9">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro09" id="p15pro09a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_09.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Testing custom concepts with static_assert.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">templat</span>e<span class="blue">&lt;typename</span> T&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">concept</span> Numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">static_assert</span>(Numeric&lt;<span class="blue">int</span>&gt;); <span class="lgreen">// OK: int is Numeric</span>&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">static_assert</span>(Numeric&lt;<span class="blue">double</span>&gt;); <span class="lgreen">// OK: double is Numeric</span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">static_assert</span>(Numeric&lt;std::string&gt;); <span class="lgreen">// error: string is not Numeric</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">fig15_09.cpp:12:4: <strong>error: static_assert failed</strong>&#13;
   static_assert(Numeric&lt;std::string&gt;); // error: string is not Numeric&#13;
   ^             ~~~~~~~~~~~~~~~~~~~~&#13;
&#13;
fig15_09.cpp:12:18: <strong>note: because does not satisfy</strong>&#13;
   static_assert(Numeric&lt;std::string&gt;); // error: string is not Numeric&#13;
                 ^&#13;
&#13;
fig15_09.cpp:7:24: <strong>note: because</strong>&#13;
concept Numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;&#13;
                       ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/&#13;
concepts:102:24: <strong>note: because evaluated to false</strong>&#13;
    concept integral = is_integral_v&lt;_Tp&gt;;&#13;
                       ^&#13;
&#13;
fig15_09.cpp:7:44: <strong>note: and</strong>&#13;
concept Numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;&#13;
                                           ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/&#13;
concepts:111:30: <strong>note: because evaluated to false</strong>&#13;
    concept floating_point = is_floating_point_v&lt;_Tp&gt;;&#13;
                             ^&#13;
&#13;
1 error generated.</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.9</strong></span> | Testing custom concepts with <code>static_assert</code>. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> When the <strong><code>static_assert</code></strong> argument is <code>false</code>, the compiler outputs an error message. If <strong><code>static_assert</code></strong> argument is <code>true</code>, the compiler does not output any messages—it simply continues compiling the code. The expression in line 10</p>&#13;
<pre class="pre"><span class="blue">static_assert</span>(Numeric&lt;<span class="blue">int</span>&gt;);</pre>&#13;
<p>specializes the <strong><code>Numeric</code> concept</strong> with type <code>int</code>. If <code>int</code> satisfies <code>Numeric</code>’s requirements, which it does, <code>Numeric&lt;int&gt;</code> evaluates to <code>true</code>, so the compiler continues compiling the code. Similarly, line 11’s <code>Numeric&lt;double&gt;</code> also evaluates to <code>true</code>.</p>&#13;
<p>However, <code>Numeric&lt;std::string&gt;</code> in line 12 evaluates to <code>false</code> because a <code>string</code> is not <code>Numeric</code>. The output window shows the error messages produced by the <strong>Clang C++</strong> compiler. We highlighted the key messages in bold and added blank lines for readability. For the <strong><code>Numeric</code> concept</strong>, the compiler tells you that</p>&#13;
<pre class="pre"><code>(aka does not satisfy</code></pre>&#13;
<p>The messages also provide more detail, saying that</p>&#13;
<pre class="pre"><code>does not satisfy</code></pre>&#13;
<p>and that</p>&#13;
<pre class="pre"><code>does not satisfy</code></pre>&#13;
<p>A <strong><code>static_assert</code></strong> declaration optionally may specify as a second argument a string to include in the error message for <code>false</code> assertions.</p>&#13;
<h3 class="h3" id="sec15_8"><span class="violet">15.8</span> Creating a Custom Algorithm</h3>&#13;
<p>We saw in <a href="ch13.xhtml#ch13">Chapters 13</a> and <a href="ch14.xhtml#ch14">14</a> that the Standard Template Library is divided into containers, iterators and algorithms. We showed algorithms operating on container elements via iterators. You can take advantage of this architecture to <strong>define custom algorithms capable of operating on any container that supports your algorithm’s iterator requirements</strong>. <a href="ch15.xhtml#fig15_10">Figure 15.10</a> defines a constrained <code>average</code> algorithm in which the argument must satisfy our custom <code>NumericInputRange</code> concept (described after the figure).</p>&#13;
<div class="group" id="fig15_10">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro10" id="p15pro10a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_10.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// A custom algorithm to calculate the average of</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// a numeric input range's elements.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;concepts&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> &lt;ranges&gt;&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="lgreen">// concept for an input range containing integer or floating-point values</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">templat</span>e<span class="blue">&lt;typename</span> T&gt;&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">concept</span> NumericInputRange = std::ranges::input_range&lt;T&gt; &amp;&amp;&#13;
<span class="cviolet"><strong>15</strong></span>      (std::integral&lt;<span class="blue">typename</span> T::value_type&gt; ||&#13;
<span class="cviolet"><strong>16</strong></span>      std::floating_point&lt;<span class="blue">typename</span> T::value_type&gt;);&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="lgreen">// calculate the average of a NumericInputRange's elements</span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="blue">auto</span> average(NumericInputRange <span class="blue">auto const</span>&amp; range) {&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">long double</span> total{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">for</span> (<span class="blue">auto</span> i{range.begin()}; i != range.end(); ++i) {&#13;
<span class="cviolet"><strong>23</strong></span>         total += *i; <span class="lgreen">// dereference iterator and add value to total</span>&#13;
<span class="cviolet"><strong>24</strong></span>      }&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>      <span class="lgreen">// divide total by the number of elements in range</span>&#13;
<span class="cviolet"><strong>27</strong></span>      <span class="blue">return</span> total / std::ranges::distance(range);&#13;
<span class="cviolet"><strong>28</strong></span>   }&#13;
<span class="cviolet"><strong>29</strong></span>&#13;
<span class="cviolet"><strong>30</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>31</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; outputInt(std::cout, <span class="green">" "</span>);&#13;
<span class="cviolet"><strong>32</strong></span>      const std::array ints{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>};&#13;
<span class="cviolet"><strong>33</strong></span>      std::cout &lt;&lt; <span class="green">"array ints: "</span>;&#13;
<span class="cviolet"><strong>34</strong></span>      std::ranges::copy(ints, outputInt);&#13;
<span class="cviolet"><strong>35</strong></span>      std::cout &lt;&lt; <span class="green">"\naverage of ints: "</span> &lt;&lt; average(ints);&#13;
<span class="cviolet"><strong>36</strong></span>&#13;
<span class="cviolet"><strong>37</strong></span>      std::ostream_iterator&lt;<span class="blue">double</span>&gt; outputDouble(std::cout, <span class="green">" "</span>);&#13;
<span class="cviolet"><strong>38</strong></span>      const std::vector doubles{<span class="green">10.1</span>, <span class="green">20.2</span>, <span class="green">35.3</span>};&#13;
<span class="cviolet"><strong>39</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nvector doubles: "</span>;&#13;
<span class="cviolet"><strong>40</strong></span>      std::ranges::copy(doubles, outputDouble);&#13;
<span class="cviolet"><strong>41</strong></span>      std::cout &lt;&lt; <span class="green">"\naverage of doubles: "</span> &lt;&lt; average(doubles);&#13;
<span class="cviolet"><strong>42</strong></span>&#13;
<span class="cviolet"><strong>43</strong></span>      std::ostream_iterator&lt;<span class="blue">long double</span>&gt; outputLongDouble(std::cout, <span class="green">" "</span>);&#13;
<span class="cviolet"><strong>44</strong></span>      const std::vector longDoubles{<span class="green">10.1L</span>, <span class="green">20.2L</span>, <span class="green">35.3L</span>};&#13;
<span class="cviolet"><strong>45</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nlist longDoubles: "</span>;&#13;
<span class="cviolet"><strong>46</strong></span>      std::ranges::copy(longDoubles, outputDouble);&#13;
<span class="cviolet"><strong>47</strong></span>      std::cout &lt;&lt; <span class="green">"\naverage of longDoubles: "</span> &lt;&lt; average(longDoubles)&#13;
<span class="cviolet"><strong>48</strong></span>         &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>49</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">array ints: 1 2 3 4 5&#13;
average of ints: 3&#13;
&#13;
vector doubles: 10.1 20.2 35.3&#13;
average of doubles: 21.8667&#13;
&#13;
list longDoubles: 10.1 20.2 35.3&#13;
average of doubles: 21.8667</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.10</strong></span> | A custom algorithm to calculate the average of a numeric input range (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec37"><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Custom <code>NumericInputRange</code> Concept</h5>&#13;
<p>Lines 13–16 define the <strong>custom <code>NumericInputRange</code> concept</strong>, which checks:</p>&#13;
<p class="bull">• whether a type satisfies the <code>input_range</code> concept (line 14), so the argument supports <strong>input iterators</strong> for reading its elements, and</p>&#13;
<p class="bull">• whether range’s elements satisfy the <code>std::integral</code> or <code>std::floating_point</code> concepts (lines 15–16), so they can be used in calculations.</p>&#13;
<p>Recall from <a href="ch13.xhtml#sec13_2_1">Section 13.2.1</a> that <strong>each standard container has a nested <code>value_type</code> alias</strong>, which indicates the container’s element type. We use this to check whether the element type satisfies this concept’s requirements. In lines 15 and 16, the notation</p>&#13;
<pre class="pre"><span class="blue">typename</span> T::value_type</pre>&#13;
<p>uses <code>typename</code> to indicate that <strong><code>T::value_type</code></strong> is an <strong>alias for the range’s element type</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec38">Custom <code>average</code> Algorithm</h5>&#13;
<p>Lines 19–28 define <code>average</code> as an <strong>abbreviated function template</strong>. We constrained its <code>range</code> parameter with our <strong>custom concept <code>NumericInputRange</code></strong>, so this algorithm can operate on any <strong><code>input_range</code></strong> of numeric values. To ensure that <code>average</code> can support any built-in numeric type, we use a <code>long double</code> (line 20) to store the sum of the elements. Lines 22–24 iterate through the <code>range</code> from its <strong><code>begin</code> iterator</strong> up to, but not including, its <strong><code>end</code> iterator</strong> and add each element’s value to the total. Then line 27 divides the <code>total</code> by the range’s number of elements, as determined by the <strong><code>std::ranges::distance</code> algorithm</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec39">Using Our <code>average</code> Algorithm on Standard Library Containers</h5>&#13;
<p>To show that our custom <code>average</code> algorithm can process various standard library containers, lines 32, 38 and 44 define an <code>array</code> of <code>int</code>s, a <code>vector</code> of <code>double</code>s and a <code>list</code> of <code>long double</code>s, respectively. Lines 35, 41 and 47 call <code>average</code> with each of these containers to calculate the averages of their elements.</p>&#13;
<h3 class="h3" id="sec15_9"><span class="violet">15.9</span> Creating a Custom Container and Iterators</h3>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <a href="ch11.xhtml#ch11">Chapter 11</a> introduced our <code>MyArray</code> class to demonstrate special member functions and operator overloading. The C++ Core Guidelines recommend that you implement as a template any class representing a container of values or range of values.<sup><a id="ch15fn65a" href="ch15.xhtml#ch15fn65">65</a></sup> So, here, we’ll implement a <code>MyArray</code> class template and enhance it using various STL conventions.<sup><a id="ch15fn66a" href="ch15.xhtml#ch15fn66">66</a></sup> We’ll also define <strong>custom iterators</strong> so <code>MyArray</code> objects can be used with various standard library algorithms.</p>&#13;
<p class="footnote"><a id="ch15fn65" href="ch15.xhtml#ch15fn65a">65</a>. “T.3: Use templates to express containers and ranges.” Accessed June 20, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-cont">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-cont</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn66" href="ch15.xhtml#ch15fn66a">66</a>. Jonathan Boccara, “Make Your Containers Follow the Conventions of the STL,” April 24, 2018. Accessed May 24, 2021. <code><a href="https://www.fluentcpp.com/2018/04/24/following-conventions-stl/">https://www.fluentcpp.com/2018/04/24/following-conventions-stl/</a></code>.</p>&#13;
<p>Our goal here is to give you a sense of what’s involved in creating STL-like containers. Achieving full STL compatibility and backward compatibility with prior C++ language versions involves lots of <strong>conditional compilation directives</strong> beyond this book’s scope. If you’d like to build reusable STL-like containers, study the code provided by the compiler vendors, and check out the research sources cited in our footnotes. <a href="ch15.xhtml#fig15_11">Figure 15.11</a> defines our <code>MyArray</code> class template and its custom iterators. We broke the figure into several parts for discussion.</p>&#13;
<h5 class="h5" id="ch15lev3sec40">Single Header File</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> One change you’ll notice from <a href="ch11.xhtml#ch11">Chapter 11</a>’s <code>MyArray</code> class is that <strong>the entire class and its custom iterators are defined in a single header</strong>, which is typical of class templates. <strong>The compiler needs the complete definition where the template is used in order to specialize it.</strong> Also, defining member functions inside the class template definition simplifies the syntax—you do not need <code>template</code> headers on each member function.</p>&#13;
<h5 class="h5" id="ch15lev3sec41"><code>MyArray</code> Supports Bidirectional Iterator</h5>&#13;
<p>We modeled this example after the standard library’s <strong><code>array</code></strong> class template, which uses a compile-time allocated, fixed-size, <strong>built-in array</strong>. As we discussed in <a href="ch13.xhtml#sec13_3">Section 13.3</a>, pointers into such arrays satisfy all the requirements of random-access iterators. For this example, however, we’ll implement <strong>custom bidirectional iterators</strong> using class templates. The iterator architecture we use was inspired by the <strong>Microsoft open-source C++ standard library <code>array</code></strong> implementation,<sup><a id="ch15fn67a" href="ch15.xhtml#ch15fn67">67</a></sup> which <strong>defines two iterator classes</strong>:</p>&#13;
<p class="footnote"><a id="ch15fn67" href="ch15.xhtml#ch15fn67a">67</a>. “<code>array</code> standard header.” Latest commit (i.e., when the file was last updated) February 24, 2021. Accessed May 24, 2021. <code><a href="https://github.com/microsoft/STL/blob/main/stl/inc/array">https://github.com/microsoft/STL/blob/main/stl/inc/array</a></code>.</p>&#13;
<p class="bull">• one for <strong>iterators that manipulate <code>const</code> objects</strong>, and</p>&#13;
<p class="bull">• one for <strong>iterators that manipulate non-<code>const</code> objects</strong>.</p>&#13;
<p>You can view their implementation at:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p865pro01" id="p865pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://github.com/microsoft/STL/blob/main/stl/inc/array</pre>&#13;
<p>We defined the following custom iterator classes:</p>&#13;
<p class="bull">• Our <strong><code>ConstIterator</code></strong> class represents <strong>read-only bidirectional iterator</strong>.</p>&#13;
<p class="bull">• Our <strong><code>Iterator</code></strong> class represents a <strong>read/write bidirectional iterator</strong>.</p>&#13;
<p>The <strong>GNU</strong> and <strong>Clang</strong> <code>array</code> implementations simply use pointers for their <strong><code>array</code></strong> iterators. You can see their implementations at</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p866pro01" id="p866pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/&#13;
   include/std/array</pre>&#13;
<p>and</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p866pro02" id="p866pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">https://github.com/llvm/llvm-project/blob/main/libcxx/include/array</pre>&#13;
<h5 class="h5" id="ch15lev3sec42">Why We Implemented Bidirectional Rather Than Random-Access Iterators</h5>&#13;
<p>Recall from our introduction to iterators in <a href="ch13.xhtml#sec13_3">Section 13.3</a> that various levels of iterators are supported by STL containers. The most powerful are <strong>random-access iterators</strong>. Most standard library algorithms operate on ranges of container elements, and <strong>only 12 algorithms require random-access iterators</strong>—<code>shuffle</code> and 11 sorting-related algorithms. <strong><code>MyArray</code>’s bidirectional iterators enable most standard library algorithms to process <code>MyArray</code> objects</strong>. Random-access iterators have many additional requirements<sup><a id="ch15fn68a" href="ch15.xhtml#ch15fn68">68</a></sup> shown in the table below. As an exercise, you could enhance <code>MyArray</code>’s custom iterators with these capabilities to make them <strong>random-access iterators</strong>.</p>&#13;
<p class="footnote"><a id="ch15fn68" href="ch15.xhtml#ch15fn68a">68</a>. “23.3.4.13 Concept <code>random_access_iterator</code> [iterator.concept.random.access].” Accessed June 27, 2021. <code><a href="https://eel.is/c++draft/iterator.concept.random.access">https://eel.is/c++draft/iterator.concept.random.access</a></code>.</p>&#13;
<div class="image"><img src="Images/866tab01.jpg" alt="Images" width="787" height="572"/></div>&#13;
<h5 class="h5" id="ch15lev3sec43">Basic Iterator Requirements</h5>&#13;
<p>All iterators must support:<sup><a id="ch15fn69a" href="ch15.xhtml#ch15fn69">69</a>,<a id="ch15fn70a" href="ch15.xhtml#ch15fn70">70</a>,<a id="ch15fn71a" href="ch15.xhtml#ch15fn71">71</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn69" href="ch15.xhtml#ch15fn69a">69</a>. “C++ named requirements: LegacyIterator,” Accessed May 24, 2021. <code><a href="https://en.cppreference.com/w/cpp/named_req/Iterator">https://en.cppreference.com/w/cpp/named_req/Iterator</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn70" href="ch15.xhtml#ch15fn70a">70</a>. Triangles, “Writing a custom iterator in modern C++,” December 19, 2020. Accessed May 24, 2021. <code><a href="https://internalpointers.com/post/writing-custom-iterators-modern-cpp">https://internalpointers.com/post/writing-custom-iterators-modern-cpp</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn71" href="ch15.xhtml#ch15fn71a">71</a>. David Gorski, "Custom STL Compatible Iterators," March 2, 2019. Accessed May 24, 2021. <code><a href="https://davidgorski.ca/posts/stl-iterators/">https://davidgorski.ca/posts/stl-iterators/</a></code>.</p>&#13;
<p class="bull">• default construction,</p>&#13;
<p class="bull">• copy construction,</p>&#13;
<p class="bull">• copy assignment,</p>&#13;
<p class="bull">• destruction, and</p>&#13;
<p class="bull">• swapping.</p>&#13;
<p>We implement our iterator classes using the “<strong>Rule of Zero</strong>” (<a href="ch11.xhtml#sec11_6_6">Section 11.6.6</a>), letting the compiler generate the <strong>copy constructor</strong>, <strong>copy assignment operator</strong>, <strong>move constructor</strong>, <strong>move assignment operator</strong> and <strong>destructor</strong> special member functions.</p>&#13;
<h4 class="h4" id="sec15_9_1">15.9.1 Class Template <code>ConstIterator</code></h4>&#13;
<p>Lines 14–76 of <a href="ch15.xhtml#fig15_11">Fig. 15.11</a> define the <strong>class template <code>ConstIterator</code></strong>, which class <code>MyArray</code> uses to create <strong>read-only iterators</strong>. The template has one type parameter <code>T</code> (line 14), representing a <code>MyArray</code>’s element type. Each <code>ConstIterator</code> points to an element of that type.</p>&#13;
<div class="group" id="fig15_11">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro11" id="p15pro11a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 15.11: MyArray.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Class template MyArray with custom iterators implemented</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// by class templates ConstIterator and Iterator</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#pragma</span> once&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;initializer_list&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> &lt;memory&gt;&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">#include</span> &lt;utility&gt;&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="lgreen">// class template ConstIterator for a MyArray const iterator</span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt;&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">class</span> ConstIterator {&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="lgreen">// public iterator nested type names</span>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="blue">using</span> iterator_category = std::bidirectional_iterator_tag;&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">using</span> difference_type = std::ptrdiff_t;&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">using</span> value_type = T;&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">using</span> pointer = <span class="blue">const</span> value_type*;&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">using</span> reference = <span class="blue">const</span> value_type&amp;;&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="lgreen">// default constructor</span>&#13;
<span class="cviolet"><strong>25</strong></span>      ConstIterator() : m_ptr{<span class="blue">nullptr</span>} {}&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>      <span class="lgreen">// initialize a ConstIterator with a pointer into a MyArray</span>&#13;
<span class="cviolet"><strong>28</strong></span>      ConstIterator(pointer p) : m_ptr{p} {}&#13;
<span class="cviolet"><strong>29</strong></span>&#13;
<span class="cviolet"><strong>30</strong></span>      <span class="lgreen">// OPERATIONS ALL ITERATORS MUST PROVIDE</span>&#13;
<span class="cviolet"><strong>31</strong></span>      <span class="lgreen">// increment the iterator to the next element and</span>&#13;
<span class="cviolet"><strong>32</strong></span>      <span class="lgreen">// return a reference to the iterator</span>&#13;
<span class="cviolet"><strong>33</strong></span>      ConstIterator&amp; operator++() <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>34</strong></span>         ++m_ptr;&#13;
<span class="cviolet"><strong>35</strong></span>         <span class="blue">return</span> *this;&#13;
<span class="cviolet"><strong>36</strong></span>      }&#13;
<span class="cviolet"><strong>37</strong></span>&#13;
<span class="cviolet"><strong>38</strong></span>      <span class="lgreen">// increment the iterator to the next element and</span>&#13;
<span class="cviolet"><strong>39</strong></span>      <span class="lgreen">// return the iterator before the increment</span>&#13;
<span class="cviolet"><strong>40</strong></span>      ConstIterator operator++(int) <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>41</strong></span>         ConstIterator temp{*thi<span class="blue">s};</span>&#13;
<span class="cviolet"><strong>42</strong></span>         ++(*thi<span class="blue">s);</span>&#13;
<span class="cviolet"><strong>43</strong></span>         <span class="blue">return</span> temp;&#13;
<span class="cviolet"><strong>44</strong></span>      }&#13;
<span class="cviolet"><strong>45</strong></span>&#13;
<span class="cviolet"><strong>46</strong></span>      <span class="lgreen">// OPERATIONS INPUT ITERATORS MUST PROVIDE</span>&#13;
<span class="cviolet"><strong>47</strong></span>      <span class="lgreen">// return a const reference to the element m_ptr points to</span>&#13;
<span class="cviolet"><strong>48</strong></span>      reference <span class="blue">operator</span>*() <span class="blue">const</span> <span class="blue">noexcept</span> {<span class="blue">return</span> *m_ptr;}&#13;
<span class="cviolet"><strong>49</strong></span>&#13;
<span class="cviolet"><strong>50</strong></span>      <span class="lgreen">// return a const pointer to the element m_ptr points to</span>&#13;
<span class="cviolet"><strong>51</strong></span>      pointer <span class="blue">operator</span>-&gt;() <span class="blue">const</span> <span class="blue">noexcept</span> {<span class="blue">return</span> m_ptr;}&#13;
<span class="cviolet"><strong>52</strong></span>&#13;
<span class="cviolet"><strong>53</strong></span>      <span class="lgreen">// &lt;=&gt; operator automatically supports equality/relational operators.</span>&#13;
<span class="cviolet"><strong>54</strong></span>      <span class="lgreen">// Only == and != are needed for bidirectional iterators.</span>&#13;
<span class="cviolet"><strong>55</strong></span>      <span class="lgreen">// This implementation would support the &lt;, &lt;=, &gt; and &gt;= required</span>&#13;
<span class="cviolet"><strong>56</strong></span>      <span class="lgreen">// by random-access iterators.</span>&#13;
<span class="cviolet"><strong>57</strong></span>      <span class="blue">auto operator</span>&lt;=&gt;(<span class="blue">const</span> ConstIterator&amp; other) <span class="blue">const</span> <span class="blue">noexcept</span> = <span class="blue">default</span>;&#13;
<span class="cviolet"><strong>58</strong></span>&#13;
<span class="cviolet"><strong>59</strong></span>      <span class="lgreen">// OPERATIONS BIDIRECTIONAL ITERATORS MUST PROVIDE</span>&#13;
<span class="cviolet"><strong>60</strong></span>      <span class="lgreen">// decrement the iterator to the previous element and</span>&#13;
<span class="cviolet"><strong>61</strong></span>      <span class="lgreen">// return a reference to the iterator</span>&#13;
<span class="cviolet"><strong>62</strong></span>      ConstIterator&amp; <span class="blue">operator</span>--() <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>63</strong></span>         --m_ptr;&#13;
<span class="cviolet"><strong>64</strong></span>         <span class="blue">return</span> *<span class="blue">this</span>;&#13;
<span class="cviolet"><strong>65</strong></span>      }&#13;
<span class="cviolet"><strong>66</strong></span>&#13;
<span class="cviolet"><strong>67</strong></span>      <span class="lgreen">// decrement the iterator to the previous element and</span>&#13;
<span class="cviolet"><strong>68</strong></span>      <span class="lgreen">// return the iterator before the deccrement</span>&#13;
<span class="cviolet"><strong>69</strong></span>      ConstIterator <span class="blue">operator</span>--(<span class="blue">int</span>) <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>70</strong></span>      ConstIterator temp{*thi<span class="blue">s};</span>&#13;
<span class="cviolet"><strong>71</strong></span>         --(*thi<span class="blue">s);</span>&#13;
<span class="cviolet"><strong>72</strong></span>         <span class="blue">return</span> temp;&#13;
<span class="cviolet"><strong>73</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>74</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>75</strong></span>      pointer m_ptr;&#13;
<span class="cviolet"><strong>76</strong></span>   };&#13;
<span class="cviolet"><strong>77</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.11</strong></span> | Class template <code>MyArray</code> with custom iterators implemented by class templates <code>ConstIterator</code> and <code>Iterator</code>—class <code>ConstIterator</code>. (Part 3 of 3.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec44">Standard Iterator Nested Type Names</h5>&#13;
<p>Lines 18–22 define type aliases for the <strong>nested type names that the C++ standard library expects in iterator classes</strong>:<sup><a id="ch15fn72a" href="ch15.xhtml#ch15fn72">72</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn72" href="ch15.xhtml#ch15fn72a">72</a>. “23.3.2.3 Iterator traits.” Accessed June 30, 2021. <code><a href="https://eel.is/c++draft/iterators#iterator.traits">https://eel.is/c++draft/iterators#iterator.traits</a></code>.</p>&#13;
<p class="bull">• <span class="size">20</span> <strong><code>iterator_category</code></strong>: The iterator’s category (<a href="ch13.xhtml#sec13_3_2">Section 13.3.2</a>), specified here as the type <strong><code>std::bidirectional_iterator_tag</code></strong> from header <code>&lt;iterator&gt;</code>. This “<code>tag</code>” type indicates <strong>bidirectional iterators</strong>. The standard library algorithms use type traits and C++20 concepts to confirm that a container’s iterators have the correct category for use with each algorithm.</p>&#13;
<p class="bull">• <strong><code>difference_type</code></strong>: The result type of subtracting one <code>ConstIterator</code> from another—<strong><code>std::ptrdiff_t</code></strong> is the result type for pointer subtraction.</p>&#13;
<p class="bull">• <strong><code>value_type</code></strong>: The element type to which a <code>ConstIterator</code> points.</p>&#13;
<p class="bull">• <strong><code>pointer</code></strong>: The type of a pointer to a <code>const</code> object of the <code>value_type</code>. The <code>Const-Iterator</code>’s data member (line 75) is declared with this type.</p>&#13;
<p class="bull">• <strong><code>reference</code></strong>: The type of a reference to a <code>const</code> object of the <code>value_type</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec45">Constructors</h5>&#13;
<p>Class <code>ConstIterator</code> provides a no-argument constructor that initializes a <code>ConstIterator</code> to <code>nullptr</code> (line 25), and a constructor that initializes a <code>ConstIterator</code> from a <code>pointer</code> to an element (line 28). <strong>The class’s copy and move constructors are autogenerated.</strong></p>&#13;
<h5 class="h5" id="ch15lev3sec46"><code>++</code> Operators</h5>&#13;
<p>Lines 33–36 and 40–44 define the preincrement and postincrement operators required by all iterators. The preincrement operator aims the iterator’s <code>m_ptr</code> member at the next element and returns a reference to the incremented iterator. The postincrement operator aims the iterator’s <code>m_ptr</code> member at the next element and returns a copy of the iterator before the increment.</p>&#13;
<h5 class="h5" id="ch15lev3sec47">Overloaded * and -&gt; Operators</h5>&#13;
<p>Semantically, iterators are like pointers, so they must overload the <code>*</code> and <code>-&gt;</code> operators (lines 48 and 51). The overloaded <code>operator*</code> dereferences <code>m_ptr</code> to access the element the iterator currently points to and returns a <code>reference</code> to that element. The overloaded <code>operator-&gt;</code> returns <code>m_ptr</code> as a <code>pointer</code> to that element.</p>&#13;
<h5 class="h5" id="ch15lev3sec48">Bidirectional Iterator Comparisons</h5>&#13;
<p><strong>Bidirectional iterators</strong> must be comparable with <code>==</code> and <code>!=</code>. Here we used the <strong>compiler-generated three-way comparison operator <code>&lt;=&gt;</code></strong> (line 57) to support <code>ConstIterator</code> comparisons. If you enhance our iterator classes to make them random-access iterators, this implementation also enables comparisons with the operators &lt;, &lt;=, &gt; and &gt;=, as required by random-access iterators.</p>&#13;
<h5 class="h5" id="ch15lev3sec49"><code>--</code> Operators</h5>&#13;
<p>Lines 62–65 and 69–73 define the predecrement and postdecrement operators required by bidirectional iterators. These operators work like the <code>++</code> operators, but aim the <code>m_ptr</code> member at the previous element.</p>&#13;
<h4 class="h4" id="sec15_9_2">15.9.2 Class Template <code>Iterator</code></h4>&#13;
<p>Lines 80–136 of <a href="ch15.xhtml#fig15_11">Fig. 15.11</a> define the <strong>class template <code>Iterator</code></strong>, which class <code>MyArray</code> uses to create <strong>read/write iterators</strong>. The template has one type parameter <code>T</code> (line 80), representing a <code>MyArray</code>’s element type. Class <code>Iterator</code> inherits from class <code>ConstIterator&lt;T&gt;</code> (line 81).</p>&#13;
<div class="group" id="fig15_11a">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro11-a" id="p15pro11-a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>78</strong></span>   <span class="lgreen">// class template Iterator for a MyArray non-const iterator;</span>&#13;
<span class="cviolet"><strong>79</strong></span>   <span class="lgreen">// redefines several inherited operators to return non-const results</span>&#13;
<span class="cviolet"><strong>80</strong></span>   <span class="blue">template</span> &lt;typename T&gt;&#13;
<span class="cviolet"><strong>81</strong></span>   <span class="blue">class</span> Iterator : <span class="blue">public</span> ConstIterator&lt;T&gt; {&#13;
<span class="cviolet"><strong>82</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>83</strong></span>      <span class="lgreen">// public iterator nested type names</span>&#13;
<span class="cviolet"><strong>84</strong></span>      <span class="blue">using</span> iterator_category = std::bidirectional_iterator_tag;&#13;
<span class="cviolet"><strong>85</strong></span>      <span class="blue">using</span> difference_type = std::ptrdiff_t;&#13;
<span class="cviolet"><strong>86</strong></span>      <span class="blue">using</span> value_type = T;&#13;
<span class="cviolet"><strong>87</strong></span>      <span class="blue">using</span> pointer = value_type*;&#13;
<span class="cviolet"><strong>88</strong></span>      <span class="blue">using</span> reference = value_type&amp;;&#13;
<span class="cviolet"><strong>89</strong></span>&#13;
<span class="cviolet"><strong>90</strong></span>      <span class="lgreen">// inherit ConstIterator constructors</span>&#13;
<span class="cviolet"><strong>91</strong></span>      <span class="blue">using</span> ConstIterator&lt;T&gt;::ConstIterator;&#13;
<span class="cviolet"><strong>92</strong></span>&#13;
<span class="cviolet"><strong>93</strong></span>      <span class="lgreen">// OPERATIONS ALL ITERATORS MUST PROVIDE</span>&#13;
<span class="cviolet"><strong>94</strong></span>      <span class="lgreen">// increment the iterator to the next element and</span>&#13;
<span class="cviolet"><strong>95</strong></span>      <span class="lgreen">// return a reference to the iterator</span>&#13;
<span class="cviolet"><strong>96</strong></span>      Iterator&amp; <span class="blue">operator</span>++() <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>97</strong></span>         ConstIterator&lt;T&gt;::operator++(); <span class="lgreen">// call base-class version</span>&#13;
<span class="cviolet"><strong>98</strong></span>         <span class="blue">return</span> *<span class="blue">this</span>;&#13;
<span class="cviolet"><strong>99</strong></span>      }&#13;
<span class="cviolet"><strong>100</strong></span>&#13;
<span class="cviolet"><strong>101</strong></span>     <span class="lgreen">// increment the iterator to the next element and</span>&#13;
<span class="cviolet"><strong>102</strong></span>     <span class="lgreen">// return the iterator before the increment</span>&#13;
<span class="cviolet"><strong>103</strong></span>     Iterator <span class="blue">operator</span>++(<span class="blue">int</span>) <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>104</strong></span>        Iterator temp{*thi<span class="blue">s};</span>&#13;
<span class="cviolet"><strong>105</strong></span>        ConstIterator&lt;T&gt;::ope<span class="blue">rator++(</span>); <span class="lgreen">// call base-class version</span>&#13;
<span class="cviolet"><strong>106</strong></span>        <span class="blue">return</span> temp;&#13;
<span class="cviolet"><strong>107</strong></span>     <code>}</code>&#13;
<span class="cviolet"><strong>108</strong></span>&#13;
<span class="cviolet"><strong>109</strong></span>     <span class="lgreen">// OPERATIONS INPUT ITERATORS MUST PROVIDE</span>&#13;
<span class="cviolet"><strong>110</strong></span>     <span class="lgreen">// return a const reference to the element m_ptr points to; this</span>&#13;
<span class="cviolet"><strong>111</strong></span>     <span class="lgreen">// operator returns a non-const reference for output iterator support</span>&#13;
<span class="cviolet"><strong>112</strong></span>     reference <span class="blue">operator</span>*() <span class="blue">const noexcept</span> {&#13;
<span class="cviolet"><strong>113</strong></span>        <span class="blue">return</span> const_cast&lt;reference&gt;(ConstIterator&lt;T&gt;::<span class="blue">operator</span>*());&#13;
<span class="cviolet"><strong>114</strong></span>     }&#13;
<span class="cviolet"><strong>115</strong></span>&#13;
<span class="cviolet"><strong>116</strong></span>     <span class="lgreen">// return a const pointer to the element m_ptr points</span> <span class="lgreen">to</span>&#13;
<span class="cviolet"><strong>117</strong></span>     <span class="blue">pointer</span> <span class="blue">operator</span>-&gt;() <span class="blue">const noexcept</span> {&#13;
<span class="cviolet"><strong>118</strong></span>        <span class="blue">return const_cast</span>&lt;pointer&gt;(ConstIterator&lt;T&gt;::<span class="blue">operator</span>-&gt;());&#13;
<span class="cviolet"><strong>119</strong></span>     }&#13;
<span class="cviolet"><strong>120</strong></span>&#13;
<span class="cviolet"><strong>121</strong></span>     <span class="lgreen">// OPERATIONS BIDIRECTIONAL ITERATORS MUST PROVIDE</span>&#13;
<span class="cviolet"><strong>122</strong></span>     <span class="lgreen">// decrement the iterator to the previous element and</span>&#13;
<span class="cviolet"><strong>123</strong></span>     <span class="lgreen">// return a reference to the iterator</span>&#13;
<span class="cviolet"><strong>124</strong></span>     Iterator&amp; <span class="blue">operator</span>--() <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>125</strong></span>        ConstIterator&lt;T&gt;::operator--(); <span class="lgreen">// call base-class version</span>&#13;
<span class="cviolet"><strong>126</strong></span>        <span class="blue">return</span> *<span class="blue">this</span>;&#13;
<span class="cviolet"><strong>127</strong></span>     }&#13;
<span class="cviolet"><strong>128</strong></span>&#13;
<span class="cviolet"><strong>129</strong></span>     <span class="lgreen">// decrement the iterator to the previous element and</span>&#13;
<span class="cviolet"><strong>130</strong></span>     <span class="lgreen">// return the iterator before the decrement</span>&#13;
<span class="cviolet"><strong>131</strong></span>     Iterator <span class="blue">operator</span>--(<span class="blue">int</span>) <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>132</strong></span>        Iterator temp{*thi<span class="blue">s};</span>&#13;
<span class="cviolet"><strong>133</strong></span>        ConstIterator&lt;T&gt;::ope<span class="blue">rator--(</span>); <span class="lgreen">// call base-class version</span>&#13;
<span class="cviolet"><strong>134</strong></span>        <span class="blue">return</span> temp;&#13;
<span class="cviolet"><strong>135</strong></span>     }&#13;
<span class="cviolet"><strong>136</strong></span>  };&#13;
<span class="cviolet"><strong>137</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.11</strong></span> | Class template <code>MyArray</code> with custom iterators implemented by class templates <code>ConstIterator</code> and <code>Iterator</code>—class <code>Iterator</code>. (Part 2 of 2.).</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec50">Standard Iterator Nested Type Names</h5>&#13;
<p>Lines 84–88 define <strong>type aliases for the nested type names that the C++ standard library expects in iterator classes</strong>. Class template <code>Iterator</code> defines <strong>read/write iterators</strong>, so lines 87–88 define the <code>pointer</code> and <code>reference</code> <strong>type aliases</strong> without <code>const</code>. Pointers and references of these types can be used to write new values into elements.</p>&#13;
<h5 class="h5" id="ch15lev3sec51">Constructors</h5>&#13;
<p><code>ConstIterator</code>’s constructors know how to initialize <code>Iterator</code>’s inherited <code>m_ptr</code> member, so line 91 simply inherits the base class’s constructors.</p>&#13;
<h5 class="h5" id="ch15lev3sec52"><code>++</code> and <strong><code>--</code></strong> Operators</h5>&#13;
<p>Lines 96–99, 103–107, 124–127 and 131–135 define the preincrement, postincrement, predecrement and postdecrement operators. Each simply calls <strong><code>ConstIterator</code></strong>’s corresponding version. The prefix operators <code>return</code> a reference to the updated <code>Iterator</code>. The postfix operators return a copy of the <code>Iterator</code> before the increment or decrement.</p>&#13;
<h5 class="h5" id="ch15lev3sec53">Overloaded * and -&gt; Operators</h5>&#13;
<p>Lines 112–114 and 117–119 overload the <code>*</code> and <code>-&gt;</code> operators. Each calls <strong><code>ConstIterator</code></strong>’s version. Those versions return a pointer or reference that views the <code>value_type</code> as <code>const</code>. Since <code>Iterator</code>s should allow both reading and writing element values, lines 113 and 118 use <span class="violet"><strong><code>const_cast</code></strong></span> to <strong>cast away the <code>const</code>-ness</strong> (that is, remove the <strong><code>const</code></strong>) of the pointer or reference returned by the base-class overloaded operators.</p>&#13;
<h4 class="h4" id="sec15_9_3">15.9.3 Class Template <code>MyArray</code></h4>&#13;
<p>Lines 140–210 of <a href="ch15.xhtml#fig15_11">Fig. 15.11</a> define our simplified <code>MyArray</code> class template. We removed some overloaded operators and various special member functions presented in <a href="ch11.xhtml#ch11">Chapter 11</a> to focus on the <strong>container</strong> and its <strong>iterators</strong>. To mimic the <code>std::array</code> class template, we define <code>MyArray</code> as an <strong>aggregate type</strong> (<a href="ch09.xhtml#ch09lev1sec21">Section 9.21</a>), which requires all non-<code>static</code> data to be <code>public</code>. So, we defined <code>MyArray</code> using a <code>struct</code>, which has <code>public</code> members by default. Also, rather than using dynamic memory allocation, the new <code>MyArray</code> class template’s data is stored as a fixed-size built-in array (line 209) allocated at compilation time.</p>&#13;
<div class="group" id="fig15_11b">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro11-b" id="p15pro11-ba">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>138</strong></span>   <span class="lgreen">// class template MyArray contains a fixed-size T[SIZE] array;</span>&#13;
<span class="cviolet"><strong>139</strong></span>   <span class="lgreen">// MyArray is an aggregate type with public data, like std::array</span>&#13;
<span class="cviolet"><strong>140</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> T, size_t SIZE&gt;&#13;
<span class="cviolet"><strong>141</strong></span>   <span class="blue">struct</span> MyArray {&#13;
<span class="cviolet"><strong>142</strong></span>      <span class="lgreen">// type names used in standard library containers</span>&#13;
<span class="cviolet"><strong>143</strong></span>      <span class="blue">using</span> value_type = T;&#13;
<span class="cviolet"><strong>144</strong></span>      <span class="blue">using</span> size_type = size_t;&#13;
<span class="cviolet"><strong>145</strong></span>      <span class="blue">using</span> difference_type = ptrdiff_t;&#13;
<span class="cviolet"><strong>146</strong></span>      <span class="blue">using</span> pointer = value_type*;&#13;
<span class="cviolet"><strong>147</strong></span>      <span class="blue">using</span> const_pointer = <span class="blue">const</span> value_type*;&#13;
<span class="cviolet"><strong>148</strong></span>      <span class="blue">using</span> reference = value_type&amp;;&#13;
<span class="cviolet"><strong>149</strong></span>      <span class="blue">using</span> const_reference = <span class="blue">const</span> value_type&amp;;&#13;
<span class="cviolet"><strong>150</strong></span>&#13;
<span class="cviolet"><strong>151</strong></span>      <span class="lgreen">// iterator type names used in standard library containers</span>&#13;
<span class="cviolet"><strong>152</strong></span>      <span class="blue">using</span> iterator = Iterator&lt;T&gt;;&#13;
<span class="cviolet"><strong>153</strong></span>      <span class="blue">using</span> const_iterator = ConstIterator&lt;T&gt;;&#13;
<span class="cviolet"><strong>154</strong></span>      <span class="blue">using</span> reverse_iterator = std::reverse_iterator&lt;iterator&gt;;&#13;
<span class="cviolet"><strong>155</strong></span>      <span class="blue">using</span> const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;&#13;
<span class="cviolet"><strong>156</strong></span>&#13;
<span class="cviolet"><strong>157</strong></span>      <span class="lgreen">// Rule of Zero: MyArray</span>&#13;
<span class="cviolet"><strong>158</strong></span>&#13;
<span class="cviolet"><strong>159</strong></span>      <span class="blue">constexpr</span> size_type size() <span class="blue">const</span> <span class="blue">noexcept</span> {<span class="blue">return</span> SIZE;} <span class="lgreen">// return size</span>&#13;
<span class="cviolet"><strong>160</strong></span>&#13;
<span class="cviolet"><strong>161</strong></span>      <span class="lgreen">// member functions that return iterators</span>&#13;
<span class="cviolet"><strong>162</strong></span>      iterator begin() {<span class="blue">return</span> iterator{&amp;m_data[<span class="green">0</span>]};}&#13;
<span class="cviolet"><strong>163</strong></span>      iterator end() {<span class="blue">return</span> iterator{&amp;m_data[<span class="green">0</span>] + size()};}&#13;
<span class="cviolet"><strong>164</strong></span>      const_iterator begin() <span class="blue">const</span> {<span class="blue">return</span> const_iterator{&amp;m_data[<span class="green">0</span>]};}&#13;
<span class="cviolet"><strong>165</strong></span>      const_iterator end() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>166</strong></span>         <span class="blue">return</span> const_iterator{&amp;m_data[<span class="green">0</span>] + size()};&#13;
<span class="cviolet"><strong>167</strong></span>      }&#13;
<span class="cviolet"><strong>168</strong></span>      const_iterator cbegin() <span class="blue">const</span> {<span class="blue">return</span> begin();}&#13;
<span class="cviolet"><strong>169</strong></span>      const_iterator cend() <span class="blue">const</span> {<span class="blue">return</span> end();}&#13;
<span class="cviolet"><strong>170</strong></span>&#13;
<span class="cviolet"><strong>171</strong></span>      <span class="lgreen">// member functions that return reverse iterators</span>&#13;
<span class="cviolet"><strong>172</strong></span>      reverse_iterator rbegin() {<span class="blue">return</span> reverse_iterator{end()};}&#13;
<span class="cviolet"><strong>173</strong></span>      reverse_iterator rend() {<span class="blue">return</span> reverse_iterator{begin()};}&#13;
<span class="cviolet"><strong>174</strong></span>      const_reverse_iterator rbegin() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>175</strong></span>         <span class="blue">return</span> const_reverse_iterator{cend()};&#13;
<span class="cviolet"><strong>176</strong></span>      }&#13;
<span class="cviolet"><strong>177</strong></span>      const_reverse_iterator rend() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>178</strong></span>         <span class="blue">return</span> const_reverse_iterator{cbegin()};&#13;
<span class="cviolet"><strong>179</strong></span>      }&#13;
<span class="cviolet"><strong>180</strong></span>      const_reverse_iterator crbegin() <span class="blue">const</span> {<span class="blue">return</span> rbegin();}&#13;
<span class="cviolet"><strong>181</strong></span>      const_reverse_iterator crend() <span class="blue">const</span> {<span class="blue">return</span> rend();}&#13;
<span class="cviolet"><strong>182</strong></span>&#13;
<span class="cviolet"><strong>183</strong></span>      <span class="lgreen">// auto-generated three-way comparison operator</span>&#13;
<span class="cviolet"><strong>184</strong></span>      <span class="blue">auto</span> operator&lt;=&gt;(<span class="blue">const</span> MyArray&amp; t) <span class="blue">const</span> <span class="blue">noexcept</span> = <span class="blue">default</span>;&#13;
<span class="cviolet"><strong>185</strong></span>&#13;
<span class="cviolet"><strong>186</strong></span>      <span class="lgreen">// overloaded subscript operator for non-const MyArrays;</span>&#13;
<span class="cviolet"><strong>187</strong></span>      <span class="lgreen">// reference return creates a modifiable lvalue</span>&#13;
<span class="cviolet"><strong>188</strong></span>      T&amp; operator[](size_type index) {&#13;
<span class="cviolet"><strong>189</strong></span>         <span class="lgreen">// check for index out-of-range error</span>&#13;
<span class="cviolet"><strong>190</strong></span>         <span class="blue">if</span> (index &gt;= SIZE) {&#13;
<span class="cviolet"><strong>191</strong></span>            <span class="blue">throw</span> std::out_of_range{<span class="green">"Index out of range"</span>};&#13;
<span class="cviolet"><strong>192</strong></span>         }&#13;
<span class="cviolet"><strong>193</strong></span>&#13;
<span class="cviolet"><strong>194</strong></span>         <span class="blue">return</span> m_data[index]; <span class="lgreen">// reference return</span>&#13;
<span class="cviolet"><strong>195</strong></span>      }&#13;
<span class="cviolet"><strong>196</strong></span>&#13;
<span class="cviolet"><strong>197</strong></span>      <span class="lgreen">// overloaded subscript operator for const MyArrays;</span>&#13;
<span class="cviolet"><strong>198</strong></span>      <span class="lgreen">// const reference return creates a non-modifiable lvalue</span>&#13;
<span class="cviolet"><strong>199</strong></span>      <span class="blue">const</span> T&amp; operator[](size_type index) <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>200</strong></span>         <span class="lgreen">// check for subscript out-of-range error</span>&#13;
<span class="cviolet"><strong>201</strong></span>         <span class="blue">if</span> (index &gt;= SIZE) {&#13;
<span class="cviolet"><strong>202</strong></span>            <span class="blue">throw</span> std::out_of_range{<span class="green">"Index out of range"</span>};&#13;
<span class="cviolet"><strong>203</strong></span>         }&#13;
<span class="cviolet"><strong>204</strong></span>&#13;
<span class="cviolet"><strong>205</strong></span>         <span class="blue">return</span> m_data[index]; <span class="lgreen">// returns copy of this element</span>&#13;
<span class="cviolet"><strong>206</strong></span>      }&#13;
<span class="cviolet"><strong>207</strong></span>&#13;
<span class="cviolet"><strong>208</strong></span>      <span class="lgreen">// like std::array the data is public to make this an aggregate type</span>&#13;
<span class="cviolet"><strong>209</strong></span>      T m_data[SIZE]; <span class="lgreen">// built-in array of type T with SIZE elements</span>&#13;
<span class="cviolet"><strong>210</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>211</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.11</strong></span> | Class template <code>MyArray</code> with custom iterators implemented by class templates <code>ConstIterator</code> and <code>Iterator</code>—class <code>MyArray</code>. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec54"><code>MyArray</code>’s <strong><code>template</code></strong> Header</h5>&#13;
<p>The <code>template</code> header (line 140) indicates that <code>MyArray</code> is a <strong>class template</strong>. The header specifies two parameters:</p>&#13;
<p class="bull">• <code>T</code> represents the <code>MyArray</code>’s element type.</p>&#13;
<p class="bull">• <code>SIZE</code> is a <strong><span class="violet">non-type template parameter</span></strong> that’s treated as a compile-time constant. We use <code>SIZE</code> to represent the <code>MyArray</code>’s number of elements.</p>&#13;
<p>Line 209 creates a built-in array of type <code>T</code> containing <code>SIZE</code> elements. Though we do not do so here, non-type template parameters can have <strong>default arguments</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec55">Standard Container Nested Type Names</h5>&#13;
<p>Lines 143–155 define type aliases for the nested type names that the C++ standard library expects in container classes. The types for <strong>reverse iterators</strong> are specific to containers with <strong>bidirectional</strong> or <strong>random-access iterators</strong>:<sup><a id="ch15fn73a" href="ch15.xhtml#ch15fn73">73</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn73" href="ch15.xhtml#ch15fn73a">73</a>. “Table 73: Container requirements [tab:container.req].” Accessed June 30, 2021. <code><a href="https://eel.is/c++draft/container.requirements#tab:container.req">https://eel.is/c++draft/container.requirements#tab:container.req</a></code>.</p>&#13;
<p class="bull">• <strong><code>value_type</code></strong>: The container’s element type (<code>T</code>).</p>&#13;
<p class="bull">• <strong><code>size_type</code></strong>: The type used representing the container’s number of elements.</p>&#13;
<p class="bull">• <strong><code>difference_type</code></strong>: The result type when subtracting iterators.</p>&#13;
<p class="bull">• <strong><code>pointer</code></strong>: The type of a pointer to a <code>value_type</code> object.</p>&#13;
<p class="bull">• <strong><code>const_pointer</code></strong>: The type of a pointer to a <code>const value_type</code> object.</p>&#13;
<p class="bull">• <strong><code>reference</code></strong>: The type of a reference to a <code>value_type</code> object.</p>&#13;
<p class="bull">• <strong><code>const_reference</code></strong>: The type of a reference to a <code>const value_type</code> object.</p>&#13;
<p class="bull">• <strong><code>iterator</code></strong>: <code>MyArray</code>’s read/write iterator type (<code>Iterator&lt;T&gt;</code>).</p>&#13;
<p class="bull">• <strong><code>const_iterator</code></strong>: <code>MyArray</code>’s read-only iterator type (<code>ConstIterator&lt;T&gt;</code>).</p>&#13;
<p class="bull">• <strong><code>reverse_iterator</code></strong>: <code>MyArray</code>’s read/write iterator type for iterating backward from the end of a <code>MyArray</code>. The <strong><span class="violet">iterator adapter</span></strong> <span class="violet"><strong><code>std::reverse_iterator</code></strong></span> creates a reverse-iterator type from its bidirectional or random-access iterator type argument.</p>&#13;
<p class="bull">• <strong><code>const_reverse_iterator</code></strong>: <code>MyArray</code>’s read-only iterator type for moving backward from the end of the <code>MyArray</code>—<code>std::reverse_iterator</code> creates a <code>const</code> reverse-iterator type from its bidirectional or random-access iterator type argument.</p>&#13;
<h5 class="h5" id="ch15lev3sec56"><code>MyArray</code> Member Functions That Return Iterators</h5>&#13;
<p>Lines 162–181 define the <code>MyArray</code> member functions that return <code>MyArray</code>’s various kinds of iterators and reverse iterators. The key functions are <code>begin</code> and <code>end</code> in lines 162–167:</p>&#13;
<p class="bull">• <strong><code>begin</code></strong> (line 162) returns an <code>iterator</code> pointing to the <code>MyArray</code>’s first element.</p>&#13;
<p class="bull">• <strong><code>end</code></strong> (line 163) returns an <code>iterator</code> pointing to the <code>MyArray</code>’s last element.</p>&#13;
<p class="bull">• <strong><code>begin</code></strong> (line 164) is an overload that returns a <code>const_iterator</code> pointing to the <code>MyArray</code>’s first element.</p>&#13;
<p class="bull">• <strong><code>end</code></strong> (line 165–167) is an overload that returns a <code>const_iterator</code> pointing to the <code>MyArray</code>’s last element.</p>&#13;
<p>The other member functions that return iterators call these <code>begin</code> and <code>end</code> functions:</p>&#13;
<p class="bull">• <strong><code>cbegin</code></strong> and <strong><code>cend</code></strong> (lines 168–169) call the versions of <code>begin</code> and <code>end</code> that return <code>const</code> iterators.</p>&#13;
<p class="bull">• <strong><code>rbegin</code></strong> and <strong><code>rend</code></strong> (lines 172–173) produce <code>reverse_iterator</code>s based on the <code>iterator</code>s returned by the <strong>non-<code>const</code> versions of <code>begin</code> and <code>end</code></strong>.</p>&#13;
<p class="bull">• <strong><code>rbegin</code></strong> and <strong><code>rend</code></strong> (lines 174–179) are overloads that produce <code>const_reverse_iterator</code>s based on the <code>const_iterator</code>s returned by the <strong><code>const</code> versions of <code>begin</code> and <code>end</code></strong>.</p>&#13;
<p class="bull">• <strong><code>crbegin</code></strong> and <strong><code>crend</code></strong> (lines 180–181) return the <code>const_reverse_iterator</code>s from calling the <code>const</code> versions of <code>rbegin</code> and <code>rend</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec57">MyArray Overloaded Operators</h5>&#13;
<p>Lines 184, 188–195 and 199–206 define <code>MyArray</code>’s overloaded operators. Though we won’t use it in this example, the <strong>compiler-generated three-way comparison operator</strong> (line 184) enables you to compare entire <code>MyArray</code> objects of the same specialized type. The overloaded <code>operator[]</code> member functions are identical to those in <a href="ch11.xhtml#ch11">Chapter 11</a>’s <code>MyArray</code> class, but we now use the <strong>non-type template parameter <code>SIZE</code></strong> (lines 190 and 201) when determining whether an <code>index</code> is outside a <code>MyArray</code>’s bounds.</p>&#13;
<h4 class="h4" id="sec15_9_4">15.9.4 MyArray Deduction Guide for Braced Initialization</h4>&#13;
<p>As you’ve seen, you can initialize a <code>std::array</code> using <strong>class-template argument deduction (CTAD)</strong>. For example, when the compiler sees the statement:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p875pro01" id="p875pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">std::array ints{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>};</pre>&#13;
<p>it infers that the <code>array</code>’s element type is <code>int</code> because all the initializers are <code>int</code>s, and it counts the initializers to determine the <code>array</code>’s size. For our <code>MyArray</code> class template, we did not define a constructor that can receive any number of arguments. However, we can define a <strong><span class="violet">deduction guide</span></strong><sup><a id="ch15fn74a" href="ch15.xhtml#ch15fn74">74</a></sup> (lines 213–214) that shows the compiler how to deduce a <code>MyArray</code>’s type from a braced initializer. Then the compiler can use <strong>aggregate initialization</strong> to place the initializers into our <code>MyArray</code> aggregate type’s built-in array data member.</p>&#13;
<p class="footnote"><a id="ch15fn74" href="ch15.xhtml#ch15fn74a">74</a>. "Class template argument deduction." Accessed June 30, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">https://en.cppreference.com/w/cpp/language/class_template_argument_deduction</a></code>.</p>&#13;
<div class="group" id="fig15_11c">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro11-c" id="p15pro11-ca">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>212</strong></span>   <span class="lgreen">// deduction guide to enable MyArrays to be brace initialized</span>&#13;
<span class="cviolet"><strong>213</strong></span>   <span class="blue">templat</span>e<span class="blue">&lt;typename</span> T, <span class="blue">typename</span>... U&gt;&#13;
<span class="cviolet"><strong>214</strong></span>   MyArray(T first, U... rest) -&gt; MyArray&lt;T, <span class="green">1</span> + <span class="blue">sizeof</span>...(U)&gt;;</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.11</strong></span> | Class template <code>MyArray</code> with custom iterators implemented by class templates <code>ConstIterator</code> and <code>Iterator</code>—<code>MyArray</code> deduction guide.</p>&#13;
</div>&#13;
<p>A deduction guide is a <strong>template</strong>. This deduction guide’s <code>template</code> header uses <strong>variadic template syntax (<code>...</code>)</strong>, which we discuss extensively in Section 15.15. Line 213 indicates that the compiler is looking for an initializer list that</p>&#13;
<p class="bull">• contains at least one initializer, specified by <code>typename T</code>, and</p>&#13;
<p class="bull">• may contain any number of additional initializers, as specified by <code>typename... U</code>, which is known as a <strong><span class="violet">parameter pack</span></strong>.</p>&#13;
<p>To the left of the <code>-&gt;</code> in line 214, you specify what looks like the beginning of a <code>MyArray</code> constructor that receives its first argument in the <code>T</code> parameter named <code>first</code> and all other arguments in the <code>U...</code> parameter named <code>rest</code>. To the right of the <code>-&gt;</code> you tell the compiler that when it sees a <code>MyArray</code> initialized using <strong>class template argument deduction</strong>, it should deduce that we want to create a <code>MyArray</code> with elements of type <code>T</code> and with its size specified by</p>&#13;
<pre class="pre"><span class="green">1</span> + <span class="blue">sizeof</span>...(U)</pre>&#13;
<p>In this expression,</p>&#13;
<p class="bull">• <code>1</code> is the initializer list’s minimum number of initializers and</p>&#13;
<p class="bull">• <span class="size">11</span> <code>sizeof...(U)</code> uses C++11’s compile-time <span class="violet"><strong><code>sizeof...</code></strong></span> <strong><span class="violet">operator</span></strong> to determine the additional number of initializers the compiler placed in the parameter pack <code>U</code>.</p>&#13;
<p>Our deduction guide is a simplified version of those provided by GNU and Clang for their <code>std::array</code> implementations. Their deduction guides also ensure that all the initializers have the same type. You can view GNU’s and Clang’s deduction guides in their respective <code>&lt;array&gt;</code> headers at:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p876pro01" id="p876pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/&#13;
   include/std/array</pre>&#13;
<p>and</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p876pro02" id="p876pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">https://github.com/llvm/llvm-project/blob/main/libcxx/include/array</pre>&#13;
<h4 class="h4" id="sec15_9_5">15.9.5 Using <code>MyArray</code> and Its Custom Iterators with <code>std::ranges</code> Algorithms</h4>&#13;
<p><a href="ch15.xhtml#fig15_12">Figure 15.12</a> creates three <code>MyArray</code>s that store <code>int</code>s, <code>double</code>s and <code>string</code>s, respectively, then uses them with various <strong><code>std::ranges</code></strong> algorithms that require <strong>input</strong>, <strong>output</strong>, <strong>forward</strong> or <strong>bidirectional iterators</strong>. We also use a <strong>range-based <code>for</code> statement</strong> to iterate through a <strong><code>MyArray</code></strong>. <code>MyArray</code> has <strong>bidirectional iterators</strong>, so we also could use it with our custom <code>average</code> algorithm in <a href="ch15.xhtml#fig15_10">Fig. 15.10</a>, which required only <strong>input iterators</strong>.</p>&#13;
<div class="group" id="fig15_12">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro12" id="p15pro12a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_12.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Using MyArray with range-based for and with</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// C++ standard library algorithms.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"MyArray.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; outputInt{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>10</strong></span>      std::ostream_iterator&lt;<span class="blue">double</span>&gt; outputDouble{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>11</strong></span>      std::ostream_iterator&lt;std::string&gt; outputString{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      std::cout &lt;&lt; <span class="green">"Displaying MyArrays with std::ranges::copy, "</span>&#13;
<span class="cviolet"><strong>14</strong></span>         &lt;&lt; <span class="green">"which requires input iterators:\n"</span>;&#13;
<span class="cviolet"><strong>15</strong></span>      MyArray ints{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>, <span class="green">7</span>, <span class="green">8</span>};&#13;
<span class="cviolet"><strong>16</strong></span>      std::cout &lt;&lt; <span class="green">"ints: "</span>;&#13;
<span class="cviolet"><strong>17</strong></span>      std::ranges::copy(ints, outputInt);&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      MyArray doubles{<span class="green">1.1</span>, <span class="green">2.2</span>, <span class="green">3.3</span>, <span class="green">4.4</span>, <span class="green">5.5</span>};&#13;
<span class="cviolet"><strong>20</strong></span>      std::cout &lt;&lt; <span class="green">"\ndoubles: "</span>;&#13;
<span class="cviolet"><strong>21</strong></span>      std::ranges::copy(doubles, outputDouble);&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>      MyArray strings{<span class="green">"red"</span>, <span class="green">"orange"</span>, <span class="green">"yellow"</span>};&#13;
<span class="cviolet"><strong>24</strong></span>      std::cout &lt;&lt; "\nstrings: ";&#13;
<span class="cviolet"><strong>25</strong></span>      std::ranges::copy(strings, outputString);&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nDisplaying a MyArray with a range-based for "</span>&#13;
<span class="cviolet"><strong>28</strong></span>         &lt;&lt; <span class="green">"statement, which requires input iterators:\n"</span>;&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="blue">for</span> (<span class="blue">const auto</span>&amp; item : doubles) {&#13;
<span class="cviolet"><strong>30</strong></span>         std::cout &lt;&lt; item &lt;&lt; <span class="green">" "</span>;&#13;
<span class="cviolet"><strong>31</strong></span>      }&#13;
<span class="cviolet"><strong>32</strong></span>&#13;
<span class="cviolet"><strong>33</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nCopying a MyArray with std::ranges::copy, "</span>&#13;
<span class="cviolet"><strong>34</strong></span>         &lt;&lt; <span class="green">"which requires input iterators:\n"</span>;&#13;
<span class="cviolet"><strong>35</strong></span>      MyArray&lt;std::string, strings.size()&gt; strings2{};&#13;
<span class="cviolet"><strong>36</strong></span>      std::ranges::copy(strings, strings2.begin());&#13;
<span class="cviolet"><strong>37</strong></span>      std::cout &lt;&lt; <span class="green">"strings2 after copying from strings1: "</span>;&#13;
<span class="cviolet"><strong>38</strong></span>      std::ranges::copy(strings2, outputString);&#13;
<span class="cviolet"><strong>39</strong></span>&#13;
<span class="cviolet"><strong>40</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nFinding min and max elements in a MyArray "</span>&#13;
<span class="cviolet"><strong>41</strong></span>         &lt;&lt; <span class="green">"with std::ranges::minmax_element, which requires "</span>&#13;
<span class="cviolet"><strong>42</strong></span>         &lt;&lt; <span class="green">"forward iterators:\n"</span>;&#13;
<span class="cviolet"><strong>43</strong></span>      <span class="blue">const auto</span>&amp; [min, max] {std::ranges::minmax_element(strings)};&#13;
<span class="cviolet"><strong>44</strong></span>      std::cout &lt;&lt; <span class="green">"min and max elements of strings are: "</span>&#13;
<span class="cviolet"><strong>45</strong></span>         &lt;&lt; *min &lt;&lt; <span class="green">", "</span> &lt;&lt; *max;&#13;
<span class="cviolet"><strong>46</strong></span>&#13;
<span class="cviolet"><strong>47</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nReversing a MyArray with std::ranges::reverse, "</span>&#13;
<span class="cviolet"><strong>48</strong></span>         &lt;&lt; <span class="green">"which requires bidirectional iterators:\n"</span>;&#13;
<span class="cviolet"><strong>49</strong></span>      std::ranges::reverse(ints);&#13;
<span class="cviolet"><strong>50</strong></span>      std::cout &lt;&lt; <span class="green">"ints after reversing elements: "</span>;&#13;
<span class="cviolet"><strong>51</strong></span>      std::ranges::copy(ints, outputInt);&#13;
<span class="cviolet"><strong>52</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>53</strong></span>   }</pre>&#13;
<pre class="pre1">Displaying MyArrays with std::ranges::copy, which requires input iterators:&#13;
ints: 1 2 3 4 5 6 7 8&#13;
doubles: 1.1 2.2 3.3 4.4 5.5&#13;
strings: red orange yellow&#13;
&#13;
Displaying a MyArray with a range-based for statement, which requires input&#13;
iterators:&#13;
1.1 2.2 3.3 4.4 5.5&#13;
&#13;
Copying a MyArray with std::ranges::copy, which requires input iterators:&#13;
strings2 after copying from strings1: red orange yellow&#13;
&#13;
Finding min and max elements in a MyArray with std::ranges::minmax_element,&#13;
which requires forward iterators:&#13;
min and max elements of strings are: orange, yellow&#13;
&#13;
Reversing a MyArray with std::ranges::reverse, which requires bidirectional&#13;
iterators:&#13;
ints after reversing elements: 8 7 6 5 4 3 2 1</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.12</strong></span> | Using <code>MyArray</code> with range-based <code>for</code> and with C++ standard library algorithms. (Part 3 of 3.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec58">Creating <code>MyArray</code>s and Displaying Them with <strong><code>std::ranges::copy</code></strong></h5>&#13;
<p>In lines 13–25, we create three <code>MyArray</code>s (lines 15, 19 and 23), using <strong>class template argument deduction</strong> to infer their element types and sizes. Lines 17, 21 and 25 display each <code>MyArray</code>’s contents using <strong><code>std::ranges::copy</code></strong>. This algorithm’s first argument is an <strong><code>input_range</code></strong> which requires the range to have <strong>input iterators</strong>, so <code>MyArray</code>s are compatible with this algorithm because they have more powerful <strong>bidirectional iterators</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec59">Displaying a <code>MyArray</code> with a Range-Based <strong><code>for</code></strong> Statement</h5>&#13;
<p><span class="size">17</span> Lines 29–31 display the contents of <code>MyArray doubles</code> using a range-based <code>for</code>, which requires only <strong>input iterators</strong>, so it <strong>works with any iterable object</strong>, including <code>MyArray</code>s. In this case, the <code>MyArray doubles</code> is not a <code>const</code> object, so the <code>MyArray</code>’s read/write iterators are used. <strong>If you have a non-<code>const</code> object that you want to treat as <code>const</code>, you can create a <code>const</code> view of the non-<code>const</code> object by passing it to C++17’s</strong> <span class="violet"><strong><code>std::as_const</code></strong></span> <strong><span class="violet">function</span></strong>. For example, this example’s range-based <code>for</code> does not modify <code>doubles</code>’ elements, so we could have written line 29 as</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p878pro01" id="p878pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">auto</span>&amp; item : std::as_const(doubles)) {</pre>&#13;
<p>In this case, <code>item</code>’s type will be inferred as a reference to a <code>const double</code> element.</p>&#13;
<h5 class="h5" id="ch15lev3sec60">Copying a <code>MyArray</code> with <strong><code>std::ranges::copy</code></strong></h5>&#13;
<p>Line 35 creates a new <code>MyArray</code> into which we’ll copy the <code>MyArray strings</code>’ elements. Line 36 uses <strong><code>std::ranges::copy</code></strong> to copy <code>strings</code>’ elements into <code>strings2</code>. The algorithm uses an <strong>input iterator</strong> to read each element from <code>strings</code> and an <strong>output iterator</strong> to specify where to write the element into <code>strings2</code>. <code>MyArray</code>’s <strong>non-<code>const</code> bidirectional iterators</strong> support both reading (input) and writing (output), so one <code>MyArray</code> can be copied into another of the same specialized type with <strong><code>std::ranges::copy</code></strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec61">Finding the Minimum and Maximum Elements in a <code>MyArray</code> with <strong><code>std::ranges::minmax_element</code></strong></h5>&#13;
<p>Line 43 uses the <strong><code>std::ranges::minmax_element</code></strong> algorithm to get iterators pointing to the elements containing a <code>MyArray</code>’s minimum and maximum values. This algorithm requires a <strong><code>forward_range</code></strong>, which provides <strong>forward iterators</strong>. <code>MyArray</code>’s <strong>bidirectional iterators</strong> are more powerful than <strong>forward iterators</strong>, so the algorithm can operate on a <code>MyArray</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec62">Copying a <code>MyArray</code> with <strong><code>std::ranges::copy</code></strong></h5>&#13;
<p>Line 49 reverses <code>MyArray ints</code>’ elements using the <strong><code>std::ranges::reverse</code></strong> algorithm, which requires a <strong><code>bidirectional_range</code></strong> with <strong>bidirectional iterators</strong>. These are the exact iterators provided by <code>MyArray</code>, so the algorithm can operate on a <code>MyArray</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec63">Attempting to Use <code>MyArray</code> with <strong><code>std::ranges::sort</code></strong></h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <code>MyArray</code>’s iterators do not support all the features of <strong>random-access iterators</strong>, so we <strong>cannot pass a <code>MyArray</code> to algorithms that require them</strong>. To prove this, we wrote a short program containing only the following statements that create a <code>MyArray</code> of <code>int</code>s then attempt to sort it with <strong><code>std::ranges::sort</code></strong>, which requires <strong>random-access iterators</strong>:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p879pro01" id="p879pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">MyArray integers{<span class="green">10</span>, <span class="green">2</span>, <span class="green">33</span>, <span class="green">4</span>, <span class="green">7</span>, <span class="green">1</span>, <span class="green">80</span>};&#13;
std::ranges::sort(integers);</pre>&#13;
<p>The <strong>Clang</strong> compiler produced the error messages in the output window below. We highlighted key messages in bold and added some blank lines for readability. The messages clearly indicate that the code does not compile</p>&#13;
<pre class="pre"><strong><code>because</code></strong></pre>&#13;
<p>and, in turn,</p>&#13;
<pre class="pre"><strong><code>because not satisfy</code></strong></pre>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p879pro02" id="p879pro02a">Click here to view code image</a></p>&#13;
<pre class="pre1">/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/rang-&#13;
es_algo.h:2030:7: <strong>note: candidate template ignored: constraints not satisfied</strong>&#13;
[with _Range = MyArray&lt;int, 7&gt; &amp;, _Comp = std::ranges::less, _Proj =&#13;
std::identity]&#13;
      operator()(_Range&amp;&amp; __r, _Comp __comp = {}, _Proj __proj = {}) const&#13;
      ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/rang-&#13;
es_algo.h:2026:14: <strong>note: because dom_access_range</strong>&#13;
    template&lt;random_access_range _Range,&#13;
             ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/&#13;
range_access.h:924:37: <strong>note: because erator&lt;int&gt;</strong>&#13;
      = bidirectional_range&lt;_Tp&gt; &amp;&amp; random_access_iterator&lt;iterator_t&lt;_Tp&gt;&gt;;&#13;
                                    ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/iter-&#13;
ator_concepts.h:591:10: note: because cept&lt;Iterator&lt;int&gt; &gt;, std::random_ac-&#13;
cess_iterator_tag&gt;&#13;
      &amp;&amp; derived_from&lt;__detail::__iter_concept&lt;_Iter&gt;,&#13;
         ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/con-&#13;
cepts:67:28: note: because std::bidirectional_iterator_tag)&#13;
    concept derived_from = __is_base_of(_Base, _Derived)&#13;
                           ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/&#13;
rang8least 2 arguments, but 1 was provided&#13;
      operator()(_Iter __first, _Sent __last,&#13;
      ^&#13;
&#13;
1 error generated.</pre>&#13;
<h3 class="h3" id="sec15_10"><span class="violet">15.10</span> Default Arguments for Template Type Parameters</h3>&#13;
<p>A type parameter also can specify a <strong><span class="violet">default type argument</span></strong>. For example, the C++ stan-dard’s <strong><code>stack</code> container adapter</strong> class template begins with:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p880pro01" id="p880pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span> &lt;<span class="blue">class</span> T, <span class="blue">class</span> Container = deque&lt;T&gt;&gt;</pre>&#13;
<p>which specifies that a <code>stack</code> uses a <code>deque</code> by default to store the <code>stack</code>’s elements of type <code>T</code>. When the compiler sees the declaration</p>&#13;
<pre class="pre">stack&lt;<span class="blue">int</span>&gt; values;</pre>&#13;
<p>it <strong>specializes <code>stack</code> for type <code>int</code></strong> and uses the specialization to instantiate the object named <code>values</code>. The <code>stack</code>’s elements are stored in a <strong><code>deque&lt;int&gt;</code></strong>.</p>&#13;
<p><span class="size">11</span> <strong>Default type parameters</strong> must be the rightmost (trailing) parameters in a template’s type-parameter list. When you instantiate a template with two or more default arguments, if an omitted argument is not the rightmost, all type parameters to the right of it also must be omitted. <strong>C++11 added the ability to use default type arguments for template type parameters in function templates.</strong></p>&#13;
<h3 class="h3" id="sec15_11"><span class="violet">15.11</span> Variable Templates</h3>&#13;
<p><span class="size">14</span> You’ve specialized function templates and class templates to define groups of related functions and classes, respectively. C++14 added <strong><span class="violet">variable templates</span></strong>, which can be specialized to define groups of related variables. <strong>When placed at class scope</strong> (inside a class but outside its member functions), <strong>variable templates define <code>static</code> class variables</strong>.</p>&#13;
<p><span class="size">17</span> You used several <strong>predefined variable templates</strong> in <a href="ch15.xhtml#fig15_6">Fig. 15.6</a>’s type traits demonstration. C++17 added convenient <strong>variable templates for accessing each type trait’s <code>value</code> member</strong>. For example, rather than testing whether a type <code>T</code> is an integral type with:</p>&#13;
<pre class="pre"><code>is_integral&lt;T&gt;::value</code></pre>&#13;
<p>we can use the corresponding <strong>variable template</strong>:</p>&#13;
<pre class="pre"><code>is_integral_v&lt;T&gt;</code></pre>&#13;
<p>which is defined in the standard as:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p880pro02" id="p880pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">template</span>&lt;class T&gt;&#13;
<span class="blue">inline constexpr bool</span> is_arithmetic_v = is_arithmetic&lt;T&gt;::value;</pre>&#13;
<p><span class="size">17</span> <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> This variable template defines an <code>inline bool</code> variable that evaluates to a <strong>compile-time constant</strong> (indicated by <code>constexpr</code>). C++17 added <code>inline</code> variables to better support header-only libraries, which can be included in multiple source-code files—known as <strong>compilation units</strong>—within the same application.<sup><a id="ch15fn75a" href="ch15.xhtml#ch15fn75">75</a></sup> When you define a regular variable in a header, including that header more than once in an application results in <strong>multiple definition errors</strong> for that variable. On the other hand, <strong>identical <code>inline</code> variable definitions are allowed in separate compilation units within the same application</strong>.<sup><a id="ch15fn76a" href="ch15.xhtml#ch15fn76">76</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn75" href="ch15.xhtml#ch15fn75a">75</a>. Alex Pomeranz, “6.8 — Global constants and inline variables,” January 3, 2020. Accessed June 13, 2021. <code><a href="https://www.learncpp.com/cpp-tutorial/global-constants-and-inline-variables/">https://www.learncpp.com/cpp-tutorial/global-constants-and-inline-variables/</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn76" href="ch15.xhtml#ch15fn76a">76</a>. "<code>inline</code> specifier.” Accessed June 24, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/inline">https://en.cppreference.com/w/cpp/language/inline</a></code>.</p>&#13;
<h3 class="h3" id="sec15_12"><span class="violet">15.12</span> Variadic Templates and Fold Expressions</h3>&#13;
<p><span class="size">11</span> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Before C++11, each class template or function template had a fixed number of template parameters. Defining a class or function template with <strong>different numbers of template parameters</strong> required a separate template definition for each case. C++11 <strong><span class="violet">variadic templates</span> accept any number of arguments</strong>. <strong>They simplify template programming because you can provide one variadic function template rather than many overloaded ones with different numbers of parameters.</strong></p>&#13;
<h4 class="h4" id="sec15_12_1">15.12.1 <code>tuple</code> Variadic Class Template</h4>&#13;
<p><span class="size">11</span> C++11’s <code>tuple</code> class (from header <span class="violet"><strong><code>&lt;tuple&gt;</code></strong></span>) is a <strong>variadic-class-template generalization of class template <code>pair</code></strong> (introduced in <a href="ch13.xhtml#sec13_9">Section 13.9</a>. A <span class="violet"><strong><code>tuple</code></strong></span> is a collection of related values, possibly of mixed types. <a href="ch15.xhtml#fig15_13">Figure 15.13</a> demonstrates several <code>tuple</code> capabilities.</p>&#13;
<div class="group" id="fig15_13">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro13" id="p15pro13a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_13.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Manipulating tuples.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;tuple&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// type alias for a tuple representing a hardware part's inventory</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">using</span> Part = std::tuple&lt;<span class="blue">int</span>, std::string, <span class="blue">int</span>, <span class="blue">double</span>&gt;;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="lgreen">// return a part's inventory tuple</span>&#13;
<span class="cviolet"><strong>12</strong></span>   Part getInventory<span class="blue">(int</span> partNumber) {&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">using</span> <span class="blue">namespace</span> std::string_literals; <span class="lgreen">// for string object literals</span>&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="blue">switch</span> (partNumber) {&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">case</span> 1:&#13;
<span class="cviolet"><strong>17</strong></span>         <span class="blue">return</span> {<span class="green">1</span>, <span class="green">"Hammer"</span>s, <span class="green">32</span>, <span class="green">9.95</span>}; <span class="lgreen">// return a Part tuple</span>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="blue">case</span> 2:&#13;
<span class="cviolet"><strong>19</strong></span>         <span class="blue">return</span> {<span class="green">2</span>, <span class="green">"Screwdriver"</span>s, <span class="green">106</span>, <span class="green">6.99</span>}; <span class="lgreen">// return a Part tuple</span>&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">default</span>:&#13;
<span class="cviolet"><strong>21</strong></span>         <span class="blue">return</span> {<span class="green">0</span>, <span class="green">"INVALID PART"</span>s, <span class="green">0</span>, <span class="green">0.0</span>}; <span class="lgreen">// return a Part tuple</span>&#13;
<span class="cviolet"><strong>22</strong></span>      }&#13;
<span class="cviolet"><strong>23</strong></span>   }&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>26</strong></span>      <span class="lgreen">// display the hardware part inventory</span>&#13;
<span class="cviolet"><strong>27</strong></span>      <span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">1</span>}; i &lt;= <span class="green">2</span>; ++i) {&#13;
<span class="cviolet"><strong>28</strong></span>         <span class="lgreen">// unpack the returned tuple into four variables;</span>&#13;
<span class="cviolet"><strong>29</strong></span>         <span class="lgreen">// variables' types are inferred from the tuple's element values</span>&#13;
<span class="cviolet"><strong>30</strong></span>         <span class="blue">auto</span> [partNumber, partName, quantity, price] {getInventory(i)};&#13;
<span class="cviolet"><strong>31</strong></span>&#13;
<span class="cviolet"><strong>32</strong></span>         std::cout &lt;&lt; fmt::format("{}<span class="green">: {}, {}: {}, {}: {}, {}: {:.2f}\n",</span>&#13;
<span class="cviolet"><strong>33</strong></span>            <span class="green">"Part number"</span>, partNumber, <span class="green">"Tool"</span>, partName,&#13;
<span class="cviolet"><strong>34</strong></span>            <span class="green">"Quantity"</span>, quantity, <span class="green">"Price"</span>, price);&#13;
<span class="cviolet"><strong>35</strong></span>      }&#13;
<span class="cviolet"><strong>36</strong></span>&#13;
<span class="cviolet"><strong>37</strong></span>      std::cout &lt;&lt; <span class="green">"\nAccessing a tuple's elements by index number:\n"</span>;&#13;
<span class="cviolet"><strong>38</strong></span>      <span class="blue">auto</span> hammer{getInventory(<span class="green">1</span>)};&#13;
<span class="cviolet"><strong>39</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"{}: {}, {}: {}, {}: {}, {}: {:.2f}\n"</span>,&#13;
<span class="cviolet"><strong>40</strong></span>         <span class="green">"Part number"</span>, std::get&lt;<span class="green">0</span>&gt;(hammer), <span class="green">"Tool"</span>, std::get&lt;<span class="green">1</span>&gt;(hammer),&#13;
<span class="cviolet"><strong>41</strong></span>         <span class="green">"Quantity"</span>, std::get&lt;<span class="green">2</span>&gt;(hammer), <span class="green">"Price"</span>, std::get&lt;<span class="green">3</span>&gt;(hammer));&#13;
<span class="cviolet"><strong>42</strong></span>&#13;
<span class="cviolet"><strong>43</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"A Part tuple has {} elements\n"</span>,&#13;
<span class="cviolet"><strong>44</strong></span>         std::tuple_size&lt;Part&gt;{});&#13;
<span class="cviolet"><strong>45</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Part number: 1, Tool: Hammer, Quantity: 32, Price: 9.95&#13;
Part number: 2, Tool: Screwdriver, Quantity: 106, Price: 6.99&#13;
&#13;
Accessing a tuple&#13;
Part number: 1, Tool: Hammer, Quantity: 32, Price: 9.95&#13;
A Part tuple has 4 elements</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.13</strong></span> | Manipulating tuples. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>Line 9’s <code>using</code> declaration (introduced in <a href="ch10.xhtml#sec10_13">Section 10.13</a>) creates a <strong>type alias</strong> named <code>Part</code> for a <code>tuple</code> representing a hardware part’s inventory. Each <code>Part</code> consists of</p>&#13;
<p class="bull">• an <code>int</code> part number,</p>&#13;
<p class="bull">• a <code>string</code> part name,</p>&#13;
<p class="bull">• an <code>int</code> quantity and</p>&#13;
<p class="bull">• a <code>double</code> price.</p>&#13;
<p>In a <code>tuple</code> declaration, every template type parameter corresponds to a value at the same position in the <code>tuple</code>. <strong>The number of <code>tuple</code> elements always matches the number of type parameters</strong>. We use the <code>Part</code> type alias to simplify the rest of the code.</p>&#13;
<h5 class="h5" id="ch15lev3sec64">Packing a <code>tuple</code></h5>&#13;
<p>Creating a <code>tuple</code> object is called <strong><span class="violet">packing a</span></strong> <span class="violet"><strong><code>tuple</code></strong></span>. Lines 12–23 define a <code>getInventory</code> function that receives a part number and returns a <code>Part</code> tuple. The function packs <code>Part tuple</code>s by returning an <strong>initializer list</strong> (lines 17, 19 or 21) containing four elements (an <code>int</code>, a <code>string</code>, an <code>int</code> and a <code>double</code>), which the compiler uses to initialize the returned <code>Part std::tuple</code> object. A <code>tuple</code>’s size is fixed once you create it, so <code>tuple</code>s are said to be immutable.</p>&#13;
<h5 class="h5" id="ch15lev3sec65">Creating a <code>tuple</code> with <strong><code>std::make_tuple</code></strong></h5>&#13;
<p>You also can pack a <code>tuple</code> with the <code>&lt;tuple&gt;</code> header’s <span class="violet"><strong><code>make_tuple</code></strong></span><strong><span class="violet"> function</span></strong>, which infers a <code>tuple</code>’s type parameters from the function’s arguments. For example, you could create the <code>tuple</code>s in lines 17, 19 and 21 with <code>make_tuple</code> calls like</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p882pro01" id="p882pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">std::make_tuple(<span class="green">1</span>, <span class="green">"Hammer"</span>s, <span class="green">32</span>, <span class="green">9.95</span>)</pre>&#13;
<p>If we had used this approach, <code>getInventory</code>’s return type could be specified as <strong><code>auto</code> to infer the return type from <code>make_tuple</code>’s result</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec66">Unpacking a <code>tuple</code> with Structured Bindings</h5>&#13;
<p>You can <strong><span class="violet">unpack a</span></strong> <span class="violet"><strong><code>tuple</code></strong></span> to access its elements using <strong>C++17 structured bindings</strong> (<a href="ch14.xhtml#sec14_4_3">Section 14.4.3</a>). Line 30 unpacks a <code>Part</code>’s members into variables, which we display in lines 32–34.</p>&#13;
<h5 class="h5" id="ch15lev3sec67">Using <code>get&lt;</code>index<strong><code>&gt;</code></strong> to Obtain a <strong><code>tuple</code></strong> Member by Index</h5>&#13;
<p>Class template <code>pair</code> contains public members <code>first</code> and <code>second</code> for accessing a <code>pair</code>’s two members. Each <code>tuple</code> you create can have any number of elements, so <code>tuple</code>s do not have similarly named data members. Instead, the <code>&lt;tuple&gt;</code> header provides the function template <span class="violet"><strong><code>get&lt;</code></strong></span> <span class="violet"><em><strong>index</strong></em></span><span class="violet"><strong><code>&gt;(</code></strong></span><span class="violet"><em><strong>tupleObject</strong></em></span><span class="violet"><strong><code>)</code></strong></span>, which returns a reference to the <em>tupleObject</em>’s member at the specified <em>index</em>. The first member has index <code>0</code>. Line 38 gets a tuple for the hammer inventory, then lines 39–41 access each <code>tuple</code> element by <code>index</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec68">C++14 Using <code>get&lt;</code> <em>type</em><strong><code>&gt;</code></strong> to Obtain a <strong><code>tuple</code></strong> Member By Type</h5>&#13;
<p><span class="size">14</span> C++14 added a <code>get</code> overload that gets a <code>tuple</code> member of a specific type, provided that the tuple contains <strong>only one member of that type</strong>. For example, the following statement gets the <code>hammerInventory tuple</code>’s <code>string</code> member:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p883pro01" id="p883pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">auto</span> partName{get&lt;std::string&gt;(hammerInventory)};</pre>&#13;
<p>However, the statement</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p883pro02" id="p883pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">auto</span> partNumber{get&lt;<span class="blue">int</span>&gt;(hammerInventory)};</pre>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> would generate a compilation error because the call is <strong>ambiguous</strong>—the <code>hammerInventory tuple</code> contains two <code>int</code> members for its part number and quantity.</p>&#13;
<h5 class="h5" id="ch15lev3sec69">Other <code>tuple</code> Features</h5>&#13;
<p>The following table shows several other <strong><code>tuple</code> class template features</strong>. For the <code>tuple</code> class template’s complete details, see:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p883pro03" id="p883pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/utility/tuple/tuple</pre>&#13;
<p>For other <code>tuple</code>-related utilities defined in the <code>&lt;tuple&gt;</code> header, see:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p883pro04" id="p883pro04a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/utility/tuple</pre>&#13;
<div class="image"><img src="Images/883tab01.jpg" alt="Images" width="801" height="502"/></div>&#13;
<h4 class="h4" id="sec15_12_2">15.12.2 Variadic Function Templates and an Intro to C++17 Fold Expressions</h4>&#13;
<p><strong>Variadic function templates</strong> enable you to define functions that can receive any number of arguments. <a href="ch15.xhtml#fig15_14">Figure 15.14</a> uses <strong>variadic function templates</strong> to sum one or more arguments. This example assumes the arguments can be operands to the <code>+</code> operator and have the same type. We show two ways to process the variadic parameters:</p>&#13;
<p class="bull">• using <strong>compile-time recursion</strong> (which was required before C++17), and</p>&#13;
<p class="bull">• using a <strong>C++17 fold expression</strong> to eliminate the recursion.</p>&#13;
<p><a href="ch15.xhtml#sec15_12_7">Section 15.12.7</a> shows how to <strong>test whether all the arguments have the same type</strong>.</p>&#13;
<div class="group" id="fig15_14">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro14" id="p15pro14a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_14.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Variadic function templates.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="lgreen">// base-case function for one argument</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">auto</span> sum(T item) {&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">return</span> item;&#13;
<span class="cviolet"><strong>11</strong></span>   }&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="lgreen">// recursively add one or more arguments</span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> FirstItem, <span class="blue">typename</span>... RemainingItems&gt;&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">auto</span> sum(FirstItem first, RemainingItems... theRest) {&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">return</span> first + sum(theRest...); <span class="lgreen">// expand parameter pack for next call</span>&#13;
<span class="cviolet"><strong>17</strong></span>   }&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="lgreen">// add one or more arguments with a fold expression</span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> FirstItem, <span class="blue">typename</span>... RemainingItems&gt;&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">auto</span> foldingSum(FirstItem first, RemainingItems... theRest) {&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">return</span> (first + ... + theRest); <span class="lgreen">// expand the parameter</span>&#13;
<span class="cviolet"><strong>23</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>26</strong></span>      <span class="blue">using namespace</span> std::literals;&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>      std::cout &lt;&lt; <span class="green">"Recursive variadic function template sum:"</span>&#13;
<span class="cviolet"><strong>29</strong></span>         &lt;&lt; fmt::format("\n<span class="green">{}{}\n{}{}\n{}{}\n{}{}\n\n",</span>&#13;
<span class="cviolet"><strong>30</strong></span>               <span class="green">"sum(1): "</span>, sum(<span class="green">1</span>), <span class="green">"sum(1, 2): "</span>, sum(<span class="green">1</span>, <span class="green">2</span>),&#13;
<span class="cviolet"><strong>31</strong></span>               <span class="green">"sum(1, 2, 3): "</span>, sum(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>),&#13;
<span class="cviolet"><strong>32</strong></span>               <span class="green">"sum(\"s\"s, \"u\"s, \"m\"s): "</span>, sum(<span class="green">"s"s</span>, <span class="green">"u"s</span>, <span class="green">"m"s</span>));&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>      std::cout &lt;&lt; <span class="green">"Variadic function template foldingSum:"</span>&#13;
<span class="cviolet"><strong>35</strong></span>         &lt;&lt; fmt::format("\n<span class="green">{}{}\n{}{}\n{}{}\n{}{}\n",</span>&#13;
<span class="cviolet"><strong>36</strong></span>               <span class="green">"sum(1): "</span>, foldingSum(<span class="green">1</span>), <span class="green">"sum(1, 2): "</span>, foldingSum(<span class="green">1</span>, <span class="green">2</span>),&#13;
<span class="cviolet"><strong>37</strong></span>               <span class="green">"sum(1, 2, 3): "</span>, foldingSum(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>),&#13;
<span class="cviolet"><strong>38</strong></span>               <span class="green">"sum(\"s\"s, \"u\"s, \"m\"s): "</span>,&#13;
<span class="cviolet"><strong>39</strong></span>               foldingSum("s"s, <span class="green">"u"s</span>, <span class="green">"m"s</span>));&#13;
<span class="cviolet"><strong>40</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Recursive variadic function template sum:&#13;
sum(1): 1&#13;
sum(1, 2): 3&#13;
sum(1, 2, 3): 6&#13;
sum("s"s, "u"s, "m"s): sum&#13;
&#13;
Variadic function template foldingSum:&#13;
sum(1): 1&#13;
sum(1, 2): 3&#13;
sum(1, 2, 3): 6&#13;
sum("s"s, "u"s, "m"s): sum</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.14</strong></span> | Variadic function templates. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec70">Compile-Time Recursion</h5>&#13;
<p>Lines 8–11 and 14–17 define overloaded function templates named <code>sum</code> that use <strong>compile-time recursion</strong> to process <strong>variadic parameter packs</strong>. The function template <code>sum</code> with one template parameter (lines 8–11) represents the <strong>recursion’s base case</strong> in which <code>sum</code> receives only one argument and returns it. The <strong>recursive function template <code>sum</code></strong> (lines 14–17) specifies two type parameters:</p>&#13;
<p class="bull">• The type parameter <code>FirstItem</code> represents the first function argument.</p>&#13;
<p class="bull">• The type parameter <code>RemainingItems</code> represents all the other arguments passed to the function</p>&#13;
<p>The notation <span class="violet"><strong><code>typename...</code></strong></span> introduces a variadic template’s <strong>parameter pack</strong>, which again represents <strong>any number of arguments</strong>. In the function’s parameter list (line 9), the variable-length parameter must appear last and is denoted with <strong><code>...</code></strong> after the parameter’s type (<code>RemainingItems</code>). Note that the <code>...</code> position is different in the template header and in the function parameter list. The return statement adds the <code>first</code> argument to the result of the <strong>recursive call</strong></p>&#13;
<pre class="pre"><code>sum(theRest...)</code></pre>&#13;
<p>The expression <code>theRest...</code> is a <strong><span class="violet">parameter-pack expansion</span></strong>—the compiler turns the parameter pack’s elements into a comma-delimited list. We’ll say more about this in a moment.</p>&#13;
<h5 class="h5" id="ch15lev3sec71">Calling <code>sum</code> with One Argument</h5>&#13;
<p>When line 30 calls</p>&#13;
<pre class="pre">sum(<span class="green">1</span>)</pre>&#13;
<p>which has one argument, the compiler invokes <code>sum</code>’s one-argument version (lines 8–11). If we have only one argument, the sum is simply the argument’s value (in this case, <code>1</code>).</p>&#13;
<h5 class="h5" id="ch15lev3sec72">Calling <code>sum</code> with Two Arguments</h5>&#13;
<p>When line 30 calls</p>&#13;
<pre class="pre">sum(<span class="green">1</span>, <span class="green">2</span>)</pre>&#13;
<p>the compiler invokes <code>sum</code>’s <strong>variadic version</strong> (lines 14–17), which receives <code>1</code> in the parameter <code>first</code> and <code>2</code> in the <strong>parameter pack</strong> <code>theRest</code>. The function then adds <code>1</code> and the result of calling <code>sum</code> with the <strong>parameter-pack expansion (<code>...</code>)</strong>. The parameter pack contains only <code>2</code>, so this call becomes <code>sum(2)</code>, which invokes <code>sum</code>’s one-argument version, ending the <strong>recursion</strong>. So, the final result is <code>3</code> (i.e., <code>1 + 2</code>).</p>&#13;
<p>Though <code>sum</code>’s <strong>variadic version</strong> looks like traditional <strong>recursion</strong>, the compiler generates separate template instantiations for each <strong>recursive call</strong>. So, the original <code>sum(1, 2)</code> call becomes</p>&#13;
<pre class="pre">sum(<span class="green">1</span>, sum(<span class="green">2</span>))</pre>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> And because the compiler has all the values used in the calculation, it can perform the calculations and inline them in the program as compile-time constants, <strong>eliminating execution-time function-call overhead</strong>.<sup><a id="ch15fn77a" href="ch15.xhtml#ch15fn77">77</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn77" href="ch15.xhtml#ch15fn77a">77</a>. “Template metaprogramming—Compile-time code optimization.” Accessed June 29, 2021. <code><a href="https://en.wikipedia.org/wiki/Template_metaprogramming#Compile-time_code_optimization">https://en.wikipedia.org/wiki/Template_metaprogramming#Compile-time_code_optimization</a></code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec73">Calling <code>sum</code> with Three Arguments</h5>&#13;
<p>When line 31 calls</p>&#13;
<pre class="pre">sum(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>)</pre>&#13;
<p>the compiler again invokes <code>sum</code>’s <strong>variadic version</strong> (lines 14–17):</p>&#13;
<p class="bull">• In this initial call, parameter <code>first</code> receives <code>1</code> and the <strong>parameter pack</strong> <code>theRest</code> receives <code>2</code> and <code>3</code>. The function adds <code>1</code> and the result of calling <code>sum</code> with the <strong>parameter-pack expansion</strong>, producing the call <code>sum(2, 3)</code>.</p>&#13;
<p class="bull">• In the call <code>sum(2, 3)</code>, parameter <code>first</code> receives <code>2</code> and the <strong>parameter pack</strong> <code>theRest</code> receives <code>3</code>. The function then adds <code>2</code> and the result of calling <code>sum</code> with the <strong>parameter-pack expansion</strong> producing the call <code>sum(3)</code>.</p>&#13;
<p class="bull">• The call <code>sum(3)</code> invokes <code>sum</code>’s one-argument version (the <strong>base case</strong>) with <code>3</code>, which returns 3. At this point, the <code>sum(2, 3)</code> call’s body becomes <code>2 + 3</code> (that is <code>5</code>), and the <code>sum(1, 2, 3)</code> call’s body becomes <code>1 + 5</code>, producing the final result <code>6</code>.</p>&#13;
<p>Effectively, the original call became</p>&#13;
<pre class="pre">sum(<span class="green">1</span>, sum(<span class="green">2</span>, sum(<span class="green">3</span>)))</pre>&#13;
<p>where the compiler knows the value of the innermost call, <code>sum(3)</code>, and can determine the results of the other calls.</p>&#13;
<h5 class="h5" id="ch15lev3sec74">Calling <code>sum</code> with Three <strong><code>string</code></strong> Objects</h5>&#13;
<p>Line 32’s <code>sum</code> call</p>&#13;
<pre class="pre">sum(<span class="green">"s"s</span>, <span class="green">"u"s</span>, <span class="green">"m"s</span>)</pre>&#13;
<p>receives three <code>string</code>-object literals. Recall that <code>+</code> for <code>string</code>s performs <strong>string concatenation</strong>, so the original call effectively becomes</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p887pro01" id="p887pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">sum(<span class="green">"s"s</span>, sum(<span class="green">"u"s</span>, sum(<span class="green">"m"s</span>)))</pre>&#13;
<p>producing the string <code>"sum"</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec75">C++17 Fold Expressions</h5>&#13;
<p><span class="size">17</span> <strong><span class="violet">Fold expressions</span></strong><sup><a id="ch15fn78a" href="ch15.xhtml#ch15fn78">78</a>,<a id="ch15fn79a" href="ch15.xhtml#ch15fn79">79</a>,<a id="ch15fn80a" href="ch15.xhtml#ch15fn80">80</a></sup> provide a convenient notation for repeatedly applying a binary operator to all the elements in a <strong>variadic template’s parameter pack</strong>. Fold expressions are often used to <strong>reduce the values in a parameter pack to a single value</strong>. They also can <strong>apply an operation to every object in a parameter pack</strong>, such as calling a member function or displaying the pack’s elements with <code>cout</code> (as we’ll do in <a href="ch15.xhtml#sec15_12_6">Section 15.12.6</a>).</p>&#13;
<p class="footnote"><a id="ch15fn78" href="ch15.xhtml#ch15fn78a">78</a>. Jonathan Boccara, “C++ Fold Expressions 101,” March 12, 2021. Accessed June 17, 2021. <code><a href="https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/">https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn79" href="ch15.xhtml#ch15fn79a">79</a>. Jonathan Boccara, “What C++ Fold Expressions Can Bring to Your Code,” March 19, 2021. Accessed June 17, 2021. <code><a href="https://www.fluentcpp.com/2021/03/19/what-c-fold-expressions-can-bring-to-your-code/">https://www.fluentcpp.com/2021/03/19/what-c-fold-expressions-can-bring-to-your-code/</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn80" href="ch15.xhtml#ch15fn80a">80</a>. Jonathan Muller, “Nifty Fold Expression Tricks,” May 5, 2020. Accessed June 17, 2021. <code><a href="https://www.foonathan.net/2020/05/fold-tricks/">https://www.foonathan.net/2020/05/fold-tricks/</a></code>.</p>&#13;
<p>Lines 20–23 use a <strong><span class="violet">binary left fold</span></strong> (line 22)</p>&#13;
<pre class="pre"><code>(first + ... + theRest)</code></pre>&#13;
<p>which sums <code>first</code> and the zero or more arguments in the parameter pack <code>theRest</code>. <strong>Fold expressions must be parenthesized. In a binary left fold, there are two binary operators, which must be the same</strong>—in this case, the addition operator (<code>+</code>). The argument to the left of the first operator is the expression’s <strong>initial value</strong>. The <code>...</code> expands the parameter pack to the right of the second operator, separating each parameter in the parameter pack from the next with the binary operator. So, in line 37, the function call</p>&#13;
<pre class="pre">foldingSum(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>)</pre>&#13;
<p>the binary-left-fold expression expands to</p>&#13;
<pre class="pre"><code>(1 + 2 + 3)</code></pre>&#13;
<p><strong>If the parameter pack is empty, the value of the binary-left-fold expression is the initial value</strong>—in this case, the value of <code>first</code>. In <a href="ch15.xhtml#sec15_12_3">Section 15.12.3</a>, we’ll discuss fold expressions in more detail.</p>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The C++ Core Guidelines recommend using <strong>variadic function templates</strong> for arguments of <strong>mixed types</strong><sup><a id="ch15fn81a" href="ch15.xhtml#ch15fn81">81</a></sup> and using <code>initializer_list</code>s for functions that receive variable numbers of arguments of the <strong>same type</strong>.<sup><a id="ch15fn82a" href="ch15.xhtml#ch15fn82">82</a></sup> However, <strong>fold expressions cannot be applied to <code>initializer_list</code>s.</strong></p>&#13;
<p class="footnote"><a id="ch15fn81" href="ch15.xhtml#ch15fn81a">81</a>. “T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types.” Accessed June 20, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn82" href="ch15.xhtml#ch15fn82a">82</a>. “T.103: Don’t use variadic templates for homogeneous argument lists.” Accessed June 20, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic-not">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic-not</a></code>.</p>&#13;
<h4 class="h4" id="sec15_12_3">15.12.3 Types of Fold Expressions</h4>&#13;
<p>In the following descriptions,</p>&#13;
<p class="bull">• <em>pack</em> represents a parameter pack,</p>&#13;
<p class="bull">• <em>op</em> represents one of the 32 binary operators you can use in fold expressions,<sup><a id="ch15fn83a" href="ch15.xhtml#ch15fn83">83</a></sup> and</p>&#13;
<p class="footnote"><a id="ch15fn83" href="ch15.xhtml#ch15fn83a">83</a>. “fold expression.” Accessed June 17, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/fold">https://en.cppreference.com/w/cpp/language/fold</a></code>.</p>&#13;
<p class="bull">• <em>initialValue</em> represents a starting value for a binary fold expression. For example, a sum might start with 0, or a product might start with 1.</p>&#13;
<p>There are <strong>four fold-expression types</strong>:</p>&#13;
<p class="bull">• A <strong><span class="violet">unary left fold</span></strong> has one binary operator with the parameter pack expansion (<code>...</code>) as the <strong>left operand</strong>, and the <em>pack</em> as the right operand:</p>&#13;
<p class="pren"><code>(...</code> <em>op pack</em><code>)</code></p>&#13;
<p class="bull">• A <strong><span class="violet">unary right fold</span></strong> has one binary operator with the parameter pack expansion (<code>...</code>) as the <strong>right operand</strong>, and the <em>pack</em> as the left operand:</p>&#13;
<p class="pren"><code>(</code><em>pack op</em> <code>...)</code></p>&#13;
<p class="bull">• A <strong>binary left fold</strong> has two binary operators, which must be the same. The <em>initial-Value</em> is to the <strong>left of the first operator</strong>, the parameter pack expansion (<code>...</code>) is between the operators, and the <em>pack</em> is to the right of the second operator:</p>&#13;
<p class="pren"><code>(</code><em>initialValue op</em> <code>...</code> <em>op pack</em><code>)</code></p>&#13;
<p class="bull">• A <strong><span class="violet">binary right fold</span></strong> has two binary operators, which must be the same. The <em>initialValue</em> is to the <strong>right of the second operator</strong>, the parameter pack expansion (<code>...</code>) is between the operators, and <em>pack</em> is to the left of the first operator:</p>&#13;
<p class="pren"><code>(</code><em>pack op</em> <code>...</code> <em>op initialValue</em><code>)</code></p>&#13;
<h4 class="h4" id="sec15_12_4">15.12.4 How Unary Fold Expressions Apply Their Operators</h4>&#13;
<p>The key difference between left- and right-fold expressions is the order in which they apply their operators. <strong>Left folds group left-to-right and right folds group right-to-left</strong>. Depending on the operator, the grouping can produce different results. <a href="ch15.xhtml#fig15_15">Figure 15.15</a> demonstrates unary left and right fold operations using the addition (<code>+</code>) and subtraction (<code>-</code>) operators:</p>&#13;
<p class="bull">• Lines 6–9 define <strong><code>unaryLeftAdd</code></strong>, which uses a <strong>unary left fold</strong> to add the items in its parameter pack.</p>&#13;
<p class="bull">• Lines 11–14 define <strong><code>unaryRightAdd</code></strong>, which uses a <strong>unary right fold</strong> operation to add the items in its parameter pack.</p>&#13;
<p class="bull">• Lines 16–19 define <strong><code>unaryLeftSubtract</code></strong>, which uses a <strong>unary left fold</strong> operation to subtract the items in its parameter pack.</p>&#13;
<p class="bull">• Lines 21–24 define <strong><code>unaryRightSubtract</code></strong>, which uses a <strong>unary right fold</strong> operation to subtract the items in its parameter pack.</p>&#13;
<div class="group" id="fig15_15">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro15" id="p15pro15a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_15.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Unary fold expressions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">template</span> &lt;typename... Items&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">auto</span> unaryLeftAdd(Items... items) {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">return</span> (... + items); <span class="lgreen">// unary left fold</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   }&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">template</span> &lt;typename... Items&gt;&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">auto</span> unaryRightAdd(Items... items) {&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">return</span> (items + ...); <span class="lgreen">// unary right fold</span>&#13;
<span class="cviolet"><strong>14</strong></span>   }&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span>... Items&gt;&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="blue">auto</span> unaryLeftSubtract(Items... items) {&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="blue">return</span> (... - items); <span class="lgreen">// unary left fold</span>&#13;
<span class="cviolet"><strong>19</strong></span>   }&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span>... Items&gt;&#13;
<span class="cviolet"><strong>22</strong></span>   <span class="blue">auto</span> unaryRightSubtract(Items... items) {&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">return</span> (items - ...); <span class="lgreen">// unary right fold</span>&#13;
<span class="cviolet"><strong>24</strong></span>   }&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>27</strong></span>      std::cout &lt;&lt; <span class="green">"Unary left and right fold with addition:"</span>&#13;
<span class="cviolet"><strong>28</strong></span>         &lt;&lt; fmt::format("\n<span class="green">{}{}\n{}{}\n\n",</span>&#13;
<span class="cviolet"><strong>29</strong></span>               <span class="green">"unaryLeftAdd(1, 2, 3, 4): "</span>, unaryLeftAdd(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>),&#13;
<span class="cviolet"><strong>30</strong></span>               <span class="green">"unaryRightAdd(1, 2, 3, 4): "</span>, unaryRightAdd(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>));&#13;
<span class="cviolet"><strong>31</strong></span>&#13;
<span class="cviolet"><strong>32</strong></span>      std::cout &lt;&lt; <span class="green">"Unary left and right fold with subtraction:"</span>&#13;
<span class="cviolet"><strong>33</strong></span>         &lt;&lt; fmt::format("\n<span class="green">{}{}\n{}{}\n",</span>&#13;
<span class="cviolet"><strong>34</strong></span>               <span class="green">"unaryLeftSubtract(1, 2, 3, 4): "</span>,&#13;
<span class="cviolet"><strong>35</strong></span>               unaryLeftSubtract(1, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>),&#13;
<span class="cviolet"><strong>36</strong></span>               <span class="green">"unaryRightSubtract(1, 2, 3, 4): "</span>,&#13;
<span class="cviolet"><strong>37</strong></span>               unaryRightSubtract(1, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>));&#13;
<span class="cviolet"><strong>38</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Unary left and right fold with addition:&#13;
unaryLeftAdd(1, 2, 3, 4): 10&#13;
unaryRightAdd(1, 2, 3, 4): 10&#13;
&#13;
Unary left and right fold with subtraction:&#13;
unaryLeftSubtract(1, 2, 3, 4): -8&#13;
unaryRightSubtract(1, 2, 3, 4): -2</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.15</strong></span> | Unary fold expressions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec76">Unary Left and Right Folds for Addition</h5>&#13;
<p>Consider the line 29 call:</p>&#13;
<pre class="pre">unaryLeftAdd(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>)</pre>&#13;
<p>in which the <strong>parameter pack</strong> contains <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code>. This function performs a <strong>unary left fold</strong> using the <code>+</code> operator, which calculates:</p>&#13;
<pre class="pre"><code>(((1 + 2) + 3) + 4)</code></pre>&#13;
<p>Similarly, the line 30 call:</p>&#13;
<pre class="pre">unaryRightAdd(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>)</pre>&#13;
<p>performs a <strong>unary right fold</strong>, which calculates:</p>&#13;
<pre class="pre"><code>(1 + (2 + (3 + 4)))</code></pre>&#13;
<p>The order in which + is applied does not matter, so both expressions produce the same value (<code>10</code>) in this case.</p>&#13;
<h5 class="h5" id="ch15lev3sec77">Unary Left and Right Folds for Subtraction</h5>&#13;
<p>The order in which some operators are applied can produce different results. Consider the call line 36 call:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p890pro01" id="p890pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">unaryLeftSubtract(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>)</pre>&#13;
<p>This function performs a <strong>unary left fold</strong> using the <code>-</code> operator, which calculates:</p>&#13;
<pre class="pre"><code>(((1 - 2) - 3) - 4)</code></pre>&#13;
<p>producing <code>-8</code>. On the other hand, the line 37 call:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p890pro02" id="p890pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">unaryRightSubtract(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>)</pre>&#13;
<p>performs a <strong>unary right fold</strong> using the <code>-</code> operator, which calculates:</p>&#13;
<pre class="pre"><code>(1 - (2 - (3 - 4)))</code></pre>&#13;
<p>producing <code>-2</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec78">Parameter Packs in Unary Fold Expressions Must Not Be Empty</h5>&#13;
<p><strong>Unary-fold expressions must be applied only to parameter packs with at least one element</strong>. The only exceptions to this are for the binary operators <code>&amp;&amp;</code>, <code>||</code> and comma (<code>,</code>):</p>&#13;
<p class="bull">• An <code>&amp;&amp;</code> operation with an <strong>empty parameter pack</strong> evaluates to <code>true</code>.</p>&#13;
<p class="bull">• An <code>||</code> operation with an <strong>empty parameter pack</strong> evaluates to <code>false</code>.</p>&#13;
<p class="bull">• Any operation performed with the <strong>comma operator</strong> on an <strong>empty parameter pack</strong> evaluates to <strong><code>void()</code></strong>, which simply means no operation is performed. We show a fold expression using the comma operator in <a href="ch15.xhtml#sec15_12_6">Section 15.12.6</a>.</p>&#13;
<h4 class="h4" id="sec15_12_5">15.12.5 How Binary-Fold Expressions Apply Their Operators</h4>&#13;
<p>If an <strong>empty parameter pack</strong> is possible, you can use a <strong>binary left fold</strong> or <strong>binary right fold</strong>. Each requires an initial value. If the <strong>parameter pack</strong> is empty, the initial value is used as the fold expression’s value. <a href="ch15.xhtml#fig15_16">Figure 15.16</a> demonstrates <strong>binary left folds</strong> and <strong>binary right folds</strong> for addition and subtraction:</p>&#13;
<p class="bull">• Lines 6–9 define <strong><code>binaryLeftAdd</code></strong>, which uses a <strong>binary left fold</strong> to add the items in its parameter pack starting with the initial value <code>0</code>.</p>&#13;
<p class="bull">• Lines 11–14 define <strong><code>binaryRightAdd</code></strong>, which uses a <strong>binary right fold</strong> to add the items in its parameter pack starting with the initial value <code>0</code>.</p>&#13;
<p class="bull">• Lines 16–19 define <strong><code>binaryLeftSubtract</code></strong>, which uses a <strong>binary left fold</strong> to subtract the items in its parameter pack starting with the initial value <code>0</code>.</p>&#13;
<p class="bull">• Lines 21–24 define <strong><code>binaryRightSubtract</code></strong>, which uses a <strong>binary right fold</strong> to subtract the items in its parameter pack starting with the initial value <code>0</code>.</p>&#13;
<p>Once again, note that the fold expressions’ grouping for addition does not matter, but for subtraction leads to different results.</p>&#13;
<div class="group" id="fig15_16">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro16" id="p15pro16a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_16.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Binary fold expressions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span>... Items&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">auto</span> binaryLeftAdd(Items... items) {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">return</span> (<span class="green">0</span> + ... + items); <span class="lgreen">// binary left fold</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   }&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span>... Items&gt;&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">auto</span> binaryRightAdd(Items... items) {&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">return</span> (items + ... + <span class="green">0</span>); <span class="lgreen">// binary right fold</span>&#13;
<span class="cviolet"><strong>14</strong></span>   }&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span>... Items&gt;&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="blue">auto</span> binaryLeftSubtract(Items... items) {&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="blue">return</span> (<span class="green">0</span> - ... - items); <span class="lgreen">// binary left fold</span>&#13;
<span class="cviolet"><strong>19</strong></span>   }&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span>... Items&gt;&#13;
<span class="cviolet"><strong>22</strong></span>   <span class="blue">auto</span> binaryRightSubtract(Items... items) {&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">return</span> (items - ... - <span class="green">0</span>); <span class="lgreen">// binary right fold</span>&#13;
<span class="cviolet"><strong>24</strong></span>   }&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>27</strong></span>      std::cout &lt;&lt; <span class="green">"Binary left and right fold with addition:"</span>&#13;
<span class="cviolet"><strong>28</strong></span>         &lt;&lt; fmt::format("\n<span class="green">{}{}\n{}{}\n{}{}\n{}{}\n\n",</span>&#13;
<span class="cviolet"><strong>29</strong></span>               <span class="green">"binaryLeftAdd(): "</span>, binaryLeftAdd(),&#13;
<span class="cviolet"><strong>30</strong></span>               <span class="green">"binaryLeftAdd(1, 2, 3, 4): "</span>, binaryLeftAdd(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>),&#13;
<span class="cviolet"><strong>31</strong></span>               <span class="green">"binaryRightAdd(): "</span>, binaryRightAdd(),&#13;
<span class="cviolet"><strong>32</strong></span>               <span class="green">"binaryRightAdd(1, 2, 3, 4): "</span>, binaryRightAdd(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>));&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>      std::cout &lt;&lt; <span class="green">"Binary left and right fold with subtraction:"</span>&#13;
<span class="cviolet"><strong>35</strong></span>         &lt;&lt; fmt::format("\n<span class="green">{}{}\n{}{}\n{}{}\n{}{}\n",</span>&#13;
<span class="cviolet"><strong>36</strong></span>               <span class="green">"binaryLeftSubtract(): "</span>, binaryLeftSubtract(),&#13;
<span class="cviolet"><strong>37</strong></span>               <span class="green">"binaryLeftSubtract(1, 2, 3, 4): "</span>,&#13;
<span class="cviolet"><strong>38</strong></span>               binaryLeftSubtract(1, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>),&#13;
<span class="cviolet"><strong>39</strong></span>               <span class="green">"binaryRightSubtract(): "</span>, binaryRightSubtract(),&#13;
<span class="cviolet"><strong>40</strong></span>               <span class="green">"binaryRightSubtract(1, 2, 3, 4): "</span>,&#13;
<span class="cviolet"><strong>41</strong></span>               binaryRightSubtract(1, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>));&#13;
<span class="cviolet"><strong>42</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Binary left and right fold with addition:&#13;
binaryLeftAdd(): 0&#13;
binaryLeftAdd(1, 2, 3, 4): 10&#13;
binaryRightAdd(): 0&#13;
binaryRightAdd(1, 2, 3, 4): 10&#13;
&#13;
Binary left and right fold with subtraction:&#13;
binaryLeftSubtract(): 0&#13;
binaryLeftSubtract(1, 2, 3, 4): -10&#13;
binaryRightSubtract(): 0&#13;
binaryRightSubtract(1, 2, 3, 4): -2</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.16</strong></span> | Binary fold expressions.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec15_12_6">15.12.6 Using the Comma Operator to Repeatedly Perform an Operation</h4>&#13;
<p>The <strong>comma operator</strong> evaluates the expression to its left, then the expression to its right. The value of a comma-operator expression is the value of the rightmost expression. You can <strong>combine the comma operator with fold expressions to repeatedly perform tasks for every item in a parameter pack</strong>. <a href="ch15.xhtml#fig15_17">Figure 15.17</a>’s <code>printItems</code> function displays every item in its parameter pack (<code>items</code>) on a line by itself. Line 9 executes the expression on the left of the comma operator:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p892pro01" id="p892pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">(std::cout &lt;&lt; items &lt;&lt; <span class="green">"\n"</span>)</pre>&#13;
<p>once for each item in the parameter pack <code>items</code>.</p>&#13;
<div class="group" id="fig15_17">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro17" id="p15pro17a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_17.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Repeating a task using the comma operator and fold expressions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span>... Items&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">void</span> printItems(Items... items) {&#13;
<span class="cviolet"> <strong>9</strong></span>      ((std::cout &lt;&lt; items &lt;&lt; <span class="green">"\n"</span>), ...); <span class="lgreen">// binary left fold</span>&#13;
<span class="cviolet"><strong>10</strong></span>   }&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>13</strong></span>      std::cout &lt;&lt; <span class="green">"printItems(1, 2.2, \"hello\"):\n"</span>;&#13;
<span class="cviolet"><strong>14</strong></span>      printItems(<span class="green">1</span>, <span class="green">2.2</span>, <span class="green">"hello"</span>);&#13;
<span class="cviolet"><strong>15</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">printItems(1, 2.2, "hello"):&#13;
1&#13;
2.2&#13;
hello</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.17</strong></span> | Repeating a task using the comma operator and fold expressions.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec15_12_7">15.12.7 Constraining Parameter Pack Elements to the Same Type</h4>&#13;
<p>When using <strong>fold expressions</strong>, there may be cases in which you’d like every element to have the <strong>same type</strong>. For example, you might want a variadic function template to sum its arguments and produce a result of the same type as the arguments. <a href="ch15.xhtml#fig15_18">Figure 15.18</a> uses the <strong>predefined concept <code>std::same_as</code></strong> to check that all the elements of a parameter pack have the same type as another type argument.</p>&#13;
<div class="group" id="fig15_18">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro18" id="p15pro18a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_18.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Constraining a variadic-function-template parameter pack to</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// elements of the same type.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;concepts&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> T, <span class="blue">typename</span>... U&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">concept</span> SameTypeElements = (std::same_as&lt;T, U&gt; &amp;&amp; ...);&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="lgreen">// add one or more arguments with a fold expression</span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> FirstItem, <span class="blue">typename</span>... RemainingItems&gt;&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">requires</span> SameTypeElements&lt;FirstItem, RemainingItems...&gt;&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">auto</span> foldingSum(FirstItem first, RemainingItems... theRest) {&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="blue">return</span> (first + ... + theRest); <span class="lgreen">// expand the parameter</span>&#13;
<span class="cviolet"><strong>16</strong></span>   }&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">using namespace</span> std::literals;&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      foldingSum(<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>); <span class="lgreen">// valid: all are int values</span>&#13;
<span class="cviolet"><strong>22</strong></span>      foldingSum(<span class="green">"s"</span>s, <span class="green">"u"</span>s, <span class="green">"m"</span>s); <span class="lgreen">// valid: all are std::string objects</span>&#13;
<span class="cviolet"><strong>23</strong></span>      foldingSum(<span class="green">1</span>, <span class="green">2.2</span>, <span class="green">"hello"</span>s); <span class="lgreen">// error: three different types</span>&#13;
<span class="cviolet"><strong>24</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">fig15_18.cpp:23:4: <strong>error: no matching function for call to</strong>&#13;
   foldingSum(1, 2.2, "hello"s); // error: three different types&#13;
   ^~~~~~~~~~&#13;
&#13;
fig15_18.cpp:14:6: <strong>note: candidate template ignored: constraints not satisfied</strong>&#13;
[with FirstItem = int, RemainingItems = &lt;double, std::basic_string&lt;char&gt;&gt;]&#13;
auto foldingSum(FirstItem first, RemainingItems... theRest) {&#13;
     ^&#13;
&#13;
fig15_18.cpp:13:13: <strong>note: because sic_string&lt;char&gt; &gt;</strong>&#13;
   requires SameTypeElements&lt;FirstItem, RemainingItems...&gt;&#13;
            ^&#13;
&#13;
fig15_18.cpp:9:34: <strong>note: because false</strong>&#13;
concept SameTypeElements = (std::same_as&lt;T, U&gt; &amp;&amp; ...);&#13;
                                 ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/&#13;
concepts:63:19: note: because false&#13;
= __detail::__same_as&lt;_Tp, _Up&gt; &amp;&amp; __detail::__same_as&lt;_Up, _Tp&gt;;&#13;
            ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/&#13;
concepts:57:27: note: because false&#13;
      concept __same_as = std::is_same_v&lt;_Tp, _Up&gt;;&#13;
                          ^&#13;
&#13;
fig15_18.cpp:9:34: <strong>note: and evaluated to false</strong>&#13;
concept SameTypeElements = (std::same_as&lt;T, U&gt; &amp;&amp; ...);&#13;
                                 ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/&#13;
concepts:63:19: note: because sic_string&lt;char&gt; &gt;&#13;
      = __detail::__same_as&lt;_Tp, _Up&gt; &amp;&amp; __detail::__same_as&lt;_Up, _Tp&gt;;&#13;
                  ^&#13;
&#13;
/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/&#13;
concepts:57:27: note: because evaluated to false&#13;
      concept __same_as = std::is_same_v&lt;_Tp, _Up&gt;;&#13;
                          ^&#13;
&#13;
1 error generated.</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.18</strong></span> | Constraining a variadic-function-template parameter pack to elements of the same type. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec79">Custom Concept for a Variadic Template</h5>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Lines 8–9 define a custom concept <code>SameTypeElements</code> with two type parameters:</p>&#13;
<p class="bull">• the first represents a single type, and</p>&#13;
<p class="bull">• the second is a <strong>variadic type parameter</strong>.</p>&#13;
<p>The constraint</p>&#13;
<pre class="pre"><code>std::same_as&lt;T, U&gt;</code></pre>&#13;
<p>compares the type <code>T</code> to one type from the parameter pack <code>U</code>. This constraint is in a fold expression, so the <strong>parameter pack expansion (<code>...</code>)</strong> applies <code>std::same_as&lt;T, U&gt;</code> once for each type from the parameter pack <code>U</code>, comparing every type in <code>U</code> to the type <code>T</code>. If every <code>U</code> is the same as <code>T</code>, then the constraint evaluates to <code>true</code>. Line 13 in the <code>foldingSum</code> function template applies our <code>SameTypeElements</code> concept to the function’s type parameters.</p>&#13;
<h5 class="h5" id="ch15lev3sec80">Calling <code>foldingSum</code></h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> In <code>main</code>, lines 21 and 22 call <code>foldingSum</code> with three <code>int</code>s and three <code>string</code>s, respectively. Each call has three arguments of the same type, so these statements will successfully compile. However, line 23 attempts to call <code>foldingSum</code> with an <code>int</code>, a <code>double</code> and a <code>string</code>. In that call, type <code>T</code> in the <code>SameTypeElements</code> concept is <code>int</code>, and types <code>double</code> and <code>string</code> are placed in the parameter pack <code>U</code>. Of course, both <code>double</code> and <code>string</code> are not <code>int</code>, so each use of the concept <code>std::same_as&lt;T, U&gt;</code> fails. <a href="ch15.xhtml#fig15_18">Figure 15.18</a> shows the <strong>Clang</strong> compiler error messages. We highlighted key messages in bold and added vertical spacing for readability. Clang indicates:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p895pro01" id="p895pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><strong><code>error: no matching function for call to</code></strong></pre>&#13;
<p>and</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p895pro02" id="p895pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><strong><code>note: candidate template ignored: constraints not satisfied</code></strong></pre>&#13;
<p>It also points out in its notes each individual <code>std::same_as</code> test that failed because a type was not the same as <code>int</code>:</p>&#13;
<pre class="pre"><strong><code>note: because</code></strong>&#13;
<strong><code>note: and false</code></strong></pre>&#13;
<h3 class="h3" id="sec15_13"><span class="violet">15.13</span> Template Metaprogramming</h3>&#13;
<p>As we’ve mentioned, a goal of modern C++ is to do work at compile time to enable the compiler to optimize your code for runtime performance. Much of this optimization work is done via <strong><span class="violet">template metaprogramming (TMP)</span></strong>, which enables the compiler to</p>&#13;
<p class="bull">• manipulate types,</p>&#13;
<p class="bull">• perform compile-time computations, and</p>&#13;
<p class="bull">• generate optimized code.</p>&#13;
<p>The <strong>concepts</strong>, <strong>concept-based overloading</strong> and <strong>type traits</strong> capabilities we’ve introduced in this chapter all are crucial template-metaprogramming capabilities.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Template metaprogramming is complex. When properly used, it can help you improve the runtime performance of your programs. So it’s important to be aware of template metaprogramming’s powerful capabilities.</p>&#13;
<p>Our goal in this section is to present a variety of manageable template-metaprogramming examples and to provide in our footnote citations resources for further study. We’ll show examples demonstrating:</p>&#13;
<p class="bull">• computing values at compile-time with metafunctions,</p>&#13;
<p class="bull">• computing values at compile-time with <code>constexpr</code> functions,</p>&#13;
<p class="bull">• using type traits at compile-time via the <code>constexpr if</code> statement to optimize runtime performance, and</p>&#13;
<p class="bull">• manipulating types at compile-time with metafunctions.</p>&#13;
<h4 class="h4" id="sec15_13_1">15.13.1 C++ Templates Are Turing Complete</h4>&#13;
<p>Todd Veldhuizen proved that C++ templates are <strong>Turing complete</strong>,<sup><a id="ch15fn84a" href="ch15.xhtml#ch15fn84">84</a>,<a id="ch15fn85a" href="ch15.xhtml#ch15fn85">85</a></sup> so anything that can be computed at runtime with traditional C++, also can be computed at compile-time with C++ template metaprogramming. One of the first attempts to demonstrate such compile-time computation was presented in 1994 during C++’s early standardization efforts. Erwin Unruh wrote a template metaprogram to calculate the prime numbers less than 30.<sup><a id="ch15fn86a" href="ch15.xhtml#ch15fn86">86</a>,<a id="ch15fn87a" href="ch15.xhtml#ch15fn87">87</a></sup> Though the program did not compile, the compiler’s error messages included the prime-number calculation results. You can view the original program— which is no longer valid C++—and the original compiler error messages at:</p>&#13;
<p class="footnote"><a id="ch15fn84" href="ch15.xhtml#ch15fn84a">84</a>. Todd Veldhuizen, “C++ Templates are Turing Complete,” 2003. Accessed July 2, 2021. <code><a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670">https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn85" href="ch15.xhtml#ch15fn85a">85</a>. “Template metaprogramming.” Accessed July 2, 2021. <code><a href="https://en.wikipedia.org/wiki/Template_metaprogramming">https://en.wikipedia.org/wiki/Template_metaprogramming</a></code>.</p>&#13;
<p class="footnote"><a id="ch15fn86" href="ch15.xhtml#ch15fn86a">86</a>. Erwin Unruh, “Prime Number Computation,” 1994. ANSI X3J16-94-0075/ISO WG21-4-62.</p>&#13;
<p class="footnote"><a id="ch15fn87" href="ch15.xhtml#ch15fn87a">87</a>. Rainer Grimm, “C++ Core Guidelines: Rules for Template Metaprogramming,” January 7, 2019. Accessed July 2, 2021. <code><a href="https://www.modernescpp.com/index.php/c-core-guidelines-rules-for-template-metaprogramming">https://www.modernescpp.com/index.php/c-core-guidelines-rules-for-template-metaprogramming</a></code>. Our thanks to Rainer Grimm for this blog post that pointed us to the historical note about Erwin Unruh.</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p896pro01" id="p896pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">http://www.erwin-unruh.de/primorig.html</pre>&#13;
<p>Here are a few of those error messages. The specializations of his class template <code>D</code> showing the first several prime numbers are highlighted in bold:</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p896pro02" id="p896pro02a">Click here to view code image</a></p>&#13;
<pre class="pre1">|    Type <strong>D&lt;2&gt;</strong>'("primes.cpp",L2/C25).&#13;
|    Type <strong>D&lt;3&gt;</strong>' ("primes.cpp",L2/C25).&#13;
|    Type <strong>D&lt;5&gt;</strong>' ("primes.cpp",L2/C25).&#13;
|    Type <strong>D&lt;7&gt;</strong>' ("primes.cpp",L2/C25).</pre>&#13;
<h4 class="h4" id="sec15_13_2">15.13.2 Computing Values at Compile Time</h4>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The goal of compile-time calculations is to optimize a program’s runtime performance.<sup><a id="ch15fn88a" href="ch15.xhtml#ch15fn88">88</a></sup> <a href="ch15.xhtml#fig15_19">Figure 15.19</a> uses template metaprogramming to calculate factorials at compile time. First, we use a recursive factorial definition implemented with templates. Then, we show two compile-time <code>constexpr</code> functions using the iterative and recursive algorithms presented in <a href="ch05.xhtml#ch05lev1sec18">Section 5.18</a>. The C++ Core Guidelines recommend using <code>constexpr</code> functions to compute values at compile time<sup>89</sup>—such functions use traditional C++ syntax.</p>&#13;
<p class="footnote"><a id="ch15fn88" href="ch15.xhtml#ch15fn88a">88</a>. “Template metaprogramming.” Accessed June 24, 2021. <code><a href="https://en.wikipedia.org/wiki/Template_metaprogramming">https://en.wikipedia.org/wiki/Template_metaprogramming</a></code>.</p>&#13;
<div class="group" id="fig15_19">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro19" id="p15pro19a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_19.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Calculating factorials at compile time.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="lgreen">// Factorial value metafunction calculates factorials recursively</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">template</span> &lt;<span class="blue">int</span> N&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">struct</span> Factorial {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">static constexpr long long</span> value{N * Factorial&lt;N - <span class="green">1</span>&gt;::value};&#13;
<span class="cviolet"> <strong>9</strong></span>   };&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="lgreen">// Factorial specialization for the base case</span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">template</span> &lt;&gt;&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">struct</span> Factorial&lt;<span class="green">0</span>&gt; {&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">static constexpr long long</span> value{<span class="green">1</span>}; <span class="lgreen">// 0! is 1</span>&#13;
<span class="cviolet"><strong>15</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// constexpr compile-time recursive factorial</span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">constexpr long long</span> recursiveFactorial(<span class="blue">int</span> number) {&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">if</span> (number &lt;= <span class="green">1</span>) {&#13;
<span class="cviolet"><strong>20</strong></span>         <span class="blue">return</span> <span class="green">1</span>; <span class="lgreen">// base cases: 0! = 1 and 1! = 1</span>&#13;
<span class="cviolet"><strong>21</strong></span>      }&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">else</span> { <span class="lgreen">// recursion step</span>&#13;
<span class="cviolet"><strong>23</strong></span>         <span class="blue">return</span> number * recursiveFactorial(number - <span class="green">1</span>);&#13;
<span class="cviolet"><strong>24</strong></span>      }&#13;
<span class="cviolet"><strong>25</strong></span>   }&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// constexpr compile-time iterative factorial</span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">constexpr long long</span> iterativeFactorial(<span class="blue">int</span> number) {&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="blue">long long</span> factorial{<span class="green">1</span>}; <span class="lgreen">// result for 0! and 1!</span>&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>      <span class="blue">for</span> (<span class="blue">long long</span> i{<span class="green">2</span>}; i &lt;= number; ++i) {&#13;
<span class="cviolet"><strong>32</strong></span>         factorial *= i;&#13;
<span class="cviolet"><strong>33</strong></span>      }&#13;
<span class="cviolet"><strong>34</strong></span>&#13;
<span class="cviolet"><strong>35</strong></span>      <span class="blue">return</span> factorial;&#13;
<span class="cviolet"><strong>36</strong></span>   }&#13;
<span class="cviolet"><strong>37</strong></span>&#13;
<span class="cviolet"><strong>38</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>39</strong></span>      <span class="lgreen">// "calling" a value metafunction requires specializing</span>&#13;
<span class="cviolet"><strong>40</strong></span>      <span class="lgreen">// the template and accessing its static value member</span>&#13;
<span class="cviolet"><strong>41</strong></span>      std::cout &lt;&lt; <span class="green">"CALCULATING FACTORIALS AT COMPILE-TIME"</span>&#13;
<span class="cviolet"><strong>42</strong></span>         &lt;&lt; <span class="green">"\nWITH A RECURSIVE METAFUNCTION"</span>&#13;
<span class="cviolet"><strong>43</strong></span>         &lt;&lt; <span class="green">"\nFactorial(0): "</span> &lt;&lt; Factorial&lt;<span class="green">0</span>&gt;::value&#13;
<span class="cviolet"><strong>44</strong></span>         &lt;&lt; <span class="green">"\nFactorial(1): "</span> &lt;&lt; Factorial&lt;<span class="green">1</span>&gt;::value&#13;
<span class="cviolet"><strong>45</strong></span>         &lt;&lt; <span class="green">"\nFactorial(2): "</span> &lt;&lt; Factorial&lt;<span class="green">2</span>&gt;::value&#13;
<span class="cviolet"><strong>46</strong></span>         &lt;&lt; <span class="green">"\nFactorial(3): "</span> &lt;&lt; Factorial&lt;<span class="green">3</span>&gt;::value&#13;
<span class="cviolet"><strong>47</strong></span>         &lt;&lt; <span class="green">"\nFactorial(4): "</span> &lt;&lt; Factorial&lt;<span class="green">4</span>&gt;::value&#13;
<span class="cviolet"><strong>48</strong></span>         &lt;&lt; <span class="green">"\nFactorial(5): "</span> &lt;&lt; Factorial&lt;<span class="green">5</span>&gt;::value;&#13;
<span class="cviolet"><strong>49</strong></span>&#13;
<span class="cviolet"><strong>50</strong></span>      <span class="lgreen">// calling the recursive constexpr function recursiveFactorial</span>&#13;
<span class="cviolet"><strong>51</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nCALCULATING FACTORIALS AT COMPILE-TIME"</span>&#13;
<span class="cviolet"><strong>52</strong></span>         &lt;&lt; <span class="green">"\nWITH A RECURSIVE CONSTEXPR FUNCTION"</span>&#13;
<span class="cviolet"><strong>53</strong></span>         &lt;&lt; <span class="green">"\nrecursiveFactorial(0): "</span> &lt;&lt; recursiveFactorial(<span class="green">0</span>)&#13;
<span class="cviolet"><strong>54</strong></span>         &lt;&lt; <span class="green">"\nrecursiveFactorial(1): "</span> &lt;&lt; recursiveFactorial(<span class="green">1</span>)&#13;
<span class="cviolet"><strong>55</strong></span>         &lt;&lt; <span class="green">"\nrecursiveFactorial(2): "</span> &lt;&lt; recursiveFactorial(<span class="green">2</span>)&#13;
<span class="cviolet"><strong>56</strong></span>         &lt;&lt; <span class="green">"\nrecursiveFactorial(3): "</span> &lt;&lt; recursiveFactorial(<span class="green">3</span>)&#13;
<span class="cviolet"><strong>57</strong></span>         &lt;&lt; <span class="green">"\nrecursiveFactorial(4): "</span> &lt;&lt; recursiveFactorial(<span class="green">4</span>)&#13;
<span class="cviolet"><strong>58</strong></span>         &lt;&lt; <span class="green">"\nrecursiveFactorial(5): "</span> &lt;&lt; recursiveFactorial(<span class="green">5</span>);&#13;
<span class="cviolet"><strong>59</strong></span>&#13;
<span class="cviolet"><strong>60</strong></span>      <span class="lgreen">// calling the iterative constexpr function recursiveFactorial</span>&#13;
<span class="cviolet"><strong>61</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nCALCULATING FACTORIALS AT COMPILE-TIME"</span>&#13;
<span class="cviolet"><strong>62</strong></span>         &lt;&lt; <span class="green">"\nWITH AN ITERATIVE CONSTEXPR FUNCTION"</span>&#13;
<span class="cviolet"><strong>63</strong></span>         &lt;&lt; <span class="green">"\niterativeFactorial(0): "</span> &lt;&lt; iterativeFactorial(<span class="green">0</span>)&#13;
<span class="cviolet"><strong>64</strong></span>         &lt;&lt; <span class="green">"\niterativeFactorial(1): "</span> &lt;&lt; iterativeFactorial(<span class="green">1</span>)&#13;
<span class="cviolet"><strong>65</strong></span>         &lt;&lt; <span class="green">"\niterativeFactorial(2): "</span> &lt;&lt; iterativeFactorial(<span class="green">2</span>)&#13;
<span class="cviolet"><strong>66</strong></span>         &lt;&lt; <span class="green">"\niterativeFactorial(3): "</span> &lt;&lt; iterativeFactorial(<span class="green">3</span>)&#13;
<span class="cviolet"><strong>67</strong></span>         &lt;&lt; <span class="green">"\niterativeFactorial(4): "</span> &lt;&lt; iterativeFactorial(<span class="green">4</span>)&#13;
<span class="cviolet"><strong>68</strong></span>         &lt;&lt; <span class="green">"\niterativeFactorial(5): "</span> &lt;&lt; iterativeFactorial(<span class="green">5</span>) &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>69</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">CALCULATING FACTORIALS AT COMPILE-TIME&#13;
WITH A RECURSIVE METAFUNCTION&#13;
Factorial(0): 1&#13;
Factorial(1): 1&#13;
Factorial(2): 2&#13;
Factorial(3): 6&#13;
Factorial(4): 24&#13;
Factorial(5): 120&#13;
&#13;
CALCULATING FACTORIALS AT COMPILE-TIME&#13;
WITH A RECURSIVE CONSTEXPR FUNCTION&#13;
recursiveFactorial(0): 1&#13;
recursiveFactorial(1): 1&#13;
recursiveFactorial(2): 2&#13;
recursiveFactorial(3): 6&#13;
recursiveFactorial(4): 24&#13;
recursiveFactorial(5): 120&#13;
&#13;
CALCULATING FACTORIALS AT COMPILE-TIME&#13;
WITH AN ITERATIVE CONSTEXPR FUNCTION&#13;
iterativeFactorial(0): 1&#13;
iterativeFactorial(1): 1&#13;
iterativeFactorial(2): 2&#13;
iterativeFactorial(3): 6&#13;
iterativeFactorial(4): 24&#13;
iterativeFactorial(5): 120</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.19</strong></span> | Calculating factorials at compile time. (Part 3 of 3.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec81">Metafunctions</h5>&#13;
<p>You can perform compile-time calculations with <strong><span class="violet">metafunctions</span></strong>. Like the functions you’ve defined so far, metafunctions have arguments and return values, but their syntax is significantly different. <strong>Metafunctions are implemented as class templates—</strong>typically using <code>struct</code>s<strong>.</strong> A metafunction’s arguments are the items used to specialize the class template, and its return value is a <code>public</code> class member. The type traits introduced in <a href="ch15.xhtml#sec15_5">Section 15.5</a> are metafunctions.</p>&#13;
<p>There are two types of metafunctions:</p>&#13;
<p class="bull">• A <strong><span class="violet">value metafunction</span></strong> is a class template with a <code>public static constexpr</code> <strong>data member named <code>value</code></strong>. The class template uses its template arguments to compute <code>value</code> at compile time. This is how we implement factorial calculations.</p>&#13;
<p class="bull">• A <strong><span class="violet">type metafunction</span></strong> is a class template with a <strong>nested <code>type</code> member</strong>, typically defined as a <strong>type alias</strong>. The class template uses its template arguments to manipulate a type at compile time. <a href="ch15.xhtml#sec15_13_4">Section 15.13.4</a> presents type metafunctions.</p>&#13;
<p>The metafunction member names <code>value</code> and <code>type</code> are conventions<sup><a id="ch15fn90a" href="ch15.xhtml#ch15fn90">90</a></sup> used throughout the C++ standard library and in metaprogramming in general.</p>&#13;
<p class="footnote"><a id="ch15fn90" href="ch15.xhtml#ch15fn90a">90</a>. Jody Hagins, “Template Metaprogramming: Type Traits (part 1 of 2),” YouTube video, September 22, 2020. Accessed June 15, 2021. <code><a href="https://www.youtube.com/watch?v=tiAVWcjIF6o">https://www.youtube.com/watch?v=tiAVWcjIF6o</a></code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec82"><code>Factorial</code> Metafunction</h5>&#13;
<p>Our <code>Factorial</code> metafunction (lines 6–9) is implemented using the recursive factorial definition:</p>&#13;
<p class="pren"><em>n</em>! = <em>n</em>  · (<em>n</em> – 1)! </p>&#13;
<p><code>Factorial</code> has one <strong>non-type template parameter</strong>—the <code>int</code> parameter <code>N</code> (line 6)—representing the metafunction’s argument. Per the C++ standard’s conventions for value meta-functions, line 8 defines a <code>public static contexpr</code> data member named <code>value</code>. Factorials grow quickly, so we declared the variable’s type as <code>long long</code>. The constant <code>value</code> is initialized with the result of the expression:</p>&#13;
<pre class="pre">N * Factorial&lt;N - <span class="green">1</span>&gt;::value</pre>&#13;
<p>which mulitplies <code>N</code> by the result of “calling” the <code>Factorial</code> metafunction for <code>N - 1</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec83">“Calling” a Metafunction</h5>&#13;
<p><strong>You “call” a metafunction by specializing its template</strong>, which probably feels weird to you. For example, to calculate the factorial of 3, you’d use the specialization:</p>&#13;
<pre class="pre">Factorial&lt;<span class="green">3</span>&gt;::value</pre>&#13;
<p>in which <code>3</code> is the <strong>template argument</strong> and <code>::value</code> is the <strong>return value</strong>. This expression causes the compiler to create a new type representing the factorial of 3. We’ll say more about this momentarily.</p>&#13;
<h5 class="h5" id="ch15lev3sec84"><code>Factorial</code> Metafunction Specialization for the Base Case—<strong><code>Factorial&lt;0&gt;</code></strong></h5>&#13;
<p>For the recursive factorial calculation, 0! is the <strong>base case</strong>, which is defined to be 1. In <strong>meta-function recursion</strong>, you specify the base case with a <strong><span class="violet">full template specialization</span></strong> (lines 12– 15). Such a specialization uses the notation <code>template &lt;&gt;</code> (line 12) to indicate that all the template’s arguments will be specified explicitly in the angle brackets following the class name. The full template specialization <code>Factorial&lt;0&gt;</code> matches only <code>Factorial</code> calls with the argument <code>0</code>. Line 14 sets the specialization’s <code>value</code> member to be <code>1</code>.<sup><a id="ch15fn91a" href="ch15.xhtml#ch15fn91">91</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn91" href="ch15.xhtml#ch15fn91a">91</a>. <a href="ch05.xhtml#ch05lev1sec18">Section 5.18</a> specified that 0 and 1 are both base cases for factorial calculations. To mimic that, we could implement a second full template specialization named <code>Factorial&lt;1&gt;</code>. As implemented, the <code>Factorial</code> metafunction handles <code>Factorial&lt;1&gt;</code> as <code>1 * Factorial&lt;0&gt;</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec85">How the Compiler Evaluates Metafunction <code>Factorial</code> for the Argument <strong><code>0</code></strong></h5>&#13;
<p>When the compiler encounters a metafunction call, such as <strong><code>Factorial&lt;0&gt;::value</code></strong> (line 41 in <code>main</code>), it must determine which <code>Factorial</code> class template to use. The template argument is the <code>int</code> value <code>0</code>. The class template <code>Factorial</code> in lines 6–9 can match any <code>int</code> value, and the full-template specialization <code>Factorial&lt;0&gt;</code> in lines 12–15 specifically matches only the value 0. <strong>The compiler always chooses the most specialized template from multiple matching templates.</strong> So, <code>Factorial&lt;0&gt;</code> matches the full template specialization, and <code>Factorial&lt;0&gt;::value</code> evaluates to <code>1</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec86">How the Compiler Evaluates Metafunction <code>Factorial</code> for the Argument <strong><code>3</code></strong></h5>&#13;
<p>Now, let’s reconsider the metafunction call <strong><code>Factorial&lt;3&gt;::value</code></strong> (line 46 in <code>main</code>). The compiler generates each specialization needed produce the final result at compile time. When the compiler encounters <strong><code>Factorial&lt;3&gt;::value</code></strong>, it specializes the class template in lines 6–9 with <code>3</code> as the argument. In doing so, line 8 of the specialization becomes</p>&#13;
<pre class="pre"><strong><code>3 * Factorial&lt;2&gt;::value</code></strong></pre>&#13;
<p>The compiler sees that to complete the <strong><code>Factorial&lt;3&gt;</code></strong> definition, it must specialize the template again for <strong><code>Factorial&lt;2&gt;</code></strong>. In that specialization, line 8 becomes</p>&#13;
<pre class="pre"><strong><code>2 * Factorial&lt;1&gt;::value</code></strong></pre>&#13;
<p>Next, the compiler sees that to complete the <strong><code>Factorial&lt;2&gt;</code></strong> definition, it must specialize the template again for <strong><code>Factorial&lt;1&gt;</code></strong>. In that specialization, line 8 becomes</p>&#13;
<pre class="pre"><strong><code>1 * Factorial&lt;0&gt;::value</code></strong></pre>&#13;
<p>The compiler knows that <strong><code>Factorial&lt;0&gt;::value</code></strong> is <strong><code>1</code></strong> from the full specialization in lines 12–15. This completes the <code>Factorial</code> specializations for <strong><code>Factorial&lt;3&gt;</code></strong>.</p>&#13;
<p>Now, the compiler knows everything it needs to complete the earlier <code>Factorial</code> specializations:</p>&#13;
<p class="bull">• <strong><code>Factorial&lt;1&gt;::value</code></strong> stores the result of <code>1 * 1</code>, which is <code>1</code>.</p>&#13;
<p class="bull">• <strong><code>Factorial&lt;2&gt;::value</code></strong> stores the result of <code>2 * 1</code>, which is <code>2</code>.</p>&#13;
<p class="bull">• <strong><code>Factorial&lt;3&gt;::value</code></strong> stores the result of <code>3 * 2</code>, which is <code>6</code>.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> So the compiler can insert the final constant value <code>6</code> in place of the original metafunction call—<strong>without any runtime overhead</strong>. Each of the <code>Factorial</code> metafunction calls in lines 43–48 of <code>main</code> are evaluated similarly by the compiler, <strong>enabling it to optimize the program’s performance by removing computations from runtime</strong>.</p>&#13;
<h5 class="h5" id="ch15lev3sec87">Functional Programming</h5>&#13;
<p>None of what the compiler does during <strong>template specialization</strong> modifies variable values after they’re initialized.<sup><a id="ch15fn92a" href="ch15.xhtml#ch15fn92">92</a></sup> <strong>There are no mutable variables in template metaprograms</strong>. This is a hallmark of <strong>functional programming</strong>. All the values processed in this example are compile-time constants.</p>&#13;
<p class="footnote"><a id="ch15fn92" href="ch15.xhtml#ch15fn92a">92</a>. “Template metaprogramming.” Accessed June 24, 2021. <code><a href="https://en.wikipedia.org/wiki/Template_metaprogramming">https://en.wikipedia.org/wiki/Template_metaprogramming</a></code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec88">Using <code>constexpr</code> Functions to Perform Compile-Time Calculations</h5>&#13;
<p>As you can see, using metafunctions to calculate values at compile time is not as straightforward as using traditional runtime functions. C++ provides two options for compile-time evaluation of traditional functions:</p>&#13;
<p class="bull">• A function declared <span class="violet"><strong><code>constexpr</code></strong></span> can be <strong>called at compile-time or runtime</strong>, but it must produce a constant.</p>&#13;
<p class="bull">• <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> In C++20, you can declare a function <span class="violet"><strong><code>consteval</code></strong></span> (rather than <code>constexpr</code>) to indicate that it can be <strong>called only at compile-time</strong> to produce a constant.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Many computations performed with metafunctions are easier to implement using traditional functions that are declared <code>constexpr</code> or <code>consteval</code>. Such functions also are part of compile-time metaprogramming</strong>. In fact, various members of the C++ standard committee prefer <code>constexpr</code>-based metaprogramming over template-based metaprogramming, which is “difficult to use, does not scale well and is basically equivalent to inventing a new language within C++.”<sup><a id="ch15fn93a" href="ch15.xhtml#ch15fn93">93</a></sup> They’ve proposed various <code>constexpr</code> enhancements to simplify other aspects of metaprogramming in future C++ versions.</p>&#13;
<p class="footnote"><a id="ch15fn93" href="ch15.xhtml#ch15fn93a">93</a>. Louis Dionne, “Metaprogramming by design, not by accident,” June 18, 2017. Accessed June 30, 2021. <code><a href="https://wg21.link/p0425r0">https://wg21.link/p0425r0</a></code>.</p>&#13;
<p>Lines 18–25 and 28–36 define the <code>recursiveFactorial</code> and <code>iterativeFactorial</code> functions using the algorithms from <a href="ch05.xhtml#ch05lev1sec18">Section 5.18</a> and traditional C++ sytnax. Each function is declared <code>constexpr</code>, so the compiler can evaluate the function’s result at compile time. Lines 53–58 demonstrate <code>recursiveFactorial</code>, and lines 63–68 demonstrate <code>iterativeFactorial</code>.</p>&#13;
<h4 class="h4" id="sec15_13_3">15.13.3 Conditional Compilation with Template Metaprogramming and <code>constexpr if</code></h4>&#13;
<p><span class="size">20</span> <span class="size">17</span> Another aspect of doing more at compile time to optimize runtime execution is generating code that executes optimally at runtime. <a href="ch15.xhtml#sec15_6_4">Section 15.6.4</a> showed the C++20 way to optimize runtime execution for a <code>customDistance</code> function template using <strong>concept-based function overloading</strong>. In that example, the compiler chose the correct overloaded function template to call based on the template parameter’s type constraints. Here, we’ll reimplement that example using a single <code>customDistance</code> function template. Inside the function, a C++17 <strong>compile-time <code>if</code> statement</strong>—known as a <span class="violet"><strong><code>constexpr</code></strong></span> <span class="violet"><strong><code>if</code></strong></span>—uses the <strong><code>std::is_same</code> type trait</strong> (introduced in <a href="ch15.xhtml#sec15_12_7">Section 15.12.7</a>) to decide whether to generate the <em>O</em>(1) or <em>O</em>(<em>n</em>) distance calculation based on the function’s iterator arguments.</p>&#13;
<div class="group" id="fig15_20">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro20" id="p15pro20a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_20.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Implementing customDistance using template metaprogramming.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;list&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;ranges&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;type_traits&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="lgreen">// calculate the distance (number of items) between two iterators;</span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="lgreen">// requires at least input iterators</span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> Iterator&gt;&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">requires</span> std::input_iterator&lt;Iterator&gt;&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">auto</span> customDistance(Iterator begin, Iterator end) {&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="lgreen">// for random-access iterators subtract the iterators</span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">if constexpr</span> (std::is_same&lt;Iterator::iterator_category,&#13;
<span class="cviolet"><strong>17</strong></span>         std::random_access_iterator_tag&gt;::value) {&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>         std::cout &lt;&lt; <span class="green">"customDistance with random-access iterators\n"</span>;&#13;
<span class="cviolet"><strong>20</strong></span>         <span class="blue">return</span> end - begin; <span class="lgreen">// O(1) operation for random-access iterators</span>&#13;
<span class="cviolet"><strong>21</strong></span>      }&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">else</span> { <span class="lgreen">// for all other iterators</span>&#13;
<span class="cviolet"><strong>23</strong></span>         std::cout &lt;&lt; <span class="green">"customDistance with non-random-access iterators\n"</span>;&#13;
<span class="cviolet"><strong>24</strong></span>         std::ptrdiff_t count{0};&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>         <span class="lgreen">// increment from begin to end and count number of iterations;</span>&#13;
<span class="cviolet"><strong>27</strong></span>         <span class="lgreen">// O(n) operation for non-random-access iterators</span>&#13;
<span class="cviolet"><strong>28</strong></span>         <span class="blue">for</span> (<span class="blue">auto</span>&amp; iter{begin}; iter != end; ++iter) {&#13;
<span class="cviolet"><strong>29</strong></span>            ++count;&#13;
<span class="cviolet"><strong>30</strong></span>         }&#13;
<span class="cviolet"><strong>31</strong></span>&#13;
<span class="cviolet"><strong>32</strong></span>         <span class="blue">return</span> count;&#13;
<span class="cviolet"><strong>33</strong></span>      }&#13;
<span class="cviolet"><strong>34</strong></span>   }&#13;
<span class="cviolet"><strong>35</strong></span>&#13;
<span class="cviolet"><strong>36</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>37</strong></span>      <span class="blue">const</span> std::array ints1{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>}; <span class="lgreen">// has random-access iterators</span>&#13;
<span class="cviolet"><strong>38</strong></span>      <span class="blue">const</span> std::list ints2{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>}; <span class="lgreen">// has bidirectional iterators</span>&#13;
<span class="cviolet"><strong>39</strong></span>&#13;
<span class="cviolet"><strong>40</strong></span>      <span class="blue">auto</span> result1{customDistance(ints1.begin(), ints1.end())};&#13;
<span class="cviolet"><strong>41</strong></span>      std::cout &lt;&lt; <span class="green">"ints1 number of elements: "</span> &lt;&lt; result1 &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>42</strong></span>      <span class="blue">auto</span> result2{customDistance(ints2.begin(), ints2.end())};&#13;
<span class="cviolet"><strong>43</strong></span>      std::cout &lt;&lt; <span class="green">"ints1 number of elements: "</span> &lt;&lt; result2 &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>44</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">customDistance with random-access iterators&#13;
ints1 number of elements: 5&#13;
customDistance with non-random-access iterators&#13;
ints1 number of elements: 3</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.20</strong></span> | Implementing <code>customDistance</code> using template metaprogramming. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>Lines 12–34 define function template <code>customDistance</code>. Since this function requires <strong>at least input iterators</strong> to perform its task, line 13 constrains the type parameter <code>Iterator</code> using the <strong>concept <code>std::input_iterator</code></strong>. Though the <strong>compile-time <code>if</code> statement</strong> is known in the C++ standard as a <strong><code>constexpr if</code></strong>, it’s written in code as <strong><code>if constexpr</code></strong> (line 16). This statement’s condition must evaluate at compile-time to a <code>bool</code>.</p>&#13;
<p>Lines 16–17 use the <strong><code>std::is_same</code> type trait</strong> to compare two types:</p>&#13;
<p class="bull">• <code>Iterator::iterator_category</code> and</p>&#13;
<p class="bull">• <code>std::random_access_iterator_tag</code>.</p>&#13;
<p>Recall that a standard iterator has a <strong>nested type named <code>iterator_category</code></strong>, which designates the iterator’s type using one of the following “<code>tag</code>” types from <strong>header <code>&lt;iterator&gt;</code></strong>:</p>&#13;
<p class="bull">• <strong><code>input_iterator_tag</code></strong>,</p>&#13;
<p class="bull">• <strong><code>output_iterator_tag</code></strong>,</p>&#13;
<p class="bull">• <strong><code>forward_iterator_tag</code></strong>,</p>&#13;
<p class="bull">• <strong><code>bidirectional_iterator_tag</code></strong>,</p>&#13;
<p class="bull">• <strong><code>random_access_iterator_tag</code></strong>, or</p>&#13;
<p class="bull">• <strong><code>contiguous_iterator_tag</code></strong>.</p>&#13;
<p>In line 16, the expression <strong><code>Iterator::iterator_category</code></strong> gets the iterator tag from the argument’s iterator type, which the <strong>metafunction <code>std::is_same</code></strong> then compares to</p>&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p902pro01" id="p902pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>std::random_access_iterator_tag</code></pre>&#13;
<p>The comparison result is <code>true</code> or <code>false</code>, which we access via <strong>metafunction <code>std::is_same</code></strong>’s <strong><code>value</code> member</strong>. If <strong><code>value</code></strong> is <code>true</code>, the compiler instantiates the code in the <code>if constexpr</code> body (lines 19–20), which is optimized for <strong>random-access iterators</strong> to perform the <strong><em>O</em>(1)</strong> calculation. Otherwise, the compiler instantiates <code>else</code>’s body (lines 23–32), which uses the <strong><em>O</em>(<em>n</em>)</strong> approach that works for all other iterator types.</p>&#13;
<h4 class="h4" id="sec15_13_4">15.13.4 Type Metafunctions</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Type metafunctions frequently are used to add attributes to and remove attributes from types at compile-time</strong>. This is a more advanced template-metaprogramming technique used primarily by template class-library implementers. Here, we’ll add and remove type attributes using our own type metafunctions that mimic ones from the <strong><code>&lt;type_traits&gt;</code> header</strong> so you can see how they might be implemented. We’ll also use predefined ones. <strong>Always prefer the <code>&lt;type_traits&gt;</code> header’s predefined type traits rather than implementing your own.</strong></p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch15_images.xhtml#p15pro21" id="p15pro21a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig15_21.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Adding and removing type attributes with type metafunctions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;type_traits&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="lgreen">// add const to a type T</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">struct</span> my_add_const {&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">using</span> type = <span class="blue">const</span> T;&#13;
<span class="cviolet"><strong>11</strong></span>   };&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="lgreen">// general case: no pointer in type, so set nested type variable to T</span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt;&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">struct</span> my_remove_ptr {&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">using</span> type = T;&#13;
<span class="cviolet"><strong>17</strong></span>   };&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="lgreen">// partial template specialization: T is a pointer type, so remove *</span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt;&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">struct</span> my_remove_ptr&lt;T*&gt; {&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">using</span> type = T;&#13;
<span class="cviolet"><strong>23</strong></span>   };&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>26</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"{}\n{}{}\n{}{}\n\n"</span>,&#13;
<span class="cviolet"><strong>27</strong></span>         <span class="green">"ADD CONST TO A TYPE VIA A CUSTOM TYPE METAFUNCTION"</span>,&#13;
<span class="cviolet"><strong>28</strong></span>         <span class="green">"std::is_same&lt;const int, my_add_const&lt;int&gt;::type&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>29</strong></span>         std::is_same&lt;con<span class="blue">st</span> <span class="blue">int</span>, my_add_const&lt;<span class="blue">int</span>&gt;::type&gt;::value,&#13;
<span class="cviolet"><strong>30</strong></span>         <span class="green">"std::is_same&lt;int* const, my_add_const&lt;int*&gt;::type&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>31</strong></span>         std::is_same&lt;int<span class="blue">*</span> <span class="blue">const</span>, my_add_const&lt;<span class="blue">int</span>*&gt;::type&gt;::value);&#13;
<span class="cviolet"><strong>32</strong></span>&#13;
<span class="cviolet"><strong>33</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"{}\n{}{}\n{}{}\n\n"</span>,&#13;
<span class="cviolet"><strong>34</strong></span>         <span class="green">"REMOVE POINTER FROM TYPES VIA A CUSTOM TYPE METAFUNCTION"</span>,&#13;
<span class="cviolet"><strong>35</strong></span>         <span class="green">"std::is_same&lt;int, my_remove_ptr&lt;int&gt;::type&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>36</strong></span>         std::is_same&lt;int<span class="blue">, m</span>y_remove_ptr&lt;int<span class="blue">&gt;::</span>type&gt;::value,&#13;
<span class="cviolet"><strong>37</strong></span>         <span class="green">"std::is_same&lt;int, my_remove_ptr&lt;int*&gt;::type&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>38</strong></span>         std::is_same&lt;int<span class="blue">, m</span>y_remove_ptr&lt;int<span class="blue">*&gt;:</span>:type&gt;::value);&#13;
<span class="cviolet"><strong>39</strong></span>&#13;
<span class="cviolet"><strong>40</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"{}\n{}{}\n{}{}\n\n"</span>,&#13;
<span class="cviolet"><strong>41</strong></span>         <span class="green">"ADD REFERENCES TO TYPES USING STANDARD TYPE TRAITS"</span>,&#13;
<span class="cviolet"><strong>42</strong></span>         <span class="green">"std::is_same&lt;int&amp;, std::add_lvalue_reference&lt;int&gt;::type&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>43</strong></span>         std::is_same&lt;int<span class="blue">&amp;,</span> std::add_lvalue_reference&lt;int<span class="blue">&gt;::</span>type&gt;::value,&#13;
<span class="cviolet"><strong>44</strong></span>         <span class="green">"std::is_same&lt;int&amp;&amp;, std::add_rvalue_reference&lt;int&gt;::type&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>45</strong></span>         std::is_same&lt;int<span class="blue">&amp;&amp;,</span> std::add_rvalue_reference&lt;int<span class="blue">&gt;::</span>type&gt;::value);&#13;
<span class="cviolet"><strong>46</strong></span>&#13;
<span class="cviolet"><strong>47</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"{}\n{}{}\n{}{}\n{}{}\n"</span>,&#13;
<span class="cviolet"><strong>48</strong></span>         <span class="green">"REMOVE REFERENCES FROM TYPES USING STANDARD TYPE TRAITS"</span>,&#13;
<span class="cviolet"><strong>49</strong></span>         <span class="green">"std::is_same&lt;int, std::remove_reference&lt;int&gt;::type&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>50</strong></span>         std::is_same&lt;int<span class="blue">, s</span>td::remove_reference&lt;int<span class="blue">&gt;::</span>type&gt;::value,&#13;
<span class="cviolet"><strong>51</strong></span>         <span class="green">"std::is_same&lt;int, std::remove_reference&lt;int&amp;&gt;::type&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>52</strong></span>         std::is_same&lt;int<span class="blue">, s</span>td::remove_reference&lt;int<span class="blue">&amp;&gt;:</span>:type&gt;::value,&#13;
<span class="cviolet"><strong>53</strong></span>         <span class="green">"std::is_same&lt;int, std::remove_reference&lt;int&amp;&amp;&gt;::type&gt;::value: "</span>,&#13;
<span class="cviolet"><strong>54</strong></span>         std::is_same&lt;int<span class="blue">, s</span>td::remove_reference&lt;int<span class="blue">&amp;&amp;&gt;</span>::type&gt;::value);&#13;
<span class="cviolet"><strong>55</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">ADD CONST TO A TYPE VIA A CUSTOM TYPE METAFUNCTION&#13;
std::is_same&lt;const int, my_add_const&lt;int&gt;::type&gt;::value: true&#13;
std::is_same&lt;int* const, my_add_const&lt;int*&gt;::type&gt;::value: true&#13;
&#13;
REMOVE POINTER FROM TYPES VIA A CUSTOM TYPE METAFUNCTION&#13;
std::is_same&lt;int, my_remove_ptr&lt;int&gt;::type&gt;::value: true&#13;
std::is_same&lt;int, my_remove_ptr&lt;int*&gt;::type&gt;::value: true&#13;
&#13;
ADD REFERENCES TO TYPES USING STANDARD TYPE TRAITS&#13;
std::is_same&lt;int&amp;, std::add_lvalue_reference&lt;int&amp;gt;::type&gt;::value: true&#13;
std::is_same&lt;int&amp;&amp;, std::add_rvalue_reference&lt;int&amp;gt;::type&gt;::value: true&#13;
&#13;
REMOVE REFERENCES FROM TYPES USING STANDARD TYPE TRAITS&#13;
std::is_same&lt;int, std::remove_reference&lt;int&amp;gt;::type&gt;::value: true&#13;
std::is_same&lt;int, std::remove_reference&lt;int&amp;&gt;::type&gt;::value: true&#13;
std::is_same&lt;int, std::remove_reference&lt;int&amp;&amp;&gt;::type&gt;::value: true</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 15.21</strong></span> | Compile-time type manipulation. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec89">Adding <code>const</code> to a Type</h5>&#13;
<p>Lines 8–11 implement a <strong>type metafunction</strong> named <strong><code>my_add_const</code></strong> that’s a simplified version of the <strong><code>std::add_const</code> metafunction</strong> from header <code>&lt;type_traits&gt;</code>. By convention, a <strong>type metafunction must have a <code>public</code> member named <code>type</code></strong>. When <strong><code>my_add_const</code></strong> is specialized with a type, the compiler defines the type alias in line 10, which precedes the type with <code>const</code>. The <strong>predefined <code>std::add_const</code> metafunction</strong> is more elaborate. It also checks whether the type <code>T</code> is a reference, a function, or a <code>const</code>-qualified type and, if so, sets its <code>type</code> member to that same type; otherwise, it applies <code>const</code> to the type.<sup><a id="ch15fn94a" href="ch15.xhtml#ch15fn94">94</a></sup></p>&#13;
<p class="footnote"><a id="ch15fn94" href="ch15.xhtml#ch15fn94a">94</a>. “20.15.8.2 Const-volatile modifications [meta.trans.cv].” Accessed June 26, 2021. <code><a href="https://eel.is/c++draft/meta#trans.cv">https://eel.is/c++draft/meta#trans.cv</a></code>.</p>&#13;
<p>Lines 26–31 in <code>main</code> demonstrate the <strong><code>my_add_const</code> metafunction</strong>. Line 29</p>&#13;
<pre class="pre">my_add_const&lt;<span class="blue">int</span>&gt;::type</pre>&#13;
<p>specializes the template with the non-<code>const</code> type <code>int</code>. To confirm that <code>const</code> was added to <code>int</code>, we use the <strong>type trait <code>std::is_same</code></strong> to compare the type <code>const int</code> to the type returned by the preceding expression. They are the same, so <strong><code>std::is_same</code>’s <code>value</code></strong> member is <code>true</code>, as shown in the output.</p>&#13;
<h5 class="h5" id="ch15lev3sec90">Removing * from a Pointer Type</h5>&#13;
<p>Lines 14–17 and 20–23 implement a <strong>custom type metafunction named <code>my_remove_ptr</code></strong> that mimics the <strong><code>std::remove_pointer</code> metafunction</strong> from the <strong><code>&lt;type_traits&gt;</code> header</strong> to show how that metafunction could be implemented. This requires two metafunction class templates:</p>&#13;
<p class="bull">• The one in lines 14–17 handles the general case in which a type is not a pointer. Line 16’s type alias defines the <code>type</code> member simply as <code>T</code>, which can be specialized with any type. For any type that does not include an <code>*</code> to indicate a pointer, this metafunction simply returns the type used to specialize the template.</p>&#13;
<p class="bull">• The metafunction class template in lines 20–23 matches only pointer types. For this purpose, we define a <strong><span class="violet">partial template specialization</span></strong>.<sup><a id="ch15fn95a" href="ch15.xhtml#ch15fn95">95</a></sup> Unlike a <strong>full template specialization</strong> that begins with the <strong>template header <code>template&lt;&gt;</code></strong>, a partial template specialization still specifies a <code>template</code> header (line 20) with one or more parameters, which it uses in the angle brackets following the class name (line 21). In this case, the partial specialization is that <code>T</code> must be a pointer—indicated with <code>T*</code>. To remove the <code>*</code> from the pointer type, the type alias in line 22 defines the <code>type</code> member simply as <code>T</code>.</p>&#13;
<p class="footnote"><a id="ch15fn95" href="ch15.xhtml#ch15fn95a">95</a>. Inbal Levi. “Exploration of C++20 Metaprogramming.” September 29, 2020. Accessed June 14, 2021. <code><a href="https://www.youtube.com/watch?v=XgrjybKaIV8">https://www.youtube.com/watch?v=XgrjybKaIV8</a></code>.</p>&#13;
<p>Lines 36 and 38 in <code>main</code> demonstrate our <strong>custom <code>my_remove_ptr</code> type metafunctions</strong>. Let’s consider the compiler’s matching process for invoking them.</p>&#13;
<h5 class="h5" id="ch15lev3sec91">Specializing <code>my_remove_pointer</code> for Non-Pointer Types</h5>&#13;
<p>The expression in line 36</p>&#13;
<pre class="pre"><strong>my_remove_ptr&lt;int&gt;::type</strong></pre>&#13;
<p>specializes the template with the non-pointer type <code>int</code>. The compiler must decide which definition of <strong><code>my_remove_ptr</code></strong> matches the template specialization. Since there is no <code>*</code> to indicate a pointer in the type <code>int</code>, this specialization matches only the <strong><code>my_remove_ptr</code></strong> definition in lines 14–17, which sets its <code>type</code> member to the type argument <code>int</code>. To confirm this, we use the <strong>type trait <code>std::is_same</code></strong> to compare type <code>int</code> to the type returned by the preceding expression. They are the same, so <strong><code>std::is_same</code>’s <code>value</code></strong> member is <code>true</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec92">Specializing <code>my_remove_pointer</code> for Pointer Types</h5>&#13;
<p>The expression in line 38</p>&#13;
<pre class="pre"><strong>my_remove_ptr&lt;int*&gt;::type</strong></pre>&#13;
<p>specializes the template with the pointer type <code>int*</code>, which can match both definitions of <strong><code>my_remove_const</code></strong>:</p>&#13;
<p class="bull">• the first definition can match any type, and</p>&#13;
<p class="bull">• the second can match any pointer type.</p>&#13;
<p>Again, the <strong>compiler always chooses the most specific matching template</strong>. In this case, the type <code>int*</code> matches the <strong>partial template specialization</strong> in lines 20–23:</p>&#13;
<p class="bull">• the <code>int</code> in the preceding expression matches <code>T</code> in line 21, and</p>&#13;
<p class="bull">• the <code>*</code> in the preceding expression matches the <code>*</code> in line 21, separating it from the type <code>int</code>—this is what enables the <strong>partial template specialization</strong> to remove the pointer (<code>*</code>) from the type.</p>&#13;
<p>To confirm that the <code>*</code> was removed, we use <strong><code>std::is_same</code></strong> to compare <code>int</code> to the type returned by the preceding expression. They are the same, so <strong><code>std::is_same</code>’s <code>value</code></strong> member is <code>true</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec93">Adding <em>lvalue</em> and <em>rvalue</em> References to a Type</h5>&#13;
<p>The <strong>predefined type metafunctions</strong> that modify types work similarly to our <strong><code>my_add_const</code></strong> and <strong><code>my_remove_ptr</code></strong> type metafunctions. Lines 43 and 45 in <code>main</code> demonstrate the <strong>predefined type metafunctions <code>add_lvalue_reference</code></strong> and <strong><code>add_rvalue_reference</code></strong>. Line 43 converts type <code>int</code> to type <code>int&amp;</code>—an <strong><em>lvalue</em> reference type</strong>. Line 45 converts type <code>int</code> to type <code>int&amp;&amp;</code>—an <strong><em>rvalue</em> reference type</strong>. We use <strong><code>std::is_same</code></strong> to confirm both results.</p>&#13;
<h5 class="h5" id="ch15lev3sec94">Removing <em>lvalue</em> and <em>rvalue</em> References from a Reference Type</h5>&#13;
<p>Lines 50, 52 and 54 test the <strong><code>&lt;type_traits&gt;</code> header</strong>’s <strong>predefined <code>std::remove_reference</code> metafunction</strong>, which removes <em>lvalue</em> or <em>rvalue</em> references from a type. We specialize <strong><code>std::remove_reference</code></strong> with the types <code>int</code>, <code>int&amp;</code> and <code>int&amp;&amp;</code>, respectively:</p>&#13;
<p class="bull">• non-reference types (like <code>int</code>) are returned as is,</p>&#13;
<p class="bull">• <em>lvalue</em> reference types have the <code>&amp;</code> removed, and</p>&#13;
<p class="bull">• <em>rvalue</em> reference types have the <code>&amp;&amp;</code> removed.</p>&#13;
<p>To confirm this, we use <strong><code>std::is_same</code></strong> to compare <code>int</code> to the type returned by each expression in lines 50, 52 and 54. They are the same, so <code>std::is_same</code>’s <code>value</code> member is <code>true</code> in each case.</p>&#13;
<h3 class="h3" id="sec15_14"><span class="violet">15.14</span> Wrap-Up</h3>&#13;
<p>In this chapter, we demonstrated the power of generic programming and compile-time polymorphism with templates and concepts. We used class templates to create related custom classes, distinguishing between the templates you write and template specializations the compiler generates from your code.</p>&#13;
<p>We introduced C++20’s abbreviated function templates and templated lambdas. We used C++20 concepts to constrain template parameters and overload function templates based on their type requirements. Next, we introduced type traits and showed how they relate to C++20 concepts. We created our own custom concept and showed how to test it at compile-time with <code>static_assert</code>.</p>&#13;
<p>We demonstrated how to create a custom concept-constrained algorithm, then used it to manipulate objects of several C++ standard library container classes. Next, we rebuilt our class <code>MyArray</code> as a custom container class template with custom iterators. We showed that those iterators enabled C++ standard library algorithms to manipulate <code>MyArray</code> elements. We also introduced non-type template parameters for passing compile-time constants to templates and discussed default template arguments.</p>&#13;
<p>We demonstrated that variadic templates can receive any number of parameters, first using the standard library’s <code>tuple</code> variadic class template, then with variadic function templates. We also showed how to apply binary operators to variadic parameter packs using fold expressions.</p>&#13;
<p>Many of the techniques we demonstrated are newer ways to perform various aspects of compile-time metaprogramming. We concluded with an introduction to several other metaprogramming techniques, including how to compute values at compile time with value metafunctions, how to perform compile-time conditional compilation with <code>constexpr if</code> and how to modify types at compile time with type metafunctions.</p>&#13;
<p>In the next chapter, we present C++ techniques that enable you to take advantage of your system’s multicore architecture—concurrency, parallelism, C++20 coroutines and the parallel STL algorithms.</p>&#13;
</div></body>
</html>