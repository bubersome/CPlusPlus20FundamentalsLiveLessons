<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch16">Chapter 16. C++20 Modules: Large-Scale Development</h2>&#13;
<div class="image"><img src="Images/common.jpg" alt="Images" width="370" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Understand the motivation for modularity, especially for large software systems.</p>&#13;
<p class="squ"><span class="red">■</span> See how modules improve encapsulation.</p>&#13;
<p class="squ"><span class="red">■</span>  <code>import</code> standard library headers as module header units.</p>&#13;
<p class="squ"><span class="red">■</span> Define a <code>module</code>’s primary interface unit.</p>&#13;
<p class="squ"><span class="red">■</span>  <code>export</code> declarations from a <code>module</code> to make them available to other translation units.</p>&#13;
<p class="squ"><span class="red">■</span>  <code>import</code> modules to use their <code>export</code>ed declarations.</p>&#13;
<p class="squ"><span class="red">■</span> Separate a module’s interface from its implementation by placing the implementation in a <code>:private</code> module fragment or a module implementation unit.</p>&#13;
<p class="squ"><span class="red">■</span> See what compilation errors occur when you attempt to use non-exported module items.</p>&#13;
<p class="squ"><span class="red">■</span> Use module partitions to organize modules into logical components.</p>&#13;
<p class="squ"><span class="red">■</span> Divide a module into “submodules” so client-code developers can choose the portion(s) of a library they wish to use.</p>&#13;
<p class="squ"><span class="red">■</span> Understand visibility vs. reachability of declarations.</p>&#13;
<p class="squ"><span class="red">■</span> See how modules can reduce translation unit sizes and compilation times.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_1"><span class="violet"><strong>16.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_2"><span class="violet"><strong>16.2</strong></span> Compilation and Linking Prior to C++20</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_3"><span class="violet"><strong>16.3</strong></span> Advantages and Goals of Modules</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_4"><span class="violet"><strong>16.4</strong></span> Example: Transitioning to Modules— Header Units</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_5"><span class="violet"><strong>16.5</strong></span> Example: Creating and Using a Module</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_5_1">16.5.1  <code>module</code> Declaration for a Module Interface Unit</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_5_2">16.5.2 Exporting a Declaration</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_5_3">16.5.3 Exporting a Block of Declarations</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_5_4">16.5.4 Exporting a <code>namespace</code></a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_5_5">16.5.5 Exporting a <code>namespace</code> Member</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_5_6">16.5.6 Importing a Module to Use Its Exported Declarations</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_5_7">16.5.7 Example: Attempting to Access Non-Visible Module Contents</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_6"><span class="violet"><strong>16.6</strong></span> Global Module Fragment</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_7"><span class="violet"><strong>16.7</strong></span> Separating Interface from Implementation</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_7_1">16.7.1 Example: The <code>:private</code> Module Fragment</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_7_2">16.7.2 Example: Module Implementation Units</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_7_3">16.7.3 Example: Modularizing a Class</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_8"><span class="violet"><strong>16.8</strong></span> Partitions</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_8_1">16.8.1 Example: Module Interface Partition Units</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_8_2">16.8.2 Module Implementation Partition Units</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_8_3">16.8.3 Example: “Submodules” vs. Partitions</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_9"><span class="violet"><strong>16.9</strong></span> Additional Modules Examples</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_9_1">16.9.1 Example: Importing the C++ Standard Library as Modules</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_9_2">16.9.2 Example: Cyclic Dependencies Are Not Allowed</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_9_3">16.9.3 Example: <code>imports</code> Are Not Transitive</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_9_4">16.9.4 Example: Visibility vs. Reachability</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_10"><span class="violet"><strong>16.10</strong></span> Modules Can Reduce Translation Unit Sizes and Compilation Times</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_11"><span class="violet"><strong>16.11</strong></span> Migrating Code to Modules</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_12"><span class="violet"><strong>16.12</strong></span> Future of Modules and Modules Tooling</a></p>&#13;
<p class="chap-lev1"><a href="ch16.xhtml#sec16_13"><span class="violet"><strong>16.13</strong></span> Wrap-Up</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_14">Appendix: Modules Videos Bibliography</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_15">Appendix: Modules Articles Bibliography</a></p>&#13;
<p class="chap-lev2"><a href="ch16.xhtml#sec16_16">Appendix: Modules Glossary</a></p>&#13;
</div>&#13;
<h3 class="h3" id="sec16_1"><span class="violet">16.1</span> Introduction</h3>&#13;
<p><span class="size">20</span> <span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <strong><span class="violet">Modules</span></strong>—one of C++20’s “big four” features—provide a new way to organize your code, precisely control which declarations you expose to client code and encapsulate implementation details.<sup><a id="ch16fn1a" href="ch16.xhtml#ch16fn1">1</a></sup> Each module is a uniquely named, reusable group of related declarations and definitions with a well-defined interface that client code can use.</p>&#13;
<p class="footnote"><a id="ch16fn1" href="ch16.xhtml#ch16fn1a">1</a>. Daveed Vandevoorde, “Modules in C++ (Revision 6),” January 11, 2012. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf</a></code>.</p>&#13;
<p>This chapter presents many complete, working code examples that introduce modules. Modules help developers be more productive, especially as they build, maintain and evolve <strong>large software systems</strong>.<sup><a id="ch16fn2a" href="ch16.xhtml#ch16fn2">2</a></sup> Modules also help make such systems more scalable.<sup><a id="ch16fn3a" href="ch16.xhtml#ch16fn3">3</a></sup> C++ creator Bjarne Stroustrup says, “Modules offer a historic opportunity to improve code hygiene and compile times for C++ (bringing C++ into the 21st century).”<sup><a id="ch16fn4a" href="ch16.xhtml#ch16fn4">4</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn2" href="ch16.xhtml#ch16fn2a">2</a>. Gabriel Dos Reis, “Programming in the Large With C++ 20 - Meeting C++ 2020 Keynote,” December 11, 2020. Accessed August 7, 2021. <code><a href="https://www.youtube.com/watch?v=j4du4LNsLiI">https://www.youtube.com/watch?v=j4du4LNsLiI</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn3" href="ch16.xhtml#ch16fn3a">3</a>. Vassil Vassilev1, David Lange1, Malik Shahzad Muzaffar, Mircho Rodozov, Oksana Shadura and Alexander Penev, “C++ Modules in ROOT and Beyond,” August 25, 2020. Accessed August 15, 2021. <code><a href="https://arxiv.org/pdf/2004.06507.pdf">https://arxiv.org/pdf/2004.06507.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn4" href="ch16.xhtml#ch16fn4a">4</a>. Bjarne Stroustrup, “Modules and macros.” February 11, 2018. Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0955r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0955r0.pdf</a></code>.</p>&#13;
<p>Even in small systems, modules can offer immediate benefits in every program. For example, you can replace C++ standard library <code>#include</code> preprocessor directives with <code>import</code> statements. This eliminates repeated processing of <code>#include</code>d content because modules-style <code>import</code>ed headers (<a href="ch16.xhtml#sec16_4">Section 16.4</a>), and modules in general, are <strong>compiled once</strong> then reused where you import them in the program.</p>&#13;
<h5 class="h5" id="ch16lev3sec1">Brief History of Modules</h5>&#13;
<p>C++ modules were challenging to implement, and the effort took many years. The first designs were proposed in the early 2000s, but the C++ committee was focused on completing C++0x, which eventually became C++11. In 2014, modularization efforts continued with the proposal, “A Module System for C++,” based on Gabriel Dos Reis’s and Bjarne Stroustrup’s work at Texas A&amp;M University.<sup><a id="ch16fn5a" href="ch16.xhtml#ch16fn5">5</a>,<a id="ch16fn6a" href="ch16.xhtml#ch16fn6">6</a></sup> The C++ committee formed a modules study group that eventually led to the Modules TS (technical specification).<sup><a id="ch16fn7a" href="ch16.xhtml#ch16fn7">7</a></sup> Most subsequent committee discussions focused on technical compromises and the specification details for C++20’s modules capabilities.<sup><a id="ch16fn8a" href="ch16.xhtml#ch16fn8">8</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn5" href="ch16.xhtml#ch16fn5a">5</a>. Bjarne Stroustrup, “Thriving in a Crowded and Changing World: C++ 2006–2020—<a href="ch09.xhtml#ch09lev2sec1">Section 9.3.1</a> Modules,” June 12, 2020. Accessed August 14 2021. <code><a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn6" href="ch16.xhtml#ch16fn6a">6</a>. Gabriel Dos Reis, Mark Hall and Gor Nishanov, “A Module System for C++,” May 27, 2014. Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4047.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4047.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn7" href="ch16.xhtml#ch16fn7a">7</a>. Gabriel Dos Reis (Ed.), “Working Draft, Extensions to C++ for Modules,” January 29, 2018. Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4720.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4720.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn8" href="ch16.xhtml#ch16fn8a">8</a>. Bjarne Stroustrup, “Thriving in a Crowded and Changing World: C++ 2006–2020—<a href="ch09.xhtml#ch09lev2sec1">Section 9.3.1</a> Modules,” June 12, 2020. Accessed August 14 2021. <code><a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf</a></code>.</p>&#13;
<h5 class="h5" id="ch16lev3sec2">Compiler Support for Modules</h5>&#13;
<p>At the time of this writing, our preferred compilers did not fully support modules. We tried each live-code example on each compiler. For the most part, we were able to compile each example on each compiler. We present the required compilation commands for each example and indicate which compiler(s), if any, did not support that modules feature.<sup><a id="ch16fn9a" href="ch16.xhtml#ch16fn9">9</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn9" href="ch16.xhtml#ch16fn9a">9</a>. The compilation steps for all three compilers might change as their modules implementations evolve. If you encounter problems with the steps, email us at <code>deitel@deitel.com</code>. We’ll respond promptly and post updates on the book’s website <code><a href="https://deitel.com/c-plus-plus-20-for-programmers">https://deitel.com/c-plus-plus-20-for-programmers</a></code>.</p>&#13;
<h5 class="h5" id="ch16lev3sec3">Docker Containers for <code>g++</code> 11.2 and <strong><code>clang++</code></strong> 13</h5>&#13;
<p>To test our modules code examples in the most current <code>g++</code> and <code>clang++</code> versions, we used the following free <strong>Docker containers</strong> from <code><a href="https://hub.docker.com">https://hub.docker.com</a></code>:</p>&#13;
<p class="bull">• For <code>g++</code>, we used the official GNU GCC container’s latest version (11.2):</p>&#13;
<pre class="pre"><code>docker pull gcc:latest</code></pre>&#13;
<p class="bull">• The LLVM/Clang team does not have an official Docker container, but many working containers are available on <code>hub.docker.com</code>. We used the most recent and widely downloaded one containing <code>clang++</code> version 13:<sup><a id="ch16fn10a" href="ch16.xhtml#ch16fn10">10</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn10" href="ch16.xhtml#ch16fn10a">10</a>. The version of <code>clang++</code> in Xcode does not have as many of the C++20 features implemented as the version directly from the LLVM/Clang team. Also, at the time of this writing, using <code>"latest"</code> rather than <code>"13"</code> in the <code>docker pull</code> command gives you a docker container with <code>clang++</code> 12 not 13.</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1035pro01" id="p1035pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>docker pull teeks99/clang-ubuntu:13</code></pre>&#13;
<p>If you’re not familiar with running Docker containers, see the book’s Before You Begin section, and the Docker overview and getting started instructions at:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1035pro02" id="p1035pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>https://docs.docker.com/get-started/overview/</code></pre>&#13;
<h5 class="h5" id="ch16lev3sec4">C++ Compilation and Linking Prior to C++20</h5>&#13;
<p>In <a href="ch16.xhtml#sec16_2">Section 16.2</a>, we’ll discuss the traditional C++ compilation and linking process and various problems with that model.</p>&#13;
<h5 class="h5" id="ch16lev3sec5">Advantages and Goals of Modules</h5>&#13;
<p>In <a href="ch16.xhtml#sec16_3">Section 16.3</a>, we’ll point out various modules benefits, some of which correct problems with and improve upon the pre-C++20 compilation process.</p>&#13;
<h5 class="h5" id="ch16lev3sec6">Future of Modules and Modules Tooling</h5>&#13;
<p><a href="ch16.xhtml#sec16_12">Section 16.12</a>, Future of Modules and Modules Tooling, discusses and provides references for some C++23 modules features that are under development.</p>&#13;
<h5 class="h5" id="ch16lev3sec7">Videos and Articles Bibliographies; Modules Glossary</h5>&#13;
<p>For your further study, we provide appendices at the end of this chapter containing lists of videos, articles, papers and documentation we referenced as we wrote this chapter. We also provide a modules glossary with key modules terms and definitions.</p>&#13;
<h3 class="h3" id="sec16_2"><span class="violet">16.2</span> Compilation and Linking Prior to C++20</h3>&#13;
<p>C++ has always had a <strong>modular architecture for managing code</strong> via a combination of <strong>header files</strong> and <strong>source-code files</strong>:</p>&#13;
<p class="bull">• Under the guidance of <strong>preprocessor directives</strong>, the <strong>preprocessor</strong> performs <strong>text substitutions</strong> and other text manipulations on each <strong>source-code file</strong>. A preprocessed source-code file is called a <strong><span class="violet">translation unit</span></strong>.<sup><a id="ch16fn11a" href="ch16.xhtml#ch16fn11">11</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn11" href="ch16.xhtml#ch16fn11a">11</a>. "Translation unit (programming)." Accessed August 18, 2021. <code><a href="https://en.wikipedia.org/wiki/Translation_unit_(programming)">https://en.wikipedia.org/wiki/Translation_unit_(programming)</a></code>.</p>&#13;
<p class="bull">• The compiler converts each <strong>translation unit</strong> into an <strong>object-code file</strong>.</p>&#13;
<p class="bull">• The <strong>linker</strong> combines a program’s <strong>object-code files</strong> with library object files, such as those of the <strong>C++ standard library</strong>, to create a program’s <strong>executable</strong>.</p>&#13;
<p>This approach has been around since the 1970s. C++ inherited it from C.<sup><a id="ch16fn12a" href="ch16.xhtml#ch16fn12">12</a></sup> We discuss the preprocessor in online Appendix D, Preprocessor.<sup><a id="ch16fn13a" href="ch16.xhtml#ch16fn13">13</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn12" href="ch16.xhtml#ch16fn12a">12</a>. Gabriel Dos Reis, “Programming with C++ Modules: Guide for the Working Software Developer,” October 5, 2019. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=tjSuKOz5HK4">https://www.youtube.com/watch?v=tjSuKOz5HK4</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn13" href="ch16.xhtml#ch16fn13a">13</a>. If you’re not familiar with the preprocessor, you might want to read online Appendix D, Preprocessor, before reading this chapter.</p>&#13;
<h5 class="h5" id="ch16lev3sec8">Problems with the Current Header-File/Source-Code-File Model</h5>&#13;
<p>The preprocessor is simply a <strong>text-substitution mechanism</strong>—it does not understand C++. As motivation for C++20 modules, C++ creator Bjarne Stroustrup calls out three key preprocessor problems:<sup><a id="ch16fn14a" href="ch16.xhtml#ch16fn14">14</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn14" href="ch16.xhtml#ch16fn14a">14</a>. Bjarne Stroustrup, “Thriving in a Crowded and Changing World: C++ 2006–2020—<a href="ch09.xhtml#ch09lev2sec1">Section 9.3.1</a> Modules,” June 12, 2020. Accessed August 14 2021. <code><a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf</a></code>.</p>&#13;
<p class="bull"><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> • One header’s contents can affect any subsequent <code>#include</code>d header, so <strong>the order of <code>#include</code>s is important</strong> and can cause subtle errors.</p>&#13;
<p class="bull"><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> • A given C++ entity can have <strong>different declarations in multiple translation units</strong>. The compiler and linker do not always report such problems.</p>&#13;
<p class="bull"><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> • <strong>Reprocessing the same <code>#include</code>d content is slow</strong>, particularly in large programs where a header can be included dozens or even hundreds of times. For each <code>#include</code>, the preprocessor will insert the header’s contents in a <strong>translation unit</strong>, possibly causing the same code to be compiled many times. Eliminating this reprocessing by instead <code>import</code>ing headers as <strong>header units</strong> can significantly improve compilation times in large codebases.</p>&#13;
<p>Other preprocessor problems include:<sup><a id="ch16fn15a" href="ch16.xhtml#ch16fn15">15</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn15" href="ch16.xhtml#ch16fn15a">15</a>. Bryce Adelstein Lelbach, “Modules are coming,” May 1, 2020. Accessed August 12, 2021. <code><a href="https://www.youtube.com/watch?v=yee9i2rUF3s">https://www.youtube.com/watch?v=yee9i2rUF3s</a></code>.</p>&#13;
<p class="bull">• Definitions in headers can violate C++’s <strong>One Definition Rule (ODR)</strong>. The ODR says, “No translation unit shall contain more than one definition of any variable, function, class type, enumeration type, template, default argument for a parameter (for a function in a given scope), or default template argument.”<sup><a id="ch16fn16a" href="ch16.xhtml#ch16fn16">16</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn16" href="ch16.xhtml#ch16fn16a">16</a>. “C++20 Standard: 6 Basics—6.3 One-definition rule.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/basic.def.odr">https://eel.is/c++draft/basic.def.odr</a></code>.</p>&#13;
<p class="bull">• <strong>Headers do not offer encapsulation</strong>—everything in a header is available to the translation unit that <code>#include</code>s the header.</p>&#13;
<p class="bull">• Headers can have <strong>accidental cyclic dependencies</strong> on one another that cause compilation errors and other problems.<sup><a id="ch16fn17a" href="ch16.xhtml#ch16fn17">17</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn17" href="ch16.xhtml#ch16fn17a">17</a>. “Circular dependency.” Accessed August 18, 2021. <code><a href="https://en.wikipedia.org/wiki/Circular_dependency">https://en.wikipedia.org/wiki/Circular_dependency</a></code>.</p>&#13;
<p class="bull"><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> • Headers often define <strong><span class="violet">macros</span></strong>—<span class="violet"><strong><code>#define</code></strong></span><strong><span class="violet"> preprocessor directives</span></strong> that create constants represented as symbols (such as, <code>#define SIZE 10</code>), and function-like operations (such as, <code>#define SQUARE(x) ((x) * (x))</code>).<sup><a id="ch16fn18a" href="ch16.xhtml#ch16fn18">18</a></sup> Macros are not part of C++, so the compiler cannot check their syntax and cannot report <strong>multiple-definition errors</strong> if two or more headers define the same macro name.</p>&#13;
<p class="footnote"><a id="ch16fn18" href="ch16.xhtml#ch16fn18a">18</a>. The all capital letters naming for preprocessor constants (like <code>SIZE</code>) and macros (like <code>SQUARE</code>) is a convention that some programmers prefer.</p>&#13;
<h3 class="h3" id="sec16_3"><span class="violet">16.3</span> Advantages and Goals of Modules</h3>&#13;
<p>Some modules benefits include:<sup><a id="ch16fn19a" href="ch16.xhtml#ch16fn19">19</a>,<a id="ch16fn20a" href="ch16.xhtml#ch16fn20">20</a>,<a id="ch16fn21a" href="ch16.xhtml#ch16fn21">21</a>,<a id="ch16fn22a" href="ch16.xhtml#ch16fn22">22</a>,<a id="ch16fn23a" href="ch16.xhtml#ch16fn23">23</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn19" href="ch16.xhtml#ch16fn19a">19</a>. Corentin Jabot, “What do we want from a modularized Standard Library?,” May 16, 2020. Accessed August 12, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2172r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2172r0.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn20" href="ch16.xhtml#ch16fn20a">20</a>. Gabriel Dos Reis and Pavel Curtis, “Modules, Componentization, and Transition,” October 5, 2015. Accessed August 12, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn21" href="ch16.xhtml#ch16fn21a">21</a>. Daniela Engert, “Modules the beginner's guide,” May 2, 2020. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=Kqo-jIq4V3I">https://www.youtube.com/watch?v=Kqo-jIq4V3I</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn22" href="ch16.xhtml#ch16fn22a">22</a>. Rainer Grimm, “C++20: The Advantages of Modules,” May 10, 2020. Accessed August 12, 2021. <code><a href="https://www.modernescpp.com/index.php/cpp20-modules">https://www.modernescpp.com/index.php/cpp20-modules</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn23" href="ch16.xhtml#ch16fn23a">23</a>. Dmitry Guzeev, “A Few Words on C++ Modules,” January 8, 2018. Accessed August 10, 2021. <code><a href="https://medium.com/@dmitrygz/brief-article-on-c-modules-f58287a6c64">https://medium.com/@dmitrygz/brief-article-on-c-modules-f58287a6c64</a></code>.</p>&#13;
<p class="bull"><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> • Better organization and componentization of large codebases.</p>&#13;
<p class="bull">• Reducing translation unit sizes.</p>&#13;
<p class="bull"><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> • Reduced compilation times.<sup><a id="ch16fn24a" href="ch16.xhtml#ch16fn24">24</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn24" href="ch16.xhtml#ch16fn24a">24</a>. Rene Rivera, “Are modules fast? (revision 1),” March 6 2019, Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1441r1.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1441r1.pdf</a></code>.</p>&#13;
<p class="bull">• Eliminating repetitive <code>#include</code> processing—<strong>a compiled module does not have to be re-processed for every source code file that uses it.</strong></p>&#13;
<p class="bull">• Eliminating <code>#include</code> ordering issues.</p>&#13;
<p class="bull">• Eliminating many preprocessor directives that can introduce subtle errors.</p>&#13;
<p class="bull">• Eliminating <strong>One Definition Rule (ODR)</strong> violations.</p>&#13;
<h5 class="h5" id="ch16lev3sec9">Cons of Modules</h5>&#13;
<p>Some modules disadvantages include:<sup><a id="ch16fn25a" href="ch16.xhtml#ch16fn25">25</a>,<a id="ch16fn26a" href="ch16.xhtml#ch16fn26">26</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn25" href="ch16.xhtml#ch16fn25a">25</a>. Steve Downey, “Writing a C++20 Module,” July 5, 2021. Accessed August 18, 2021. <code><a href="https://www.youtube.com/watch?v=AO4piAqV9mg">https://www.youtube.com/watch?v=AO4piAqV9mg</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn26" href="ch16.xhtml#ch16fn26a">26</a>. Eric Niebler, “C++ Modules Might Be Dead-on-Arrival,” January 27, 2019. Accessed August 18, 2019. <code><a href="https://vector-of-bool.github.io/2019/01/27/modules-doa.html">https://vector-of-bool.github.io/2019/01/27/modules-doa.html</a></code>.</p>&#13;
<p class="bull">• Modules support is incomplete in most C++ compilers at the time of this writing.</p>&#13;
<p class="bull">• Existing codebases will need to be modified to fully benefit from modules.</p>&#13;
<p class="bull">• Modules impact systems at a level where it can be challenging to make modules portable across systems.</p>&#13;
<p class="bull">• Modules do not solve C++ problems with respect to packaging and distributing software conveniently, like the package managers used with several other popular languages.</p>&#13;
<p class="bull">• Compiled modules have compiler-specific aspects that are not portable across compilers and platforms, so you might need to distribute modules as source-code until appropriate modules tooling becomes available.</p>&#13;
<p class="bull">• Modules uptake initially will be slow as organizations cautiously review the capabilities, decide how to structure new codebases, potentially modify existing ones and wait for information about the experiences of others.</p>&#13;
<p class="bull">• There currently are few modules recommendations and guidelines—for example, the C++ Core Guidelines have not yet been updated for modules.</p>&#13;
<h3 class="h3" id="sec16_4"><span class="violet">16.4</span> Example: Transitioning to Modules—Header Units</h3>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> One goal of modules is to <strong>eliminate the need for the preprocessor</strong>. There are enormous numbers of preexisting libraries. Most libraries today are provided as</p>&#13;
<p class="bull">• <strong>header-only libraries</strong>,</p>&#13;
<p class="bull">• a combination of <strong>headers and source-code files</strong>, or</p>&#13;
<p class="bull">• a combination of <strong>headers and object-code files</strong>.</p>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> It will take time for library developers to modularize their libraries. Some libraries might never be modularized. As a transitional step from the preprocessor to modules, you can</p>&#13;
<p><span class="violet"><strong><code>import</code></strong></span> existing headers<sup><a id="ch16fn27a" href="ch16.xhtml#ch16fn27">27</a></sup> from the <strong>C++ standard library</strong>, as shown in line 3 of <a href="ch16.xhtml#fig16_1">Fig. 16.1</a>. Doing so treats that header as a <strong><span class="violet">header unit</span></strong>.</p>&#13;
<p class="footnote"><a id="ch16fn27" href="ch16.xhtml#ch16fn27a">27</a>. “C++20 Standard: 10 Modules—10.3 Import declaration.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module.import">https://eel.is/c++draft/module.import</a></code>.</p>&#13;
<div class="group" id="fig16_1">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro01" id="p16pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_01.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Importing a standard library header as a header unit.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;iostream&gt;; <span class="lgreen">// instead of #include &lt;iostream&gt;</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>6</strong></span>      std::cout &lt;&lt; <span class="green">"Welcome to C++20 Modules!\n"</span>;&#13;
<span class="cviolet"> <strong>7</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Welcome to C++20 Modules!</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.1</strong></span> | Importing a standard library header as a header unit.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec10">How Header Units Differ from Header Files</h5>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Rather than the preprocessor including the header’s contents into a source-code file, the compiler processes the header as a <strong>translation unit</strong>, compiling it and producing information to treat the header as a module. In large-scale systems, this <strong>improves compilation performance</strong> because the <strong>header</strong> is compiled once, rather than having its contents inserted into every <strong>translation unit</strong> that includes the <strong>header</strong>.<sup><a id="ch16fn28a" href="ch16.xhtml#ch16fn28">28</a></sup> Header units are similar to using <strong>pre-compiled headers</strong> in some C++ environments prior to modules.<sup><a id="ch16fn29a" href="ch16.xhtml#ch16fn29">29</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn28" href="ch16.xhtml#ch16fn28a">28</a>. Gabriel Dos Reis, “Programming with C++ Modules: Guide for the Working Software Developer,” October 5, 2019. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=tjSuKOz5HK4">https://www.youtube.com/watch?v=tjSuKOz5HK4</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn29" href="ch16.xhtml#ch16fn29a">29</a>. Cameron DaCamara, “Practical C++20 Modules and the future of tooling around C++ Modules,” May 4, 2020. Accessed August 13, 2021. <code><a href="https://www.youtube.com/watch?v=ow2zV0Udd9M">https://www.youtube.com/watch?v=ow2zV0Udd9M</a></code>.</p>&#13;
<p>Unlike <code>#include</code> directives, the order of <code>import</code>s is irrelevant, so for example:<sup><a id="ch16fn30a" href="ch16.xhtml#ch16fn30">30</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn30" href="ch16.xhtml#ch16fn30a">30</a>. Bjarne Stroustrup, “Thriving in a Crowded and Changing World: C++ 2006–2020—<a href="ch09.xhtml#ch09lev2sec1">Section 9.3.1</a> Modules,” June 12, 2020. Accessed August 14 2021. <code><a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf</a></code>.</p>&#13;
<pre class="pre"><span class="blue">import</span> SomeModule;&#13;
<span class="blue">import</span> SomeOtherModule;</pre>&#13;
<p>produces the same results as:</p>&#13;
<pre class="pre"><span class="blue">import</span> SomeOtherModule;&#13;
<span class="blue">import</span> SomeModule;</pre>&#13;
<p>A <strong>header unit</strong>’s declarations are available to the <strong>importing translation unit</strong> because <strong>header units implicitly “export” their contents</strong>.<sup><a id="ch16fn31a" href="ch16.xhtml#ch16fn31">31</a></sup> You’ll see in <a href="ch16.xhtml#sec16_5">Section 16.5</a> that you can specify which declarations a module <strong>exports</strong> for use in other <strong>translation units</strong>—giving you precise control over your module’s interface. Unlike a <code>#include</code>, an <code>import</code> statement does not add code to the <code>importi</code>ng translation unit, so “an unused <code>import</code> is essentially costfree.”<sup><a id="ch16fn32a" href="ch16.xhtml#ch16fn32">32</a></sup> Also, preprocessor directives in a <strong>translation unit</strong> that appear before you <code>import</code> a <strong>header unit</strong> do not affect the header unit’s contents.<sup><a id="ch16fn33a" href="ch16.xhtml#ch16fn33">33</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn31" href="ch16.xhtml#ch16fn31a">31</a>. “C++20 Standard: 10 Modules—10.3 Import declaration.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module.import">https://eel.is/c++draft/module.import</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn32" href="ch16.xhtml#ch16fn32a">32</a>. Bjarne Stroustrup, “Thriving in a Crowded and Changing World: C++ 2006–2020—<a href="ch09.xhtml#ch09lev2sec1">Section 9.3.1</a> Modules,” June 12, 2020. Accessed August 14 2021. <code><a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn33" href="ch16.xhtml#ch16fn33a">33</a>. Eric Niebler, “Understanding C++ Modules: Part 3: Linkage and Fragments,” October 7, 2019. Accessed August 15, 2021. <code><a href="https://vector-of-bool.github.io/2019/10/07/modules-3.html">https://vector-of-bool.github.io/2019/10/07/modules-3.html</a></code>.</p>&#13;
<h5 class="h5" id="ch16lev3sec11">Import All Headers as Header Units (if Possible)</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> You should generally <code>import</code> all headers as <strong>header units</strong> and use <code>#include</code>s only if necessary.<sup><a id="ch16fn34a" href="ch16.xhtml#ch16fn34">34</a></sup> Unfortunately, not all headers can be processed as <strong>header units</strong>. You’ll typically use <code>#include</code> if:</p>&#13;
<p class="footnote"><a id="ch16fn34" href="ch16.xhtml#ch16fn34a">34</a>. Daniela Engert, “Modules the beginner's guide,” May 2, 2020. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=Kqo-jIq4V3I">https://www.youtube.com/watch?v=Kqo-jIq4V3I</a></code>.</p>&#13;
<p class="bull"><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> • importing a <strong>header</strong> as a <strong>header unit</strong> produces <strong>compilation errors</strong>, or</p>&#13;
<p class="bull">• you need to include a <strong>header</strong> that depends on <strong><code>#define</code>d preprocessor macros</strong>— referred to as <strong>preprocessor state</strong>.</p>&#13;
<h5 class="h5" id="ch16lev3sec12">Compiling with Header Units in Microsoft Visual Studio</h5>&#13;
<p>At the time of this writing, many modules features require a preview release of Visual Studio. You can install <strong>Visual Studio preview</strong> releases from:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1040pro01" id="p1040pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>https://visualstudio.microsoft.com/vs/preview/</code></pre>&#13;
<p>On the <code><strong>Available</strong></code> tab, choose the preview release you wish to install, download the installer and run it. For this chapter, we used the free <strong>Microsoft Visual Studio Community 2019 Preview version 16.11.0 Preview 3.0</strong>, but you also may use the <strong>Microsoft Visual Studio Community 2022 Preview 2</strong>—or the latest preview release available.<sup><a id="ch16fn35a" href="ch16.xhtml#ch16fn35">35</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn35" href="ch16.xhtml#ch16fn35a">35</a>. We tried the Visual Studio 2022 preview release and found compilation with it to be slow.</p>&#13;
<p>To compile any of this chapter’s examples that use <strong>header units</strong>, configure your Visual Studio project as follows:<sup><a id="ch16fn36a" href="ch16.xhtml#ch16fn36">36</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn36" href="ch16.xhtml#ch16fn36a">36</a>. This might change once C++20 modules are fully implemented in Visual C++.</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> Right-click the project name in <code><strong>Solution Explorer</strong></code> and select <code><strong>Properties</strong></code>.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> In the <code><strong>Property Pages</strong></code> dialog, select <code><strong>All Configurations</strong></code> from the <code><strong>Configurations</strong></code> drop-down.</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> In the left column, under <code><strong>Configuration Properties &gt; C/C++ &gt; Language</strong></code>, set the <code><strong>C++ Language Standard</strong></code> option to <code><strong>Preview - Features from the Latest C++ Working Draft (/std:c++latest)</strong></code>.</p>&#13;
<p class="num"><span class="red"><strong>4.</strong></span> In the left column, under <code><strong>Configuration Properties &gt; C/C++ &gt; All Options</strong></code> set the <code><strong>Scan Sources for Module Dependencies</strong></code> option to <code><strong>Yes</strong></code>.</p>&#13;
<p class="num"><span class="red"><strong>5.</strong></span> Click <code><strong>Apply</strong></code>, then click <code><strong>OK</strong></code>.</p>&#13;
<p>Add <code>fig16_01.cpp</code> to your project’s <code><strong>Source Files</strong></code> folder, then compile and run the project.</p>&#13;
<h5 class="h5" id="ch16lev3sec13">Compiling with Header Units in <code>g++</code></h5>&#13;
<p>In <code>g++</code>, you must first <strong>compile each header</strong> you’ll <strong><code>import</code></strong> as a <strong>header unit</strong>.<sup><a id="ch16fn37a" href="ch16.xhtml#ch16fn37">37</a>,<a id="ch16fn38a" href="ch16.xhtml#ch16fn38">38</a>,<a id="ch16fn39a" href="ch16.xhtml#ch16fn39">39</a></sup> The following command compiles the <strong><code>&lt;iostream&gt;</code> standard library header</strong> as a <strong>header unit</strong>:</p>&#13;
<p class="footnote"><a id="ch16fn37" href="ch16.xhtml#ch16fn37a">37</a>. This might change once C++20 modules are fully implemented in <code>g++</code>.</p>&#13;
<p class="footnote"><a id="ch16fn38" href="ch16.xhtml#ch16fn38a">38</a>. “3.23 C++ Modules.” Accessed August 10, 2021. <code><a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Modules.html">https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Modules.html</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn39" href="ch16.xhtml#ch16fn39a">39</a>. Nathan Sidwell, “C++ Modules: A Brief Tour,” October 19, 2020. Accessed August 10, 2021. <code><a href="https://accu.org/journals/overload/28/159/sidwell/">https://accu.org/journals/overload/28/159/sidwell/</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1041pro01" id="p1041pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -x c++-system-header iostream</code></pre>&#13;
<p class="bull">• The <span class="violet"><strong><code>-fmodules-ts</code></strong></span> <strong><span class="violet">compiler flag</span></strong> is currently required rather than <code>-std=c++20</code> to compile any code that uses C++20 modules.</p>&#13;
<p class="bull">• The <span class="violet"><strong><code>-x</code></strong></span> <span class="violet"><strong><code>c++-system-header</code></strong></span> <strong><span class="violet">compiler flag</span></strong> indicates that we are compiling a <strong>C++ standard library header</strong> as a <strong>header unit</strong>. You specify the header’s name without the angle brackets.<sup><a id="ch16fn40a" href="ch16.xhtml#ch16fn40">40</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn40" href="ch16.xhtml#ch16fn40a">40</a>. There are also <code>c++-header</code> and <code>c++-user-header</code> flags for precompiling other headers as header units. See <code><a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Modules.html">https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Modules.html</a></code>.</p>&#13;
<p>Next, compile the source-code file <code>fig16_01.cpp</code> using the following command:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1041pro02" id="p1041pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts fig16_01.cpp -o fig16_01</code></pre>&#13;
<p>This produces an <strong>executable</strong> named <code>fig16_01</code>, which you can execute with the command:</p>&#13;
<pre class="pre"><code>./fig16_01</code></pre>&#13;
<h5 class="h5" id="ch16lev3sec14">Compiling with Header Units in clang++</h5>&#13;
<p>Use the following command to compile this example in <code>clang++</code> version 12:<sup><a id="ch16fn41a" href="ch16.xhtml#ch16fn41">41</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn41" href="ch16.xhtml#ch16fn41a">41</a>. This might change once C++20 modules are fully implemented in <code>clang++</code>.</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1041pro03" id="p1041pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
<code>   -fimplicit-module-maps fig16_01.cpp -o fig16_01</code></pre>&#13;
<p>This produces an <strong>executable</strong> named <code>fig16_01</code>, which you can execute with the command:</p>&#13;
<pre class="pre"><code>./fig16_01</code></pre>&#13;
<p>In the compilation command, the flags have the following meanings:</p>&#13;
<p class="bull">• The flag <code>-std=c++20</code> indicates that we’re using C++20 language features.</p>&#13;
<p class="bull">• On some systems, <code>g++</code>’s C++ standard library is the default C++ library. The flag <code>-stdlib=libc++</code> ensures that <code>clang++</code>’s C++ standard library is used.</p>&#13;
<p class="bull">• The flags <code>-fimplicit-modules</code> and <code>-fimplicit-module-maps</code> enable <code>clang++</code> to generate and find the information it needs to treat <strong>headers</strong> as <strong>header units</strong>.</p>&#13;
<h3 class="h3" id="sec16_5"><span class="violet">16.5</span> Example: Creating and Using a Module</h3>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> Next, let’s define our first <strong>module</strong>. A <strong><span class="violet">module’s interface</span></strong> specifies the module members that the module makes available for use in other <strong>translation units</strong>. You do this by <strong><span class="violet">exporting the member’s declaration</span></strong> using the <span class="violet"><strong><code>export</code></strong></span> keyword in one of four ways:<sup><a id="ch16fn42a" href="ch16.xhtml#ch16fn42">42</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn42" href="ch16.xhtml#ch16fn42a">42</a>. “C++ Standard: 10 Modules—10.2 Export declaration.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module.interface">https://eel.is/c++draft/module.interface</a></code>.</p>&#13;
<p class="bull">• <strong><code>export</code> its declaration directly</strong>,</p>&#13;
<p class="bull">• <strong><code>export</code> a block in braces (</strong><code>{</code> <strong>and</strong> <code>}</code><strong>)</strong>—which may contain many declarations,</p>&#13;
<p class="bull">• <strong><code>export</code> a <code>namespace</code></strong>—which may contain many declarations, and</p>&#13;
<p class="bull">• <strong><code>export</code> a <code>namespace</code> member</strong>—which also exports the <code>namespace</code>’s name, but not the <code>namespace</code>’s other members.</p>&#13;
<p>Recall that if the first occurrence of an identifier is its definition, it also serves as the identifier’s declaration. So each item listed above may export declarations or definitions.</p>&#13;
<h4 class="h4" id="sec16_5_1">16.5.1 <code>module</code> Declaration for a Module Interface Unit</h4>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <a href="ch16.xhtml#fig16_2">Figure 16.2</a> defines our first <strong><span class="violet">module unit</span></strong><sup><a id="ch16fn43a" href="ch16.xhtml#ch16fn43">43</a></sup>—a <strong>translation unit</strong> that is part of a module. When a module is composed of <strong>one translation unit</strong>, the <strong>module unit</strong> is commonly referred to simply as a <strong>module</strong>. The module in <a href="ch16.xhtml#fig16_2">Fig. 16.2</a> contains four functions (lines 8–10, 14–16, 21–23 and 28–30) to demonstrate <strong>exporting declarations</strong> for use in other <strong>translation units</strong>. In the following subsections, we’ll discuss the <strong><code>export</code></strong> and <strong><code>namespace</code> “wrappers”</strong> around the functions in lines 14–16, 21–23 and 28–30.</p>&#13;
<p class="footnote"><a id="ch16fn43" href="ch16.xhtml#ch16fn43a">43</a>. “C++ Standard: 10 Modules—10.1 Module units and purviews.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module.unit">https://eel.is/c++draft/module.unit</a></code>.</p>&#13;
<div class="group" id="fig16_2">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro02" id="p16pro02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.2: welcome.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface for a module named welcome.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> welcome; <span class="lgreen">// introduces the module name</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> &lt;string&gt;; <span class="lgreen">// class string is used in this module</span>&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="lgreen">// exporting a function</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">export</span> std::string welcomeStandalone() {&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">return</span> <span class="green">"welcomeStandalone function called"</span>;&#13;
<span class="cviolet"><strong>10</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="lgreen">// export block exports all items in the block's braces</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">export</span> {&#13;
<span class="cviolet"><strong>14</strong></span>      <code>std::string welcomeFromExportBlock() {</code>&#13;
<span class="cviolet"><strong>15</strong></span>         <span class="blue">return</span> <span class="green">"welcomeFromExportBlock function called"</span>;&#13;
<span class="cviolet"><strong>16</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>17</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="lgreen">// exporting a namespace exports all items in the namespace</span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="blue">export</span> <span class="blue">namespace</span> TestNamespace1 {&#13;
<span class="cviolet"><strong>21</strong></span>      <code>std::string welcomeFromTestNamespace1() {</code>&#13;
<span class="cviolet"><strong>22</strong></span>         <span class="blue">return</span> <span class="green">"welcomeFromTestNamespace1 function called"</span>;&#13;
<span class="cviolet"><strong>23</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>24</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="lgreen">// exporting an item in a namespace exports the namespace name too</span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="blue">namespace</span> TestNamespace2 {&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="blue">export</span> std::string welcomeFromTestNamespace2() {&#13;
<span class="cviolet"><strong>29</strong></span>         <span class="blue">return</span> <span class="green">"welcomeFromTestNamespace2 function called"</span>;&#13;
<span class="cviolet"><strong>30</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>31</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.2</strong></span> | Primary module interface for a module named <code>welcome</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec15">Module Declaration and Module Naming</h5>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> Line 3’s <span class="violet"><strong><code>module</code></strong></span><strong><span class="violet"> declaration</span></strong> names the module <code>welcome</code>. <strong>Module names</strong> are identifiers separated by dots (<code>.</code>)<sup><a id="ch16fn44a" href="ch16.xhtml#ch16fn44">44</a></sup>—such as <code>deitel.time</code> or <code>deitel.math</code>, which we’ll use in subsequent examples. The dots do not have special meaning—in fact, there’s a proposal to remove dot-separated naming from modules.<sup><a id="ch16fn45a" href="ch16.xhtml#ch16fn45">45</a></sup> Both <code>deitel.time</code> and <code>deitel.math</code> begin with “<code>deitel.</code>” but these modules are not “submodules” of a larger module named <code>deitel</code>. All declarations from the <strong>module declaration</strong> to the end of the <strong>translation unit</strong> are part of the <strong><span class="violet">module purview</span></strong>, as are declarations from all other units that make up the module.<sup><a id="ch16fn46a" href="ch16.xhtml#ch16fn46">46</a></sup> We show <strong>multi-file modules</strong> in subsequent sections.</p>&#13;
<p class="footnote"><a id="ch16fn44" href="ch16.xhtml#ch16fn44a">44</a>. Corentin Jabot, “Naming guidelines for modules,” June 16, 2019. Accessed August 18, 2021. <code><a href="https://isocpp.org/files/papers/P1634R0.html">https://isocpp.org/files/papers/P1634R0.html</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn45" href="ch16.xhtml#ch16fn45a">45</a>. Michael Spencer, “P1873R1: remove.dots.in.module.names,” September 17, 2019. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1873r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1873r1.html</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn46" href="ch16.xhtml#ch16fn46a">46</a>. “C++ Standard: 10 Modules—10.1 Module units and purviews.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module.unit">https://eel.is/c++draft/module.unit</a></code>.</p>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> When you precede a <strong><code>module</code> declaration</strong> with <span class="violet"><strong><code>export</code></strong></span>, it introduces a <strong><span class="violet">module interface unit</span></strong>, which specifies the <strong>module members</strong> that the <strong>client code</strong> can access. Every module has one <span class="violet"><strong>primary module interface unit</strong></span> containing an <strong><code>export module</code> declaration</strong> that introduces the module’s name. You’ll see in <a href="ch16.xhtml#sec16_8">Section 16.8</a> that the <strong>primary module interface unit</strong> may be composed of <strong>module interface partition units</strong>.</p>&#13;
<h5 class="h5" id="ch16lev3sec16">Module Interface File Extension</h5>&#13;
<p>Microsoft Visual C++ uses the <span class="violet"><strong><code>.ixx</code></strong></span><strong><span class="violet"> filename extension</span></strong> for <strong>module interface units</strong>. To add a <strong>module interface unit</strong> to your Visual C++ project:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> Right-click your project’s <code><strong>Source Files</strong></code> folder and select <code><strong>Add Module…</strong></code>.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> In the <code><strong>Add New Item</strong></code> dialog, specify a file name (we used the name <code>welcome.ixx</code>), specify where you want to save the file and click <code><strong>Add</strong></code>.</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> Replace the default code with the code in <a href="ch16.xhtml#fig16_2">Fig. 16.2</a>.</p>&#13;
<p>You are not required to use the <strong><code>.ixx</code> filename extension</strong>. If you name a <strong>module interface unit</strong>’s file with a different extension, right-click the file in your project, select <code><strong>Properties</strong></code>, and ensure that the file’s <code><strong>Item Type</strong></code> is set to <code><strong>C/C++ compiler</strong></code>.</p>&#13;
<h5 class="h5" id="ch16lev3sec17">Module Interface File Extensions for <code>g++</code> and <strong><code>clang++</code></strong></h5>&#13;
<p><strong>The <code>g++</code> and <code>clang++</code> compilers do not require special filename extensions for module interface units</strong>. We’ll show how to enable <code>g++</code> and <code>clang++</code> to compile <code>.ixx</code> files so you can use the same filename extensions for all three compilers.</p>&#13;
<p>Common filename extensions you’ll encounter when using C++20 modules include:</p>&#13;
<p class="bull">• <strong><code>.ixx</code></strong>—Microsoft Visual C++ filename extension for the <strong>primary module interface unit</strong>.</p>&#13;
<p class="bull">• <strong><code>.ifc</code></strong>—Microsoft Visual C++ filename extension for the compiled version of the <strong>primary module interface unit</strong>.<sup><a id="ch16fn47a" href="ch16.xhtml#ch16fn47">47</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn47" href="ch16.xhtml#ch16fn47a">47</a>. Cameron DaCamara, “Practical C++20 Modules and the future of tooling around C++ Modules,” May 4, 2020. Accessed August 13, 2021. <code><a href="https://www.youtube.com/watch?v=ow2zV0Udd9M">https://www.youtube.com/watch?v=ow2zV0Udd9M</a></code>.</p>&#13;
<p class="bull">• <strong><code>.cpp</code></strong>—Filename extension for the C++ source code in a <strong>translation unit</strong>, including <strong>module units</strong>.</p>&#13;
<p class="bull">• <strong><code>.cppm</code></strong>—A recommended <code>clang++</code> filename extension for <strong>module units</strong>.</p>&#13;
<p class="bull">• <strong><code>.pcm</code></strong>—The <strong>primary module interface unit</strong> filename extension in <code>clang++</code>. When you compile a <strong>primary module interface unit</strong> in <code>clang++</code>, the resulting file uses this extension.</p>&#13;
<h4 class="h4" id="sec16_5_2">16.5.2 Exporting a Declaration</h4>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> You must <span class="violet"><strong><code>export</code></strong></span> <strong><span class="violet">a declaration</span></strong> to make it available for use outside the module. Line 8 of <a href="ch16.xhtml#fig16_2">Fig. 16.2</a> applies <strong><code>export</code></strong> to a function definition, which exports the <strong>function’s declaration</strong> (that is, its <strong>prototype</strong>) as part of the <strong>module’s interface</strong>. All <code>export</code>ed declarations must appear after a <strong><code>module</code> declaration</strong> in a <strong>translation unit</strong> and must appear at either <strong>file scope</strong> (known as <strong><span class="violet">global namespace scope</span></strong>) or in a <strong>named namespace’s scope</strong> (<a href="ch16.xhtml#sec16_5_5">Section 16.5.5</a>). The declarations in <code>export</code> statements must not have <strong><span class="violet">internal linkage</span></strong>,<sup><a id="ch16fn48a" href="ch16.xhtml#ch16fn48">48</a></sup> which includes:</p>&#13;
<p class="footnote"><a id="ch16fn48" href="ch16.xhtml#ch16fn48a">48</a>. “C++ Standard: 10 Modules—10.2 Export declaration.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module.interface">https://eel.is/c++draft/module.interface</a></code>.</p>&#13;
<p class="bull">• <code>static</code> variables and functions at <strong>global namespace scope</strong> in a <strong>translation unit</strong>,</p>&#13;
<p class="bull">• <code>const</code> or <code>constexpr</code> <strong>global variables</strong> in a <strong>translation unit</strong>, and</p>&#13;
<p class="bull">• identifiers declared in “<strong>unnamed namespaces</strong>.”<sup><a id="ch16fn49a" href="ch16.xhtml#ch16fn49">49</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn49" href="ch16.xhtml#ch16fn49a">49</a>. "Namespaces—Unnamed namespaces." Accessed August 13, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/namespace#Unnamed_namespaces">https://en.cppreference.com/w/cpp/language/namespace#Unnamed_namespaces</a></code>.</p>&#13;
<p>Also, if a module defines any preprocessor macros, they’re for use only in that module and cannot be <code>export</code>ed.<sup><a id="ch16fn50a" href="ch16.xhtml#ch16fn50">50</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn50" href="ch16.xhtml#ch16fn50a">50</a>. Gabriel Dos Reis, “Programming with C++ Modules: Guide for the Working Software Developer,” October 5, 2019. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=tjSuKOz5HK4">https://www.youtube.com/watch?v=tjSuKOz5HK4</a></code>.</p>&#13;
<h5 class="h5" id="ch16lev3sec18">Defining Templates in Modules</h5>&#13;
<p>Similar to headers, when you <strong>define a template in a module</strong>, you must <code>export</code> its complete definition so the compiler has access to it wherever the module is imported.</p>&#13;
<h4 class="h4" id="sec16_5_3">16.5.3 Exporting a Block of Declarations</h4>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Rather than applying <strong><code>export</code></strong> to individual declarations, you can place a group of declarations in an <span class="violet"><strong><code>export</code></strong></span> <strong><span class="violet">block</span></strong> (lines 13–17). <strong>Every declaration in an <code>export</code> block is implicitly exported</strong>. An <strong><code>export</code> block</strong>’s braces do not define a new scope, so identifiers declared in such a block continue to exist beyond the block’s closing brace. An <strong><code>export</code> block</strong> must be placed at <strong>global namespace scope</strong>; otherwise, a compilation error occurs.</p>&#13;
<h4 class="h4" id="sec16_5_4">16.5.4 Exporting a <code>namespace</code></h4>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> A program may include many identifiers defined in different scopes. Sometimes a variable of one scope will collide with a variable of the same name in a different scope, possibly creating a naming conflict and resulting in errors. C++ solves this problem with <span class="violet"><strong><code>name-space</code></strong></span><strong><span class="violet">s</span></strong>. Each <code>namespace</code> defines a scope in which identifiers and variables are placed. As you know, the C++ standard library’s features are defined in the <strong><code>std</code> namespace</strong>, which helps ensure that these identifiers do not conflict with identifiers in your own programs. Placing <code>main</code> in a <code>namespace</code> is a compilation error.</p>&#13;
<h5 class="h5" id="ch16lev3sec19">Defining and Exporting <code>namespace</code>s</h5>&#13;
<p>Lines 20–24 define the namespace <code>TestNamespace1</code>. A <code>namespace</code>’s body is delimited by braces (<code>{}</code>). A <code>namespace</code> may contain constants, data, classes and functions. Definitions of <code>namespace</code>s must be placed at <strong>global namespace scope</strong> or must be <strong>nested</strong> in other <code>name-space</code>s. Unlike classes, <code>namespace</code> members may be defined in separate but identically named <code>namespace</code> blocks. For example, each C++ standard library header has a <code>namespace</code> block like:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1045pro01" id="p1045pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">namespace</span> std {&#13;
   <span class="lgreen">// standard library header's declarations</span>&#13;
}</pre>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> indicating that the <strong>header’s declarations</strong> are in <code>namespace std</code>. <strong>When you <code>export</code> a name-space, all its members are <code>export</code>ed</strong>.</p>&#13;
<h5 class="h5" id="ch16lev3sec20">Accessing <code>namespace</code> Members</h5>&#13;
<p>To use a <strong><code>namespace</code></strong> member, you must qualify the member’s name with the <strong><code>namespace</code> name</strong> and the <strong>scope resolution operator (<code>::</code>)</strong>, as in the expression</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1045pro02" id="p1045pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>TestNamespace1::welcomeInTestNamespace1()</code></pre>&#13;
<p>or you must provide a <strong><code>using</code> declaration</strong> or <strong><code>using</code> directive</strong> before the member is used in the <strong>translation unit</strong>. A <strong><code>using</code> declaration</strong> like</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1045pro03" id="p1045pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">using</span> TestNamespace1::welcomeInTestNamespace1;</pre>&#13;
<p>brings one name (<code>welcomeInTestNamespace1</code>) into the scope where the directive appears. A <strong><code>using</code> directive</strong> like</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1045pro04" id="p1045pro04a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">using</span> namespace TestNamespace1;</pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> brings all the names from the specified <code>namespace</code> into the scope where the directive appears. Members of the same <code>namespace</code> can access one another directly without using a <strong><code>namespace</code> qualifier</strong>.</p>&#13;
<h4 class="h4" id="sec16_5_5">16.5.5 Exporting a <code>namespace</code> Member</h4>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> It’s also possible to <strong><code>export</code></strong> specific <code>namespace</code> members rather than an entire <code>namespace</code>, as shown in lines 27–31. In this case, the <code>namespace</code>’s name also is exported. This does not implicitly <code>export</code> the namespace’s other members.</p>&#13;
<h4 class="h4" id="sec16_5_6">16.5.6 Importing a Module to Use Its Exported Declarations</h4>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> To use a <strong>module’s <code>export</code>ed declarations</strong> in a given <strong>translation unit</strong>, you must provide an <span class="violet"><strong><code>import</code></strong></span> <strong><span class="violet">declaration</span></strong> (<a href="ch16.xhtml#fig16_3">Fig. 16.3</a>, line 4) at <strong>global namespace scope</strong> containing the module’s name. The <strong>module’s <code>export</code>ed declarations</strong> are available from the <strong><code>import</code></strong> declaration to the end of the <strong>translation unit</strong>. <strong>Importing a module does not insert the module’s code into a translation unit.</strong> So, unlike headers, modules do not need <strong>include guards</strong> (<a href="ch09.xhtml#ch09lev2sec6">Section 9.7.4</a>). Lines 7–10 call the four functions we exported from the <code>welcome</code> module (<a href="ch16.xhtml#fig16_2">Fig. 16.2</a>). For the functions defined in namespaces, lines 9 and 10 precede each function name with its <code>namespace</code>’s name and the <strong>scope resolution operator (<code>::</code>)</strong>. The program’s output shows that we could call each of module <code>welcome</code>’s <code>export</code>ed functions.</p>&#13;
<div class="group" id="fig16_3">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro03" id="p16pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_03.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Importing a module and using its exported items.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> welcome; <span class="lgreen">// import the welcome module</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>7</strong></span>      std::cout &lt;&lt; welcomeStandalone() &lt;&lt; <span class="green">'\n'</span>&#13;
<span class="cviolet"> <strong>8</strong></span>         &lt;&lt; welcomeFromExportBlock() &lt;&lt; <span class="green">'\n'</span>&#13;
<span class="cviolet"> <strong>9</strong></span>         &lt;&lt; TestNamespace1::welcomeFromTestNamespace1() &lt;&lt; <span class="green">'\n'</span>&#13;
<span class="cviolet"><strong>10</strong></span>         &lt;&lt; TestNamespace2::welcomeFromTestNamespace2() &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>11</strong></span>   }</pre>&#13;
<pre class="pre1">welcomeStandalone function called&#13;
welcomeFromExportBlock function called&#13;
welcomeFromTestNamespace1 function called&#13;
welcomeFromTestNamespace2 function called</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.3</strong></span> | Importing a module and using its exported items.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec21">Importing a Module into Another Module</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Sometimes one module will import another to use (and possibly re-<code>export</code>) its features. In such cases, the <code>import</code> statement must appear after the importing module’s <strong><code>module</code> declaration</strong> and before any of the <strong>importing module’s declarations and definitions</strong>; otherwise, a compilation error occurs.</p>&#13;
<h5 class="h5" id="ch16lev3sec22">Compiling This Example in Visual C++</h5>&#13;
<p>In Visual C++, ensure that <code>fig16_03.cpp</code> is in your project’s <code><strong>Source Files</strong></code> folder, then run your project to compile the module and the <code>main</code> application.</p>&#13;
<h5 class="h5" id="ch16lev3sec23">Compiling This Example in <code>g++</code></h5>&#13;
<p>In <code>g++</code>, execute the following commands, which might change once C++20 modules are finalized in this compiler:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> Compile the <code>&lt;string&gt;</code> and <code>&lt;iostream&gt;</code> headers as <strong>header units</strong> because they’re used in our module and our <code>main</code> application, respectively:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1046pro01" id="p1046pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -x c++-system-header string</code>&#13;
<code>g++ -fmodules-ts -x c++-system-header iostream</code></pre>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> Compile the <strong>module interface unit</strong>—this produces the file <code>welcome.o</code>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1046pro02" id="p1046pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -c -x c++ welcome.ixx</code></pre>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> Compile the <code>main</code> application and link it with <code>welcome.o</code>—this command produces the <strong>executable file</strong> <code>fig16_03</code>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1046pro03" id="p1046pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts fig16_03.cpp welcome.o -o fig16_03</code></pre>&#13;
<p>In Step 2:</p>&#13;
<p class="bull">• the <code>-c</code> option says to compile <code>welcome.ixx</code>, but not link it, and</p>&#13;
<p class="bull">• the <code>-x c++</code> option indicates that <code>welcome.ixx</code> is a C++ file.</p>&#13;
<p>The <code>-x c++</code> is required because <code>.ixx</code> is not a standard <code>g++</code> filename extension. If we name <code>welcome.ixx</code> as <code>welcome.cpp</code>, then the <code>-x c++</code> option is not required.</p>&#13;
<h5 class="h5" id="ch16lev3sec24">Compiling This Example in <code>clang++</code></h5>&#13;
<p>In <code>clang++</code>, execute the following commands, which might change once C++20 modules are finalized in this compiler:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> Compile the <strong>module interface unit</strong> into a <strong><span class="violet">precompiled module (</span></strong><span class="violet"><strong><code>.pcm</code></strong></span><strong><span class="violet">) file</span></strong>, which is specific to the <code>clang++</code> compiler:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1047pro01" id="p1047pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -c -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -xc++ welcome.ixx</code>&#13;
   <code>-Xclang -emit-module-interface -o welcome.pcm</code></pre>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> Compile the <code>main</code> application and link it with <code>welcome.pcm</code>—this command produces the <strong>executable file</strong> <code>fig16_03</code>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1047pro02" id="p1047pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -fprebuilt-module-path=.</code>&#13;
   <code>fig16_03.cpp welcome.pcm -o fig16_03</code></pre>&#13;
<p>In Step 1:</p>&#13;
<p class="bull">• the <code>-c</code> option says to compile <code>welcome.ixx</code>, but not link it, and</p>&#13;
<p class="bull">• the <code>-x c++</code> option indicates that <code>welcome.ixx</code> is a C++ file.</p>&#13;
<p>The <code>-x c++</code> is required because <code>.ixx</code> is not a standard <code>clang++</code> filename extension. If we name the file <code>welcome.cpp</code>, then the <code>-x c++</code> option is not required. In Step 2, the option</p>&#13;
<pre class="pre"><code>-fprebuilt-module-path=.</code></pre>&#13;
<p>indicates where <code>clang++</code> can locate <strong>precompiled module (<code>.pcm</code>) files</strong>—the dot (<code>.</code>) is the current folder but could be a relative or full path to another location on your system.</p>&#13;
<h4 class="h4" id="sec16_5_7">16.5.7 Example: Attempting to Access Non-Visible Module Contents</h4>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Modules do not implicitly <code>export</code> declarations</strong>—this is known as <strong><span class="violet">strong encapsulation</span></strong>. You have precise control over the declarations you <code>export</code> for use in other <strong>translation units</strong>. <a href="ch16.xhtml#fig16_4">Figure 16.4</a> defines a <strong>primary module interface unit</strong> (line 3) named <code>deitel.math</code> containing namespace <code>deitel::math</code> that is not exported. You can add this file to your Visual C++ project, as you saw in <a href="ch16.xhtml#sec16_5_1">Section 16.5.1</a>. In the namespace, we define two functions—<code>square</code> (lines 7–9) is exported, and <code>cube</code> (lines 12–14) is not. <strong>Exporting the function <code>square</code> implicitly exports the enclosing namespace’s name but does not export the namespace’s other members</strong>. Since <code>cube</code> is not exported, other <strong>translation units</strong> cannot call it (as you’ll see in <a href="ch16.xhtml#fig16_5">Fig. 16.5</a>). This is a key difference from <strong>headers</strong>—everything declared in a <strong>header</strong> can be used wherever you <code>#include</code> it.<sup><a id="ch16fn51a" href="ch16.xhtml#ch16fn51">51</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn51" href="ch16.xhtml#ch16fn51a">51</a>. Gabriel Dos Reis, “Programming with C++ Modules: Guide for the Working Software Developer,” October 5, 2019. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=tjSuKOz5HK4">https://www.youtube.com/watch?v=tjSuKOz5HK4</a></code>.</p>&#13;
<div class="group" id="fig16_4">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro04" id="p16pro04a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.4: deitel.math.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface for a module named deitel.math.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> deitel.math; <span class="lgreen">// introduces the module name</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">namespace</span> deitel::math {&#13;
<span class="cviolet"> <strong>6</strong></span>      <span class="lgreen">// exported function square; namespace deitel::math implicitly exported</span>&#13;
<span class="cviolet"> <strong>7</strong></span>      <span class="blue">export int</span> square(<span class="blue">int</span> x) {&#13;
<span class="cviolet"> <strong>8</strong></span>         <span class="blue">return</span> x * x;&#13;
<span class="cviolet"> <strong>9</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="lgreen">// non-exported function cube is not implicitly exported</span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">int</span> cube(<span class="blue">int</span> x) {&#13;
<span class="cviolet"><strong>13</strong></span>         <span class="blue">return</span> x * x * x;&#13;
<span class="cviolet"><strong>14</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>15</strong></span>   };</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.4</strong></span> | Primary module interface for a module named <code>deitel.math</code>. (Part 1 of 2.)</p>&#13;
</div>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> It’s good practice in a module to <strong>put exported identifiers in namespaces</strong> to help <strong>avoid name collisions</strong> when multiple <strong>modules export the same identifier</strong>. We found in our research that <strong>namespace names</strong> typically mimic their <strong>module names</strong><sup><a id="ch16fn52a" href="ch16.xhtml#ch16fn52">52</a></sup>—so for the <code>deitel.math</code> module, we specified the namespace <code>deitel::math</code> (line 5).</p>&#13;
<p class="footnote"><a id="ch16fn52" href="ch16.xhtml#ch16fn52a">52</a>. Daniela Engert, “Modules the beginner’s guide,” May 2, 2020. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=Kqo-jIq4V3I">https://www.youtube.com/watch?v=Kqo-jIq4V3I</a></code>.</p>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> In <a href="ch16.xhtml#fig16_5">Fig. 16.5</a>, line 4 imports the <code>deitel.math</code> module. Line 9 calls the module’s exported <code>deitel::math::square</code> function, <strong>qualifying the function name with its enclosing namespace’s name</strong>. This compiles because <code>add</code> was exported by the <code>deitel.math</code> module. Line 12, however, results in compilation errors—the <code>deitel.math</code> module did not export the <code>cube</code> function. The compilation errors in <a href="ch16.xhtml#fig16_5">Fig. 16.5</a> are from Visual C++. We highlighted key error messages in bold and added vertical spacing for readability.</p>&#13;
<div class="group" id="fig16_5">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro05" id="p16pro05a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_05.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Showing that a module's non-exported identifiers are inaccessible.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> deitel.math; <span class="lgreen">// import the welcome module</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>7</strong></span>      <span class="lgreen">// can call square because it's exported from namespace deitel::math,</span>&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="lgreen">// which implicitly exports the namespace</span>&#13;
<span class="cviolet"> <strong>9</strong></span>       std::cout &lt;&lt; <span class="green">"square(3) = "</span> &lt;&lt; deitel::math::square(<span class="green">3</span>) &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="lgreen">// cannot call cube because it's not exported</span>&#13;
<span class="cviolet"><strong>12</strong></span>       std::cout &lt;&lt; <span class="green">"cube(3) = "</span> &lt;&lt; deitel::math::cube(<span class="green">3</span>) &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>13</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Build started...&#13;
1&gt;------ Build started: Project: modules_demo, Configuration: Debug Win32 ------&#13;
1&gt;Scanning sources for module dependencies...&#13;
1&gt;deitel.math.ixx&#13;
1&gt;fig16_05.cpp&#13;
1&gt;Compiling...&#13;
1&gt;deitel.math.ixx&#13;
1&gt;fig16_05.cpp&#13;
&#13;
1&gt;C:\Users\pauldeitel\Documents\examples\ch16\fig16_04-&#13;
05\fig16_05.cpp(12,47):</code>  <strong>error C2039: 'cube': is not a member of 'deitel::math'</strong>&#13;
&#13;
<code>1&gt;C:\Users\pauldeitel\Documents\examples\examples\ch16\fig16_04-05\de-&#13;
itel.math.ixx(5): message : see declaration of 'deitel::math'</code>&#13;
&#13;
<code>1&gt;C:\Users\pauldeitel\Documents\examples\examples\ch16\fig16_04-&#13;
05\fig16_05.cpp(12,51):</code>  <strong>error C3861: 'cube': identifier not found</strong>&#13;
&#13;
<code>1&gt;Done building project "modules_demo.vcxproj" -- FAILED.&#13;
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.5</strong></span> | Showing that a module's non-exported identifiers are inaccessible. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec25"><code>g++</code> Error Messages</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> To see the <code>g++</code> error messages, execute the following commands, each of which we explained in <a href="ch16.xhtml#sec16_5_6">Section 16.5.6</a>:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span>  <code>g++ -fmodules-ts -x c++-system-header iostream</code></p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span>  <code>g++ -fmodules-ts -c -x c++ deitel.math.ixx</code></p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span>  <code>g++ -fmodules-ts fig16_05.cpp deitel.math.o</code></p>&#13;
<p>We highlighted the key error message in bold:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1049pro01" id="p1049pro01a">Click here to view code image</a></p>&#13;
<pre class="pre1"><code>fig16_05.cpp: In function 'int main()':&#13;
fig16_05.cpp:12:49: <strong><code>error: 'cube' is not a member of 'deitel::math'</code></strong>&#13;
   12 | std::cout &lt;&lt; "cube(e) = " &lt;&lt; deitel::math::cube(3) &lt;&lt; '\n'&#13;
      |                                            ^~~~</code></pre>&#13;
<h5 class="h5" id="ch16lev3sec26"><code>clang++</code> Error Messages</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> To see the <code>clang++</code> error messages, execute the following commands, each of which we explained in <a href="ch16.xhtml#sec16_5_6">Section 16.5.6</a>:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> <code>clang++-13 -c -std=c++20 -stdlib=libc++ -fimplicit-modules</code></p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1049pro02" id="p1049pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>-fimplicit-module-maps -xc++ deitel.math.ixx</code>&#13;
<code>-Xclang -emit-module-interface -o deitel.math.pcm</code></pre>&#13;
<p class="num"><span class="red"><strong>2.</strong></span>  <code>clang++-13 -std=c++20 -stdlib=libc++ -fimplicit-modules</code></p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1049pro03" id="p1049pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>-fimplicit-module-maps -fprebuilt-module-path=.</code>&#13;
<code>fig16_05.cpp deitel.math.pcm -o fig16_05</code></pre>&#13;
<p>We highlighted the key error message in bold:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1049pro04" id="p1049pro04a">Click here to view code image</a></p>&#13;
<pre class="pre1"><code>fig16_05.cpp:12:49:</code> <strong><code>error: no member named 'cube' in namespace 'deitel::math'</code></strong>&#13;
   <code>std::cout &lt;&lt; "cube(e) = " &lt;&lt; deitel::math::cube(3) &lt;&lt; '\n';</code>&#13;
                               <code>~~~~~~~~~~~~~~^</code>&#13;
<code>1 error generated.</code></pre>&#13;
<h3 class="h3" id="sec16_6"><span class="violet">16.6</span> Global Module Fragment</h3>&#13;
<p>As we mentioned, some <strong>headers</strong> cannot be compiled as <strong>header units</strong> because they require <strong>preprocessor state</strong>, such as macros defined in your <strong>translation unit</strong> or other <strong>headers</strong>. Such <strong>headers</strong> can be <code>#include</code>d for use in a <strong>module unit</strong> by placing them in the <strong><span class="violet">global module fragment</span></strong>:<sup><a id="ch16fn53a" href="ch16.xhtml#ch16fn53">53</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn53" href="ch16.xhtml#ch16fn53a">53</a>. “C++ Standard: 10 Modules—10.4 Global module fragment,” Accessed August 10, 2021. <code><a href="https://eel.is/c++draft/module.global.frag">https://eel.is/c++draft/module.global.frag</a></code>.</p>&#13;
<pre class="pre"><code>module;</code></pre>&#13;
<p>which you place at the beginning of a <strong>module unit</strong>, before the <strong><code>module</code> declaration</strong>. The <strong>global module fragment</strong> may contain only <strong><code>#include</code> headers</strong>. A <strong>module interface unit</strong> can <strong>export a declaration</strong> that was <code>#include</code>d into the <strong>global module fragment</strong>, so other <strong>implementation units</strong> that <strong><code>import</code> the module</strong> can use that declaration.<sup><a id="ch16fn54a" href="ch16.xhtml#ch16fn54">54</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn54" href="ch16.xhtml#ch16fn54a">54</a>. Gabriel Dos Reis, "Programming with C++ Modules: Guide for the Working Software Developer," October 5, 2019. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=tjSuKOz5HK4">https://www.youtube.com/watch?v=tjSuKOz5HK4</a></code>.</p>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> Any declaration <code>#include</code>d in the <strong>global module fragment</strong> but not used by the module is <strong>discarded</strong> by the compiler.<sup><a id="ch16fn55a" href="ch16.xhtml#ch16fn55">55</a></sup> <strong>Global module fragments</strong> from all <strong>module units</strong> are placed into the <strong><span class="violet">global module</span></strong>, as is non-modularized code in other <strong>non-module translation units</strong>, such as the one containing function <code>main</code>.</p>&#13;
<p class="footnote"><a id="ch16fn55" href="ch16.xhtml#ch16fn55a">55</a>. Eric Niebler, “Understanding C++ Modules: Part 3: Linkage and Fragments—”Discarded” Declarations,” October 7, 2019. Accessed August 13, 2021. <code><a href="https://vector-of-bool.github.io/2019/10/07/modules-3.html">https://vector-of-bool.github.io/2019/10/07/modules-3.html</a></code>.</p>&#13;
<h3 class="h3" id="sec16_7"><span class="violet">16.7</span> Separating Interface from Implementation</h3>&#13;
<p>In <a href="ch09.xhtml#ch09">Chapters 9</a> and <a href="ch10.xhtml#ch10">10</a>, we defined classes using <strong><code>.h</code> headers</strong> and <strong><code>.cpp</code> source-code files</strong> to <strong>separate a class’s interface from its implementation</strong>. The same approach is commonly used in <strong>function libraries</strong>—a <strong><code>.h</code> header</strong> specifies a <strong>library’s function prototypes</strong>, and a corresponding <strong><code>.cpp</code> file</strong> provides their <strong>implementations</strong>.</p>&#13;
<p>Modules support <strong>separating interface from implementation</strong> but with more flexibility than <strong>headers</strong> and <strong>source-code files</strong>. You can:</p>&#13;
<p class="bull"><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> • <strong>define both interface and implementation in the same source file</strong> (as shown in this section) <strong>while still hiding the implementation details from client code</strong>, or</p>&#13;
<p class="bull"><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> • <strong>split your interface and implementation into separate files</strong> (shown in subsequent sections).</p>&#13;
<h4 class="h4" id="sec16_7_1">16.7.1 Example: The <code>:private</code> Module Fragment</h4>&#13;
<p>Let’s demonstrate a module with its <strong>interface</strong> and <strong>implementation</strong> defined separately in one <strong>translation unit</strong>. <a href="ch16.xhtml#fig16_6">Figure 16.6</a> defines a <strong>primary module interface unit</strong> named <code>deitel.math</code> (line 4) that <code>export</code>s its <code>deitel::math</code> namespace. The namespace contains the <strong>prototype</strong> for an <code>average</code> function (line 11) that receives a reference to a <code>const vector&lt;int&gt;</code> and returns the average of the <code>vector&lt;int&gt;</code>’s values as a <code>double</code>.</p>&#13;
<div class="group" id="fig16_6">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro06" id="p16pro06a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.6: deitel.math.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface for a module named deitel.math</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// with a :private module fragment.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">export</span> <span class="blue">module</span> deitel.math; <span class="lgreen">// introduces the module name</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">import</span> &lt;numeric&gt;;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">import</span> &lt;vector&gt;;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">export namespace</span> deitel::math {&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="lgreen">// calculate the average of a vector&lt;int&gt;'s elements</span>&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">double</span> average(<span class="blue">const</span> std::vector&lt;<span class="blue">int</span>&gt;&amp; values);&#13;
<span class="cviolet"><strong>12</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">module</span> :<span class="blue">private</span>; <span class="lgreen">// private implementation details</span>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">namespace</span> deitel::math {&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="lgreen">// average function's implementation</span>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="blue">double</span> average(<span class="blue">const</span> std::vector&lt;<span class="blue">int</span>&gt;&amp; values) {&#13;
<span class="cviolet"><strong>19</strong></span>         <span class="blue">double</span> total{std::accumulate(values.begin(), values.end(), <span class="green">0.0</span>)};&#13;
<span class="cviolet"><strong>20</strong></span>         <span class="blue">return</span> total / values.size();&#13;
<span class="cviolet"><strong>21</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>22</strong></span>   };</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.6</strong></span> | Primary module interface for a module named <code>deitel.math</code> with a <code>:private</code> module fragment.</p>&#13;
</div>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> Line 14 introduces the <span class="violet"><strong><code>:private</code></strong></span> <strong><span class="violet">module fragment</span></strong> for <strong>separating a module’s implementation details from its interface</strong> in the <strong>primary module interface unit</strong>. With this approach, the <strong>primary module interface unit</strong> must be the module’s only <strong>module unit</strong>. The contents of the <strong><code>:private</code> module fragment</strong> do not affect the <strong>module’s interface</strong>, so this fragment may not <code>export</code> declarations.<sup><a id="ch16fn56a" href="ch16.xhtml#ch16fn56">56</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn56" href="ch16.xhtml#ch16fn56a">56</a>. “C++20 Standard: 10 Modules—Private module fragment.” Accessed August 11, 2021. <code><a href="https://eel.is/c++draft/module.private.frag">https://eel.is/c++draft/module.private.frag</a></code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> The key benefit of a <strong>primary module interface unit</strong> containing a <strong><code>:private</code> module fragment</strong> is that you can conveniently define both a <strong>module’s interface and its implementation details</strong> in <strong>one translation unit</strong> without exposing the implementation details to other <strong>translation units</strong>. Changes to the implementation details in a <strong><code>:private</code> module fragment</strong> do not affect other <strong>translation units</strong> that import the module.<sup><a id="ch16fn57a" href="ch16.xhtml#ch16fn57">57</a></sup> So, they do not need to be recompiled, potentially improving compilation times.<sup><a id="ch16fn58a" href="ch16.xhtml#ch16fn58">58</a></sup> Line 7 in <a href="ch16.xhtml#fig16_7">Fig. 16.7</a> imports the <code>deitel.math</code> module, and line 17 uses the module’s <code>deitel::math::average</code> function to calculate the average of <code>vector integers</code>’ values.</p>&#13;
<p class="footnote"><a id="ch16fn57" href="ch16.xhtml#ch16fn57a">57</a>. “C++20 Standard: 10 Modules—Private module fragment.” Accessed August 11, 2021. <code><a href="https://eel.is/c++draft/module.private.frag">https://eel.is/c++draft/module.private.frag</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn58" href="ch16.xhtml#ch16fn58a">58</a>. This will probably require build tools that are smart enough to recognize that the module interface did not change.</p>&#13;
<div class="group" id="fig16_7">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro07" id="p16pro07a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_07.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Using the deitel.math module's average function.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;algorithm&gt;;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> &lt;iterator&gt;;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">import</span> &lt;vector&gt;;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">import</span> deitel.math; <span class="lgreen">// import the deitel.math module</span>&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output(std::cout, <span class="green">" "</span>);&#13;
<span class="cviolet"><strong>11</strong></span>      std::vector integers{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>};&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      std::cout &lt;&lt; <span class="green">"vector integers: "</span>;&#13;
<span class="cviolet"><strong>14</strong></span>      <code>std::copy(integers.begin(), integers.end(), output);</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      std::cout &lt;&lt; <span class="green">"\naverage of integer's elements: "</span>&#13;
<span class="cviolet"><strong>17</strong></span>         &lt;&lt; deitel::math::average(integers) &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>18</strong></span>   }</pre>&#13;
<pre class="pre1"><code>vector integers: 1 2 3 4</code>&#13;
<code>average of integer's elements: 2.5</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.7</strong></span> | Using the <code>deitel.math</code> module’s <code>average</code> function.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec27">Compiling This Example in Visual C++</h5>&#13;
<p>Add the <code>deitel.math.ixx</code> file to your Visual C++ project as you did in <a href="ch16.xhtml#sec16_5_1">Section 16.5.1</a>, then run your project to compile the module and the <strong><code>main</code> application</strong>.</p>&#13;
<h5 class="h5" id="ch16lev3sec28">Compiling This Example in <code>g++</code></h5>&#13;
<p>First, use the commands introduced in <a href="ch16.xhtml#sec16_5_6">Section 16.5.6</a> to compile the <strong>standard library headers</strong> <code>&lt;algorithm&gt;</code>, <code>&lt;iostream&gt;</code>, <code>&lt;iterator&gt;</code>, <code>&lt;numeric&gt;</code> and <code>&lt;vector&gt;</code> as <strong>header units</strong>. Then compile<sup><a id="ch16fn59a" href="ch16.xhtml#ch16fn59">59</a></sup> the <strong>primary module interface unit</strong> as follows:</p>&#13;
<p class="footnote"><a id="ch16fn59" href="ch16.xhtml#ch16fn59a">59</a>. At the time of this writing, <code>g++</code> does not support the <code>:private</code> module fragment. Once it does, you should be able to use the specified commands to compile this example.</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1052pro01" id="p1052pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -c -x c++ deitel.math.ixx</code></pre>&#13;
<p>Finally, <strong>compile the <code>main</code> application and link it</strong> with <code>deitel.math.o</code> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1052pro03" id="p1052pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts fig16_07.cpp deitel.math.o -o fig16_07</code></pre>&#13;
<h5 class="h5" id="ch16lev3sec29">Compiling This Example in <code>clang++</code></h5>&#13;
<p>In <code>clang++</code>, compile the <strong>primary module interface unit</strong> into a <strong>precompiled module (<code>.pcm</code>) file</strong> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1052pro02" id="p1052pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -c -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -xc++ deitel.math.ixx</code>&#13;
   <code>-Xclang -emit-module-interface -o deitel.math.pcm</code></pre>&#13;
<p>Then <strong>compile the <code>main</code> application and link it</strong> with <code>deitel.math.pcm</code> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1053pro01" id="p1053pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -fprebuilt-module-path=.</code>&#13;
   <code>fig16_07.cpp deitel.math.pcm -o fig16_07</code></pre>&#13;
<h4 class="h4" id="sec16_7_2">16.7.2 Example: Module Implementation Units</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> Sometimes it’s useful to break a larger module into smaller, more manageable pieces—for example, when a team of developers is working on different aspects of the same module. You can <strong>split a module definition into multiple source files</strong>. Let’s reimplement the program of <a href="ch16.xhtml#sec16_7_1">Section 16.7.1</a> using a <strong>primary module interface unit</strong> for the <strong>module’s interface</strong> and a separate source code file for the <strong>module’s implementation details</strong>.</p>&#13;
<h5 class="h5" id="ch16lev3sec30">Primary Module Interface Unit</h5>&#13;
<p>The <code>deitel.math</code> module’s <strong>primary module interface unit</strong> (<a href="ch16.xhtml#fig16_8">Fig. 16.8</a>) exports the <code>deitel::math</code> namespace (lines 7–10), containing the <code>average</code> function’s prototype. Note that the function’s definition has been removed from this file.</p>&#13;
<div class="group" id="fig16_8">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro08" id="p16pro08a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.8: deitel.math.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface for a module named deitel.math.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> deitel.math; <span class="lgreen">// introduces the module name</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> &lt;vector&gt;;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">export namespace</span> deitel::math {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="lgreen">// calculate the average of a vector&lt;int&gt;'s elements</span>&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">double</span> average(<span class="blue">const</span> std::vector&lt;<span class="blue">int</span>&gt;&amp; values);&#13;
<span class="cviolet"><strong>10</strong></span>   };</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.8</strong></span> | Primary module interface for a module named <code>deitel.math</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec31">Module Implementation Unit</h5>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> All files containing <strong><code>module</code> declarations without the <code>export</code> keyword</strong> (line 3 of <a href="ch16.xhtml#fig16_9">Fig. 16.9</a>) are <strong><span class="violet">module implementation units</span></strong>.<sup><a id="ch16fn60a" href="ch16.xhtml#ch16fn60">60</a></sup> These can be used to <strong>split larger modules into multiple source files to make the code more manageable</strong>. <strong>Module implementation units</strong> are typically placed in <code>.cpp</code> files. Line 3 indicates that this file is a <strong>module implementation unit</strong> for the <code>deitel.math</code> module. A <strong>module implementation unit</strong> implicitly imports the interface for the specified module name. The compiler combines the <strong>primary module interface unit</strong> and its corresponding <strong>module implementation unit(s)</strong> into a single <strong><span class="violet">named module</span></strong><sup><a id="ch16fn61a" href="ch16.xhtml#ch16fn61">61</a></sup> that other <strong>translation units</strong> can <code>import</code>. Lines 10–13 implement the <code>average</code> function in a namespace that must have the same name as the one enclosing <code>average</code>’s <strong>function prototype</strong> in the <strong>primary module interface unit</strong> (<a href="ch16.xhtml#fig16_8">Fig. 16.8</a>). The <code>main</code> program in this example is identical to <a href="ch16.xhtml#fig16_7">Fig. 16.7</a> and produces the same output, so we did not repeat it in this section.</p>&#13;
<p class="footnote"><a id="ch16fn60" href="ch16.xhtml#ch16fn60a">60</a>. “C++20 Standard: 10 Modules—10.1 Module units and purviews.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module#unit">https://eel.is/c++draft/module#unit</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn61" href="ch16.xhtml#ch16fn61a">61</a>. “C++20 Standard: 10 Modules.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module">https://eel.is/c++draft/module</a></code>.</p>&#13;
<div class="group" id="fig16_9">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro09" id="p16pro09a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.9: deitel.math-impl.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Module implementation unit for the module deitel.math.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">module</span> deitel.math; <span class="lgreen">// this file's contents belong to module deitel.math</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> &lt;numeric&gt;;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">import</span> &lt;vector&gt;;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">namespace</span> deitel::math {&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// average function's implementation</span>&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">double</span> average(<span class="blue">const</span> std::vector&lt;<span class="blue">int</span>&gt;&amp; values) {&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="blue">double</span> total{std::accumulate(values.begin(), values.end(), 0.0)};&#13;
<span class="cviolet"><strong>12</strong></span>         <span class="blue">return</span> total / values.size();&#13;
<span class="cviolet"><strong>13</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>14</strong></span>   };</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.9</strong></span> | Module implementation unit for the module <code>deitel.math</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec32">Compiling This Example in Visual C++</h5>&#13;
<p>Add the <code>deitel.math.ixx</code> file to your <strong>Visual C++ project</strong>, as you did in <a href="ch16.xhtml#sec16_5_1">Section 16.5.1</a>. Ensure that your project includes in its <code><strong>Source Files</strong></code> folder</p>&#13;
<p class="bull">• <code>deitel.math.ixx</code>—the <strong>primary module interface unit</strong>,</p>&#13;
<p class="bull">• <code>deitel.math-impl.cpp</code><sup><a id="ch16fn62a" href="ch16.xhtml#ch16fn62">62</a></sup>—the <strong>module implementation unit</strong>, and</p>&#13;
<p class="footnote"><a id="ch16fn62" href="ch16.xhtml#ch16fn62a">62</a>. We named the module implementation unit with <code>"-impl"</code> in the filename primarily to support the compilation steps of the <code>g++</code> compiler. This is not a requirement.</p>&#13;
<p class="bull">• <code>fig16_07.cpp</code>—a copy of the <strong>main application file</strong> from <a href="ch16.xhtml#sec16_7_1">Section 16.7.1</a>.</p>&#13;
<p>Then, simply run your project to compile the module and the <code>main</code> application.</p>&#13;
<h5 class="h5" id="ch16lev3sec33">Compiling This Example in <code>g++</code></h5>&#13;
<p>In <code>g++</code>, use the commands introduced in <a href="ch16.xhtml#sec16_5_6">Section 16.5.6</a> to compile the <strong>standard library headers</strong> <code>&lt;algorithm&gt;</code>, <code>&lt;iostream&gt;</code>, <code>&lt;iterator&gt;</code>, <code>&lt;numeric&gt;</code> and <code>&lt;vector&gt;</code> as <strong>header units</strong>. Next, compile the <strong>primary module interface unit</strong> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1054pro01" id="p1054pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -c -x c++ deitel.math.ixx</code></pre>&#13;
<p>Then, compile the <strong>module implementation unit</strong> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1054pro02" id="p1054pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -c deitel.math-impl.cpp</code></pre>&#13;
<p>We now have files named <code>deitel.math.o</code> and <code>deitel.math-impl.o</code> representing the <strong>module’s interface and implementation</strong>.</p>&#13;
<p>Finally, <strong>compile the <code>main</code> application and link it</strong> with <code>deitel.math.o</code> and <code>deitel.math-impl.o</code> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1054pro03" id="p1054pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts fig16_07.cpp deitel.math.o deitel.math-impl.o</code>&#13;
   <code>-o fig16_07</code></pre>&#13;
<h5 class="h5" id="ch16lev3sec34">Compiling This Example in <code>clang++</code></h5>&#13;
<p>In <code>clang++</code>, compile the <strong>primary module interface unit</strong> into a <strong>precompiled module (<code>.pcm</code>) file</strong> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1055pro01" id="p1055pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -c -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -xc++ deitel.math.ixx</code>&#13;
   <code>-Xclang -emit-module-interface -o deitel.math.pcm</code></pre>&#13;
<p>Next, compile the <strong>module implementation unit</strong> into an <strong>object file</strong> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1055pro02" id="p1055pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -c -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -fmodule-file=deitel.math.pcm</code>&#13;
   <code>deitel.math-impl.cpp</code></pre>&#13;
<p>The option <code>-fmodule-file=deitel.math.pcm</code> specifies the name of the module’s <strong>primary module interface unit</strong>. Finally, <strong>compile the <code>main</code> application and link it</strong> with <code>deitel.math-impl.o</code> and <code>deitel.math.pcm</code> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1055pro03" id="p1055pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -fprebuilt-module-path=. fig16_07.cpp</code>&#13;
   <code>deitel.math-impl.o deitel.math.pcm -o fig16_07</code></pre>&#13;
<h4 class="h4" id="sec16_7_3">16.7.3 Example: Modularizing a Class</h4>&#13;
<p>So far, we’ve demonstrated only <strong>function definitions in modules</strong>. Let’s define a simplified version of <a href="ch09.xhtml#ch09">Chapter 9</a>’s <code>Time</code> class with its <strong>interface</strong> in a <strong>primary module interface unit</strong> and its <strong>implementation</strong> in a <strong>module implementation unit</strong>. We’ll name our module <code>deitel.time</code> and place the class in the <code>deitel::time</code> namespace.</p>&#13;
<h5 class="h5" id="ch16lev3sec35"><code>deitel.time</code> Primary Module Interface Unit</h5>&#13;
<p>The <code>deitel.time</code> module’s <strong>primary module interface unit</strong> (<a href="ch16.xhtml#fig16_10">Fig. 16.10</a>) defines and <code>export</code>s namespace <code>deitel::time</code> (lines 7–19) containing the <code>Time</code> class definition (lines 8–18).</p>&#13;
<div class="group" id="fig16_10">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro10" id="p16pro10a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.10: deitel.time.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface for a simple Time class.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> deitel.time; <span class="lgreen">// declare primary module interface</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> &lt;string&gt;; <span class="lgreen">// rather than #include &lt;string&gt;</span>&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">export namespace</span> deitel::time {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">class</span> Time {&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>10</strong></span>         <span class="lgreen">// default constructor because it can be called with no arguments</span>&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="blue">explicit</span> Time(<span class="blue">int</span> hour = <span class="green">0</span>, <span class="blue">int</span> minute = <span class="green">0</span>, <span class="blue">int</span> second = <span class="green">0</span>);&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>         std::string toString() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>15</strong></span>         <span class="blue">int</span> m_hour{<span class="green">0</span>}; <span class="lgreen">// 0 - 23 (24-hour clock format)</span>&#13;
<span class="cviolet"><strong>16</strong></span>         <span class="blue">int</span> m_minute{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span>&#13;
<span class="cviolet"><strong>17</strong></span>         <span class="blue">int</span> m_second{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span>&#13;
<span class="cviolet"><strong>18</strong></span>      <code>};</code>&#13;
<span class="cviolet"><strong>19</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.10</strong></span> | Primary module interface for a simple <code>Time</code> class.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec36"><code>deitel.time</code> Module Implementation Unit</h5>&#13;
<p>The <strong><code>module</code> declaration</strong> in line 4 of <a href="ch16.xhtml#fig16_11">Fig. 16.11</a> indicates that <code>deitel.time-impl.cpp</code> is the <strong><code>deitel.time</code> module implementation unit</strong>. The rest of the file defines class <code>Time</code>’s member functions. Line 8:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1056pro01" id="p1056pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">using namespace</span> deitel::time;</pre>&#13;
<p>gives this <strong>module implementation unit</strong> access to namespace <code>deitel::time</code>’s contents. However, any <strong>translation unit</strong> that imports the <code>deitel.time</code> module does not see this <strong><code>using</code> directive</strong>. So other <strong>translation units</strong> still must access our <strong>module’s exported names</strong> with <code>deitel::time</code> or via their own <code>using</code> statements.</p>&#13;
<div class="group" id="fig16_11">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro11" id="p16pro11a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.11: deitel.time-impl.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// deitel.time module implementation unit containing the</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// Time class member function definitions.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">module</span> deitel.time; <span class="lgreen">// module implementation unit for deitel.time</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">import</span> &lt;stdexcept&gt;;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">import</span> &lt;string&gt;;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">using namespace</span> deitel::time;&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="lgreen">// Time constructor initializes each data member</span>&#13;
<span class="cviolet"><strong>11</strong></span>   Time::Time<span class="blue">(int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second) {&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="lgreen">// validate hour, minute and second</span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">if</span> ((hour &lt; <span class="green">0</span> || hour &gt;= <span class="green">24</span>) || (minute &lt; <span class="green">0</span> || minute &gt;= <span class="green">60</span>) ||&#13;
<span class="cviolet"><strong>14</strong></span>         (second &lt; <span class="green">0</span> || second &gt;= <span class="green">60</span>)) {&#13;
<span class="cviolet"><strong>15</strong></span>         <span class="blue">throw</span> std::invalid_argument{&#13;
<span class="cviolet"><strong>16</strong></span>            <span class="green">"hour, minute or second was out of range"</span>};&#13;
<span class="cviolet"><strong>17</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <code>m_hour = hour;</code>&#13;
<span class="cviolet"><strong>20</strong></span>      <code>m_minute = minute;</code>&#13;
<span class="cviolet"><strong>21</strong></span>      <code>m_second = second;</code>&#13;
<span class="cviolet"><strong>22</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>   <span class="lgreen">// return a string representation of the Time</span>&#13;
<span class="cviolet"><strong>25</strong></span>   std::string Time::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>26</strong></span>      <span class="blue">using</span> namespace std::string_literals;&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="blue">return</span> <span class="green">"Hour: "</span>s + std::to_string(m_hour) +&#13;
<span class="cviolet"><strong>29</strong></span>         <span class="green">"\nMinute: "</span>s + std::to_string(m_minute) +&#13;
<span class="cviolet"><strong>30</strong></span>         <span class="green">"\nSecond: "</span>s + std::to_string(m_second);&#13;
<span class="cviolet"><strong>31</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.11</strong></span> | <code>deitel.time</code> module implementation unit containing the <code>Time</code> class member function definitions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec37">Using Class Time from the <code>deitel.time</code> Module</h5>&#13;
<p>The program in <a href="ch16.xhtml#fig16_12">Fig. 16.12</a> imports the <code>deitel.time</code> module (line 7) and uses class <code>Time</code>. For convenience, line 8 indicates that this program uses the module’s <code>deitel::time</code> namespace, but you also can fully qualify the mention of class <code>Time</code> (lines 11 and 17), as in:</p>&#13;
<pre class="pre"><code>deitel::time::Time</code></pre>&#13;
<div class="group" id="fig16_12">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro12" id="p16pro12a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_12.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Importing the deitel.time module and using the modularized Time class.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> &lt;stdexcept&gt;;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> &lt;string&gt;;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">import</span> deitel.time;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">using namespace</span> deitel::time;&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">const</span> Time t{<span class="green">12</span>, <span class="green">25</span>, <span class="green">42</span>}; <span class="lgreen">// hour, minute and second specified</span>&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      std::cout &lt;&lt; <span class="green">"Time t:\n"</span> &lt;&lt; t.toString() &lt;&lt; <span class="green">"\n\n"</span>;&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="lgreen">// attempt to initialize t2 with invalid values</span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">try</span> {&#13;
<span class="cviolet"><strong>17</strong></span>         <span class="blue">const</span> Time t2{<span class="green">27</span>, <span class="green">74</span>, <span class="green">99</span>}; <span class="lgreen">// all bad values specified</span>&#13;
<span class="cviolet"><strong>18</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">catch</span> (<span class="blue">const</span> std::invalid_argument&amp; e) {&#13;
<span class="cviolet"><strong>20</strong></span>         std::cout &lt;&lt; <span class="green">"t2 not created: "</span> &lt;&lt; e.what() &lt;&lt; '<span class="green">\n'</span>;&#13;
<span class="cviolet"><strong>21</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>22</strong></span>   }</pre>&#13;
<pre class="pre1">Time t:&#13;
Hour: 12&#13;
Minute: 25&#13;
Second: 42&#13;
&#13;
t2 not created: hour, minute or second was out of range</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.12</strong></span> | Importing the <code>deitel.time</code> module and using the modularized <code>Time</code> class.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec38">Compiling This Example in Visual C++</h5>&#13;
<p>Add <code>deitel.time.ixx</code> to your <strong>Visual C++ project,</strong> as in <a href="ch16.xhtml#sec16_5_1">Section 16.5.1</a>. Next, ensure that your project includes in its <code><strong>Source Files</strong></code> folder</p>&#13;
<p class="bull">• <code>deitel.time.ixx</code>—the <strong>primary module interface unit</strong>,</p>&#13;
<p class="bull">• <code>deitel.time-impl.cpp</code><sup><a id="ch16fn63a" href="ch16.xhtml#ch16fn63">63</a></sup>—the <strong>module implementation unit</strong>, and</p>&#13;
<p class="footnote"><a id="ch16fn63" href="ch16.xhtml#ch16fn63a">63</a>. We named the module implementation unit with <code>"-impl"</code> in the filename primarily to support the compilation steps of the <code>g++</code> compiler. This is not a module implementation unit requirement.</p>&#13;
<p class="bull">• <code>fig16_12.cpp</code>—the <strong>main application file</strong>.</p>&#13;
<p>Then, simply run your project to compile the module and the <strong><code>main</code> application</strong>.</p>&#13;
<h5 class="h5" id="ch16lev3sec39">Compiling This Example in <code>g++</code></h5>&#13;
<p>In <code>g++</code>, use the commands introduced in <a href="ch16.xhtml#sec16_5_6">Section 16.5.6</a> to compile the <strong>standard library headers</strong> <code>&lt;iostream&gt;</code>, <code>&lt;string&gt;</code> and <code>&lt;stdexcept&gt;</code> as <strong>header units</strong>.</p>&#13;
<p>Next, compile the <strong>primary module interface unit</strong>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1057pro01" id="p1057pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -c -x c++ deitel.time.ixx</code></pre>&#13;
<p>Then, compile the <strong>module implementation unit</strong> as follows—this command assumes that the <code>{fmt}</code> library is located in the <code>libraries</code> folder within the book’s <code>examples</code> folder:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1058pro01" id="p1058pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -c -x c++ deitel.time-impl.ixx</code></pre>&#13;
<p>We now have files named <code>deitel.time.o</code> and <code>deitel.time-impl.o</code> representing the <code>deitel.time</code> <strong>module’s interface and implementation</strong>.</p>&#13;
<p>Finally, compile the <strong><code>main</code> application</strong> source file and link it with <code>deitel.time.o</code> and <code>deitel.time-impl.o</code>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1058pro02" id="p1058pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts fig16_12.cpp deitel.time.o deitel.time-impl.o</code>&#13;
   <code>-o fig16_07</code></pre>&#13;
<h5 class="h5" id="ch16lev3sec40">Compiling This Example in <code>clang++</code></h5>&#13;
<p>In <code>clang++</code>, compile the <strong>primary module interface unit</strong> into a <strong>precompiled module (<code>.pcm</code>) file</strong>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1058pro03" id="p1058pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -c -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -xc++ deitel.time.ixx</code>&#13;
   <code>-Xclang -emit-module-interface -o deitel.time.pcm</code></pre>&#13;
<p>Next, compile the <strong>module implementation unit</strong> into an <strong>object file</strong>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1058pro04" id="p1058pro04a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -c -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -fmodule-file=deitel.time.pcm</code>&#13;
   <code>deitel.time-impl.cpp</code></pre>&#13;
<p>The option <code>-fmodule-file=deitel.math.pcm</code> specifies the name of the module’s <strong>primary module interface unit</strong>. Finally, compile <code>fig16_12.cpp</code> and link it with <code>deitel.math-impl.o</code> and <code>deitel.math.pcm</code>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1058pro05" id="p1058pro05a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps -fprebuilt-module-path=.</code>&#13;
   <code>fig16_12.cpp deitel.time-impl.o deitel.time.pcm -o fig16_12</code></pre>&#13;
<h3 class="h3" id="sec16_8"><span class="violet">16.8</span> Partitions</h3>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> You can divide a <strong>module’s interface</strong> and/or its <strong>implementation</strong> into smaller pieces called <strong><span class="violet">partitions</span></strong>.<sup><a id="ch16fn64a" href="ch16.xhtml#ch16fn64">64</a></sup> When working on large projects, this can help you organize a module’s components into smaller, more manageable <strong>translation units</strong>. Breaking a larger module into smaller <strong>translation units</strong> also can <strong>reduce compilation times</strong> in large systems. Only <strong>translation units</strong> that have changed and <strong>translation units</strong> that depend on those changes would need to be recompiled.<sup><a id="ch16fn65a" href="ch16.xhtml#ch16fn65">65</a></sup> Whether items are recompiled would be <strong>determined by the compiler’s modules tooling</strong>.<sup><a id="ch16fn66a" href="ch16.xhtml#ch16fn66">66</a></sup> The compiler aggregates a <strong>module’s partitions</strong> into a single <strong>named module</strong> for import into other <strong>translation units</strong>.</p>&#13;
<p class="footnote"><a id="ch16fn64" href="ch16.xhtml#ch16fn64a">64</a>. At the time of this writing, <code>clang++</code> does not yet support partitions.</p>&#13;
<p class="footnote"><a id="ch16fn65" href="ch16.xhtml#ch16fn65a">65</a>. Cameron DaCamara, “Practical C++20 Modules and the future of tooling around C++ Modules,” May 4, 2020. Accessed August 12, 2021. <code><a href="https://www.youtube.com/watch?v=ow2zV0Udd9M">https://www.youtube.com/watch?v=ow2zV0Udd9M</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn66" href="ch16.xhtml#ch16fn66a">66</a>. Modules tooling is under development at the time of this writing and will continue to evolve over the next several years.</p>&#13;
<h4 class="h4" id="sec16_8_1">16.8.1 Example: Module Interface Partition Units</h4>&#13;
<p>In this example, we’ll create a <code>deitel.math</code> module that exports four functions in its <strong>primary module interface unit</strong>—<code>square</code>, <code>cube</code>, <code>squareRoot</code> and <code>cubeRoot</code>. We’ll divide these functions into two <strong>module interface partition units</strong> (<code>powers</code> and <code>roots</code>) to show partition syntax. Then we’ll aggregate their exported declarations into a single <strong>primary module interface partition</strong>.</p>&#13;
<h5 class="h5" id="ch16lev3sec41"><code>deitel.math:powers</code> Module Interface Partition Unit</h5>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> Line 3 of <a href="ch16.xhtml#fig16_13">Fig. 16.13</a> indicates that the <strong>translation unit</strong> <code>deitel.math-powers.ixx</code> is a <strong><span class="violet">module interface partition unit</span></strong>. The notation <code>deitel.math:powers</code> specifies that the <strong>partition name</strong> is <code>"powers"</code>, and the partition is part of the module <code>deitel.math</code>. This <strong>module interface partition</strong> exports the <code>deitel::math</code> namespace, containing the functions <code>square</code> and <code>cube</code>. <strong>Module partitions are not visible outside their module, so they cannot be imported into translation units that are not part of the same module</strong>.<sup><a id="ch16fn67a" href="ch16.xhtml#ch16fn67">67</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn67" href="ch16.xhtml#ch16fn67a">67</a>. “Modules—Module Partitions.” Accessed August 13, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/modules">https://en.cppreference.com/w/cpp/language/modules</a></code>.</p>&#13;
<div class="group" id="fig16_13">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro13" id="p16pro13a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.13: deitel.math-powers.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Module interface partition unit deitel.math:powers.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> deitel.math:powers;&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">export namespace</span> deitel::math {&#13;
<span class="cviolet"> <strong>6</strong></span>      <span class="blue">double</span> square(<span class="blue">double</span> x) { <span class="blue">return</span> x * x; }&#13;
<span class="cviolet"> <strong>7</strong></span>      <span class="blue">double</span> cube(<span class="blue">double</span> x) { <span class="blue">return</span> x * x * x; }&#13;
<span class="cviolet"> <strong>8</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.13</strong></span> | Module interface partition unit <code>deitel.math:additive</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec42"><code>deitel.math:roots</code> Module Interface Partition Unit</h5>&#13;
<p>Line 3 of <a href="ch16.xhtml#fig16_14">Fig. 16.14</a> indicates that the <strong>translation unit</strong> <code>deitel.math-roots.ixx</code> is a <strong>module interface partition unit</strong> with the <strong>partition name</strong> is <code>"roots"</code>. The partition belongs to module <code>deitel.math</code>. This partition exports the <code>deitel::math</code> namespace, containing the functions <code>squareRoot</code> and <code>cubeRoot</code>. There are several <strong>rules to keep in mind for partitions</strong>:</p>&#13;
<p class="bull"><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> • <strong>All module interface partitions with the same module name are part of the same module</strong> (in this case, <code>deitel.math</code>). <strong>They are not implicitly known to one another</strong>, and they <strong>do not implicitly import the module’s interface</strong>.<sup><a id="ch16fn68a" href="ch16.xhtml#ch16fn68">68</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn68" href="ch16.xhtml#ch16fn68a">68</a>. Gabriel Dos Reis, "Programming with C++ Modules: Guide for the Working Software Developer," October 5, 2019. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=tjSuKOz5HK4">https://www.youtube.com/watch?v=tjSuKOz5HK4</a></code>.</p>&#13;
<p class="bull"><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> • <strong>Partitions may be imported only into other module units that belong to the same module.</strong></p>&#13;
<p class="bull"><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> • One <strong>module interface partition unit can <code>import</code> another from the same module to use the other partition’s features</strong>.</p>&#13;
<div class="group" id="fig16_14">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro14" id="p16pro14a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.14: deitel.math-roots.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Module interface partition unit deitel.math:roots.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> deitel.math:roots;&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> &lt;cmath&gt;;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">export namespace</span> deitel::math {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">double</span> squareRoot(<span class="blue">double</span> x) { <span class="blue">return</span> std::sqrt(x); }&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">double</span> cubeRoot(<span class="blue">double</span> x) { <span class="blue">return</span> std::cbrt(x); }&#13;
<span class="cviolet"><strong>10</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.14</strong></span> | Module interface partition unit <code>deitel.math:multiplicative</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec43"><code>deitel.math</code> Primary Module Interface Unit</h5>&#13;
<p><a href="ch16.xhtml#fig16_15">Figure 16.15</a> defines the <code>deitel.math.ixx</code> <strong>primary module interface unit</strong>. Every module must have one <strong>primary module interface unit</strong> with an <strong><code>export module</code> declaration</strong> that does not include a <strong>partition name</strong> (line 4). Lines 8 and 9 <code>import</code> and <code>export</code> the <strong>module interface partition units</strong>:</p>&#13;
<p class="bull">• Each <strong><code>import</code></strong> is followed by a colon (<code>:</code>) and the name of a <strong>module interface partition unit</strong> (in this case, <code>powers</code> or <code>roots</code>).</p>&#13;
<p class="bull">• Placing the <strong><code>export</code></strong> keyword before <strong><code>import</code></strong> indicates that each <strong>module interface partition unit</strong>’s exported members also should be part of the <code>deitel.math</code> module’s <strong>primary module interface</strong>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>The users of your module cannot see its partitions</strong>.<sup><a id="ch16fn69a" href="ch16.xhtml#ch16fn69">69</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn69" href="ch16.xhtml#ch16fn69a">69</a>. “C++ Standard: 10 Modules—10.1 Module units and purviews.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module.unit">https://eel.is/c++draft/module.unit</a></code>.</p>&#13;
<div class="group" id="fig16_15">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro15" id="p16pro15a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.15: deitel.math.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface unit deitel.math exports declarations from</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// the module interface partitions :powers and :roots.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">export module</span> deitel.math; <span class="lgreen">// declares the primary module interface unit</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="lgreen">// import and re-export the declarations in the module</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="lgreen">// interface partitions :powers and :roots</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">export import</span> :powers;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">export</span> <span class="blue">import</span> :roots;</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.15</strong></span> | Primary module interface unit that exports declarations from the module interface partitions <code>:powers</code> and <code>:roots</code>.</p>&#13;
</div>&#13;
<p>You also can <strong><code>export import</code> primary module interface units</strong>. Let’s assume we have modules named <code>A</code> and <code>B</code>. If module <code>A</code>’s <strong>primary module interface unit</strong> contains</p>&#13;
<pre class="pre"><span class="blue">export import</span> B;</pre>&#13;
<p>then a <strong>translation unit</strong> that imports <code>A</code> also imports <code>B</code> and can use its <strong>exported declarations</strong>.</p>&#13;
<p>If you <strong><code>export import</code> a header unit</strong>, its preprocessor macros are available for use only in the <strong><code>import</code>ing translation unit</strong>—they are not re-<code>export</code>ed. So, to use a macro from a <strong>header unit</strong> in a specific <strong>translation unit</strong>, you must explicitly <code>import</code> the header.</p>&#13;
<h5 class="h5" id="ch16lev3sec44">Using the <code>deitel.math</code> Module</h5>&#13;
<p><a href="ch16.xhtml#fig16_16">Figure 16.16</a> imports the <code>deitel.math</code> module (line 4) and lines 9–12 use its <strong>exported functions</strong> to demonstrate that the <strong>primary module interface</strong> contains all the functions exported by the <strong>module interface partitions</strong>.</p>&#13;
<div class="group" id="fig16_16">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro16" id="p16pro16a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_16.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Using the deitel.math module's functions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> deitel.math; <span class="lgreen">// import the deitel.math module</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> deitel::math;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::cout &lt;&lt; <span class="green">"square(6): "</span> &lt;&lt; square(<span class="green">6</span>)&#13;
<span class="cviolet"><strong>10</strong></span>         &lt;&lt; <span class="green">"\ncube(5): "</span> &lt;&lt; cube(<span class="green">5</span>)&#13;
<span class="cviolet"><strong>11</strong></span>         &lt;&lt; <span class="green">"\nsquareRoot(9): "</span> &lt;&lt; squareRoot(<span class="green">9</span>)&#13;
<span class="cviolet"><strong>12</strong></span>         &lt;&lt; <span class="green">"\ncubeRoot(1000): "</span> &lt;&lt; cubeRoot(<span class="green">1000</span>) &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>13</strong></span>   }</pre>&#13;
<pre class="pre1">square(6): 36&#13;
cube(5): 125&#13;
squareRoot(9): 3&#13;
cubeRoot(1000): 10</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.16</strong></span> | Using the <code>deitel.math</code> module’s functions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec45">Compiling This Example in Visual C++</h5>&#13;
<p>Add the files <code>deitel.math-powers.ixx deitel.math-roots.ixx</code> and <code>deitel.math.ixx</code> to your <strong>Visual C++ project</strong> using the steps from <a href="ch16.xhtml#sec16_5_1">Section 16.5.1</a>, then add the file <code>fig16_16.cpp</code> to the project’s <code><strong>Source Files</strong></code> folder. Run your project to compile the module and the <strong><code>main</code> application</strong>.</p>&#13;
<h5 class="h5" id="ch16lev3sec46">Compiling This Example in <code>g++</code></h5>&#13;
<p>When <strong>building a module with partitions</strong>, you must build the partitions before the primary <strong>module interface unit</strong>. In <code>g++</code>, use the commands introduced in <a href="ch16.xhtml#sec16_5_6">Section 16.5.6</a> to compile the <strong>standard library headers</strong> <code>&lt;cmath&gt;</code> and <code>&lt;iostream&gt;</code> as <strong>header units</strong>. Next, compile each <strong>module interface partition unit</strong>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1061pro01" id="p1061pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -c -x c++ deitel.math-powers.ixx</code>&#13;
<code>g++ -fmodules-ts -c -x c++ deitel.math-roots.ixx</code></pre>&#13;
<p>Then, compile the <strong>primary module interface unit</strong>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1061pro02" id="p1061pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -c -x c++ deitel.math.ixx</code></pre>&#13;
<p>Finally, compile the <strong><code>main</code> application</strong> and the <code>{fmt}</code> library’s <code>format.cc</code> source file and link it with <code>deitel.math-additive.o</code>, <code>deitel.math-multiplicative.o</code> and <code>deitel.math.o</code>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1061pro03" id="p1061pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>g++ -fmodules-ts -I ../../libraries/fmt/include fig16_16.cpp</code>&#13;
   <code>../../libraries/fmt/src/format.cc deitel.math-powers.o</code>&#13;
   <code>deitel.math-roots.o deitel.math.o -o fig16_16</code></pre>&#13;
<h4 class="h4" id="sec16_8_2">16.8.2 Module Implementation Partition Units</h4>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> You also can divide <strong>module implementations</strong> into <strong><span class="violet">module implementation partition units</span></strong> to define a module’s implementation details across <strong>multiple source-code files</strong>.<sup><a id="ch16fn70a" href="ch16.xhtml#ch16fn70">70</a></sup> Again, this can help you organize a module’s components into smaller, more manageable <strong>translation units</strong> and possibly <strong>reduce compilation times</strong> in large systems. In a <strong>module implementation partition</strong>, the <strong><code>module</code> declaration</strong> must not contain <code>export</code> keyword:</p>&#13;
<p class="footnote"><a id="ch16fn70" href="ch16.xhtml#ch16fn70a">70</a>. Richard Smith, “Merging Modules—<a href="ch02.xhtml#ch02lev1sec2">Section 2.2</a> Module Partitions,” February 22, 2019. Accessed August 13, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf</a></code>.</p>&#13;
<pre class="pre"><span class="blue">module</span> <em>ModuleName</em><code>:</code><em>ParitionName</em><code>;</code></pre>&#13;
<p><strong>Module implementation partition units</strong> may not <code>export</code> declarations and do not implicitly <code>import</code> the <strong>primary module interface</strong>.<sup><a id="ch16fn71a" href="ch16.xhtml#ch16fn71">71</a></sup> At the time of this writing, none of our preferred compilers support <strong>module implementation partitions</strong>, so we do not show them here.</p>&#13;
<p class="footnote"><a id="ch16fn71" href="ch16.xhtml#ch16fn71a">71</a>. Daniela Engert, “Modules the beginner’s guide,” May 2, 2020. Accessed August 13, 2021. <code><a href="https://www.youtube.com/watch?v=Kqo-jIq4V3I">https://www.youtube.com/watch?v=Kqo-jIq4V3I</a></code>.</p>&#13;
<h4 class="h4" id="sec16_8_3">16.8.3 Example: “Submodules” vs. Partitions</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Some libraries, like the <strong>C++ standard library</strong>, are quite large. Programmers using such a library might want the flexibility to import only portions of it. A library vendor can divide a library into <strong>logical “submodules,”</strong> each with its own <strong>primary module interface unit</strong>. These can be imported independently. In addition, library vendors can provide a <strong>primary module interface unit</strong> that aggregates the “submodules” by importing and re-exporting their interfaces. Let’s reimplement <a href="ch16.xhtml#sec16_8">Section 16.8</a>’s <code>deitel.math</code> module using only <strong>primary module interface units</strong> to demonstrate the flexibility this provides to users.</p>&#13;
<h5 class="h5" id="ch16lev3sec47"><code>deitel.math.powers</code> Primary Module Interface Unit</h5>&#13;
<p>First, let’s rename <code>deitel.math-powers.ixx</code> as <code>deitel.math.powers.ixx</code>. We used the convention <code>"-</code><em>name</em><code>"</code> previously to indicate that the <code>powers</code> partition was part of module <code>deitel.math</code>. In this program, <code>deitel.math.powers</code> is a <strong>primary module interface unit</strong> (<a href="ch16.xhtml#fig16_17">Fig. 16.17</a>). Rather than declaring a <strong>module interface partition</strong>, as in <a href="ch16.xhtml#fig16_13">Fig. 16.13</a>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1062pro01" id="p1062pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">export module</span> deitel.math:powers;</pre>&#13;
<p>line 3 of <a href="ch16.xhtml#fig16_17">Fig. 16.17</a> declares a <strong>primary module interface unit</strong> with a dot-separated name:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1062pro02" id="p1062pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">export module</span> deitel.math.powers;</pre>&#13;
<p>We can now independently import <code>deitel.math.powers</code> and use its functions (<a href="ch16.xhtml#fig16_18">Fig. 16.18</a>).</p>&#13;
<div class="group" id="fig16_17">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro17" id="p16pro17a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.17: deitel.math.powers.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface unit deitel.math.powers.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> deitel.math.powers;&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">export namespace</span> deitel::math {&#13;
<span class="cviolet"> <strong>6</strong></span>      <span class="blue">double</span> square(<span class="blue">double</span> x) { <span class="blue">return</span> x * x; }&#13;
<span class="cviolet"> <strong>7</strong></span>      <span class="blue">double</span> cube(<span class="blue">double</span> x) { <span class="blue">return</span> x * x * x; }&#13;
<span class="cviolet"> <strong>8</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.17</strong></span> | Primary module interface unit <code>deitel.math.powers</code>.</p>&#13;
</div>&#13;
<div class="group" id="fig16_18">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro18" id="p16pro18a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_18.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Using the deitel.math.powers module's functions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> deitel.math.powers; <span class="lgreen">// import the deitel.math.powers module</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> deitel::math;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::cout &lt;&lt; <span class="green">"square(6): "</span> &lt;&lt; square(<span class="green">6</span>)&#13;
<span class="cviolet"><strong>10</strong></span>         &lt;&lt; <span class="green">"\ncube(5): "</span> &lt;&lt; cube(<span class="green">5</span>) &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>11</strong></span>   }</pre>&#13;
<pre class="pre1">square(6): 36&#13;
cube(5): 125</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.18</strong></span> | Using the <code>deitel.math.powers</code> module's functions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec48"><code>deitel.math.roots</code> Primary Module Interface Unit</h5>&#13;
<p>Next, let’s rename the file <code>deitel.math-roots.ixx</code> as <code>deitel.math.roots.ixx</code> and make <code>deitel.math.powers</code> a <strong>primary module interface unit</strong> (<a href="ch16.xhtml#fig16_19">Fig. 16.19</a>). Rather than declaring a <strong>module interface partition</strong>, as in <a href="ch16.xhtml#fig16_14">Fig. 16.14</a>:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1063pro01" id="p1063pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">export module</span> deitel.math:roots;</pre>&#13;
<p>line 3 of <a href="ch16.xhtml#fig16_19">Fig. 16.19</a> declares a <strong>primary module interface unit</strong> with a dot-separated name:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1063pro02" id="p1063pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">export module</span> deitel.math.roots;</pre>&#13;
<p>We can now independently import <code>deitel.math.roots</code> and use its functions (<a href="ch16.xhtml#fig16_20">Fig. 16.20</a>).</p>&#13;
<div class="group" id="fig16_19">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro19" id="p16pro19a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.19: deitel.math.roots.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface unit deitel.math.roots.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> deitel.math.roots;&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> &lt;cmath&gt;;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">export namespace</span> deitel::math {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">double</span> squareRoot(<span class="blue">double</span> x) { <span class="blue">return</span> std::sqrt(x); }&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">double</span> cubeRoot(<span class="blue">double</span> x) { <span class="blue">return</span> std::cbrt(x); }&#13;
<span class="cviolet"><strong>10</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.19</strong></span> | Primary module interface unit <code>deitel.math.roots</code>.</p>&#13;
</div>&#13;
<div class="group" id="fig16_20">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro20" id="p16pro20a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_20.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Using the deitel.math.roots module's functions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> deitel.math.roots; <span class="lgreen">// import the deitel.math.roots module</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> deitel::math;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::cout &lt;&lt; <span class="green">"squareRoot(9): "</span> &lt;&lt; squareRoot(<span class="green">9</span>)&#13;
<span class="cviolet"><strong>10</strong></span>         &lt;&lt; <span class="green">"\ncubeRoot(1000): "</span> &lt;&lt; cubeRoot(<span class="green">1000</span>) &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>11</strong></span>   }</pre>&#13;
<pre class="pre1">square(6): 36&#13;
cube(5): 125</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.20</strong></span> | Using the <code>deitel.math.roots</code> module's functions. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec49"><code>deitel.math</code> Primary Module Interface Unit</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <a href="ch16.xhtml#fig16_17">Figures 16.17</a> and <a href="ch16.xhtml#fig16_19">16.19</a> are now <strong>separate modules</strong>—even though their dot-separated names <code>deitel.math.powers</code> and <code>deitel.math.roots</code> indicate a <strong>logical relationship</strong> between them, and both modules export the <code>deitel::math</code> namespace. For convenience, we can now <strong>aggregate these separate modules in a primary module interface unit</strong> that <strong><code>export import</code>s</strong> both <strong>“submodules”</strong> as shown in lines 7 and 8 of <a href="ch16.xhtml#fig16_21">Fig. 16.21</a>. We can then use all the functions from both <strong>“submodules”</strong> by importing <code>deitel.math</code> (<a href="ch16.xhtml#fig16_22">Fig. 16.22</a>).</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> With these <strong>“submodules”</strong> developers now have the flexibility to:</p>&#13;
<p class="bull">• import <code>deitel.math.powers</code> to use only <code>square</code> and <code>cube</code>,</p>&#13;
<p class="bull">• import <code>deitel.math.roots</code> to use only <code>squareRoot</code> and <code>cubeRoot</code>, or</p>&#13;
<p class="bull">• import the aggregated module <code>deitel.math</code> to use all four functions.</p>&#13;
<div class="group" id="fig16_21">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro21" id="p16pro21a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.21: deitel.math.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface unit deitel.math aggregates declarations</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// from "submodules" deitel.math.powers and deitel.math.roots.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">export module</span> deitel.math; <span class="lgreen">// primary module interface unit</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="lgreen">// import and re-export deitel.math.powers and deitel.math.roots</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">export import</span> deitel.math.powers;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">export import</span> deitel.math.roots;</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.21</strong></span> | Primary module interface unit <code>deitel.math</code> aggregates declarations from "submodules" <code>deitel.math.powers</code> and <code>deitel.math.roots</code>.</p>&#13;
</div>&#13;
<div class="group" id="fig16_22">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro22" id="p16pro22a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_22.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Using the deitel.math module's functions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> deitel.math; <span class="lgreen">// import the deitel.math module</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> deitel::math;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::cout &lt;&lt; <span class="green">"square(6): "</span> &lt;&lt; square(<span class="green">6</span>)&#13;
<span class="cviolet"><strong>10</strong></span>         &lt;&lt; <span class="green">"\ncube(5): "</span> &lt;&lt; cube(<span class="green">5</span>)&#13;
<span class="cviolet"><strong>11</strong></span>         &lt;&lt; <span class="green">"\nsquareRoot(9): "</span> &lt;&lt; squareRoot(<span class="green">9</span>)&#13;
<span class="cviolet"><strong>12</strong></span>         &lt;&lt; <span class="green">"\ncubeRoot(1000): "</span> &lt;&lt; cubeRoot(<span class="green">1000</span>) &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>13</strong></span>   }</pre>&#13;
<pre class="pre1">square(6): 36&#13;
cube(5): 125&#13;
squareRoot(9): 3&#13;
cubeRoot(1000): 10</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.22</strong></span> | Using the <code>deitel.math</code> module’s functions. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h3 class="h3" id="sec16_9"><span class="violet">16.9</span> Additional Modules Examples</h3>&#13;
<p>The next several subsections demonstrate additional modules concepts including:</p>&#13;
<p class="bull">• importing the modularized Microsoft and <code>clang++</code> standard libraries,</p>&#13;
<p class="bull">• some module restrictions and the compilation errors you’ll receive if you violate those restrictions, and</p>&#13;
<p class="bull">• the difference between module members that other translation units can use by name vs. module members that other translation units can use indirectly.</p>&#13;
<h4 class="h4" id="sec16_9_1">16.9.1 Example: Importing the C++ Standard Library as Modules</h4>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> The C++ standard does not currently require compilers to provide a <strong>modularized standard library</strong>. Microsoft provides one for Visual C++, which they split into several modules, and <code>clang++</code> has a single-module version of the standard library. You can <code>import</code> the following modules into your Visual C++ projects and “potentially speed up compilation times depending on the size of your project”:<sup><a id="ch16fn72a" href="ch16.xhtml#ch16fn72">72</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn72" href="ch16.xhtml#ch16fn72a">72</a>. Colin Robertson and Nick Schonning, “Overview of modules in C++,” December 13, 2019. Accessed August 13, 2021. <code><a href="https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-160">https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-160</a></code>.</p>&#13;
<p class="bull">• <code>std.core</code>—This module contains most of the standard library, except for the items below.</p>&#13;
<p class="bull">• <code>std.filesystem</code>—Module containing the <code>&lt;filesystem&gt;</code> header’s capabilities.</p>&#13;
<p class="bull">• <code>std.memory</code>—Module containing the <code>&lt;memory&gt;</code> header’s capabilities.</p>&#13;
<p class="bull">• <code>std.regex</code>—Module containing the <code>&lt;regex&gt;</code> header’s capabilities.</p>&#13;
<p class="bull">• <code>std.threading</code>—Module containing the capabilities of all the concurrency-related headers: <code>&lt;atomic&gt;</code>, <code>&lt;condition_variable&gt;</code>, <code>&lt;future&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;shared_mutex&gt;</code> and <code>&lt;thread&gt;</code>.</p>&#13;
<p>For <code>clang++</code>, you can <code>import</code> the entire C++ standard library with:</p>&#13;
<pre class="pre"><span class="blue">import</span> std;</pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> In Visual C++, you cannot combine code that <strong><code>#include</code>s standard library headers</strong> with code that <strong><code>import</code>s Microsoft’s standard library modules</strong>. The compiler will not know which version of the standard libraries to choose when the final executable is linked. At the time of this writing, <code>g++</code> did not have a <strong>modularized standard library</strong>.</p>&#13;
<p><a href="ch16.xhtml#fig16_23">Figure 16.23</a> imports the <strong><code>std.core</code> module</strong> (line 3) then uses <code>cout</code> from the standard library’s <code>&lt;iostream&gt;</code> capabilities to output a string.</p>&#13;
<div class="group" id="fig16_23">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro23" id="p16pro23a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.23.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Importing Microsoft's modularized standard library.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> std.core; <span class="lgreen">// provides access to most of the C++ standard library</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>6</strong></span>      std::cout &lt;&lt; <span class="green">"Welcome to C++20 Modules!\n"</span>;&#13;
<span class="cviolet"> <strong>7</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Welcome to C++20 Modules!</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.23</strong></span> | Importing Microsoft's modularized standard library.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec50">Compiling the Program in Visual C++</h5>&#13;
<p>Compiling a program that uses <strong>Microsoft’s modularized standard library</strong> requires additional project settings, which may change once Microsoft’s modules implementation is finalized. First, you must ensure that C++ modules support is installed:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> In Visual Studio, select <code><strong>Tools &gt; Get Tools and Features…</strong></code>.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> In the <code><strong>Individual Components</strong></code> tab, ensure that <code><strong>C++ Modules for v142 build tools</strong></code> is checked. If not, check it, then click <code><strong>Modify</strong></code> to install it. You will need to close Visual Studio to complete the installation.</p>&#13;
<p>Next, you must configure several project settings:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> In the <code><strong>Solution Explorer</strong></code>, right-click your project and select <code><strong>Properties</strong></code> to open the <code><strong>Property Pages</strong></code> dialog.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> In the left column, select <code><strong>Configuration Properties &gt; C/C++ &gt; Code Generation</strong></code>.</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> In the right column, ensure that <code><strong>Enable C++ Exceptions</strong></code> is set to <code><strong>Yes (/EHsc)</strong></code>.</p>&#13;
<p class="num"><span class="red"><strong>4.</strong></span> In the right column, ensure that <code><strong>Runtime Library</strong></code> is set to <code><strong>Multi-threaded DLL (/MD)</strong></code> if you are compiling in <code><strong>Release</strong></code> mode or <code><strong>Multi-threaded Debug DLL (/MDd)</strong></code> if you are compiling in <code><strong>Debug</strong></code> mode. You can choose settings for <code><strong>Release</strong></code> or <code><strong>Debug</strong></code> mode by changing the value in the <code><strong>Configurations</strong></code> drop-down at the top of the <code><strong>Property Pages</strong></code> dialog.</p>&#13;
<p class="num"><span class="red"><strong>5.</strong></span> In the left column, select <code><strong>Configuration Properties &gt; C/C++ &gt; Language</strong></code>.</p>&#13;
<p class="num"><span class="red"><strong>6.</strong></span> In the right column, ensure that <code><strong>Enable Experimental C++ Standard Library Modules</strong></code> is set to <code><strong>Yes (/experimental:module)</strong></code> and that <code><strong>C++ Language Standard</strong></code> is set to <code><strong>Preview - Features from the Latest C++ Working Draft (/std:c++latest)</strong></code>.</p>&#13;
<p>You can now compile and run <a href="ch16.xhtml#fig16_23">Fig. 16.23</a>.</p>&#13;
<h5 class="h5" id="ch16lev3sec51">Modifying and Compiling the Program in <code>clang++</code></h5>&#13;
<p>To compile this program in <code>clang++</code>, change line 3 of <a href="ch16.xhtml#fig16_23">Fig. 16.23</a> to:</p>&#13;
<pre class="pre"><span class="blue">import</span> std;</pre>&#13;
<p>Then compile the program using the following command:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1066pro01" id="p1066pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>clang++-13 -std=c++20 -stdlib=libc++ -fimplicit-modules</code>&#13;
   <code>-fimplicit-module-maps fig16_23.cpp -o fig16_23</code></pre>&#13;
<h4 class="h4" id="sec16_9_2">16.9.2 Example: Cyclic Dependencies Are Not Allowed</h4>&#13;
<p><strong>A module is not allowed to have a dependency on itself</strong>—that is, a module cannot import itself directly or indirectly.<sup><a id="ch16fn73a" href="ch16.xhtml#ch16fn73">73</a>,<a id="ch16fn74a" href="ch16.xhtml#ch16fn74">74</a></sup> <a href="ch16.xhtml#fig16_24">Figures 16.24</a> and <a href="ch16.xhtml#fig16_25">16.25</a> define <strong>primary module interface units</strong> <code>moduleA</code> and <code>moduleB</code>—<code>moduleA</code> imports <code>moduleB</code> and vice versa. Each module indirectly has a dependency on itself due to the <code>import</code> statements in line 5 of <a href="ch16.xhtml#fig16_24">Fig. 16.24</a> and line 5 of <a href="ch16.xhtml#fig16_25">Fig. 16.25</a>—<code>moduleA</code> imports <code>moduleB</code> which, in turn, imports <code>moduleA</code>.</p>&#13;
<p class="footnote"><a id="ch16fn73" href="ch16.xhtml#ch16fn73a">73</a>. “C++ Standard: 10 Modules—10.3 Import declaration.” Accessed August 14, 2021. <code><a href="https://eel.is/c++draft/module.import">https://eel.is/c++draft/module.import</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn74" href="ch16.xhtml#ch16fn74a">74</a>. Eric Niebler, “Understanding C++ Modules: Part 2: export, import, visible, and reachable,” March 31, 2019. Accessed August 14, 2021. <code><a href="https://vector-of-bool.github.io/2019/03/31/modules-2.html">https://vector-of-bool.github.io/2019/03/31/modules-2.html</a></code>.</p>&#13;
<div class="group" id="fig16_24">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro24" id="p16pro24a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.24: moduleA.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface unit that imports moduleB.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> moduleA; <span class="lgreen">// declares the primary module interface unit</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">export import</span> moduleB; <span class="lgreen">// import and re-export moduleB</span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.24</strong></span> | Primary module interface unit that imports <code>moduleB</code>.</p>&#13;
</div>&#13;
<div class="group" id="fig16_25">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro25" id="p16pro25a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.25: moduleB.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface unit that imports moduleA.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> moduleB; <span class="lgreen">// declares the primary module interface unit</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">export import</span> moduleA; <span class="lgreen">// import and re-export moduleA</span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.25</strong></span> | Primary module interface unit that imports <code>moduleA</code>.</p>&#13;
</div>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Compiling Figs. 16.24 and 16.25 in Visual C++ results in the following error message:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1067pro01" id="p1067pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>error :</code> <strong><code>Cannot build the following source files because there is a&#13;
cyclic dependency between them</code></strong><code>: ch16\fig16_24-26\moduleA.ixx depends&#13;
on ch16\fig16_24-26\moduleB.ixx depends on ch16\fig16_24-26\&#13;
moduleA.ixx.</code></pre>&#13;
<p>You cannot compile this example in <code>g++</code> or <code>clang++</code> because each compiler requires a <strong>primary module interface unit</strong> to be compiled before you can import it. Since each module depends on the other, this is not possible.</p>&#13;
<h4 class="h4" id="sec16_9_3">16.9.3 Example: <code>imports</code> Are Not Transitive</h4>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> In <a href="ch16.xhtml#sec16_5_7">Section 16.5.7</a>, we mentioned that modules have <strong>strong encapsulation</strong> and <strong>do not <code>export</code> declarations implicitly</strong>. Thus, <strong><code>import</code> statements are not transitive</strong>—if a <strong>translation unit</strong> imports <code>A</code> and <code>A</code> imports <code>B</code>, the <strong>translation unit</strong> that imported <code>A</code> does not automatically have access to <code>B</code>’s exported members.</p>&#13;
<p>Consider <code>moduleA</code> (<a href="ch16.xhtml#fig16_26">Fig. 16.26</a>) and <code>moduleB</code> (<a href="ch16.xhtml#fig16_27">Fig. 16.27</a>)—<strong><code>moduleB</code> imports but does not re-<code>export moduleA</code></strong> (line 6 of <a href="ch16.xhtml#fig16_27">Fig. 16.27</a>). As a result, <strong><code>moduleA</code>’s exported <code>cube</code> function is not part of <code>moduleB</code>’s interface</strong>.</p>&#13;
<div class="group" id="fig16_26">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro26" id="p16pro26a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.26: moduleA.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface unit that exports function cube.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export module</span> moduleA; <span class="lgreen">// declares the primary module interface unit</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">export int</span> cube(int x) { <span class="blue">return</span> x * x * x; }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.26</strong></span> | Primary module interface unit that exports function <code>cube</code>.</p>&#13;
</div>&#13;
<div class="group" id="fig16_27">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro27" id="p16pro27a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.27: moduleB.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface unit that imports, but does not export,</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// moduleB and exports function square.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">export</span> module moduleB; <span class="lgreen">// declares the primary module interface unit</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">import</span> moduleA; <span class="lgreen">// import but do not export moduleA</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">export int</span> square(int x) { <span class="blue">return</span> x * x; }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.27</strong></span> | Primary module interface unit that imports, but does not export, <code>moduleB</code> and exports function <code>square</code>.</p>&#13;
</div>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <a href="ch16.xhtml#fig16_28">Figure 16.28</a> imports <code>moduleB</code> and attempts to use <code>moduleA</code>’s <code>cube</code> function (line 8), which generates errors because <code>cube</code>’s declaration is not imported. The key error messages produced by Visual C++, <code>g++</code> and <code>clang++</code>, respectively, are:</p>&#13;
<p class="bull">• <code>error C3861: 'cube': identifier not found</code></p>&#13;
<p class="bull">• <code>error: 'cube' was not declared in this scope</code></p>&#13;
<p class="bull">• <code>error: declaration of 'cube' must be imported from module 'moduleA' before it is required</code></p>&#13;
<div class="group" id="fig16_28">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro28" id="p16pro28a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_28.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Showing that moduleB does not implicitly export moduleA's function.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> moduleB;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>7</strong></span>      std::cout &lt;&lt; <span class="green">"square(6): "</span> &lt;&lt; square(<span class="green">6</span>) <span class="lgreen">// exported from moduleB</span>&#13;
<span class="cviolet"> <strong>8</strong></span>         &lt;&lt; <span class="green">"\ncube(5): "</span> &lt;&lt; cube(<span class="green">5</span>) &lt;&lt; <span class="green">'\n'</span>; <span class="lgreen">// not exported from moduleB</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.28</strong></span> | Showing that <code>moduleB</code> does not implicitly export <code>moduleA</code>'s function.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec16_9_4">16.9.4 Example: Visibility vs. Reachability</h4>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> Every example so far in which we used <strong>a name <code>export</code>ed from a module</strong> demonstrated the concept of <strong><span class="violet">visibility</span></strong>. <strong>A declaration is visible in a translation unit if you can use its name</strong>. As you’ve seen, <strong>any name <code>export</code>ed from a module can be used in translation units that <code>import</code> the module</strong>.</p>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> Some declarations are <strong><span class="violet">reachable</span></strong> but not <strong>visible</strong>,<sup><a id="ch16fn75a" href="ch16.xhtml#ch16fn75">75</a>,<a id="ch16fn76a" href="ch16.xhtml#ch16fn76">76</a>,<a id="ch16fn77a" href="ch16.xhtml#ch16fn77">77</a></sup> meaning you <strong>cannot explicitly mention the declaration’s name in another translation unit, but the declaration is indirectly accessible</strong>. Anything <strong>visible</strong> is <strong>reachable</strong>, but not vice versa. The easiest way to understand this concept is with code. To demonstrate <strong>reachability</strong>, we modified <a href="ch16.xhtml#fig16_10">Fig. 16.10</a>’s <strong>primary module interface unit</strong> <code>deitel.time.ixx</code>.<sup><a id="ch16fn78a" href="ch16.xhtml#ch16fn78">78</a></sup> There are two key changes (<a href="ch16.xhtml#fig16_29">Fig. 16.29</a>):</p>&#13;
<p class="footnote"><a id="ch16fn75" href="ch16.xhtml#ch16fn75a">75</a>. “C++ Standard: 10 Modules—10.7 Reachability.” Accessed August 14, 2021. <code><a href="https://eel.is/c++draft/module.reach">https://eel.is/c++draft/module.reach</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn76" href="ch16.xhtml#ch16fn76a">76</a>. Eric Niebler, “Understanding C++ Modules: Part 2: export, import, visible, and reachable,” March 31, 2019. Accessed August 14, 2021. <code><a href="https://vector-of-bool.github.io/2019/03/31/modules-2.html">https://vector-of-bool.github.io/2019/03/31/modules-2.html</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn77" href="ch16.xhtml#ch16fn77a">77</a>. Richard Smith, “Merging Modules—<a href="ch02.xhtml#ch02lev1sec2">Section 2.2</a> Module Partitions,” February 22, 2019. Accessed August 13, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch16fn78" href="ch16.xhtml#ch16fn78a">78</a>. The module’s implementation unit (<a href="ch16.xhtml#fig16_11">Fig. 16.11</a>) is identical for this example, so we do not show it here.</p>&#13;
<p class="bull">• We no longer <code>export</code> namespace <code>deitel::time</code> (line 7), so <strong>class <code>Time</code> is not <code>export</code>ed</strong> and thus <strong>not visible to translation units that <code>import deitel.time</code></strong>.</p>&#13;
<p class="bull">• We added an <code>export</code>ed function <code>getTime</code> (line 21) that <strong>returns a <code>Time</code> object to its caller</strong>—we’ll use this function’s return value to demonstrate <strong>reachability</strong>.</p>&#13;
<div class="group" id="fig16_29">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro29" id="p16pro29a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 16.29: deitel.time.ixx</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Primary module interface unit for the deitel.time module.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">export</span> <span class="blue">module</span> deitel.time; <span class="lgreen">// declare the primary module interface</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> &lt;string&gt;; <span class="lgreen">// rather than #include &lt;string&gt;</span>&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">namespace</span> deitel::time {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">class</span> Time { <span class="lgreen">// not exported</span>&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>10</strong></span>         <span class="lgreen">// default constructor because it can be called with no arguments</span>&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="blue">explicit</span> Time(<span class="blue">int</span> hour = <span class="green">0</span>, <span class="blue">int</span> minute = <span class="green">0</span>, <span class="blue">int</span> second = <span class="green">0</span>);&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>         std::string toString() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>15</strong></span>         <span class="blue">int</span> m_hour{<span class="green">0</span>}; <span class="lgreen">// 0 - 23 (24-hour clock format)</span>&#13;
<span class="cviolet"><strong>16</strong></span>         <span class="blue">int</span> m_minute{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span>&#13;
<span class="cviolet"><strong>17</strong></span>         <span class="blue">int</span> m_second{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span>&#13;
<span class="cviolet"><strong>18</strong></span>      <code>};</code>&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="lgreen">// exported function returns a valid Time</span>&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">export</span> Time getTime() { <span class="blue">return</span> Time(<span class="green">6</span>, <span class="green">45</span>, <span class="green">0</span>); }&#13;
<span class="cviolet"><strong>22</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.29</strong></span> | Primary module interface unit for the <code>deitel.time</code> module.</p>&#13;
</div>&#13;
<p>The program in <a href="ch16.xhtml#fig16_30">Fig. 16.30</a> imports the <code>deitel.time</code> module (line 5). Line 10 calls the module’s exported <code>getTime</code> function to get a <code>Time</code> object. Note that <strong>we infer variable <code>t</code>’s type</strong>. If you were to replace <strong><code>auto</code></strong> in line 10 with <strong><code>Time</code></strong>, you’d get an error like the following (in Visual C++):</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1069pro01" id="p1069pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>error C2065: 'Time': undeclared identifier</code></pre>&#13;
<p><span class="size">Mod</span><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> because <strong><code>Time</code> is not visible in this translation unit</strong>. However, <code>Time</code>’s declaration is <strong>reachable</strong> because <strong><code>getTime</code> returns a <code>Time</code> object</strong>—the compiler knows this, so it can infer variable’s <code>t</code>’s type. <strong>When a declaration is reachable, the declaration’s members become visible.</strong> So, even though <code>deitel.time</code> does not <code>export</code> class <code>Time</code>, this translation unit can still call <code>Time</code> member function <code>toString</code> (line 14) to get <code>t</code>’s <code>string</code> representation. The compilation steps for this program are the same as those in <a href="ch16.xhtml#sec16_7_3">Section 16.7.3</a>, except that the <code>main</code> program’s filename is now <code>fig16_30.cpp</code>.</p>&#13;
<div class="group" id="fig16_30">&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p16pro30" id="p16pro30a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig16_30.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Showing that type deitel::time::Time is reachable</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// and its public members are visible.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">import</span> &lt;iostream&gt;;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">import</span> deitel.time;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="lgreen">// initalize t with the object returned by getTime; cannot declare t</span>&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// as type Time because the type is not exported, and thus not visible</span>&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">auto</span> t{ deitel::time::getTime() };&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="lgreen">// Time's toString function is reachable, even though</span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="lgreen">// class Time was not exported by module deitel.time</span>&#13;
<span class="cviolet"><strong>14</strong></span>      std::cout &lt;&lt; <span class="green">"Time t:\n"</span> &lt;&lt; t.toString() &lt;&lt; <span class="green">"\n\n"</span>;&#13;
<span class="cviolet"><strong>15</strong></span>   }</pre>&#13;
<pre class="pre1">Time t:&#13;
Hour: 6&#13;
Minute: 45&#13;
Second: 0</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 16.30</strong></span> | Showing that type <code>deitel::time::Time</code> is reachable and its <code>public</code> members are visible.</p>&#13;
</div>&#13;
<h3 class="h3" id="sec16_10"><span class="violet">16.10</span> Modules Can Reduce Translation Unit Sizes and Compilation Times</h3>&#13;
<p>One way in which modules can reduce compilation times is by eliminating repeated preprocessing of the same header files across many translation units in the same program. Consider the following simple program</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1070pro01" id="p1070pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">#include</span> &lt;iostream&gt;&#13;
&#13;
<span class="blue">int</span> main() {&#13;
   std::cout &lt;&lt; <span class="green">"Welcome to C++20 Modules!\n"</span>;&#13;
}</pre>&#13;
<p>which has fewer than 90 characters, including the vertical spacing and indentation. When you compile this program, the preprocessor inserts the contents of <code>&lt;iostream&gt;</code> into the translation unit. Each of our preferred compilers has a flag that enables you to see the result of preprocessing a source-code file:</p>&#13;
<p class="bull">• <code>-E</code> in <code>g++</code> and <code>clang++</code></p>&#13;
<p class="bull">• <code>/P</code> in Visual C++.</p>&#13;
<p>We used these flags to preprocess the preceding program. The <strong>preprocessed translation unit sizes</strong> on our system were:</p>&#13;
<p class="bull">• 1,023,010 bytes in g++,</p>&#13;
<p class="bull">• 1,883,270 bytes in clang++, and</p>&#13;
<p class="bull">• 1,497,116 bytes in Visual c++.</p>&#13;
<p><strong>The preprocessed translation units are approximately 11,000 to 21,000 times the size of the original source file</strong>—a massive increase in the number of bytes per translation unit. Now imagine a large project with <strong>thousands of translation units</strong> that each <code>#include</code> <strong>many headers</strong>. Every <code>#include</code> must be preprocessed to form the translation units that the compiler then needs to process.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <strong>When you use header units, each header is processed only once as a translation unit</strong>. Also, importing a <strong>header unit does not insert the header’s contents into each translation unit</strong>. Together, these greatly reduce compilation times.</p>&#13;
<h5 class="h5" id="ch16lev3sec52">References</h5>&#13;
<p>For more information on translation unit sizes and compilation performance, see the following resources:</p>&#13;
<p class="bull">• <strong>Bjarne Stroustrup</strong>, “<strong>Thriving in a Crowded and Changing World: C++ 2006– 2020—<a href="ch09.xhtml#ch09lev2sec1">Section 9.3.1</a> Modules</strong>,” June 12, 2020. Accessed August 14 2021. <code><a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Cameron DaCamara</strong>, “<strong>Practical C++20 Modules and the future of tooling around C++ Modules</strong>,” May 4, 2020. Accessed August 13, 2021. <code><a href="https://www.youtube.com/watch?v=ow2zV0Udd9M">https://www.youtube.com/watch?v=ow2zV0Udd9M</a></code>.</p>&#13;
<p class="bull">• <strong>Rainer Grimm</strong>, “<strong>C++20: The Advantages of Modules</strong>,” May 10, 2020. Accessed August 5, 2021. <code><a href="https://www.modernescpp.com/index.php/cpp20-modules">https://www.modernescpp.com/index.php/cpp20-modules</a></code>.</p>&#13;
<p class="bull">• <strong>Rene Rivera</strong>, “<strong>Are modules fast? (revision 1)</strong>,” March 6 2019, Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1441r1.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1441r1.pdf</a></code>.</p>&#13;
<h5 class="h5" id="ch16lev3sec53">Compiler Profiling Tools</h5>&#13;
<p>For tools you can use to profile compilation performance, see the following resources:</p>&#13;
<p class="bull">• Kevin Cadieux, Helena Gregg and Colin Robertson, “Get started with C++ Build Insights,” November 3, 2019. Accessed August 16, 2021. <code><a href="https://docs.micro-soft.com/en-us/cpp/build-insights/get-started-with-cpp-build-insights?view=msvc-160&amp;viewFallbackFrom=vs-2019">https://docs.micro-soft.com/en-us/cpp/build-insights/get-started-with-cpp-build-insights?view=msvc-160&amp;viewFallbackFrom=vs-2019</a></code>.</p>&#13;
<p class="bull">• “Clang 13 Documentation: Target-independent compilation options <code>-ftime-report</code> and <code>-ftime-trace</code>,” Accessed August 16, 2021. <code><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#target-independent-compilation-options">https://clang.llvm.org/docs/ClangCommandLineReference.html#target-independent-compilation-options</a></code>.</p>&#13;
<p class="bull">• “Profiling the C++ compilation process.” Accessed August 16, 2021. <code><a href="https://stackoverflow.com/questions/13559818/profiling-the-c-compilation-process">https://stackoverflow.com/questions/13559818/profiling-the-c-compilation-process</a></code></p>&#13;
<h3 class="h3" id="sec16_11"><span class="violet">16.11</span> Migrating Code to Modules</h3>&#13;
<p>We’ve frequently referred to the C++ Core Guidelines for advice and recommendations on the proper ways to use various language elements. At the time of this writing, modules technology is still new, the popular compilers’ modules implementations are not complete, and the C++ Core Guidelines have not yet been updated with modules recommendations. There also are not many articles and videos discussing developers’ experiences with migrating existing software systems to modules. Some of the best are listed below. The Cameron DaCamara (Microsoft) and Steve Downey (Bloomberg) videos provide the most recent tips, guidelines and insights. The Daniela Engert and Nathan Sidwell videos each demonstrate modularizing existing code, and the Yuka Takahashi, Oksana Shadura and Vassil Vassilev paper discusses their experiences with modularizing portions of the large CERN ROOT C++ codebase:</p>&#13;
<p class="bull">• <strong>Cameron DaCamara</strong>, “<strong>Moving a project to C++ named Modules</strong>,” August 10, 2021. Accessed August 16, 2021. <code><a href="https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/">https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/</a></code>.</p>&#13;
<p class="bull">• <strong>Steve Downey</strong>, “<strong>Writing a C++20 Module</strong>,<strong>”</strong> July 5, 2021. Accessed August 18, 2021. <code><a href="https://www.youtube.com/watch?v=AO4piAqV9mg">https://www.youtube.com/watch?v=AO4piAqV9mg</a></code>.</p>&#13;
<p class="bull">• <strong>Daniela Engert, “Modules: The Beginner’s Guide,”</strong> May 2, 2020. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=Kqo-jIq4V3I">https://www.youtube.com/watch?v=Kqo-jIq4V3I</a></code>.</p>&#13;
<p class="bull">• <strong>Yuka Takahashi</strong>, <strong>Oksana Shadura</strong> and <strong>Vassil Vassilev</strong>, “<strong>Migrating large code-bases to C++ Modules</strong>,” August 22, 2019. Accessed August 16, 2021. <code><a href="https://arxiv.org/abs/1906.05092">https://arxiv.org/abs/1906.05092</a></code>.</p>&#13;
<p class="bull">• <strong>Nathan Sidwell</strong>, “<strong>Converting to C++20 Modules</strong>,” October 4, 2019. Accessed August 14, 2021. <code><a href="https://www.youtube.com/watch?v=KVsWIEw3TTw">https://www.youtube.com/watch?v=KVsWIEw3TTw</a></code>.</p>&#13;
<p>We will post additional resources as they become available at:</p>&#13;
<p class="codelink"><a href="Images/ch16_images.xhtml#p1072pro01" id="p1072pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>https://deitel.com/c-plus-plus-20-for-programmers</code></pre>&#13;
<h3 class="h3" id="sec16_12"><span class="violet">16.12</span> Future of Modules and Modules Tooling</h3>&#13;
<p>The C++ standard committee has begun its work on C++23 for which one of the key items will be a <strong>modular standard library</strong>.<sup><a id="ch16fn79a" href="ch16.xhtml#ch16fn79">79</a></sup> C++20 modules are so new that the tooling to help you use modules tooling is under development and will continue to evolve over several years. You’ve already seen some tooling. For example, if you used Visual C++ in this chap-ter’s examples, you saw that Visual Studio enables you to add modules to your projects, and its build tools can compile and link your modularized applications.</p>&#13;
<p class="footnote"><a id="ch16fn79" href="ch16.xhtml#ch16fn79a">79</a>. “To boldly suggest an overall plan for C++23,” November 25, 2019. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0592r4.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0592r4.html</a></code></p>&#13;
<p>Many popular programming languages have module systems or similar capabilities:</p>&#13;
<p class="bull">• Java has the Java Platform Module System (JPMS) for which we wrote a chapter in our Java books and published an article in Oracle’s Java Magazine.<sup><a id="ch16fn80a" href="ch16.xhtml#ch16fn80">80</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn80" href="ch16.xhtml#ch16fn80a">80</a>. Paul Deitel, “Understanding Java 9 Modules,” <em>Oracle Java Magazine</em>, September/October 2017. <code><a href="https://www.oracle.com/a/ocom/docs/corporate/java-magazine-sept-oct-2017.pdf">https://www.oracle.com/a/ocom/docs/corporate/java-magazine-sept-oct-2017.pdf</a></code>.</p>&#13;
<p class="bull">• Python has a well-developed module system, which we used extensively in our Python books.<sup><a id="ch16fn81a" href="ch16.xhtml#ch16fn81">81</a>,<a id="ch16fn82a" href="ch16.xhtml#ch16fn82">82</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn81" href="ch16.xhtml#ch16fn81a">81</a>. Paul Deitel and Harvey Deitel, <em>Python for Programmers</em>, 2019. Pearson Education, Inc.</p>&#13;
<p class="footnote"><a id="ch16fn82" href="ch16.xhtml#ch16fn82a">82</a>. Paul Deitel and Harvey Deitel, <em>Intro to Python for Computer Science and Data Science: Learning to Program with AI, Big Data and the Cloud, 11/e</em>, 2020. Pearson Education, Inc.</p>&#13;
<p class="bull">• Microsoft’s .NET platform languages like C# and Visual basic can modularize code using assemblies.</p>&#13;
<p>Wikipedia lists several dozen languages with modules capabilities.<sup><a id="ch16fn83a" href="ch16.xhtml#ch16fn83">83</a></sup></p>&#13;
<p class="footnote"><a id="ch16fn83" href="ch16.xhtml#ch16fn83a">83</a>. “Modular programming.” Accessed August 18, 2021. <code><a href="https://en.wikipedia.org/wiki/Modular_programming">https://en.wikipedia.org/wiki/Modular_programming</a></code>.</p>&#13;
<p>Many languages provide tooling to help you work with their modules systems and modularize your code. Some tooling that might eventually appear in the C++ ecosystem include:</p>&#13;
<p class="bull">• <strong>module-aware build tools</strong> that manage compiling software systems,</p>&#13;
<p class="bull">• <strong>tools to produce cross-platform module interfaces</strong> so developers can distribute a module interface description and object code, rather than source code,</p>&#13;
<p class="bull">• <strong>dependency-checking tools</strong> to ensure that required modules are installed,</p>&#13;
<p class="bull">• <strong>module discovery tools</strong> to determine which modules and versions are installed,</p>&#13;
<p class="bull">• <strong>tools that visualize module dependencies</strong>, showing you the relationships among modules in software systems,</p>&#13;
<p class="bull">• <strong>module packaging and distribution tools</strong> to help developers install modules and their dependencies conveniently across platforms,</p>&#13;
<p class="bull">• and more.</p>&#13;
<h5 class="h5" id="ch16lev3sec54">References</h5>&#13;
<p>A July 2021 paper from Daniel Ruoso of Bloomberg<sup><a id="ch16fn84a" href="ch16.xhtml#ch16fn84">84</a></sup> discusses various problems with code reuse and build systems today and is meant to encourage discussions regarding the future of C++ modules tooling. That paper and the other resources below list in reverse chronological order various C++ standard and third-party vendor opportunities for module-aware tools that will improve the C++ development process: nm,./</p>&#13;
<p class="footnote"><a id="ch16fn84" href="ch16.xhtml#ch16fn84a">84</a>. Daniel Ruoso, “Requirements for Usage of C++ Modules at Bloomberg,” July 12, 2021. Accessed August 18, 2021. <code><a href="https://isocpp.org/files/papers/P2409R0.pdf">https://isocpp.org/files/papers/P2409R0.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Daniel Ruoso</strong>, “<strong>Requirements for Usage of C++ Modules at Bloomberg</strong>,” July 12, 2021. Accessed August 18, 2021. <code><a href="https://isocpp.org/files/papers/P2409R0.pdf">https://isocpp.org/files/papers/P2409R0.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Nathan Sidwell</strong>, “<strong>P1184: A Module Mapper</strong>,” July 10, 2020. Accessed August 16, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1184r2.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1184r2.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Rob Irving</strong>, <strong>Jason Turner</strong> and <strong>Gabriel Dos Reis</strong>, “<strong>Modules Present and Future</strong>,” June 18, 2020. Accessed August 16, 2021. <code><a href="https://cppcast.com/modules-gaby-dos-reis/">https://cppcast.com/modules-gaby-dos-reis/</a></code>.</p>&#13;
<p class="bull">• <strong>Cameron DaCamara</strong>, “<strong>Practical C++20 Modules and the future of tooling around C++ Modules</strong>,” May 4, 2020. Accessed August 12, 2021. Accessed August 16, 2021. <code><a href="https://www.youtube.com/watch?v=ow2zV0Udd9M">https://www.youtube.com/watch?v=ow2zV0Udd9M</a></code>.</p>&#13;
<p class="bull">• <strong>Nathan Sidwell</strong>, “<strong>C++ Modules and Tooling</strong>,” October 4, 2018. Accessed August 16, 2021. <code><a href="https://www.youtube.com/watch?v=4yOZ8Zp_Zfk">https://www.youtube.com/watch?v=4yOZ8Zp_Zfk</a></code>.</p>&#13;
<p class="bull">• <strong>Gabriel Dos Reis</strong>, “<strong>Modules Are a Tooling Opportunity</strong>,” October 16, 2017. Accessed August 16, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0822r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0822r0.pdf</a></code>.</p>&#13;
<h3 class="h3" id="sec16_13"><span class="violet">16.13</span> Wrap-Up</h3>&#13;
<p>In this chapter, we introduced modules—one of C++20’s new “big-four” features. You saw that modules help you organize your code, precisely control which declarations you expose to client code, and encapsulate implementation details. We discussed the advantages of modules, including how they make developers more productive, make systems more scalable, and can reduce translation unit sizes and improve build times. We also pointed out some disadvantages.</p>&#13;
<p>The chapter presented many complete, working modules code examples. You saw that even small systems can benefit from modules technology by transitioning from using preprocessor <code>#include</code> directives to <code>import</code>ing standard library headers as header units. We created custom modules. We implemented a primary module interface unit to specify a module’s client-code interface, then <code>import</code>ed that module into an application to use its <code>export</code>ed members. We employed <code>namespace</code>s to avoid naming conflicts with other modules’ contents. You saw that non-<code>export</code>ed members are not accessible by name in <code>import-</code>ing translation units.</p>&#13;
<p>We separated interface from implementation—first in a primary module interface unit by placing the implementation code in the <code>:private</code> module fragment, then by using a module implementation unit. We divided a module into partitions to organize its components into smaller, more manageable translation units. We showed that “submodules” are more flexible than partitions because partitions cannot be <code>import</code>ed into translation units that are not part of the same module.</p>&#13;
<p>We demonstrated how easy it is to <code>import</code> with a single statement either Microsoft’s or <code>clang++</code>’s modularized standard library. We showed that cyclic module dependencies are not allowed and that <code>import</code>s are not transitive. We discussed the difference between visible declarations and reachable declarations, mentioning that anything visible is reachable, but not necessarily vice versa.</p>&#13;
<p>We provided resources with tips for migrating legacy code to modules—a subject of great interest to organizations considering deploying modules technology. Finally, we discussed the future of C++20 modules and some types of modules tooling that might appear in the next several years. In the following appendices, for your further study we provide lists of the videos, articles, technical papers and documentation that we referenced as we wrote this chapter. We also include a glossary with key modules terms and definitions.</p>&#13;
<p>Modules technology is important. Once supported by the right tools, modules will provide C++ developers with significant opportunities to improve the design, implementation and evolution of libraries and large-scale software systems.</p>&#13;
<p>But modules are new and few organizations have experience using them. Some organizations will modularize new software—but what about the four decades’ worth of non-modularized legacy C++ software. Some of it will eventually be modularized. Some will never be, possibly because the people who built and understand the systems have moved on.</p>&#13;
<p>At Deitel &amp; Associates, we work with many widely used programming languages. Based on our experience studying, writing about and teaching the Java Platform Module System (JPMS), for example, we believe the uptake on C++20 modules will be gradual. Java introduced JPMS in 2017. Compiler vendor JetBrains’ 2021 developer survey showed that 72% of Java developers are still working in some capacity with Java 8—the version of Java before JPMS was introduced.<sup><a id="ch16fn85a" href="ch16.xhtml#ch16fn85">85</a></sup> Organizations using C++ will likely proceed with caution, too. Many will wait to learn about other organizations’ experiences modularizing large legacy codebases and launching new modularized software-development projects.</p>&#13;
<p class="footnote"><a id="ch16fn85" href="ch16.xhtml#ch16fn85a">85</a>. “The State of Developer Ecosystem 2021.” July 15, 2021. Accessed August 18, 2021. <code><a href="https://www.jetbrains.com/lp/devecosystem-2021/">https://www.jetbrains.com/lp/devecosystem-2021/</a></code>.</p>&#13;
<p><a href="ch17.xhtml#ch17">Chapter 17</a> presents C++20’s concurrency and parallelism capabilities, including the standard library’s parallel algorithms and multithreading features. We also introduce coroutines—the last of C++20’s “big four” features.</p>&#13;
<h4 class="h4b" id="sec16_14">Appendix: Modules Videos Bibliography</h4>&#13;
<p>Videos are listed in reverse chronological order.</p>&#13;
<p class="bull">• <strong>Steve Downey</strong>, “<strong>Writing a C++20 Module</strong>,<strong>”</strong> July 5, 2021. Accessed August 18, 2021. <code><a href="https://www.youtube.com/watch?v=AO4piAqV9mg">https://www.youtube.com/watch?v=AO4piAqV9mg</a></code>.</p>&#13;
<p class="bull">• <strong>Daniela Engert</strong>, <strong>“The Three Secret Spices of C++ Modules</strong>,<strong>”</strong> July 1, 2021. Accessed August 15, 2021. <code><a href="https://www.youtube.com/watch?v=l_83lyxWGtE">https://www.youtube.com/watch?v=l_83lyxWGtE</a></code>.</p>&#13;
<p class="bull">• <strong>Sy Brand,</strong> “<strong>C++ Modules: Year 2021,</strong>” May 6, 2021. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=YcZntyWpqVQ">https://www.youtube.com/watch?v=YcZntyWpqVQ</a></code></p>&#13;
<p class="bull">• <strong>Gabriel Dos Reis</strong>, “<strong>Programming in the Large With C++ 20 - Meeting C++ 2020 Keynote</strong>,” December 11, 2020. Accessed August 7, 2021. <code><a href="https://www.youtube.com/watch?v=j4du4LNsLiI">https://www.youtube.com/watch?v=j4du4LNsLiI</a></code>.</p>&#13;
<p class="bull">• <strong>Marc Gregoire</strong>, “<strong>C++20: An (Almost) Complete Overview</strong>,” September 26, 2020. Accessed August 18, 2021. <code><a href="https://www.youtube.com/watch?v=FRkJCvHWdwQ">https://www.youtube.com/watch?v=FRkJCvHWdwQ</a></code>.</p>&#13;
<p class="bull">• <strong>Cameron DaCamara</strong>, “<strong>Practical C++20 Modules and the future of tooling around C++ Modules</strong>,” May 4, 2020. Accessed August 12, 2021. <code><a href="https://www.youtube.com/watch?v=ow2zV0Udd9M">https://www.youtube.com/watch?v=ow2zV0Udd9M</a></code>.</p>&#13;
<p class="bull">• <strong>Timur Doumler, “How C++20 Changes the Way We Write Code</strong>,<strong>”</strong> October 10, 2020. Accessed July 1, 2021. <code><a href="https://www.youtube.com/watch?v=ImLFlLjSveM">https://www.youtube.com/watch?v=ImLFlLjSveM</a></code>.</p>&#13;
<p class="bull">• <strong>Daniela Engert, “Modules: The Beginner’s Guide,”</strong> May 2, 2020. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=Kqo-jIq4V3I">https://www.youtube.com/watch?v=Kqo-jIq4V3I</a></code>.</p>&#13;
<p class="bull">• <strong>Bryce Adelstein Lelbach</strong>, “<strong>Modules are coming</strong>,” May 1, 2020. Accessed August 7, 2020. <code><a href="https://www.youtube.com/watch?v=yee9i2rUF3s">https://www.youtube.com/watch?v=yee9i2rUF3s</a></code>.</p>&#13;
<p class="bull">• <strong>Pure Virtual C++ 2020 Conference</strong>, April 30, 2020. Accessed August 14, 2021. <code><a href="https://www.youtube.com/watch?v=c1ThUFISDF4">https://www.youtube.com/watch?v=c1ThUFISDF4</a></code></p>&#13;
<p class="bull">• “<strong>Demo: C++20 Modules</strong>,” March 30, 2020. Accessed July 28, 2021. <code><a href="https://www.youtube.com/watch?v=6SKIUeRaLZE">https://www.youtube.com/watch?v=6SKIUeRaLZE</a></code>.</p>&#13;
<p class="bull">• <strong>Daniela Engert</strong>, “<strong>Dr Module and Sister #include</strong>,<strong>”</strong> December 5, 2019. Accessed August 15, 2021. <code><a href="https://www.youtube.com/watch?v=OCFOTle2G-A">https://www.youtube.com/watch?v=OCFOTle2G-A</a></code>.</p>&#13;
<p class="bull">• <strong>Boris Kolpackov, “Practical C++ Modules,”</strong> Oct. 18, 2019. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=szHV6RdQdg8">https://www.youtube.com/watch?v=szHV6RdQdg8</a></code>.</p>&#13;
<p class="bull">• <strong>Michael Spencer</strong>, "<strong>Building Modules,”</strong> October 6, 2019. Accessed August 15, 2021. <code><a href="https://www.youtube.com/watch?v=L0SHHkBenss">https://www.youtube.com/watch?v=L0SHHkBenss</a></code> .</p>&#13;
<p class="bull">• <strong>Gabriel Dos Reis</strong>, “<strong>Programming with C++ Modules: Guide for the Working Software Developer</strong>,” October 5, 2019. Accessed August 6, 2021. <code><a href="https://www.youtube.com/watch?v=tjSuKOz5HK4">https://www.youtube.com/watch?v=tjSuKOz5HK4</a></code>.</p>&#13;
<p class="bull">• <strong>Gabriel Dos Reis</strong>, “<strong>Programming with C++ modules</strong>,” October 5, 2019. Accessed August 7, 2021. <code><a href="https://www.youtube.com/watch?v=tjSuKOz5HK4">https://www.youtube.com/watch?v=tjSuKOz5HK4</a></code>.</p>&#13;
<p class="bull">• <strong>Nathan Sidwell</strong>, “<strong>Converting to C++20 Modules</strong>,” October 4, 2019. Accessed August 14, 2021. <code><a href="https://www.youtube.com/watch?v=KVsWIEw3TTw">https://www.youtube.com/watch?v=KVsWIEw3TTw</a></code>.</p>&#13;
<p class="bull">• <strong>Gabriel Dos Reis</strong>, “<strong>C++ Modules: What You Should Know</strong>,” September 13 2019. Accessed August 15, 2021. <code><a href="https://www.youtube.com/watch?v=MP6SJEBt6Ss">https://www.youtube.com/watch?v=MP6SJEBt6Ss</a></code></p>&#13;
<p class="bull">• <strong>Richárd Szalay</strong>, “<strong>The Rough Road Towards Upgrading to C++ Modules</strong>,” June 16, 2019. Accessed August 15, 2021. <code><a href="https://www.youtube.com/watch?v=XJxQs8qgn-c">https://www.youtube.com/watch?v=XJxQs8qgn-c</a></code>.</p>&#13;
<p class="bull">• <strong>Nathan Sidwell</strong>, “<strong>C++ Modules and Tooling</strong>,” October 4, 2018. Accessed August 15, 2021. <code><a href="https://www.youtube.com/watch?v=4yOZ8Zp_Zfk">https://www.youtube.com/watch?v=4yOZ8Zp_Zfk</a></code>.</p>&#13;
<h4 class="h4b" id="sec16_15">Appendix: Modules Articles Bibliography</h4>&#13;
<p>Articles are listed in reverse chronological order.</p>&#13;
<p class="bull">• <strong>Cameron DaCamara</strong>, “<strong>Moving a project to C++ named Modules</strong>," August 10, 2021. Accessed August 15, 2021. <code><a href="https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/">https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/</a></code>.</p>&#13;
<p class="bull">• <strong>Cameron DaCamara</strong>, “<strong>Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</strong>,” July 21, 2021. Accessed August 4, 2021. <code><a href="https://devblogs.micro-soft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/">https://devblogs.micro-soft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/</a></code>.</p>&#13;
<p class="bull">• <strong>Daniel Ruoso</strong>, “<strong>Requirements for Usage of C++ Modules at Bloomberg</strong>,” July 12, 2021. Accessed August 18, 2021. <code><a href="https://isocpp.org/files/papers/P2409R0.pdf">https://isocpp.org/files/papers/P2409R0.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Andreas Fertig</strong> (book), “<strong>Programming with C++20 — Concepts, Coroutines, Ranges, and more</strong>.” Copyright 2021. <code><a href="https://andreasfertig.info/books/programming-with-cpp20/">https://andreasfertig.info/books/programming-with-cpp20/</a></code>.</p>&#13;
<p class="bull">• <strong>Nathan Sidwell</strong>, “<strong>C++ Modules: A Brief Tour</strong>,” October 19, 2020. Accessed August 10, 2021. <code><a href="https://accu.org/journals/overload/28/159/sidwell/">https://accu.org/journals/overload/28/159/sidwell/</a></code>.</p>&#13;
<p class="bull">• <strong>Cameron DaCamara</strong>, “<strong>Standard C++20 Modules support with MSVC in Visual Studio 2019 version 16.8</strong>,” September 14, 2020. Accessed August 4, 2021. <code><a href="https://devblogs.microsoft.com/cppblog/standard-c20-modules-support-with-msvc-in-visual-studio-2019-version-16-8/#private-module-fragments">https://devblogs.microsoft.com/cppblog/standard-c20-modules-support-with-msvc-in-visual-studio-2019-version-16-8/#private-module-fragments</a></code>.</p>&#13;
<p class="bull">• <strong>Vassil Vassilev1, David Lange1, Malik Shahzad Muzaffar, Mircho Rodozov, Oksana Shadura and Alexander Penev</strong>, “<strong>C++ Modules in ROOT and Beyond</strong>,” August 25, 2020. Accessed August 15, 2021. <code><a href="https://arxiv.org/pdf/2004.06507.pdf">https://arxiv.org/pdf/2004.06507.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Bjarne Stroustrup</strong>, “<strong>Thriving in a Crowded and Changing World: C++ 2006–2020—<a href="ch09.xhtml#ch09lev2sec1">Section 9.3.1</a> Modules</strong>,” June 12, 2020. Accessed August 14 2021. <code><a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Rainer Grimm</strong>, “<strong>C++20: Further Open Questions to Modules</strong>,” June 8, 2020. Accessed June 8, 2021. <code><a href="https://www.modernescpp.com/index.php/c-20-open-questions-to-modules">https://www.modernescpp.com/index.php/c-20-open-questions-to-modules</a></code>.</p>&#13;
<p class="bull">• <strong>Rainer Grimm</strong>, “<strong>C++20: Structure Modules</strong>,” June 1, 2020. Accessed August 5, 2021. <code><a href="https://www.modernescpp.com/index.php/c-20-divide-modules">https://www.modernescpp.com/index.php/c-20-divide-modules</a></code>.</p>&#13;
<p class="bull">• <strong>Rainer Grimm</strong>, “<strong>C++20: Module Interface Unit and Module Implementation Unit</strong>,” May 25, 2020. Accessed August 5, 2021. <code><a href="https://www.modernescpp.com/index.php/c-20-module-interface-unit-and-module-implementation-unit">https://www.modernescpp.com/index.php/c-20-module-interface-unit-and-module-implementation-unit</a></code>.</p>&#13;
<p class="bull">• <strong>Rainer Grimm</strong>, “<strong>C++20: A Simple math Module</strong>,” May 17, 2020. Accessed August 5, 2021. <code><a href="https://www.modernescpp.com/index.php/cpp20-a-first-module">https://www.modernescpp.com/index.php/cpp20-a-first-module</a></code>.</p>&#13;
<p class="bull">• <strong>Corentin Jabot</strong>, “<strong>What do we want from a modularized Standard Library?</strong>” May 16, 2020. Accessed August 12, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2172r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2172r0.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Rainer Grimm</strong>, “<strong>C++20: The Advantages of Modules</strong>,” May 10, 2020. Accessed August 5, 2021. <code><a href="https://www.modernescpp.com/index.php/cpp20-modules">https://www.modernescpp.com/index.php/cpp20-modules</a></code>.</p>&#13;
<p class="bull">• <strong>Cameron DaCamara</strong>, “<strong>C++ Modules conformance improvements with MSVC in Visual Studio 2019 16.5</strong>,” January 22, 2020. Accessed August 4, 2021. <code><a href="https://devblogs.microsoft.com/cppblog/c-modules-conformance-improvements-with-msvc-in-visual-studio-2019-16-5/">https://devblogs.microsoft.com/cppblog/c-modules-conformance-improvements-with-msvc-in-visual-studio-2019-16-5/</a></code>.</p>&#13;
<p class="bull">• <strong>Colin Robertson and Nick Schonning</strong>, “<strong>Overview of modules in C++</strong>,” December 13, 2019. Accessed August 13, 2021. <code><a href="https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-160">https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-160</a></code>.</p>&#13;
<p class="bull">• <strong>Arthur O’Dwyer, “Hello World with C++2a modules,”</strong> November 7, 2019. Accessed August 14, 2021. <code><a href="https://quuxplusone.github.io/blog/2019/11/07/modular-hello-world/">https://quuxplusone.github.io/blog/2019/11/07/modular-hello-world/</a></code>.</p>&#13;
<p class="bull">• <strong>Eric Niebler</strong>, “<strong>Understanding C++ Modules: Part 3: Linkage and Fragments</strong>,” October 7, 2019. Accessed August 4, 2021. <code><a href="https://vector-of-bool.github.io/2019/10/07/modules-3.html">https://vector-of-bool.github.io/2019/10/07/modules-3.html</a></code>.</p>&#13;
<p class="bull">• <strong>Rainer Grimm</strong>, “<strong>More Details to Modules</strong>,” May 13, 2019. Accessed August 7, 2021. <code><a href="http://modernescpp.com/index.php/c-20-more-details-to-modules">http://modernescpp.com/index.php/c-20-more-details-to-modules</a></code>.</p>&#13;
<p class="bull">• <strong>Rainer Grimm</strong>, “<strong>Modules</strong>,” May 6, 2019. Accessed August 7, 2021. <code><a href="http://modernescpp.com/index.php/c-20-modules">http://modernescpp.com/index.php/c-20-modules</a></code>.</p>&#13;
<p class="bull">• <strong>Bryce Adelstein Lelbach</strong> and <strong>Ben Craig</strong>, <strong>“</strong>P1687R1: Summary of the Tooling Study Group’s Modules Ecosystem Technical Report Telecons,” August 5, 2019. Accessed August 18, 2021. <code><a href="https://lists.isocpp.org/sg15/att-0113/P1687R1.html">https://lists.isocpp.org/sg15/att-0113/P1687R1.html</a></code>.</p>&#13;
<p class="bull">• <strong>Corentin Jabot</strong>, “<strong>Naming guidelines for modules</strong>,” June 16, 2019. Accessed August 18, 2021. <code><a href="https://isocpp.org/files/papers/P1634R0.html">https://isocpp.org/files/papers/P1634R0.html</a></code>.</p>&#13;
<p class="bull">• <strong>Eric Niebler</strong>, “<strong>Understanding C++ Modules: Part 2: export, import, visible, and reachable</strong>,” March 31, 2019. Accessed August 4, 2021. <code><a href="https://vector-of-bool.github.io/2019/03/31/modules-2.html">https://vector-of-bool.github.io/2019/03/31/modules-2.html</a></code>.</p>&#13;
<p class="bull">• <strong>Eric Niebler</strong>, “<strong>Understanding C++ Modules: Part 1: Hello Modules, and Module Units</strong>,” March 10, 2019. Accessed August 4, 2021. <code><a href="https://vector-of-bool.github.io/2019/03/10/modules-1.html">https://vector-of-bool.github.io/2019/03/10/modules-1.html</a></code>.</p>&#13;
<p class="bull">• <strong>Rene Rivera</strong>, “<strong>Are modules fast? (revision 1)</strong>,” March 6 2019, Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1441r1.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1441r1.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Richard Smith</strong>, “<strong>Merging Modules</strong>,” February 22, 2019. Accessed August 13, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Eric Niebler</strong>, “<strong>C++ Modules Might Be Dead-on-Arrival</strong>,” January 27, 2019. Accessed August 18, 2021. <code><a href="https://vector-of-bool.github.io/2019/01/27/modules-doa.html">https://vector-of-bool.github.io/2019/01/27/modules-doa.html</a></code>.</p>&#13;
<p class="bull">• <strong>Richard Smith and Gabriel Dos Reis</strong>, “<strong>Merging Modules</strong>.” June 22, 2018. Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r0.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Gabriel Dos Reis and Richard Smith</strong>, “<strong>Modules for Standard C++</strong>,” May 7 2018. Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1087r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1087r0.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Richard Smith</strong>, “<strong>Another take on Modules (Revision 1).</strong>” March 6 2018. Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html</a></code>.</p>&#13;
<p class="bull">• <strong>Bjarne Stroustrup</strong>, “<strong>Modules and macros</strong>,” February 11, 2018. Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0955r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0955r0.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Dmitry Guzeev</strong>, “<strong>A Few Words on C++ Modules</strong>,” January 8, 2018. Accessed August 10, 2021. <code><a href="https://medium.com/@dmitrygz/brief-article-on-c-modules-f58287a6c64">https://medium.com/@dmitrygz/brief-article-on-c-modules-f58287a6c64</a></code>.</p>&#13;
<p class="bull">• <strong>Gabriel Dos Reis (Ed.)</strong>, “<strong>Working Draft, Extensions to C++ for Modules</strong>,” January 29, 2018. Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4720.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4720.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Gabriel Dos Reis and Pavel Curtis</strong>, “<strong>Modules, Componentization, and Transition</strong>,” October 5, 2015. Accessed August 6, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Gabriel Dos Reis, Mark Hall and Gor Nishanov</strong>, “<strong>A Module System for C++</strong>,” May 27, 2014. Accessed August 15, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4047.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4047.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>Daveed Vandevoorde</strong>, “<strong>Modules in C++ (Revision 6)</strong>,” January 11, 2012. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf</a></code>.</p>&#13;
<h5 class="h5" id="ch16lev3sec55">Documentation</h5>&#13;
<p class="bull">• “<strong>3.23 C++ Modules</strong>.” Accessed August 10, 2021. <code><a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Modules.html">https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Modules.html</a></code>.</p>&#13;
<p class="bull">• “<strong>C++20 Standard: 10 Modules</strong>.” Accessed August 12, 2021. <code><a href="https://eel.is/c++draft/module">https://eel.is/c++draft/module</a></code>.</p>&#13;
<p class="bull">• “<strong>Modules—Module Partitions</strong>.” Accessed August 13, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/modules">https://en.cppreference.com/w/cpp/language/modules</a></code>.</p>&#13;
<p class="bull">• Wikipedia, “<strong>Bjarne Stroustrup</strong>.” Accessed August 14, 2021. <code><a href="https://en.wikipedia.org/wiki/Bjarne_Stroustrup">https://en.wikipedia.org/wiki/Bjarne_Stroustrup</a></code>.</p>&#13;
<h4 class="h4b" id="sec16_16">Appendix: Modules Glossary</h4>&#13;
<p class="bull">• <strong><code>export</code> a declaration</strong>—Make a declaration available to translation units that <code>import</code> the corresponding module.</p>&#13;
<p class="bull">• <strong><code>export</code> a definition</strong>—Make a definition (such as a template) available to <strong>translation units</strong> that <code>import</code> the corresponding module.</p>&#13;
<p class="bull">• <strong><code>export</code> block</strong>—A braced block of code preceded by <code>export</code>. A module exports all the declarations or definitions in the block. The block does not define a new scope.</p>&#13;
<p class="bull">• <strong><code>export module</code> declaration</strong>—Indicates that a module unit is the primary module interface unit and introduces the module’s name.</p>&#13;
<p class="bull">• <strong>global module</strong>—An unnamed module that contains all identifiers defined in non-module translation units or in global module fragments.</p>&#13;
<p class="bull">• <strong>global module fragment</strong>—In a module unit, th is fragment may contain only preprocessor directives and must appear before the <code>module</code> declaration. All declarations in this fragment are part of the global module and can be used throughout the remainder of the module unit.</p>&#13;
<p class="bull">• <strong>header unit</strong>—A header that is <code>import</code>ed rather than <code>#include</code>d.</p>&#13;
<p class="bull">• <strong>IFC (<code>.ifc</code>) format</strong>—A Microsoft Visual C++ file format for storing the information the compiler generates for a module.</p>&#13;
<p class="bull">• <strong><code>import</code> a header file</strong>—Enables existing headers to be processed as header units, which can reduce compilation times in large projects.</p>&#13;
<p class="bull">• <strong><code>import</code> a module</strong>—Make a module’s <code>export</code>ed declarations available in a translation unit.</p>&#13;
<p class="bull">• <strong><code>import</code> declaration</strong>—A statement used to <code>import</code> a module into a translation unit.</p>&#13;
<p class="bull">• <strong>interface dependency</strong>—If you import a module into an implementation unit, the implementation unit has an dependency on that module’s interface.</p>&#13;
<p class="bull">• <strong>module</strong>—.</p>&#13;
<p class="bull">• <strong><code>module</code> declaration</strong>—Every module unit has a <code>module</code> declaration specifying the module’s name and possibly a partition name.</p>&#13;
<p class="bull">• <strong>module implementation unit</strong>—A module unit in which the <code>module</code> declaration does not begin with the <code>export</code> keyword.</p>&#13;
<p class="bull">• <strong>module interface unit</strong>—A module unit in which the <code>module</code> declaration begins with the <code>export</code> keyword.</p>&#13;
<p class="bull">• <strong>module linkage</strong>—Names that are in a module, but not exported from it are known only in that module.</p>&#13;
<p class="bull">• <strong>module name</strong>—The name specified in a module’s <code>module</code> declaration. All module units in a given module must have the same module name.</p>&#13;
<p class="bull">• <strong>module partition</strong>—A module unit in which the module declaration specifies the module name followed by a colon and a partition name. Module partition names in the same named module must be unique. If a module partition is a module interface partition it must be exported by the module’s primary interface unit.</p>&#13;
<p class="bull">• <strong>module purview</strong>—The set of identifiers within a module unit from the <code>module</code> declaration to the end of the translation unit.</p>&#13;
<p class="bull">• <strong>module unit</strong>—An implementation unit containing a <code>module</code> declaration.</p>&#13;
<p class="bull">• <strong>named module</strong>—All module units with the same module name.</p>&#13;
<p class="bull">• <strong>named module purview</strong>—The purviews of all the module units in the named module.</p>&#13;
<p class="bull">• <strong>namespace</strong>—Defines a scope in which identifiers and variables are placed to help prevent naming conflicts with identifiers in your own programs and libraries.</p>&#13;
<p class="bull">• <strong>partition</strong>—A kind of module unit that defines a portion of a module’s interface or implementation. Partitions are not visible to translation units that import the module.</p>&#13;
<p class="bull">• <strong>precompiled module interface (<code>.pcm</code>)</strong>—A <code>clang++</code> file that contains information about a module’s interface. Used when compiling other translation units that depend on a given module.</p>&#13;
<p class="bull">• <strong>primary module interface unit</strong>—Determines the set of declarations exported by a module for use in other translation units.</p>&#13;
<p class="bull">• <strong><code>:private</code> module fragment</strong>—A section in a primary module interface unit that enables you to define a module’s implementation in the same file as its interface without exposing the implementation to other translation units.</p>&#13;
<p class="bull">• <strong>reachable declaration</strong>—A declaration is reachable if you can use it in your code without referencing it directly. For example, if you <code>import</code> a module into a translation unit and one of the module’s <code>export</code>ed functions returns an object of a non-exported type, that type is reachable in importing translation units.</p>&#13;
<p class="bull">• <strong>tooling for modules</strong>—Developer tools (under development) that will help developers implement and use modules.</p>&#13;
<p class="bull">• <strong>transitive interface dependency</strong>—import and re-export a module interface.</p>&#13;
<p class="bull">• <strong>translation unit</strong>—A preprocessed source-code file that is ready to be compiled.</p>&#13;
<p class="bull">• <strong>visible declaration</strong>—A declaration you can use by name in your code. For example, if you <code>import</code> a module into a translation unit, the module’s exported declarations are visible in that translation unit.</p>&#13;
</div></body>
</html>