<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch03">Chapter 3. Control Statements, Part 1; Intro to C++20 Text Formatting</h2>&#13;
<div class="image"><img src="Images/ch03.jpg" alt="Images" width="657" height="862"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Use the <code>if</code> and <code>if…else</code> selection statements to choose between alternative actions.</p>&#13;
<p class="squ"><span class="red">■</span> Use the <code>while</code> iteration statement to execute statements in a program repeatedly.</p>&#13;
<p class="squ"><span class="red">■</span> Use counter-controlled iteration and sentinel-controlled iteration.</p>&#13;
<p class="squ"><span class="red">■</span> Use nested control statements.</p>&#13;
<p class="squ"><span class="red">■</span> Use the compound assignment operators and the increment and decrement operators.</p>&#13;
<p class="squ"><span class="red">■</span> Learn why fundamental data types are not portable.</p>&#13;
<p class="squ"><span class="red">■</span> Continue learning with our objects natural approach with a case study on creating and manipulating integers as large as you want them to be.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++20’s new text formatting capabilities, which are more concise and more powerful than those in earlier C++ versions.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec1"><span class="violet"><strong>3.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec2"><span class="violet"><strong>3.2</strong></span> Control Structures</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec1">3.2.1 Sequence Structure</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec2">3.2.2 Selection Statements</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec3">3.2.3 Iteration Statements</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec4">3.2.4 Summary of Control Statements</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec3"><span class="violet"><strong>3.3</strong></span> <code>if</code> Single-Selection Statement</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec4"><span class="violet"><strong>3.4</strong></span> <code>if…else</code> Double-Selection Statement</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec1a">3.4.1 Nested <code>if…else</code> Statements</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec5">3.4.2 Blocks</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec6">3.4.3 Conditional Operator (<code>?:</code>)</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec5"><span class="violet"><strong>3.5</strong></span> <code>while</code> Iteration Statement</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec6"><span class="violet"><strong>3.6</strong></span> Counter-Controlled Iteration</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec7">3.6.1 Implementing Counter-Controlled Iteration</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec8">3.6.2 Integer Division and Truncation</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec7"><span class="violet"><strong>3.7</strong></span> Sentinel-Controlled Iteration</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec9">3.7.1 Implementing Sentinel-Controlled Iteration</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec10">3.7.2 Converting Between Fundamental Types Explicitly and Implicitly</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec11">3.7.3 Formatting Floating-Point Numbers</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec8"><span class="violet"><strong>3.8</strong></span> Nested Control Statements</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec12">3.8.1 Problem Statement</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec13">3.8.2 Implementing the Program</a></p>&#13;
<p class="chap-lev2"><a href="ch03.xhtml#ch03lev2sec14">3.8.3 Preventing Narrowing Conversions with C++11 List Initialization</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec9"><span class="violet"><strong>3.9</strong></span> Compound Assignment Operators</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec10"><span class="violet"><strong>3.10</strong></span> Increment and Decrement Operators</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec11"><span class="violet"><strong>3.11</strong></span> Fundamental Types Are Not Portable</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec12"><span class="violet"><strong>3.12</strong></span> Objects Natural Case Study: Arbitrary Sized Integers</a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec13"><span class="violet"><strong>3.13</strong></span> C++20 Feature Mock-Up—Text Formatting with Function <code>format</code></a></p>&#13;
<p class="chap-lev1"><a href="ch03.xhtml#ch03lev1sec14"><span class="violet"><strong>3.14</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev1sec1"><span class="violet">3.1</span> Introduction</h3>&#13;
<p>In this chapter and the next, we present the theory and principles of structured programming. The concepts presented here are crucial in building classes and manipulating objects. We discuss C++’s <code>if</code> statement in additional detail and introduce the <code>if…else</code></p>&#13;
<p>and <code>while</code> statements. We also introduce the compound assignment operators and the increment and decrement operators.</p>&#13;
<p><span class="size">20</span> We discuss why C++’s fundamental types are not portable. We continue our object natural approach with a case study on arbitrary sized integers that support values beyond the ranges of integers supported by computer hardware.</p>&#13;
<p>We begin introducing C++20’s new text-formatting capabilities, which are based on those in Python, Microsoft’s .NET languages (like C# and Visual Basic) and Rust.<sup><a id="rch0fn1" href="ch01.xhtml#ch0fn1">1</a></sup> The C++20 capabilities are more concise and more powerful than those in earlier C++ versions. In <a href="ch14.xhtml#ch14">Chapter 14</a>, you’ll see that these new capabilities are extensible, so you can use them to format objects of custom class types.</p>&#13;
<p class="footnote"><a id="ch0fn1" href="ch01.xhtml#rch0fn1">1</a>. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html</a></code>.</p>&#13;
<h5 class="h5" id="ch03lev3sec1">“Rough-Cut” E-Book for O’Reilly Online Learning Subscribers</h5>&#13;
<p>You are viewing an early-access “rough cut” of <em>C++20 for Programmers</em>. <strong>We prepared this content carefully, but it has not yet been reviewed or copy edited and is subject to change.</strong> As we complete each chapter, we’ll post it here. Please send any corrections, comments, questions and suggestions for improvement to <code><a href="mailto:paul@deitel.com">paul@deitel.com</a></code> and I’ll respond promptly. Check here frequently for updates.</p>&#13;
<h5 class="h5" id="ch03lev3sec2">“Sneak Peek” Videos for O’Reilly Online Learning Subscribers</h5>&#13;
<p>As an O’Reilly Online Learning subscriber, you also have access to the “sneak peek” of our new <em>C++20 Fundamentals LiveLessons</em> videos at:</p>&#13;
<pre class="pre"><a href="https://learning.oreilly.com/videos/c-20-fundamentals-parts/9780136875185">https://learning.oreilly.com/videos/c-20-fundamentals-parts/9780136875185</a></pre>&#13;
<p>Co-author Paul Deitel immediately records each video lesson as we complete each rough-cut e-book chapter. Lessons go live on O’Reilly Online Learning a few days later. Again, check here frequently for updates.</p>&#13;
<h3 class="h3" id="ch03lev1sec2"><span class="violet">3.2</span> Control Structures</h3>&#13;
<p>During the 1960s, it became clear that the indiscriminate use of transfers of control was the root of many problems experienced by software development groups. The blame was pointed at the <code><strong><span class="violet">goto</span></strong></code> <span class="violet"><strong>statement</strong></span> (used in most programming languages of the time), which allows you to specify a transfer of control to one of a wide range of destinations in a program.</p>&#13;
<p>The research of Bohm and Jacopini<sup><a id="rch0fn2" href="ch01.xhtml#ch0fn2">2</a></sup> had demonstrated that programs could be written without any <code>goto</code> statements. The challenge for programmers of the era was to shift their styles to “<code>goto</code>-less programming.” The term <span class="violet"><strong>structured programming</strong></span> became almost synonymous with “<code>goto</code> elimination.” The results were impressive. Software development groups reported shorter development times, more frequent on-time delivery of systems and more frequent within-budget completion of software projects. The key to these successes was that structured programs were clearer, easier to debug and modify, and more likely to be bug-free in the first place.</p>&#13;
<p class="footnote"><a id="ch0fn2" href="ch01.xhtml#rch0fn2">2</a>. C. Bohm and G. Jacopini, “Flow Diagrams, Turing Machines, and Languages with Only Two Formation Rules,” <em>Communications of the ACM</em>, Vol. 9, No. 5, May 1966, pp. 336–371.</p>&#13;
<p>Bohm and Jacopini’s work demonstrated that all programs could be written in terms of only three control structures—the <span class="violet"><strong>sequence structure</strong></span>, the <span class="violet"><strong>selection structure</strong></span> and the <span class="violet"><strong>iteration structure</strong></span>. We’ll discuss how C++ implements each of these.</p>&#13;
<h4 class="h4" id="ch03lev2sec1">3.2.1 Sequence Structure</h4>&#13;
<p>The sequence structure is built into C++. Unless directed otherwise, the computer executes C++ statements one after the other in the order in which they appear in the program—that is, in sequence. The following UML<sup><a id="rch0fn3" href="ch01.xhtml#ch0fn3">3</a></sup> <span class="violet"><strong>activity diagram</strong></span> illustrates a typical sequence structure in which two calculations are performed in order:</p>&#13;
<div class="image"><img src="Images/03unfig01.jpg" alt="Images" width="484" height="233"/></div>&#13;
<p class="footnote"><a id="ch0fn3" href="ch01.xhtml#rch0fn3">3</a>. We use the UML in this chapter and <a href="ch04.xhtml#ch04">Chapter 4</a> to show the flow of control in control statements, then use UML again in <a href="ch10.xhtml#ch10">Chapters 10</a>–<a href="ch13.xhtml#ch13">13</a> when we present custom class development.</p>&#13;
<p>C++ lets you have as many actions as you want in a sequence structure. As you’ll soon see, anywhere you may place a single action, you may place several actions in sequence.</p>&#13;
<p>An activity diagram models the <span class="violet"><strong>workflow</strong></span> (also called the <span class="violet"><strong>activity</strong></span>) of a portion of a software system. Such workflows may include a portion of an algorithm, like the sequence structure in the preceding diagram. Activity diagrams are composed of symbols, such as <span class="violet"><strong>action-state symbols</strong></span> (rectangles with their left and right sides replaced with outward arcs), <span class="violet"><strong>diamonds</strong></span> and <span class="violet"><strong>small circles</strong></span>. These symbols are connected by <span class="violet"><strong>transition</strong></span> <span class="violet"><strong>arrows</strong></span>, which represent the flow of the activity—that is, the order in which the actions should occur.</p>&#13;
<p>The preceding sequence-structure activity diagram contains two <span class="violet"><strong>action states</strong></span>, each containing an <span class="violet"><strong>action expression</strong></span>—for example, “add grade to total” or “add 1 to counter”—that specifies a particular action to perform. The arrows in the activity diagram represent <span class="violet"><strong>transitions</strong></span>, which indicate the order in which the actions represented by the action states occur.</p>&#13;
<p>The <span class="violet"><strong>solid circle</strong></span> at the top of the activity diagram represents the <span class="violet"><strong>initial state</strong></span>—the beginning of the workflow before the program performs the modeled actions. The <span class="violet"><strong>solid circle surrounded by a hollow circle</strong></span> at the bottom of the diagram represents the <span class="violet"><strong>final state</strong></span>—that is, the end of the workflow after the program performs its actions.</p>&#13;
<p>The sequence structure activity diagram also includes rectangles with the upper-right corners folded over. These are UML <span class="violet"><strong>notes</strong></span> (like comments in C++)—explanatory remarks that describe the purpose of symbols in the diagram. A <span class="violet"><strong>dotted line</strong></span> connects each note with the element it describes. We used the UML notes here to illustrate how the diagram relates to the C++ code for each action state. Activity diagrams usually do not show the C++ code.</p>&#13;
<h4 class="h4" id="ch03lev2sec2">3.2.2 Selection Statements</h4>&#13;
<p>C++ has three types of <span class="violet"><strong>selection statements</strong></span>. The <code>if</code> statement performs (selects) an action (or group of actions) if a condition is true, or skips it if the condition is false. The <code>if…else</code> statement performs an action (or group of actions) if a condition is true and performs a different action (or group of actions) if the condition is false. The <code>switch</code> statement (<a href="ch04.xhtml#ch04">Chapter 4</a>) performs one of many different actions (or group of actions), depending on the value of an expression.</p>&#13;
<p>The <code>if</code> statement is called a <span class="violet"><strong>single-selection statement</strong></span> because it selects or ignores a single action (or group of actions). The <code>if…else</code> statement is called a <span class="violet"><strong>double-selection statement</strong></span> because it selects between two different actions (or groups of actions). The <code>switch</code> statement is called a <span class="violet"><strong>multiple-selection statement</strong></span> because it selects among many different actions (or groups of actions).</p>&#13;
<h4 class="h4" id="ch03lev2sec3">3.2.3 Iteration Statements</h4>&#13;
<p>C++ provides four <span class="violet"><strong>iteration statements</strong></span>—also called <span class="violet"><strong>repetition statements</strong></span> or <span class="violet"><strong>looping statements</strong></span>—for performing statements repeatedly while a <span class="violet"><strong>loop-continuation condition</strong></span> remains true. The iteration statements are the <code>while</code>, <code>do</code>…<code>while</code>, <code>for</code> and range-based <code>for</code>. The <code>while</code> and <code>for</code> statements perform the action (or group of actions) in their bodies zero or more times. If the loop-continuation condition is initially false, the action (or group of actions) does not execute. The <code>do</code>…<code>while</code> statement performs the action (or group of actions) in its body one or more times. <a href="ch04.xhtml#ch04">Chapter 4</a> presents the <code>do</code>…<code>while</code> and <code>for</code> statements. <a href="ch06.xhtml#ch06">Chapter 6</a> presents the range-based <code>for</code> statement.</p>&#13;
<h5 class="h5" id="ch03lev3sec3">Keywords</h5>&#13;
<p>Each of the words <code>if</code>, <code>else</code>, <code>switch</code>, <code>while</code>, <code>do</code> and <code>for</code> are C++ keywords. Keywords cannot be used as identifiers, such as variable names, and must contain only lowercase letters. The following table shows the complete list of C++ keywords:</p>&#13;
<div class="image"><img src="Images/f0075-01.jpg" alt="Images" width="933" height="780"/></div>&#13;
<h5 class="h5" id="ch03lev3sec4">Other Special Identifiers</h5>&#13;
<p><span class="size">20</span> The C++20 standard indicates that the following identifiers should not be used in your code because they have special meanings in some contexts or are identifiers that may become keywords in the future:</p>&#13;
<p class="bull">• Non-keyword identifiers with special meaning—<code>final</code>, <code>import</code>, <code>module</code>, <code>override</code>, <code>transaction_safe</code> and <code>transaction_safe_dynamic</code>.</p>&#13;
<p class="bull">• Experimental keywords—<code>atomic_cancel</code>, <code>atomic_commit</code>, <code>atomic_noexcept</code>, <code>reflexpr</code> and <code>synchronized</code>.</p>&#13;
<h4 class="h4" id="ch03lev2sec4">3.2.4 Summary of Control Statements</h4>&#13;
<p>C++ has only three kinds of control structures, which from this point forward, we refer to as control statements—the sequence statement, selection statements (three types) and iteration statements (four types). Every program is formed by combining these statements as appropriate for the algorithm the program implements. We can model each control statement as an activity diagram. Each diagram contains an initial state and a final state that represent a control statement’s entry point and exit point, respectively. <span class="violet"><strong>Single-entry/single-exit control statements</strong></span> make it easy to build programs—we simply connect the exit point of one to the entry point of the next using <span class="violet"><strong>control-statement stacking</strong></span>. There’s only one other way in which you may connect control statements—<span class="violet"><strong>control-statement nesting</strong></span> in which one control statement appears inside another. Thus, algorithms in C++ programs are constructed from only three kinds of control statements, combined in only two ways. This is the essence of simplicity.</p>&#13;
<h3 class="h3" id="ch03lev1sec3"><span class="violet">3.3</span> <code>if</code> Single-Selection Statement</h3>&#13;
<p>We introduced the <code>if</code> single-selection statement briefly in <a href="ch02.xhtml#ch02lev1sec6">Section 2.6</a>. Programs use selection statements to choose among alternative courses of action. For example, suppose that the passing grade on an exam is 60. The C++ statement</p>&#13;
<pre class="pre"><span class="blue">if</span> (studentGrade &gt;= <span class="green">60</span>) {&#13;
   cout &lt;&lt; <span class="green">"Passed"</span>;&#13;
}</pre>&#13;
<p>determines whether the condition <code>studentGrade &gt;= 60</code> is true. If so, <code>"Passed"</code> is printed, and the next statement in order is performed. If the condition is false, the output statement is ignored, and the next statement in order is performed. The indentation of the second line of this selection statement is optional, but recommended for program clarity.</p>&#13;
<h5 class="h5" id="ch03lev3sec5"><code>bool</code> Data Type</h5>&#13;
<p>In <a href="ch02.xhtml#ch02">Chapter 2</a>, you created conditions using the relational or equality operators. Actually, any expression that evaluates to zero or nonzero can be used as a condition. Zero is treated as false, and nonzero is treated as true. C++ also provides the data type <code><strong><span class="violet">bool</span></strong></code> for Boolean variables that can hold only the values <code><strong><span class="violet">true</span></strong></code> and <code><strong><span class="violet">false</span></strong></code>—each of these is a C++ keyword.</p>&#13;
<p>For compatibility with earlier versions of C, which used integers for Boolean values, the <code>bool</code> value <code>true</code> also can be represented by any nonzero value (compilers typically use 1), and the <code>bool</code> value <code>false</code> also can be represented as zero.</p>&#13;
<h5 class="h5" id="ch03lev3sec6">UML Activity Diagram for an <code>if</code> Statement</h5>&#13;
<p>The following diagram illustrates the single-selection <code>if</code> statement.</p>&#13;
<div class="image"><img src="Images/03unfig02.jpg" alt="Images" width="450" height="143"/></div>&#13;
<p>This figure contains the most important symbol in an activity diagram—the diamond, or <span class="violet"><strong>decision symbol</strong></span>, which indicates that a decision is to be made. The workflow continues along a path determined by the symbol’s associated <span class="violet"><strong>guard conditions</strong></span>, which can be true or false. Each transition arrow emerging from a decision symbol has a guard condition (specified in square brackets next to the arrow). If a guard condition is true, the workflow enters the action state to which the transition arrow points. The diagram shows that if the grade is greater than or equal to 60 (i.e., the condition is true), the program prints “Passed,” then transitions to the activity’s final state. If the grade is less than 60 (i.e., the condition is false), the program immediately transitions to the final state without displaying a message. The <code>if</code> statement is a single-entry/single-exit control statement.</p>&#13;
<h3 class="h3" id="ch03lev1sec4"><span class="violet">3.4</span> <code>if…else</code> Double-Selection Statement</h3>&#13;
<p>The <code>if</code> single-selection statement performs an indicated action only when the condition is true. The <code><strong><span class="violet">if</span></strong></code><span class="violet"><strong>…</strong></span><code><strong><span class="violet">else</span></strong></code> <span class="violet"><strong>double-selection statement</strong></span> allows you to specify an action to perform when the condition is true and another action when the condition is false. For example, the C++ statement</p>&#13;
<pre class="pre"><span class="blue">if</span> (grade &gt;= <span class="green">60</span>) {&#13;
   cout &lt;&lt; <span class="green">"Passed"</span>;&#13;
}&#13;
<span class="blue">else {</span>&#13;
   cout &lt;&lt; <span class="green">"Failed"</span>;&#13;
}</pre>&#13;
<p>prints <code>“Passed”</code> if <code>grade &gt;= 60</code>, but prints <code>“Failed”</code> if it’s less than 60. In either case, after printing occurs, the next statement in sequence is performed.</p>&#13;
<p>The body of the <code>else</code> is also indented. Whatever indentation convention you choose should be applied consistently throughout your programs.</p>&#13;
<h5 class="h5" id="ch03lev3sec7">UML Activity Diagram for an <code>if…else</code> Statement</h5>&#13;
<p>The following diagram illustrates the flow of control in the preceding <code>if…else</code> statement:</p>&#13;
<div class="image"><img src="Images/03unfig03.jpg" alt="Images" width="664" height="144"/></div>&#13;
<h4 class="h4" id="ch03lev2sec1a">3.4.1 Nested <code>if…else</code> Statements</h4>&#13;
<p>A program can test multiple cases by placing <code>if…else</code> statements inside other <code>if…else</code> statements to create <span class="violet"><strong>nested</strong></span> <code><strong><span class="violet">if</span></strong></code><span class="violet"><strong>…</strong></span><code><strong><span class="violet">else</span></strong></code> <span class="violet"><strong>statements</strong></span>. For example, the following nested <code>if…else</code> prints <code>"A"</code> for exam grades greater than or equal to 90, <code>"B"</code> for grades 80 to 89, <code>"C"</code> for grades 70 to 79, <code>"D"</code> for grades 60 to 69 and <code>"F"</code> for all other grades. We use shading to highlight the nesting.</p>&#13;
<div class="image"><img src="Images/03unfig04.jpg" alt="Images" width="433" height="493"/></div>&#13;
<p>If variable <code>studentGrade</code> is greater than or equal to 90, the first four conditions in the nested <code>if…else</code> statement will be true, but only the statement in the <code>if</code>-part of the first <code>if…else</code> statement will execute. After that statement executes, the <code>else</code>-part of the “outermost” <code>if…else</code> statement is skipped. The preceding nested <code>if…else</code> statement also can be written in the following form, which is identical except for the spacing and indentation that the compiler ignores:</p>&#13;
<pre class="pre"><span class="blue">if</span> (studentGrade &gt;= <span class="green">90</span>) {&#13;
   cout &lt;&lt; <span class="green">"A"</span>;&#13;
}&#13;
<span class="blue">else if</span> (studentGrade &gt;= <span class="green">80</span>) {&#13;
   cout &lt;&lt; <span class="green">"B"</span>;&#13;
}&#13;
<span class="blue">else if</span> (studentGrade &gt;= <span class="green">70</span>) {&#13;
   cout &lt;&lt; <span class="green">"C"</span>;&#13;
}&#13;
<span class="blue">else if</span> (studentGrade &gt;= <span class="green">60</span>) {&#13;
   cout &lt;&lt; <span class="green">"D"</span>;&#13;
}&#13;
<span class="blue">else</span> {&#13;
   cout &lt;&lt; <span class="green">"F"</span>;&#13;
}</pre>&#13;
<p>This form avoids deep indentation of the code to the right, which can force lines to wrap. Throughout the text, we always enclose control statement bodies in braces (<code>{</code> and <code>}</code>), which avoids a logic error called the “dangling-<code>else</code>” problem.</p>&#13;
<h4 class="h4" id="ch03lev2sec5">3.4.2 Blocks</h4>&#13;
<p>The <code>if</code> statement expects only one statement in its body. To include several statements in its body (or the body of an <code>else</code> for an <code>if…else</code> statement), enclose the statements in braces. It’s good practice always to use the braces. Statements contained in a pair of braces (such as the body of a control statement or function) form a <span class="violet"><strong>block</strong></span>. A block can be placed anywhere in a function that a single statement can be placed.</p>&#13;
<p>The following example includes a block of multiple statements in the <code>else</code> part of an <code>if…else</code> statement:</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0046-01" id="f0046-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">if</span> (grade &gt;= <span class="green">60</span>) {&#13;
   cout &lt;&lt; <span class="green">"Passed"</span>;&#13;
}&#13;
<span class="blue">else</span>&#13;
{&#13;
   cout &lt;&lt; <span class="green">"Failed\n"</span>;&#13;
   cout &lt;&lt; <span class="green">"You must retake this course."</span>;&#13;
}</pre>&#13;
<p>In this case, if <code>grade</code> is less than 60, the program executes both statements in the body of the <code>else</code> and prints</p>&#13;
<pre class="pre">Failed&#13;
You must retake this course.</pre>&#13;
<p>Without the braces surrounding the two statements in the <code>else</code> clause, the statement</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0046-02" id="f0046-02a">Click here to view code image</a></p>&#13;
<pre class="pre">cout &lt;&lt; <span class="green">"You must retake this course."</span>;</pre>&#13;
<p>would be outside the body of the <code>else</code> part of the <code>if…else</code> statement and would execute regardless of whether the grade was less than 60—a logic error.</p>&#13;
<h5 class="h5" id="ch03lev3sec8">Empty Statement</h5>&#13;
<p>Just as a block can be placed anywhere a single statement can be placed, it’s also possible to have an <span class="violet"><strong>empty statement</strong></span>, which is represented by placing a semicolon (<code>;</code>) where a statement typically would be.</p>&#13;
<h4 class="h4" id="ch03lev2sec6">3.4.3 Conditional Operator (<code>?:</code>)</h4>&#13;
<p>C++ provides the <span class="violet"><strong>conditional operator</strong></span> (<code><strong><span class="violet">?:</span></strong></code>) that can be used in place of an <code>if…else</code> statement. This can make your code shorter and clearer. The conditional operator is C++’s only <span class="violet"><strong>ternary operator</strong></span> (i.e., an operator that takes three operands). Together, the operands and the <code>?:</code> symbol form a <span class="violet"><strong>conditional expression.</strong></span> For example, the statement</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0046-03" id="f0046-03a">Click here to view code image</a></p>&#13;
<pre class="pre">cout &lt;&lt; (studentGrade &gt;= <span class="green">60</span> ? <span class="green">"Passed"</span> : <span class="green">"Failed"</span>);</pre>&#13;
<p>prints the value of the conditional expression. The operand to the left of the <code>?</code> is a condition. The second operand (between the <code>?</code> and <code>:</code>) is the value of the conditional expression if the condition is true. The operand to the right of the <code>:</code> is the value of the conditional expression if the condition is false. The conditional expression in this statement evaluates to the string <code>"Passed"</code> if the condition</p>&#13;
<pre class="pre">studentGrade &gt;= <span class="green">60</span></pre>&#13;
<p>is true and to the string <code>"Failed"</code> if it’s false. Thus, this statement with the conditional operator performs essentially the same function as the first <code>if…else</code> statement in <a href="ch03.xhtml#ch03lev1sec4">Section 3.4</a>. The precedence of the conditional operator is low, so the entire conditional expression is normally placed in parentheses.</p>&#13;
<p>The values in a conditional expression also can be actions to execute. For example, the following conditional expression also prints <code>"Passed"</code> or <code>"Failed"</code>:</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0047-01" id="f0047-01a">Click here to view code image</a></p>&#13;
<pre class="pre">grade &gt;= <span class="green">60</span> ? cout &lt;&lt; <span class="green">"Passed"</span> : cout &lt;&lt; <span class="green">"Failed"</span>;</pre>&#13;
<p>The preceding is read, “If <code>grade</code> is greater than or equal to <code>60</code>, then <code>cout &lt;&lt; "Passed"</code>; otherwise, <code>cout &lt;&lt; "Failed"</code>.” This is comparable to an <code>if…else</code> statement. Conditional expressions can appear in some program locations where <code>if…else</code> statements cannot.</p>&#13;
<h3 class="h3" id="ch03lev1sec5"><span class="violet">3.5</span> <code>while</code> Iteration Statement</h3>&#13;
<p>An iteration statement allows you to specify that a program should repeat an action while some condition remains true.</p>&#13;
<p>As an example of C++’s <code><strong><span class="violet">while</span></strong></code> <span class="violet"><strong>iteration statement</strong></span>, consider a program segment that finds the first power of 3 larger than 100. After the following <code>while</code> statement executes, the variable <code>product</code> contains the result:</p>&#13;
<pre class="pre"><span class="blue">int</span> product{<span class="green">3</span>};&#13;
&#13;
<span class="blue">while</span> (product &lt;= <span class="green">100</span>) {&#13;
   product = <span class="green">3</span> * product;&#13;
}</pre>&#13;
<p>Each iteration of the <code>while</code> statement multiplies <code>product</code> by 3, so <code>product</code> takes on the values 9, 27, 81 and 243 successively. When <code>product</code> becomes 243, <code>product &lt;= 100</code> becomes false. This terminates the iteration, so the final value of <code>product</code> is 243. At this point, program execution continues with the next statement after the <code>while</code> statement.</p>&#13;
<h5 class="h5" id="ch03lev3sec9">UML Activity Diagram for a <code>while</code> Statement</h5>&#13;
<p>The UML activity diagram for the preceding <code>while</code> statement introduces the UML’s <span class="violet"><strong>merge symbol</strong></span>:</p>&#13;
<div class="image"><img src="Images/03unfig05.jpg" alt="Images" width="557" height="278"/></div>&#13;
<p>The UML represents both the merge symbol and the decision symbol as diamonds. The merge symbol joins two flows of activity into one. In this diagram, the merge symbol joins the transitions from the initial state and from the action state, so they both flow into the decision that determines whether the loop should begin (or continue) executing.</p>&#13;
<p>You can distinguish the decision and merge symbols by the number of incoming and outgoing transition arrows. A decision symbol has one transition arrow pointing to the diamond and two or more pointing out from it to indicate possible transitions from that point. In addition, each transition arrow pointing out of a decision symbol has a guard condition next to it. A merge symbol has two or more transition arrows pointing to the diamond and only one pointing from the diamond, to indicate multiple activity flows merging to continue the activity. None of the transition arrows associated with a merge symbol has a guard condition.</p>&#13;
<h3 class="h3" id="ch03lev1sec6"><span class="violet">3.6</span> Counter-Controlled Iteration</h3>&#13;
<p>Consider the following problem statement:</p>&#13;
<div class="bq">&#13;
<p><em>A class of ten students took a quiz. The grades (integers in the range 0–100) for this quiz are available to you. Determine the class average on the quiz.</em></p>&#13;
</div>&#13;
<p>The class average is equal to the sum of the grades divided by the number of students. The program must input each grade, keep track of the total of all grades entered, perform the averaging calculation and print the result.</p>&#13;
<p>We use <span class="violet"><strong>counter-controlled iteration</strong></span> to input the grades one at a time. This technique uses a counter to control the number of times a set of statements will execute. In this example, iteration terminates when the counter exceeds 10.</p>&#13;
<h4 class="h4" id="ch03lev2sec7">3.6.1 Implementing Counter-Controlled Iteration</h4>&#13;
<p>In <a href="ch03.xhtml#fig3_1">Fig. 3.1</a>, the <code>main</code> function implements the class-averaging algorithm with counter-controlled iteration. It allows the user to enter 10 grades, then calculates and displays the average.</p>&#13;
<div class="group" id="fig3_1">&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#aa03fig01" id="a03fig01">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">fig03_01.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Solving the class-average problem using counter-controlled iteration.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="lgreen">// initialization phase</span>&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="blue">int</span> total{<span class="green">0</span>}; <span class="lgreen">// initialize sum of grades entered by the user</span>&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="blue">int</span> gradeCounter{<span class="green">1</span>}; <span class="lgreen">// initialize grade # to be entered next</span>&#13;
<strong><span class="cviolet">10</span></strong>&#13;
<strong><span class="cviolet">11</span></strong>     <span class="lgreen">// processing phase uses counter-controlled iteration</span>&#13;
<strong><span class="cviolet">12</span></strong>     <span class="yell"><span class="blue">while</span> (gradeCounter &lt;= <span class="green">10</span>) { <span class="lgreen">// loop 10 times</span></span>&#13;
<strong><span class="cviolet">13</span></strong>        cout &lt;&lt; <span class="green">"Enter grade: "</span>; <span class="lgreen">// prompt</span>&#13;
<strong><span class="cviolet">14</span></strong>        <span class="blue">int</span> grade;&#13;
<strong><span class="cviolet">15</span></strong>        cin &gt;&gt; grade; <span class="lgreen">// input next grade</span>&#13;
<strong><span class="cviolet">16</span></strong>        total = total + grade; <span class="lgreen">// add grade to total</span>&#13;
<strong><span class="cviolet">17</span></strong>        <span class="yell">gradeCounter = gradeCounter + <span class="green">1</span>; <span class="lgreen">// increment counter by 1</span></span>&#13;
<strong><span class="cviolet">18</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>     <span class="lgreen">// termination phase</span>&#13;
<strong><span class="cviolet">21</span></strong>     <span class="yell"><span class="blue">int</span> average{total / <span class="green">10</span>}; <span class="lgreen">// int division yields int result</span></span>&#13;
<strong><span class="cviolet">22</span></strong>&#13;
<strong><span class="cviolet">23</span></strong>     <span class="lgreen">// display total and average of grades</span>&#13;
<strong><span class="cviolet">24</span></strong>     cout &lt;&lt; <span class="green">"\nTotal of all 10 grades is "</span> &lt;&lt; total;&#13;
<strong><span class="cviolet">25</span></strong>     cout &lt;&lt; <span class="green">"\nClass average is "</span> &lt;&lt; average &lt;&lt; endl;&#13;
<strong><span class="cviolet">26</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Enter grade: <strong>67</strong></code>&#13;
<code>Enter grade: <strong>78</strong></code>&#13;
<code>Enter grade: <strong>89</strong></code>&#13;
<code>Enter grade: <strong>67</strong></code>&#13;
<code>Enter grade: <strong>87</strong></code>&#13;
<code>Enter grade: <strong>98</strong></code>&#13;
<code>Enter grade: <strong>93</strong></code>&#13;
<code>Enter grade: <strong>85</strong></code>&#13;
<code>Enter grade: <strong>82</strong></code>&#13;
<code>Enter grade: <strong>100</strong></code>&#13;
&#13;
<code>Total of all 10 grades is 846</code>&#13;
<code>Class average is 84</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 3.1</strong></span> <code>S</code>olving the class-average problem using counter-controlled iteration.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch03lev3sec10">Local Variables in <code>main</code></h5>&#13;
<p>Lines 8, 9, 14 and 21 declare <code>int</code> variables <code>total</code>, <code>gradeCounter</code>, <code>grade</code> and <code>average</code>, respectively. Variable <code>grade</code> stores the user input. A variable declared in a function body is a local variable. It can be used only from the line of its declaration to the closing right brace of the block in which the variable is declared. A local variable’s declaration must appear before the variable is used. Variable <code>grade</code>—declared in the body of the <code>while</code> loop—can be used only in that block.</p>&#13;
<h5 class="h5" id="ch03lev3sec11">Initializing Variables <code>total</code> and <code>gradeCounter</code></h5>&#13;
<p>Lines 8–9 declare and initialize <code>total</code> to <code>0</code> and <code>gradeCounter</code> to <code>1</code>. These initializations occur before the variables are used in calculations.</p>&#13;
<h5 class="h5" id="ch03lev3sec12">Reading 10 Grades from the User</h5>&#13;
<p>The <code>while</code> statement (lines 12–18) continues iterating as long as <code>gradeCounter</code>’s value is less than or equal to 10. Line 13 displays the prompt <code>"Enter grade: "</code>. Line 15 inputs the grade entered by the user and assigns it to variable <code>grade</code>. Then line 16 adds the new <code>grade</code> entered by the user to the <code>total</code> and assigns the result to <code>total</code>, replacing its previous value. Line 17 adds <code>1</code> to <code>gradeCounter</code> to indicate that the program has processed a grade and is ready to input the next grade from the user. Incrementing <code>gradeCounter</code> eventually causes it to exceed 10, which terminates the loop.</p>&#13;
<h5 class="h5" id="ch03lev3sec13">Calculating and Displaying the Class Average</h5>&#13;
<p>When the loop terminates, line 21 performs the averaging calculation in the <code>average</code> variable’s initializer. Line 24 displays the text <code>"Total of all 10 grades is "</code> followed by variable <code>total</code>’s value. Then, line 25 displays the text <code>"Class average is "</code> followed by <code>average</code>’s value. When execution reaches line 26, the program terminates.</p>&#13;
<h4 class="h4" id="ch03lev2sec8">3.6.2 Integer Division and Truncation</h4>&#13;
<p>This example’s averaging calculation produces an integer result. The program’s output indicates that the sum of the grade values in the sample execution is 846, which, when divided by 10, should yield 84.6. Numbers like 84.6 that contain decimal points are <span class="violet"><strong>floating-point numbers</strong></span>. In the class-average program, however, the result of <code>total / 10</code> is the integer 84, because <code>total</code> and <code>10</code> are both integers. Dividing two integers results in <span class="violet"><strong>integer division</strong></span>—any fractional part of the calculation is truncated. In the next section, we’ll see how to obtain a floating-point result from the averaging calculation.</p>&#13;
<p>Assuming that integer division rounds (rather than truncates) can lead to incorrect results. For example, 7 / 4, which yields 1.75 in conventional arithmetic, truncates to 1 in integer arithmetic, rather than rounding to 2.</p>&#13;
<h3 class="h3" id="ch03lev1sec7"><span class="violet">3.7</span> Sentinel-Controlled Iteration</h3>&#13;
<p>Let’s generalize <a href="ch03.xhtml#ch03lev1sec6">Section 3.6</a>’s class-average problem. Consider the following problem:</p>&#13;
<div class="bq">&#13;
<p><em>Develop a class-averaging program that processes grades for an arbitrary number of students each time it’s run.</em></p>&#13;
</div>&#13;
<p>In the previous class-average example, the problem statement specified the number of students, so the number of grades (10) was known in advance. In this example, no indication is given of how many grades the user will enter during the program’s execution. The program must process an <em>arbitrary</em> number of grades.</p>&#13;
<p>One way to solve this problem is to use a special value called a <span class="violet"><strong>sentinel value</strong></span> (also called a <span class="violet"><strong>signal value</strong></span>, a <span class="violet"><strong>dummy value</strong></span> or a <span class="violet"><strong>flag value</strong></span>) to indicate “end of data entry.” The user enters grades until all legitimate grades have been entered. The user then types the sentinel value to indicate that no more grades will be entered.</p>&#13;
<p>You must choose a sentinel value that cannot be confused with an acceptable input value. Grades on a quiz are nonnegative integers, so –1 is an acceptable sentinel value for this problem. Thus, a run of the class-averaging program might process a stream of inputs such as 95, 96, 75, 74, 89 and –1. The program would then compute and print the class average for the grades 95, 96, 75, 74 and 89; since –1 is the sentinel value, it should not enter into the averaging calculation.</p>&#13;
<p>It’s possible that the user could enter –1 before entering grades, in which case the number of grades will be zero. We must test for this case before calculating the class average. According to the C++ standard, the result of division by zero in floating-point arithmetic is undefined. When performing division (<code>/</code>) or remainder (<code>%</code>) calculations in which the right operand could be zero, test for this and handle it (e.g., display an error message) rather than allowing the calculation to proceed.</p>&#13;
<h4 class="h4" id="ch03lev2sec9">3.7.1 Implementing Sentinel-Controlled Iteration</h4>&#13;
<p>In <a href="ch03.xhtml#fig3_2">Fig. 3.2</a>, the <code>main</code> function implements sentinel-controlled iteration. Although each grade entered by the user is an integer, the averaging calculation is likely to produce a floating-point number. The type <code>int</code> cannot represent such a number. C++ provides data types <code><strong><span class="violet">float</span></strong></code> and <code><strong><span class="violet">double</span></strong></code> to store floating-point numbers in memory. The primary difference between these types is that <code>double</code> variables typically store numbers with larger magnitude and finer detail—that is, more digits to the right of the decimal point, which is also known as the number’s <span class="violet"><strong>precision</strong></span>. C++ also supports type <code><strong><span class="violet">long double</span></strong></code> for floating-point values with larger magnitude and more precision than <code>double</code>. We say more about floating-point types in <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>&#13;
<div class="group" id="fig3_2">&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#aa03fig02" id="a03fig02">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig03_02.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Solving the class-average problem using sentinel-controlled iteration.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iomanip&gt; <span class="lgreen">// parameterized stream manipulators</span>&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 6</span></strong>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="lgreen">// initialization phase</span>&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="blue">int</span> total{<span class="green">0</span>}; <span class="lgreen">// initialize sum of grades</span>&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">int</span> gradeCounter{<span class="green">0</span>}; <span class="lgreen">// initialize # of grades entered so far</span>&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>     <span class="lgreen">// processing phase</span>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="lgreen">// prompt for input and read grade from user</span>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="yell">cout &lt;&lt; <span class="green">"Enter grade or -1 to quit: "</span>;</span>&#13;
<strong><span class="cviolet">15</span></strong>     <span class="yell"><span class="blue">int</span> grade;                            </span>&#13;
<strong><span class="cviolet">16</span></strong>     <span class="yell"><code>cin &gt;&gt; grade;</code>                         </span>&#13;
<strong><span class="cviolet">17</span></strong>&#13;
<strong><span class="cviolet">18</span></strong>     <span class="lgreen">// loop until sentinel value is read from user</span>&#13;
<strong><span class="cviolet">19</span></strong>     <span class="blue">while</span> (grade != <span class="green">-1</span>) {&#13;
<strong><span class="cviolet">20</span></strong>        total = total + grade; <span class="lgreen">// add grade to total</span>&#13;
<strong><span class="cviolet">21</span></strong>        gradeCounter = gradeCounter + 1; <span class="lgreen">// increment counter</span>&#13;
<strong><span class="cviolet">22</span></strong>&#13;
<strong><span class="cviolet">23</span></strong>        <span class="lgreen">// prompt for input and read next grade from user</span>&#13;
<strong><span class="cviolet">24</span></strong>        <span class="yell">cout &lt;&lt; <span class="green">"Enter grade or -1 to quit: "</span>;</span>&#13;
<strong><span class="cviolet">25</span></strong>        <span class="yell"><code>cin &gt;&gt; grade;</code>                         </span>&#13;
<strong><span class="cviolet">26</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">27</span></strong>&#13;
<strong><span class="cviolet">28</span></strong>     <span class="lgreen">// termination phase</span>&#13;
<strong><span class="cviolet">29</span></strong>     <span class="lgreen">// if user entered at least one grade...</span>&#13;
<strong><span class="cviolet">30</span></strong>     <span class="blue">if</span> (gradeCounter != <span class="green">0</span>) {&#13;
<strong><span class="cviolet">31</span></strong>        <span class="lgreen">// use number with decimal point to calculate average of grades</span>&#13;
<strong><span class="cviolet">32</span></strong>        <span class="yell"><span class="blue">double</span> average{<span class="blue">static_cast</span>&lt;<span class="blue">double</span>&gt;(total) / gradeCounter};</span>&#13;
<strong><span class="cviolet">33</span></strong>&#13;
<strong><span class="cviolet">34</span></strong>        <span class="lgreen">// display total and average (with two digits of precision)</span>&#13;
<strong><span class="cviolet">35</span></strong>        cout &lt;&lt; <span class="green">"\nTotal of the "</span> &lt;&lt; gradeCounter&#13;
<strong><span class="cviolet">36</span></strong>           &lt;&lt; <span class="green">" grades entered is "</span> &lt;&lt; total;&#13;
<strong><span class="cviolet">37</span></strong>        <span class="yell">cout &lt;&lt; setprecision(<span class="green">2</span>) &lt;&lt; fixed;</span>&#13;
<strong><span class="cviolet">38</span></strong>        cout &lt;&lt; <span class="green">"\nClass average is "</span> &lt;&lt; average &lt;&lt; endl;&#13;
<strong><span class="cviolet">39</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">40</span></strong>     <span class="blue">else</span> { <span class="lgreen">// no grades were entered, so output appropriate message</span>&#13;
<strong><span class="cviolet">41</span></strong>        cout &lt;&lt; <span class="green">"No grades were entered"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">42</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">43</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Enter grade or -1 to quit: <strong>97</strong></code>&#13;
<code>Enter grade or -1 to quit: <strong>88</strong></code>&#13;
<code>Enter grade or -1 to quit: <strong>72</strong></code>&#13;
<code>Enter grade or -1 to quit: <strong>-1</strong></code>&#13;
&#13;
<code>Total of the 3 grades entered is 257</code>&#13;
<code>Class average is 85.67</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 3.2</strong></span> Solving the class-average problem using sentinel-controlled iteration.</p>&#13;
</div>&#13;
<p>Recall that integer division produces an integer result. This program introduces a <span class="violet"><strong>cast operator</strong></span> to force the averaging calculation to produce a floating-point numeric result. This program also stacks control statements on top of one another (in sequence)—the <code>while</code> statement (lines 19–26) is followed in sequence by an <code>if…else</code> statement (lines 30–42). Much of the code in this program is identical to that in <a href="ch03.xhtml#fig3_1">Fig. 3.1</a>, so we concentrate on only the new concepts.</p>&#13;
<h5 class="h5" id="ch03lev3sec14">Program Logic for Sentinel-Controlled Iteration vs. Counter-Controlled Iteration</h5>&#13;
<p>Line 10 initializes <code>gradeCounter</code> to <code>0</code> because no grades have been entered yet. Remember that this program uses sentinel-controlled iteration to input the grades. The program increments <code>gradeCounter</code> only when the user enters a valid grade. Line 32 declares <code>double</code> variable <code>average</code>, which stores the calculated class average as a floating-point number.</p>&#13;
<p>Compare the program logic for sentinel-controlled iteration in this program with that for counter-controlled iteration in <a href="ch03.xhtml#fig3_1">Fig. 3.1</a>. In counter-controlled iteration, each iteration of the <code>while</code> statement (lines 12–18 of <a href="ch03.xhtml#fig3_1">Fig. 3.1</a>) reads a value from the user, for the specified number of iterations. In sentinel-controlled iteration, the program prompts for and reads the first value (lines 14 and 16 of <a href="ch03.xhtml#fig3_2">Fig. 3.2</a>) before reaching the <code>while</code>. This value determines whether the flow of control should enter the <code>while</code>’s body. If the condition is false, the user entered the sentinel value, so no grades were entered and the body does not execute. If the condition is true, the body begins execution, and the loop adds the <code>grade</code> value to the <code>total</code> and increments the <code>gradeCounter</code>. Then lines 24–25 in the loop body input the next value from the user. Next, program control reaches the closing right brace of the loop at line 26, so execution continues with the test of the <code>while</code>’s condition (line 19). The condition uses the most recent <code>grade</code> entered by the user to determine whether the loop body should execute again.</p>&#13;
<p>The next <code>grade</code> is always input from the user immediately before the <code>while</code> condition is tested. This allows the program to determine whether the value just input is the sentinel value before the program processes that value (i.e., adds it to the <code>total</code>). If the sentinel value is input, the loop terminates, and the program does not add –1 to the <code>total</code>.</p>&#13;
<p>After the loop terminates, the <code>if…else</code> statement at lines 30–42 executes. The condition at line 30 determines whether any grades were input. If none were input, the <code>if…else</code> statement’s <code>else</code> part executes and displays the message <code>"No grades were entered"</code>. After the <code>if…else</code> executes, the program terminates.</p>&#13;
<h4 class="h4" id="ch03lev2sec10">3.7.2 Converting Between Fundamental Types Explicitly and Implicitly</h4>&#13;
<p>If at least one grade was entered, line 32 of <a href="ch03.xhtml#fig3_2">Fig. 3.2</a></p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0053-01" id="f0053-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">double</span> average{<span class="blue">static_cast</span>&lt;<span class="blue">double</span>&gt;(total) / gradeCounter};</pre>&#13;
<p>calculates the average. Recall from <a href="ch03.xhtml#fig3_1">Fig. 3.1</a> that integer division yields an integer result. Even though variable <code>average</code> is declared as a <code>double</code>, if we had written line 32 as</p>&#13;
<pre class="pre"><span class="blue">double</span> average{total / gradeCounter};</pre>&#13;
<p>it would lose the fractional part of the quotient before the result of the division was used to initialize <code>average</code>.</p>&#13;
<h5 class="h5" id="ch03lev3sec15"><code>static_cast</code> Operator</h5>&#13;
<p>To perform a floating-point calculation with integers in this example, you first create temporary floating-point values using the <code><strong><span class="violet">static_cast</span></strong></code> <span class="violet"><strong>operator</strong></span>. Line 32 converts a temporary copy of its operand in parentheses (<code>total</code>) to the type in angle brackets (<code>double</code>). The value stored in the original <code>int</code> variable <code>total</code> is still an integer. Using a cast operator in this manner is called <span class="violet"><strong>explicit conversion</strong></span>. <code>static_cast</code> is one of several cast operators we’ll discuss.</p>&#13;
<h5 class="h5" id="ch03lev3sec16">Promotions</h5>&#13;
<p>After the cast operation, the calculation consists of the temporary <code>double</code> copy of <code>total</code> divided by the integer <code>gradeCounter</code>. For arithmetic, the compiler knows how to evaluate only expressions in which all the operand types are identical. To ensure this, the compiler performs an operation called <span class="violet"><strong>promotion</strong></span> (also called <span class="violet"><strong>implicit conversion</strong></span>) on selected operands. In an expression containing values of data types <code>int</code> and <code>double</code>, C++ <span class="violet"><strong>promotes</strong></span> <code>int</code> operands to <code>double</code> values. So in line 32, C++ promotes a temporary copy of <code>grade-Counter</code>’s value to type <code>double</code>, then performs the division. Finally, <code>average</code> is initialized with the floating-point result. <a href="ch05.xhtml#ch05lev1sec5">Section 5.5</a> discusses the allowed fundamental-type promotions.</p>&#13;
<h5 class="h5" id="ch03lev3sec17">Cast Operators for Any Type</h5>&#13;
<p>Cast operators are available for use with every fundamental type and for other types, as you’ll see beginning in <a href="ch09.xhtml#ch09">Chapter 9</a>. Simply specify the type in the angle brackets (<code>&lt;</code> and <code>&gt;</code>) that follow the <code>static_cast</code> keyword. It’s a <span class="violet"><strong>unary operator</strong></span>—that is, it has only one operand. Other unary operators include the unary plus (<code>+</code>) and minus (<code>-</code>) operators for expressions such as <code>-7</code> or <code>+5</code>. Cast operators have the second highest precedence.</p>&#13;
<h4 class="h4" id="ch03lev2sec11">3.7.3 Formatting Floating-Point Numbers</h4>&#13;
<p>The formatting capabilities in <a href="ch03.xhtml#fig3_2">Fig. 3.2</a> are introduced here briefly and explained in depth in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>&#13;
<h5 class="h5" id="ch03lev3sec18"><code>setprecision</code> Parameterized Stream Manipulator</h5>&#13;
<p>Line 37’s call to <code><strong><span class="violet">setprecision</span></strong></code>—<code>setprecision(2)</code>—indicates that floating-point values should be output with <em>two</em> digits of <span class="violet"><strong>precision</strong></span> to the right of the decimal point (e.g., 92.37). <code>setprecision</code> is a <span class="violet"><strong>parameterized stream manipulator</strong></span> because it requires an argument (in this case, <code>2</code>) to perform its task. Programs that use parameterized stream manipulators must include the header <code><strong><span class="violet">&lt;iomanip&gt;</span></strong></code>. The manipulator <code>endl</code> (lines 38 and 41) from <code>&lt;iostream&gt;</code> is a <span class="violet"><strong>nonparameterized stream manipulator</strong></span> because it does not require an argument.</p>&#13;
<h5 class="h5" id="ch03lev3sec19"><code>fixed</code> Nonparameterized Stream Manipulator</h5>&#13;
<p>The stream manipulator <code><strong><span class="violet">fixed</span></strong></code> (line 37) indicates that floating-point values should be output in <span class="violet"><strong>fixed-point format</strong></span>. This is as opposed to <span class="violet"><strong>scientific notation</strong></span><sup><a id="rch0fn4" href="ch02.xhtml#ch0fn4">4</a></sup>, which displays a number between the values of 1.0 and 10.0, multiplied by a power of 10. So, in scientific notation, the value 3,100.0 is displayed as <code>3.1e+03</code> (that is, 3.1 × 10<sup>3</sup>). This format is useful for displaying very large or very small values.</p>&#13;
<p class="footnote"><a id="ch0fn4" href="ch02.xhtml#rch0fn4">4</a>. Formatting using scientific notation is discussed further in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>&#13;
<p>Fixed-point formatting forces a floating-point number to display without scientific notation. Fixed-point formatting also forces the decimal point and trailing zeros to print, even if the value is a whole-number amount, such as 88.00. Without the fixed-point formatting option, 88.00 prints as 88 without the trailing zeros and decimal point.</p>&#13;
<p>The stream manipulators <code>setprecision</code> and <code>fixed</code> perform <span class="violet"><strong>sticky settings</strong></span>. Once they’re specified, all floating-point values formatted in your program will use those settings until you change them. <a href="ch15.xhtml#ch15">Chapter 15</a> shows how to capture the stream format settings before applying sticky settings, so you can restore the original format settings later.</p>&#13;
<h5 class="h5" id="ch03lev3sec20">Rounding Floating-Point Numbers</h5>&#13;
<p>When the stream manipulators <code>fixed</code> and <code>setprecision</code> are used, the printed value is <span class="violet"><strong>rounded</strong></span> to the number of decimal positions specified by the current precision. The value in memory remains unaltered. For a precision of <code>2</code>, the values 87.946 and 67.543 are rounded to 87.95 and 67.54, respectively.<sup><a id="rch0fn5" href="ch03.xhtml#ch0fn5">5</a></sup></p>&#13;
<p class="footnote"><a id="ch0fn5" href="ch03.xhtml#rch0fn5">5</a>. In <a href="ch03.xhtml#fig3_2">Fig. 3.2</a>, if you do not specify <code>setprecision</code> and <code>fixed</code>, C++ uses four digits of precision by default. If you specify only <code>setprecision</code>, C++ uses six digits of precision.</p>&#13;
<p>Together, lines 37 and 38 of <a href="ch03.xhtml#fig3_2">Fig. 3.2</a> output the class average rounded to the nearest hundredth and with exactly two digits to the right of the decimal point. The three grades entered during the execution of the program in <a href="ch03.xhtml#fig3_2">Fig. 3.2</a> total 257, which yields the average 85.666… and displays the rounded value 85.67.</p>&#13;
<h3 class="h3" id="ch03lev1sec8"><span class="violet">3.8</span> Nested Control Statements</h3>&#13;
<p>We’ve seen that control statements can be stacked on top of one another (in sequence). In this case study, we examine the only other structured way control statements can be connected—namely, by <span class="violet"><strong>nesting</strong></span> one control statement within another.</p>&#13;
<h4 class="h4" id="ch03lev2sec12">3.8.1 Problem Statement</h4>&#13;
<p>Consider the following problem statement:</p>&#13;
<div class="bq">&#13;
<p><em>A college offers a course that prepares students for the state licensing exam for realestate brokers. Last year, 10 of the students who completed this course took the exam. The college wants to know how well its students did on the exam. You’ve been asked to write a program to summarize the results. You’ve been given a list of these 10 students. Next to each name is written a 1 if the student passed the exam or a 2 if the student failed.</em></p>&#13;
<p><em>Your program should analyze the results of the exam as follows:</em></p>&#13;
<p class="olist"><em>1. Input each test result (i.e., a 1 or a 2). Display the message “Enter result” on the screen each time the program requests another test result.</em></p>&#13;
<p class="olist"><em>2. Count the number of test results of each type.</em></p>&#13;
<p class="olist"><em>3. Display a summary of the test results, indicating the number of students who passed and the number who failed.</em></p>&#13;
<p class="olist"><em>4. If more than eight students passed the exam, print “Bonus to instructor!”</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03lev2sec13">3.8.2 Implementing the Program</h4>&#13;
<p><a href="ch03.xhtml#fig3_3">Figure 3.3</a> implements the program with counter-controlled iteration and shows two sample executions. Lines 8–10 and 16 of <code>main</code> declare the variables that are used to process the examination results.</p>&#13;
<div class="group" id="fig3_3">&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#aa03fig03" id="a03fig03">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig03_03.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Analysis of examination results using nested control statements.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="lgreen">// initializing variables in declarations</span>&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="blue">int</span> passes{<span class="green">0</span>};&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="blue">int</span> failures{<span class="green">0</span>};&#13;
<strong><span class="cviolet">10</span></strong>     <span class="yell"><span class="blue">int</span> studentCounter{<span class="green">1</span>};</span>&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>     <span class="lgreen">// process 10 students using counter-controlled loop</span>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="blue">while</span> (studentCounter &lt;= <span class="green">10</span>) {&#13;
<strong><span class="cviolet">14</span></strong>        <span class="lgreen">// prompt user for input and obtain value from user</span>&#13;
<strong><span class="cviolet">15</span></strong>        cout &lt;&lt; <span class="green">"Enter result (1 = pass, 2 = fail): "</span>;&#13;
<strong><span class="cviolet">16</span></strong>        <span class="blue">int</span> result;&#13;
<strong><span class="cviolet">17</span></strong>        <code>cin &gt;&gt; result;</code>&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>        <span class="lgreen">// if...else is nested in the while statement</span>&#13;
<strong><span class="cviolet">20</span></strong>        <span class="yell"><span class="blue">if</span> (result == <span class="green">1</span>) {         </span>&#13;
<strong><span class="cviolet">21</span></strong>        <span class="yell">   passes = passes + <span class="green">1</span>;    </span>&#13;
<strong><span class="cviolet">22</span></strong>        <span class="yell"><code>}</code>                          </span>&#13;
<strong><span class="cviolet">23</span></strong>        <span class="yell"><span class="blue">else</span> {                     </span>&#13;
<strong><span class="cviolet">24</span></strong>        <span class="yell">   failures = failures + <span class="green">1</span>;</span>&#13;
<strong><span class="cviolet">25</span></strong>        <span class="yell"><code>}</code>                          </span>&#13;
<strong><span class="cviolet">26</span></strong>&#13;
<strong><span class="cviolet">27</span></strong>        <span class="lgreen">// increment studentCounter so loop eventually terminates</span>&#13;
<strong><span class="cviolet">28</span></strong>        studentCounter = studentCounter + <span class="green">1</span>;&#13;
<strong><span class="cviolet">29</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">30</span></strong>&#13;
<strong><span class="cviolet">31</span></strong>     <span class="lgreen">// termination phase; prepare and display results</span>&#13;
<strong><span class="cviolet">32</span></strong>     cout &lt;&lt; <span class="green">"Passed: "</span> &lt;&lt; passes &lt;&lt; <span class="green">"\nFailed: "</span> &lt;&lt; failures &lt;&lt; endl;&#13;
<strong><span class="cviolet">33</span></strong>&#13;
<strong><span class="cviolet">34</span></strong>     <span class="lgreen">// determine whether more than 8 students passed</span>&#13;
<strong><span class="cviolet">35</span></strong>     <span class="blue">if</span> (passes &gt; <span class="green">8</span>) {&#13;
<strong><span class="cviolet">36</span></strong>        cout &lt;&lt; <span class="green">"Bonus to instructor!"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">37</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">38</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>2</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Passed: 9&#13;
Failed: 1&#13;
Bonus to instructor!</code></pre>&#13;
<pre class="pre1"><code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>2</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>2</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>2</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>2</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Enter result (1 = pass, 2 = fail): <strong>1</strong></code>&#13;
<code>Passed: 6&#13;
Failed: 4</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 3.3</strong></span> Analysis of examination results using nested control statements.</p>&#13;
</div>&#13;
<p>The <code>while</code> statement (lines 13–29) loops 10 times. During each iteration, the loop inputs and processes one exam result. Notice that the <code>if…else</code> statement (lines 20–25) for processing each result is nested in the <code>while</code> statement. If the <code>result</code> is <code>1</code>, the <code>if…else</code> statement increments <code>passes</code>; otherwise, it assumes the <code>result</code> is <code>2</code><sup><a id="rch0fn6" href="ch03.xhtml#ch0fn6">6</a></sup> and increments <code>failures</code>. Line 28 increments <code>studentCounter</code> before the loop condition is tested again at line 13. After 10 values have been input, the loop terminates and line 32 displays the number of <code>passes</code> and <code>failures</code>. The <code>if</code> statement at lines 35–37 determines whether more than eight students passed the exam and, if so, outputs the message <code>"Bonus to instructor!"</code></p>&#13;
<p class="footnote"><a id="ch0fn6" href="ch03.xhtml#rch0fn6">6</a>. This could be a bad assumption if invalid data is entered. We’ll discuss data validation techniques later.</p>&#13;
<p><a href="ch03.xhtml#fig3_3">Figure 3.3</a> shows the input and output from two sample executions. During the first, the condition at line 35 is true—more than eight students passed the exam, so the program outputs a message to bonus the instructor.</p>&#13;
<h4 class="h4" id="ch03lev2sec14"><span class="size">11</span> 3.8.3 Preventing Narrowing Conversions with C++11 List Initialization</h4>&#13;
<p>Consider the C++11 list initialization in line 10 of <a href="ch03.xhtml#fig3_3">Fig. 3.3</a>:</p>&#13;
<pre class="pre"><span class="blue">int</span> studentCounter{<span class="green">1</span>};</pre>&#13;
<p>Prior to C++11, you would have written this as</p>&#13;
<pre class="pre"><span class="blue">int</span> studentCounter = <span class="green">1</span>;</pre>&#13;
<p>For fundamental-type variables, list-initialization syntax prevents <span class="violet"><strong>narrowing conversions</strong></span> that could result in <em>data loss</em>. For example, the declaration</p>&#13;
<pre class="pre"><span class="blue">int</span> x = <span class="green">12.7</span>;</pre>&#13;
<p>attempts to assign the <code>double</code> value <code>12.7</code> to the <code>int</code> variable <code>x</code>. Here, C++ converts the <code>double</code> value to an <code>int</code> by truncating the floating-point part (<code>.7</code>). This is a narrowing conversion that loses data. So, this declaration assigns <code>12</code> to <code>x</code>. Compilers typically issue a warning for this, but still compile the code.</p>&#13;
<p>However, using list initialization, as in</p>&#13;
<pre class="pre"><span class="blue">int</span> x{<span class="green">12.7</span>};</pre>&#13;
<p>yields a <em>compilation error</em>, helping you avoid a potentially subtle logic error. If you specify a whole-number <code>double</code> value, like <code>12.0</code>, you’ll still get a compilation error. The initial-izer’s type (<code>double</code>), not it’s value (<code>12.0</code>), determines whether a compilation error occurs.</p>&#13;
<p>The C++ standard document does not specify the wording of error messages. For the preceding declaration, Apple’s Xcode compiler gives the error</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0057-01" id="f0057-01a">Click here to view code image</a></p>&#13;
<pre class="pre">Type 'double' cannot be narrowed to 'int' in initializer list</pre>&#13;
<p>Visual Studio gives the error</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0057-02" id="f0057-02a">Click here to view code image</a></p>&#13;
<pre class="pre">conversion from 'double' to 'int' requires a narrowing conversion</pre>&#13;
<p>and GNU C++ gives the error</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0057-03" id="f0057-03a">Click here to view code image</a></p>&#13;
<pre class="pre">type 'double' cannot be narrowed to 'int' in initializer list&#13;
[-Wc++11-narrowing]</pre>&#13;
<p>We’ll discuss additional list-initializer features in later chapters.</p>&#13;
<h5 class="h5" id="ch03lev3sec21">A Look Back at <a href="ch03.xhtml#fig3_1">Fig. 3.1</a></h5>&#13;
<p>You might think that the following statement from <a href="ch03.xhtml#fig3_1">Fig. 3.1</a></p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0057-04" id="f0057-04a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> average{total / <span class="green">10</span>}; <span class="lgreen">// int division yields int result</span></pre>&#13;
<p>contains a narrowing conversion, but <code>total</code> and <code>10</code> are both <code>int</code> values, so the initializer value is an <code>int</code>. If in the preceding statement <code>total</code> were a <code>double</code> variable or if we used the <code>double</code> literal value <code>10.0</code> for the denominator, then the initializer value would have type <code>double</code> and the compiler would issue an error message for a narrowing conversion.</p>&#13;
<h3 class="h3" id="ch03lev1sec9"><span class="violet">3.9</span> Compound Assignment Operators</h3>&#13;
<p>You can abbreviate the statement</p>&#13;
<pre class="pre">c = c + <span class="green">3</span>;</pre>&#13;
<p>with the <span class="violet"><strong>addition compound assignment operator</strong></span>, <code><strong><span class="violet">+=</span></strong></code>, as</p>&#13;
<pre class="pre">c += <span class="green">3</span>;</pre>&#13;
<p>The <code>+=</code> operator adds the value of the expression on its right to the value of the variable on its left and stores the result in the variable on the left. Thus, the assignment expression <code>c += 3</code> adds <code>3</code> to <code>c</code>. The following table shows all the arithmetic compound assignment operators, sample expressions and explanations of what the operators do:</p>&#13;
<div class="image"><img src="Images/f0091-01.jpg" alt="Images" width="572" height="271"/></div>&#13;
<p>Later, we’ll discuss other types of compound assignment operators.</p>&#13;
<h3 class="h3" id="ch03lev1sec10"><span class="violet">3.10</span> Increment and Decrement Operators</h3>&#13;
<p>The following table summarizes C++’s two unary operators for adding 1 to or subtracting 1 from the value of a numeric variable—these are the unary <span class="violet"><strong>increment operator</strong></span>, <code><strong><span class="violet">++</span></strong></code>, and the unary <span class="violet"><strong>decrement operator</strong></span>, <code><strong><span class="violet">--</span></strong></code>:</p>&#13;
<div class="image"><img src="Images/f0091-02.jpg" alt="Images" width="877" height="336"/></div>&#13;
<p>An increment or decrement operator that’s prefixed to (placed before) a variable is referred to as the <span class="violet"><strong>prefix increment</strong></span> or <span class="violet"><strong>prefix decrement operator</strong></span>, respectively. An increment or decrement operator that’s postfixed to (placed after) a variable is referred to as the <span class="violet"><strong>postfix increment</strong></span> or <span class="violet"><strong>postfix decrement operator</strong></span>, respectively.</p>&#13;
<p>Using the prefix increment (or decrement) operator to add 1 to (or subtract 1 from) a variable <span class="violet"><strong>preincrements</strong></span> (or <span class="violet"><strong>predecrements</strong></span>) the variable. The variable is incremented (or decremented) by 1 then its new value is used in the expression in which it appears.</p>&#13;
<p>Using the postfix increment (or decrement) operator to add 1 to (or subtract 1 from) a variable <span class="violet"><strong>postincrements</strong></span> (or <span class="violet"><strong>postdecrements</strong></span>) the variable. The variable’s current value is used in the expression in which it appears then its value is incremented (or decremented) by 1. Unlike binary operators, the unary increment and decrement operators should be placed next to their operands, with no intervening spaces.</p>&#13;
<h5 class="h5" id="ch03lev3sec22">Prefix Increment vs. Postfix Increment</h5>&#13;
<p><a href="ch03.xhtml#fig3_4">Figure 3.4</a> demonstrates the difference between the prefix increment and postfix increment versions of the <code>++</code> increment operator. The decrement operator (<code>--</code>) works similarly.</p>&#13;
<div class="group" id="fig3_4">&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#aa03fig04" id="a03fig04">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig03_04.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Prefix increment and postfix increment operators.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="lgreen">// demonstrate postfix increment operator</span>&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="blue">int</span> c{<span class="green">5</span>};&#13;
<strong><span class="cviolet"> 9</span></strong>     cout &lt;&lt; <span class="green">"c before postincrement: "</span> &lt;&lt; c &lt;&lt; endl; <span class="lgreen">// prints 5</span>&#13;
<strong><span class="cviolet">10</span></strong>     cout &lt;&lt; <span class="green">" postincrementing c: "</span> &lt;&lt; c++ &lt;&lt; endl; <span class="lgreen">// prints 5</span>&#13;
<strong><span class="cviolet">11</span></strong>     cout &lt;&lt; <span class="green">" c after postincrement: "</span> &lt;&lt; c &lt;&lt; endl; <span class="lgreen">// prints 6</span>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>     cout &lt;&lt; endl; <span class="lgreen">// skip a line</span>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>     <span class="lgreen">// demonstrate prefix increment operator</span>&#13;
<strong><span class="cviolet">16</span></strong>     c = <span class="green">5</span>;&#13;
<strong><span class="cviolet">17</span></strong>     cout &lt;&lt; <span class="green">" c before preincrement: "</span> &lt;&lt; c &lt;&lt; endl; <span class="lgreen">// prints 5</span>&#13;
<strong><span class="cviolet">18</span></strong>     cout &lt;&lt; <span class="green">" preincrementing c: "</span> &lt;&lt; ++c &lt;&lt; endl; <span class="lgreen">// prints 6</span>&#13;
<strong><span class="cviolet">19</span></strong>     cout &lt;&lt; <span class="green">" c after preincrement: "</span> &lt;&lt; c &lt;&lt; endl; <span class="lgreen">// prints 6</span>&#13;
<strong><span class="cviolet">20</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>c before postincrement: 5</code>&#13;
    postincrementing c: 5&#13;
 c after postincrement: 6&#13;
&#13;
 c before preincrement: 5&#13;
     preincrementing c: 6&#13;
  <code>c after preincrement: 6</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 3.4</strong></span> Prefix increment and postfix increment operators.</p>&#13;
</div>&#13;
<p>Line 8 initializes the variable <code>c</code> to <code>5</code>, and line 9 outputs <code>c</code>’s initial value. Line 10 outputs the value of the expression <code>c++</code>. This expression postincrements the variable <code>c</code>, so <code>c</code>’s original value (<code>5</code>) is output, then <code>c</code>’s value is incremented (to 6). Thus, line 10 outputs <code>c</code>’s initial value (<code>5</code>) again. Line 11 outputs <code>c</code>’s new value (<code>6</code>) to prove that the variable’s value was indeed incremented in line 10.</p>&#13;
<p>Line 16 resets <code>c</code>’s value to <code>5</code>, and line 17 outputs <code>c</code>’s value. Line 18 outputs the value of the expression <code>++c</code>. This expression preincrements <code>c</code>, so its value is incremented; then the new value (<code>6</code>) is output. Line 19 outputs <code>c</code>’s value again to show that the value of <code>c</code> is still <code>6</code> after line 18 executes.</p>&#13;
<h5 class="h5" id="ch03lev3sec23">Simplifying Statements with the Arithmetic Compound Assignment, Increment and Decrement Operators</h5>&#13;
<p>The arithmetic compound assignment operators and the increment and decrement operators can be used to simplify program statements. For example, the three assignment statements in <a href="ch03.xhtml#fig3_3">Fig. 3.3</a> (lines 21, 24 and 28)</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0060-01" id="f0060-01a">Click here to view code image</a></p>&#13;
<pre class="pre">passes = passes + <span class="green">1</span>;&#13;
failures = failures + <span class="green">1</span>;&#13;
studentCounter = studentCounter + <span class="green">1</span>;</pre>&#13;
<p>can be written more concisely with compound assignment operators as</p>&#13;
<pre class="pre">passes += <span class="green">1</span>;&#13;
failures += <span class="green">1</span>;&#13;
studentCounter += <span class="green">1</span>;</pre>&#13;
<p>with prefix increment operators as</p>&#13;
<pre class="pre">++passes;&#13;
++failures;&#13;
++studentCounter;</pre>&#13;
<p>or with postfix increment operators as</p>&#13;
<pre class="pre">passes++;&#13;
failures++;&#13;
studentCounter++;</pre>&#13;
<p>When incrementing or decrementing a variable in a statement by itself, the prefix increment and postfix increment forms have the same effect, and the prefix decrement and postfix decrement forms have the same effect. Only when a variable appears in the context of a larger expression does preincrementing or postincrementing the variable have a different effect (and similarly for predecrementing or postdecrementing).</p>&#13;
<p>Attempting to use the increment or decrement operator on an expression other than one to which a value can be assigned is a syntax error. For example, writing <code>++(x + 1)</code> is a syntax error, because <code>(x + 1)</code> is not a variable.</p>&#13;
<h5 class="h5" id="ch03lev3sec24">Operator Precedence and Grouping</h5>&#13;
<p>The following table shows the precedence and grouping of the operators introduced to this point. The operators are shown top-to-bottom in decreasing order of precedence. The second column indicates the grouping of the operators at each level of precedence. Notice that the conditional operator (<code>?:</code>), the unary operators preincrement (<code>++</code>), predecrement (<code>--</code>), plus (<code>+</code>) and minus (<code>-</code>), and the assignment operators <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code> and <code>%=</code> group from <em>right-to-left</em>. All other operators in this table group from <em>left-to-right</em>. The third column names the various groups of operators.</p>&#13;
<div class="image"><img src="Images/f0093-01.jpg" alt="Images" width="828" height="444"/></div>&#13;
<h3 class="h3" id="ch03lev1sec11"><span class="violet">3.11</span> Fundamental Types Are Not Portable</h3>&#13;
<p>You can view the complete list of C++ fundamental types and their typical ranges at</p>&#13;
<pre class="pre"><a href="https://en.cppreference.com/w/cpp/language/types">https://en.cppreference.com/w/cpp/language/types</a></pre>&#13;
<p>In C and C++, an <code>int</code> on one machine might be represented by 16 bits (2 bytes) of memory, on a second machine by 32 bits (4 bytes), and on another machine by 64 bits (8 bytes). For this reason, code using integers is not always portable across platforms. You could write multiple versions of your programs to use different integer types on different platforms. Or you could use techniques to achieve various levels of portability.<sup><a id="rch0fn7" href="ch03.xhtml#ch0fn7">7</a></sup> In the next section, we’ll show one way to achieve portability.</p>&#13;
<p class="footnote"><a id="ch0fn7" href="ch03.xhtml#rch0fn7">7</a>. The integer types in the header <code>&lt;cstdint&gt;</code> (<code><a href="https://en.cppreference.com/w/cpp/types/integer">https://en.cppreference.com/w/cpp/types/integer</a></code>) can be used to ensure that integer variables are correct size for your application across platforms.</p>&#13;
<p><span class="size"><small>PERF</small></span> Among C++’s integer types are <code>int</code>, <code><strong><span class="violet">long</span></strong></code> and <code><strong><span class="violet">long long</span></strong></code>. The C++ standard requires type <code>int</code> to be at least 16 bits, type <code>long</code> to be at least 32 bits and type <code>long long</code> to be at least 64 bits. The standard also requires that an <code>int</code>’s size be less than or equal to a <code>long</code>’s size and that a <code>long</code>’s size be less than or equal to a <code>long long</code>’s size. Such “squishy” requirements create portability challenges, but allow compiler implementers to optimize performance by matching fundamental types sizes to your machine’s hardware.</p>&#13;
<h3 class="h3" id="ch03lev1sec12"><span class="violet">3.12</span> Objects Natural Case Study: Arbitrary Sized Integers</h3>&#13;
<p>The range of values an integer type supports depends on the number of bytes used to represent the type on a particular computer. For example, a four-byte <code>int</code> can store 2<sup>32</sup> possible values in the range –2,147,483,648 to 2,147,483,647. On most systems, a <code>long long</code> integer is 8 bytes and can store 2<sup>64</sup> possible values in the range –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.</p>&#13;
<h5 class="h5" id="ch03lev3sec25">Some Applications Need Numbers Outside a <code>long long</code> Integer’s Range</h5>&#13;
<p>Consider factorial calculations. A factorial is the product of the integers from 1 to a given value. The factorial of 5 (written 5!) is 1 * 2 * 3 * 4 * 5, which is 120. The highest factorial value we can represent in a 64-bit integer is 20!, which is 2,432,902,008,176,640,000. Factorials quickly grow outside the range representable by a <code>long long</code> integer. With big data getting bigger quickly, an increasing number of real-world applications will exceed the limitations of <code>long long</code> integers.</p>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> Another application requiring extremely large integers is cryptography—an important aspect of securing data that’s transmitted between computers over the Internet. Many cryptography algorithms perform calculations using 128-bit or 256-bit integer values—far larger than we can represent with C++’s fundamental types.</p>&#13;
<h5 class="h5" id="ch03lev3sec26">Arbitrary Precision Integers with Class <code>BigNumber</code></h5>&#13;
<p>Any application requiring integers outside <code>long long</code>’s range requires special processing. Unfortunately, the C++ standard library does not (yet) have a class for arbitrary precision integers. So, for this example, we’ll dive into the vast world of open-source class libraries to demonstrate one of the many C++ classes that you can use to can create and manipulate arbitrary precision integers. We’ll use the class <code><strong><span class="violet">BigNumber</span></strong></code> from:</p>&#13;
<pre class="pre"><a href="https://github.com/limeoats/BigNumber">https://github.com/limeoats/BigNumber</a></pre>&#13;
<p>For your convenience, we included the download in this example’s <code>fig03_05</code> folder. Be sure to read the license terms included in the provided <code>LICENSE.md</code> file.</p>&#13;
<p>To use <code>BigNumber</code>, you don’t have to understand how it’s implemented.<sup><a id="rch0fn8" href="ch03.xhtml#ch0fn8">8</a></sup> You simply include its header file (<code>bignumber.h</code>), create objects of the class then use them in your code. <a href="ch03.xhtml#fig3_5">Figure 3.5</a> demonstrates <code>BigNumber</code> and shows a sample output. For this example, we’ll use the maximum <code>long long</code> integer value to show that we can create an even bigger integer with <code>BigNumber</code>. At the end of this section, we show how to compile and run the code.</p>&#13;
<p class="footnote"><a id="ch0fn8" href="ch03.xhtml#rch0fn8">8</a>. After you get deeper into C++, you might want to peek at <code>BigNumber</code>’s source code (approximately 1000 lines) to see how it’s implemented. In our object-oriented programming presentation later in this book, you’ll learn a variety of techniques that you can use to create your own big integer class.</p>&#13;
<div class="group" id="fig3_5">&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#aa03fig05" id="a03fig05">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig03_05.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Integer ranges and arbitrary precision integers.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="yell"><span class="blue">#include</span> <span class="green">"bignumber.h"</span></span>&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 6</span></strong>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="lgreen">// use the maximum long long fundamental type value in calculations</span>&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="yell"><span class="blue">long long</span> value1{<span class="green">9'223'372'036'854'775'807LL</span>};</span> <span class="lgreen">// max long long value</span>&#13;
<strong><span class="cviolet">10</span></strong>     cout &lt;&lt; <span class="green">"long long value1: "</span> &lt;&lt; value1&#13;
<strong><span class="cviolet">11</span></strong>        &lt;&lt; <span class="green">"\nvalue1 - 1 = "</span> &lt;&lt; <span class="yell">value1 - <span class="green">1</span></span> <span class="lgreen">// OK</span>&#13;
<strong><span class="cviolet">12</span></strong>        &lt;&lt; <span class="green">"\nvalue1 + 1 = "</span> &lt;&lt; <span class="yell">value1 + <span class="green">1</span></span>; <span class="lgreen">// result is undefined</span>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="lgreen">// use an arbitrary precision integer</span>&#13;
<strong><span class="cviolet">15</span></strong>     <span class="yell"><code>BigNumber value2{value1};</code></span>&#13;
<strong><span class="cviolet">16</span></strong>     cout &lt;&lt; <span class="green">"\n\nBigNumber value2: "</span> &lt;&lt; value2&#13;
<strong><span class="cviolet">17</span></strong>        &lt;&lt; <span class="green">"\nvalue2 - 1 = "</span> &lt;&lt; <span class="yell">value2 - <span class="green">1</span></span> <span class="lgreen">// OK</span>&#13;
<strong><span class="cviolet">18</span></strong>        &lt;&lt; <span class="green">"\nvalue2 + 1 = "</span> &lt;&lt; <span class="yell">value2 + <span class="green">1</span></span>; <span class="lgreen">// OK</span>&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>     <span class="lgreen">// powers of 100,000,000 with long long</span>&#13;
<strong><span class="cviolet">21</span></strong>     <span class="blue">long long</span> value3{<span class="green">100'000'000</span>};&#13;
<strong><span class="cviolet">22</span></strong>     cout &lt;&lt; <span class="green">"\n\nvalue3: "</span> &lt;&lt; value3;&#13;
<strong><span class="cviolet">23</span></strong>&#13;
<strong><span class="cviolet">24</span></strong>     <span class="blue">int</span> counter{<span class="green">2</span>};&#13;
<strong><span class="cviolet">25</span></strong>&#13;
<strong><span class="cviolet">26</span></strong>     <span class="blue">while</span> (counter &lt;= <span class="green">5</span>) {&#13;
<strong><span class="cviolet">27</span></strong>        <span class="yell">value3 *= <span class="green">100'000'000</span>;</span> <span class="lgreen">// quickly exceeds maximum long long value</span>&#13;
<strong><span class="cviolet">28</span></strong>        cout &lt;&lt; <span class="green">"\nvalue3 to the power "</span> &lt;&lt; counter &lt;&lt; <span class="green">": "</span> &lt;&lt; value3;&#13;
<strong><span class="cviolet">29</span></strong>        <code>++counter;</code>&#13;
<strong><span class="cviolet">30</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">31</span></strong>&#13;
<strong><span class="cviolet">32</span></strong>     <span class="lgreen">// powers of 100,000,000 with BigNumber</span>&#13;
<strong><span class="cviolet">33</span></strong>     <span class="yell">BigNumber value4{<span class="green">100'000'000</span>};</span>&#13;
<strong><span class="cviolet">34</span></strong>     cout &lt;&lt; <span class="green">"\n\nvalue4: "</span> &lt;&lt; value4 &lt;&lt; endl;&#13;
<strong><span class="cviolet">35</span></strong>&#13;
<strong><span class="cviolet">36</span></strong>     counter = <span class="green">2</span>;&#13;
<strong><span class="cviolet">37</span></strong>&#13;
<strong><span class="cviolet">38</span></strong>     <span class="blue">while</span> (counter &lt;= <span class="green">5</span>) {&#13;
<strong><span class="cviolet">39</span></strong>        cout &lt;&lt; <span class="green">"value4.pow("</span> &lt;&lt; counter &lt;&lt; <span class="green">"): "</span>&#13;
<strong><span class="cviolet">40</span></strong>           <code>&lt;&lt; value4.pow(counter) &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">41</span></strong>        <code>++counter;</code>&#13;
<strong><span class="cviolet">42</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">43</span></strong>&#13;
<strong><span class="cviolet">44</span></strong>     <code>cout &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">45</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>long long value1: 9223372036854775807&#13;
value1 - 1: 9223372036854775806</code>                          <span class="non_code"><em>OK</em></span>&#13;
<code>value1 + 1: -9223372036854775808</code>                         <span class="non_code"><em>Incorrect result</em></span>&#13;
&#13;
<code>BigNumber value2: 9223372036854775807&#13;
value2 - 1: 9223372036854775806</code>                          <span class="non_code"><em>OK</em></span>&#13;
<code>value2 + 1: 9223372036854775808</code>                          <span class="non_code"><em>OK</em></span>&#13;
&#13;
<code>value3: 100000000&#13;
value3 to the power 2: 10000000000000000</code>                 <span class="non_code"><em>OK</em></span>&#13;
<code>value3 to the power 3: 2003764205206896640</code>               <span class="non_code"><em>Incorrect result</em></span>&#13;
<code>value3 to the power 4: -8814407033341083648</code>              <span class="non_code"><em>Incorrect result</em></span>&#13;
<code>value3 to the power 5: -5047021154770878464</code>              <span class="non_code"><em>Incorrect result</em></span>&#13;
&#13;
<code>value4: 100000000&#13;
value4.pow(2): 10000000000000000</code>                         <span class="non_code"><em>OK</em></span>&#13;
<code>value4.pow(3): 1000000000000000000000000</code>                 <span class="non_code"><em>OK</em></span>&#13;
<code>value4.pow(4): 100000000000000000000000000000000</code>         <span class="non_code"><em>OK</em></span>&#13;
<code>value4.pow(5): 10000000000000000000000000000000000000000</code> <span class="non_code"><em>OK</em></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 3.5</strong></span> Integer ranges and arbitrary precision integers.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch03lev3sec27">Including a Header That Is Not in the C++ Standard Library</h5>&#13;
<p>In an <code>#include</code> directive, headers that are not from the C++ Standard Library typically are placed in double quotes (<code>""</code>), rather than the angle brackets (<code>&lt;&gt;</code>). The double quotes tell the compiler that header is in your application’s folder or another folder that you specify.</p>&#13;
<h5 class="h5" id="ch03lev3sec28">What Happens When You Exceed the Maximum <code>long long</code> Integer Value?</h5>&#13;
<p>Line 9 initializes the variable <code>value1</code> with the maximum <code>long long</code> value on our system:<sup><a id="rch0fn9" href="ch03.xhtml#ch0fn9">9</a></sup></p>&#13;
<p class="footnote"><a id="ch0fn9" href="ch03.xhtml#rch0fn9">9</a>. The platforms on which we tested this book’s code each have as their maximum <code>long long</code> integer value 9,223,372,036,854,775,807. You can determine this value programmatically with the expression <code>std::numeric_limits&lt;long long&gt;::max()</code>, which uses class <code>numeric_limits</code> from the C++ standard library header <code>&lt;limits&gt;</code>. The <code>&lt;&gt;</code> and <code>::</code> notations used in this expression are covered in later chapters, so we used the literal value 9,223,372,036,854,775,807 in <a href="ch03.xhtml#fig3_5">Fig. 3.5</a>.</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0063-01" id="f0063-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">long long</span> value1{<span class="green">9'223'372'036'854'775'807LL</span>}; <span class="lgreen">// max long long value</span></pre>&#13;
<p><span class="size">20</span> Typing numeric literals with many digits can be error prone. To make such literals more readable and reduce errors, C++14 introduced the <span class="violet"><strong>digit separator</strong></span> <code><strong><span class="violet">'</span></strong></code> (a single-quote character), which you insert between groups of digits in numeric literals—we used it so separate groups of three digits. Also, note the <code><strong><span class="violet">LL</span></strong></code> (“el el”) at the end of the literal value—this indicates that the literal is a <code>long long</code> integer.</p>&#13;
<p>Line 10 displays <code>value1</code>, then line 11 subtracts one from it to demonstrate a valid calculation. Next, we attempt to add <code>1</code> to <code>value1</code>, which already contains the maximum <code>long long</code> value. All our compilers displayed as the result the <em>minimum</em> <code><em>long long</em></code> <em>value</em>. The C++ standard actually says the result of this calculation is <span class="violet"><strong>undefined behavior</strong></span>. Such behaviors can differ between systems—ours displayed an incorrect value but other systems could terminate the program and display an error message. This is another example of why the fundamental integer types are not portable.</p>&#13;
<h5 class="h5" id="ch03lev3sec29">Performing the Same Operations with a <code>BigNumber</code> Object</h5>&#13;
<p>Lines 15–18 use a <code>BigNumber</code> object to repeat the operations from lines 9–12. We create a <code>BigNumber</code> object named <code>value2</code> and initialize it with <code>value1</code>, which contains the maximum value of a <code>long long</code> integer:</p>&#13;
<pre class="pre">BigNumber value2{value1};</pre>&#13;
<p>Next, we display the <code>BigNumber</code> then subtract one from it and display the result. Line 18 adds one to <code>value2</code>, which contains the maximum value of a <code>long long</code>. <code>BigNumber</code> handles arbitrary precision integers, so it <em>correctly performs this calculation</em>. The result is a value that C++’s fundamental integer types cannot handle on our systems.</p>&#13;
<p><code>BigNumber</code> supports all the typical arithmetic operations, including <code>+</code> and <code>-</code> used in this program. The compiler already knows how to use arithmetic operators with fundamental numeric types, but it has to be taught how to handle those operators for class objects. We discuss that process—called operator overloading—in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>&#13;
<h5 class="h5" id="ch03lev3sec30">Powers of 100,000,000 with <code>long long</code> Integers</h5>&#13;
<p>Lines 21–30 calculate powers of 100,000,000 using <code>long long</code> integers. First, we create the variable <code>value3</code> and display its value. Lines 26–30 loop five times. The calculation</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0064-01" id="f0064-01a">Click here to view code image</a></p>&#13;
<pre class="pre">value3 *= <span class="green">100'000'000</span>; <span class="lgreen">// quickly exceeds maximum long long value</span></pre>&#13;
<p>multiples <code>value3</code>’s current value by 100,000,000 to raise <code>value3</code> to the next power. As you can see in the program’s output, only the loop’s first iteration produces a correct result.</p>&#13;
<h5 class="h5" id="ch03lev3sec31">Powers of 100,000,000 with <code>BigNumber</code> Objects</h5>&#13;
<p>To demonstrate that <code>BigNumber</code> can handle significantly larger values than the fundamental integer types, lines 33–42 calculate powers of 100,000,000 using a <code>BigNumber</code> object. First, we create <code>BigNumber value4</code> and display its initial value. Lines 38–42 loop five times. The calculation</p>&#13;
<pre class="pre">value4.pow(counter)</pre>&#13;
<p>calls <code>BigNumber</code> member function <code><strong><span class="violet">pow</span></strong></code> to raise <code>value4</code> to the power <code>counter</code>. <code>BigNumber</code> correctly handles each calculation, producing massive values that are far outside the ranges supported by our Windows, macOS and Linux systems’ fundamental integer types.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> Though a <code>BigNumber</code> can represent any integer value, it does not match your system’s hardware. So you’ll likely sacrifice some performance in exchange for the flexibility <code>Big-Number</code> provides.</p>&#13;
<h5 class="h5" id="ch03lev3sec32">Compiling and Running the Example in Microsoft Visual Studio</h5>&#13;
<p>In Microsoft Visual Studio:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> Create a new project, as described in Section 1.9.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> In the <span class="std">Solution Explorer</span>, right-click the project’s <span class="std">Source Files</span> folder and select <span class="std">Add &gt; Existing Item…</span>.</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> Navigate to the <code>fig03_05</code> folder, select <code>fig03_05.cpp</code> and click <span class="std">Add</span>.</p>&#13;
<p class="num"><span class="red"><strong>4.</strong></span> Repeat Steps 2–3 for <code>bignumber.cpp</code> from the <code>fig03_05\BigNumber\src</code> folder.</p>&#13;
<p class="num"><span class="red"><strong>5.</strong></span> In the <span class="std">Solution Explorer</span>, right-click the project’s name and select <span class="std">Properties…</span>.</p>&#13;
<p class="num"><span class="red"><strong>6.</strong></span> Under <span class="std">Configuration Properties</span>, select <span class="std">C/C++</span>, then on the right side of the dialog, add to the <span class="std">Additional Include Directories</span> the full path to the <code>BigNumber\src</code> folder on your system. For our system, this was</p>&#13;
<p class="web1"><code>C:\Users\</code><em>account</em><code>\Documents\examples\ch03\fig03_05\BigNumber\src</code></p>&#13;
<p class="num"><span class="red"><strong>7.</strong></span> Click <span class="std">OK</span>.</p>&#13;
<p class="num"><span class="red"><strong>8.</strong></span> Type <em>Ctrl + F5</em> to compile and run the program.</p>&#13;
<h5 class="h5" id="ch03lev3sec33">Compiling and Running the Example in GNU g++</h5>&#13;
<p>For GNU g++ (these instructions also work from a Terminal window on macOS):</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> At your command line, change to this example’s <code>fig03_05</code> folder.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> Type the following command to compile the program—the <code>-I</code> option specifies additional folders in which the compiler should search for header files:</p>&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#f0065-01" id="f0065-01a">Click here to view code image</a></p>&#13;
<pre class="pre">g++ -std=c++2a -I BigNumber/src fig03_05.cpp \&#13;
BigNumber/src/bignumber.cpp -o fig03_05</pre>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> Type the following command to execute the program:</p>&#13;
<pre class="pre">./fig03_05</pre>&#13;
<h5 class="h5" id="ch03lev3sec34">Compiling and Running the Example in Apple Xcode</h5>&#13;
<p>In Apple Xcode:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> Create a new project, as described in Section 1.9, and delete <code>main.cpp</code>.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> Drag <code>fig03_05.cpp</code> from the <code>fig03_05</code> folder in the Finder onto your project’s source code folder in Xcode, then click <span class="std">Finish</span> in the dialog that appears.</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> Drag <code>bignumber.h</code> and <code>bignumber.cpp</code> from the <code>fig03_05/BigNumber/src</code> folder onto your project’s source code folder in Xcode, then click <span class="std">Finish</span> in the dialog that appears.</p>&#13;
<p class="num"><span class="red"><strong>4.</strong></span> Type <img class="inline" src="Images/common08.jpg" alt="Images" width="23" height="17"/> + <em>R</em> to compile and run the program.</p>&#13;
<h3 class="h3" id="ch03lev1sec13"><span class="violet">3.13</span> C++20 Feature Mock-Up—Text Formatting with Function <code>format</code></h3>&#13;
<p><span class="size">20</span> C++20 introduces powerful new string formatting capabilities via the <code><strong><span class="violet">format</span></strong></code> <span class="violet"><strong>function</strong></span> (in header <code><strong><span class="violet">&lt;format&gt;</span></strong></code>). These capabilities greatly simplify C++ formatting by using a syntax similar to that used in Python, Microsoft’s .NET languages (like C# and Visual Basic) and the up-and-coming newer language Rust.<sup><a id="rch0fn10" href="ch03.xhtml#ch0fn10">10</a></sup> You’ll see throughout the book that the C++20 text-formatting capabilities are more concise and more powerful than those in earlier C++ versions. In <a href="ch14.xhtml#ch14">Chapter 14</a>, we’ll also show that these new capabilities can be customized to work with your own new class types. We’ll show both old- and new-style formatting because in your career you may work with software that uses the old style.</p>&#13;
<p class="footnote"><a id="ch0fn10" href="ch03.xhtml#rch0fn10">10</a>. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html</a></code>.</p>&#13;
<h5 class="h5" id="ch03lev3sec35">C++20 String Formatting Is Not Yet Implemented</h5>&#13;
<p>At the time of this writing (April 2020), the C++ standard was about to be approved (May 2020) and C++ compilers had not yet fully implemented many of C++20’s features, including text formatting. However, the <code>{fmt}</code> library at</p>&#13;
<pre class="pre"><a href="https://github.com/fmtlib/fmt">https://github.com/fmtlib/fmt</a></pre>&#13;
<p>provides a full implementation of the new text-formatting features.<sup><a id="rch0fn11" href="ch03.xhtml#ch0fn11">11</a></sup>,<sup><a id="rch0fn12" href="ch03.xhtml#ch0fn12">12</a></sup> So, we’ll use this library until the C++20 compilers implement text formatting.<sup><a id="rch0fn13" href="ch03.xhtml#ch0fn13">13</a></sup> For your convenience, we included the complete download in the <code>examples</code> folder’s <code>libraries</code> subfolder, then included only the required files in the <code>fig03_06</code> folder. Be sure to read the library’s license terms included in the provided <code>format.h</code> file.</p>&#13;
<p class="footnote"><a id="ch0fn11" href="ch03.xhtml#rch0fn11">11</a>. According to <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html</a></code>, which is the C++ standard committee proposal for C++20 text formatting.</p>&#13;
<p class="footnote"><a id="ch0fn12" href="ch03.xhtml#rch0fn12">12</a>. C++20’s text formatting features are a subset of the features provided by the <code>{fmt}</code> library.</p>&#13;
<p class="footnote"><a id="ch0fn13" href="ch03.xhtml#rch0fn13">13</a>. Some of our C++20 Feature Mock-Up sections present code that does not compile or run. Once the compilers implement those features, we’ll retest the code, update our digital products and post updates for our print products at <code><a href="https://deitel.com/c-plus-plus-20-for-programmers">https://deitel.com/c-plus-plus-20-for-programmers</a></code>. The code in this example runs, but uses the <code>{fmt}</code> open-source library to demonstrate features that C++20 compilers will support eventually.</p>&#13;
<h5 class="h5" id="ch03lev3sec36">Format String Placeholders</h5>&#13;
<p>The <code>format</code> function’s first argument is a <span class="violet"><strong>format string</strong></span> containing <span class="violet"><strong>placeholders</strong></span> delimited by curly braces (<code>{</code> and <code>}</code>). The function replaces the placeholders with the values of the function’s other arguments, as demonstrated in <a href="ch03.xhtml#fig3_6">Fig. 3.6</a>.</p>&#13;
<div class="group" id="fig3_6">&#13;
<p class="codelink"><a href="Images/ch03_images.xhtml#aa03fig06" id="a03fig06">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig03_06.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// C++20 string formatting.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> <span class="yell">4</span></span></strong>  <span class="yell"><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// C++20: This will be #include &lt;format&gt;</span></span>&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> <span class="yell">6</span></span></strong>  <span class="yell"><span class="blue">using namespace</span> fmt; <span class="lgreen">// not needed in C++20</span></span>&#13;
<strong><span class="cviolet"> 7</span></strong>&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 9</span></strong>     string student{<span class="green">"Paul"</span>};&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">int</span> grade{<span class="green">87</span>};&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>     cout &lt;&lt; <span class="yell">format(<span class="green">"{}'s grade is {}"</span>, student, grade)</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">13</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Paul's grade is 87</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 3.6</strong></span> C++20 string formatting.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch03lev3sec37">Placeholders Are Replaced Left-to-Right</h5>&#13;
<p>The <code>format</code> function replaces its format string argument’s placeholders left-to-right by default. So, line 11’s <code>format</code> call inserts into the format string</p>&#13;
<pre class="pre">"{}'s grade is {}"</pre>&#13;
<p><code>student</code>’s value (<code>"Paul"</code>) in the first placeholder and <code>grade</code>’s value (<code>87</code>) in the second placeholder, then returns the string</p>&#13;
<pre class="pre">"Paul's grade is 87"</pre>&#13;
<h5 class="h5" id="ch03lev3sec38">Compiling and Running the Example in Microsoft Visual Studio</h5>&#13;
<p>The steps below are the same as those in <a href="ch03.xhtml#ch03lev1sec12">Section 3.12</a> with the following changes:</p>&#13;
<p class="bull">• In Step 3, navigate to the <code>fig03_06</code> folder, add both the files <code>fig03_06.cpp</code> and <code>format.cc</code> to your project’s <span class="std">Source Files</span> folder.</p>&#13;
<p class="bull">• In Step 6, add to the <span class="std">Additional Include Directories</span> the full path to the <code>fig03_06</code> folder on your system. For our system, this was</p>&#13;
<p class="web"><code>C:\Users\</code><em>account</em><code>\Documents\examples\ch03\fig03_06</code></p>&#13;
<h5 class="h5" id="ch03lev3sec39">Compiling and Running the Example in GNU g++</h5>&#13;
<p>For GNU g++ (these instructions also work from a Terminal window on macOS):</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> At your command line, change folders to this example’s <code>fig03_06</code> folder.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> Type the following command to compile the program:</p>&#13;
<pre class="pre">g++ -std=c++2a -I fmt fig03_06.cpp format.cc -o fig03_06</pre>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> Type the following command to execute the program:</p>&#13;
<pre class="pre">./fig03_06</pre>&#13;
<h5 class="h5" id="ch03lev3sec40">Compiling and Running the Example in Apple Xcode</h5>&#13;
<p>The steps for this example are the same as those in <a href="ch03.xhtml#ch03lev1sec12">Section 3.12</a> with the following change:</p>&#13;
<p class="bull">• In Step 2, drag the files <code>fig03_06.cpp</code>, <code>format.cc</code> and the folder <code>fmt</code> from to the <code>fig03_06</code> folder onto your project’s source code folder in Xcode.</p>&#13;
<h3 class="h3" id="ch03lev1sec14"><span class="violet">3.14</span> Wrap-Up</h3>&#13;
<p>Only three types of control statements—sequence, selection and iteration—are needed to develop any algorithm. We demonstrated the <code>if</code> single-selection statement, the <code>if…else</code> double-selection statement and the <code>while</code> iteration statement. We used control-statement stacking to total and compute the average of a set of student grades with counter- and sentinel-controlled iteration, and we used control-statement nesting to analyze and make decisions based on a set of exam results. We introduced C++’s compound assignment operators and its increment and decrement operators. We discussed why C++’s fundamental types are not portable, then used objects of the open-source class <code>BigNumber</code> to perform integer arithmetic with values outside the range supported by our systems. Finally, we introduced C++20’s new text formatting in the context of the open-source <code>{fmt}</code> library. In <a href="ch04.xhtml#ch04">Chapter 4</a>, we continue our discussion of control statements, introducing the <code>for</code>, <code>do</code>…<code>while</code> and <code>switch</code> statements, and we introduce the logical operators for creating compound conditions.</p>&#13;
</div></body>
</html>