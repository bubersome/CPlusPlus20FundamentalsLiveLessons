<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch14">Chapter 14. Standard Library Algorithms and C++20 Ranges &amp; Views</h2>&#13;
<div class="image"><img src="Images/common.jpg" alt="Images" width="370" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Understand minimum iterator requirements for working with standard library containers and algorithms.</p>&#13;
<p class="squ"><span class="red">■</span> Create lambda expressions that capture local variables to use in the lambda expressions’ bodies.</p>&#13;
<p class="squ"><span class="red">■</span> Use many of the C++20 <code>std::ranges</code> algorithms.</p>&#13;
<p class="squ"><span class="red">■</span> Understand the C++20 concepts that correspond to the C++20 <code>std::ranges</code> algorithms’ minimum iterator requirements.</p>&#13;
<p class="squ"><span class="red">■</span> Compare the new C++20 <code>std::ranges</code> algorithms with older common-range <code>std</code> algorithms.</p>&#13;
<p class="squ"><span class="red">■</span> Use iterators with algorithms to access and manipulate the elements of standard library containers.</p>&#13;
<p class="squ"><span class="red">■</span> Pass lambdas, function pointers and function objects into standard library algorithms mostly interchangeably.</p>&#13;
<p class="squ"><span class="red">■</span> Use projections to transform objects in a range before processing them with C++20 range algorithms.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++20 views and lazy evaluation with C++20 ranges.</p>&#13;
<p class="squ"><span class="red">■</span> Learn about C++ ranges features possibly coming in C++23.</p>&#13;
<p class="squ"><span class="red">■</span> Be introduced to parallel algorithms for performance enhancement—we’ll discuss these in <a href="ch16.xhtml#ch16">Chapter 16</a>.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_1"><span class="violet"><strong>14.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_2"><span class="violet"><strong>14.2</strong></span> Algorithm Requirements: C++20 Concepts</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_3"><span class="violet"><strong>14.3</strong></span> Lambdas and Algorithms</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_4"><span class="violet"><strong>14.4</strong></span> Algorithms (Mostly C++20 <code>std::ranges</code> Versions)</a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_1">14.4.1  <code>fill</code>, <code>fill_n</code>, <code>generate</code> and <code>generate_n</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_2">14.4.2  <code>equal</code>, <code>mismatch</code> and <code>lexicographical_compare</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_3">14.4.3  <code>remove</code>, <code>remove_if</code>, <code>remove_copy</code> and <code>remove_copy_if</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_4">14.4.4  <code>replace</code>, <code>replace_if</code>, <code>replace_copy</code> and <code>replace_copy_if</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_5">14.4.5 Mathematical Algorithms</a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_6">14.4.6 Searching and Sorting Algorithms</a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_7">14.4.7  <code>swap</code>, <code>iter_swap</code> and <code>swap_ranges</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_8">14.4.8  <code>copy_backward</code>, <code>merge</code>, <code>unique</code>, <code>reverse</code>, <code>copy_if</code> and <code>copy_n</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_9">14.4.9 <code>inplace_merge</code>, <code>unique_copy</code> and <code>reverse_copy</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_10">14.4.10 Set Operations</a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_11">14.4.11  <code>lower_bound</code>, <code>upper_bound</code> and <code>equal_range</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_12">14.4.12  <code>min</code>, <code>max</code> and <code>minmax</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_13">14.4.13 Algorithms <code>gcd</code>, <code>lcm</code>, <code>iota</code>, <code>reduce</code> and <code>partial_sum</code> from Header <code>&lt;numeric&gt;</code></a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_4_14">14.4.14 Heapsort</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_5"><span class="violet"><strong>14.5</strong></span> Function Objects (Functors)</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_6"><span class="violet"><strong>14.6</strong></span> Projections</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_7"><span class="violet"><strong>14.7</strong></span> C++20 Views and Functional-Style Programming</a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_7_1">14.7.1 Range Adaptors</a></p>&#13;
<p class="chap-lev2"><a href="ch14.xhtml#sec14_7_2">14.7.2 Working with Range Adaptors and Views</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_8"><span class="violet"><strong>14.8</strong></span> Intro to Parallel Algorithms</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_9"><span class="violet"><strong>14.9</strong></span> Standard Library Algorithm Summary</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_10"><span class="violet"><strong>14.10</strong></span> A Look Ahead to C++23 Ranges</a></p>&#13;
<p class="chap-lev1"><a href="ch14.xhtml#sec14_11"><span class="violet"><strong>14.11</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="sec14_1"><span class="violet">14.1</span> Introduction</h3>&#13;
<p>This chapter discusses the standard library’s algorithms, focusing on common container manipulations, including <strong>filling with values</strong>, <strong>generating values</strong>, <strong>comparing elements or entire containers</strong>, <strong>removing elements</strong>, <strong>replacing elements</strong>, <strong>mathematical operations</strong>, <strong>searching</strong>, <strong>sorting</strong>, <strong>swapping, copying</strong>, <strong>merging</strong>, <strong>set operations</strong>, <strong>determining boundaries</strong>, and <strong>calculating minimums and maximums</strong>. The standard library provides many pre-packaged, templatized algorithms:</p>&#13;
<p class="bull"><span class="size">20</span> • 90 in the <strong><code>&lt;algorithm&gt;</code></strong> header’s <code>std</code> namespace—82 also are overloaded in the</p>&#13;
<p><strong><code>std::ranges</code> namespace</strong> for use with <strong>C++20 ranges</strong>,</p>&#13;
<p class="bull">• 11 in the <strong><code>&lt;numeric&gt;</code></strong> header’s <code>std</code> namespace—none are overloaded in the <strong>C++20 <code>std::ranges</code> namespace</strong>, and</p>&#13;
<p class="bull"><span class="size">20</span> • 14 in the <strong><code>&lt;memory&gt;</code></strong> header’s <code>std</code> namespace—all 14 also are overloaded in the <strong><code>std::ranges</code> namespace</strong> for use with <strong>C++20 ranges</strong>.</p>&#13;
<p><span class="size">11</span> <span class="size">17</span> <span class="size">20</span> Many algorithms were added in C++11 and C++20, and a few in C++17. The <strong><code>&lt;algorithm&gt;</code></strong> header contains <strong>mutating sequence algorithms</strong>, <strong>nonmodifying sequence algorithms</strong> and <strong>sorting and related algorithms</strong>. Many have parallel versions (which we overview in <a href="ch14.xhtml#sec14_8">Section 14.8</a> and demonstrate in <a href="ch17.xhtml#ch17">Chapter 17</a>, Concurrency, Parallelism, C++20 Coroutines and the Parallel STL). For the complete list of algorithms and their descriptions, visit:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p752pro01" id="p752pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/algorithm</pre>&#13;
<h5 class="h5" id="ch14lev3sec1"><span class="size">20</span> Minimum Algorithm Requirements and C++20 Concepts</h5>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The standard library’s algorithms specify <strong>minimum requirements</strong> that help you determine which <strong>containers</strong>, <strong>iterators</strong> and <strong>functions</strong> can be passed to each algorithm. The <strong>C++20 range-based algorithms</strong> in the <strong><code>std::ranges</code> namespace</strong> use <strong>C++20 concepts</strong> feature to specify their requirements. We briefly introduce <strong>C++20 concepts</strong> as needed for you to understand the requirements for working with these algorithms. We’ll discuss concepts in more depth in <a href="ch15.xhtml#ch15">Chapter 15</a> as we build templates.</p>&#13;
<h5 class="h5" id="ch14lev3sec2">C++20 Range-Based Algorithms vs. Earlier Common-Range Algorithms</h5>&#13;
<p>Most of the algorithms we present in this chapter have overloads in</p>&#13;
<p class="bull"><span class="size">20</span> • the <strong><code>std::ranges</code> namespace</strong> for use with <strong>C++20 ranges</strong>, and</p>&#13;
<p class="bull">• the <strong><code>std</code> namespace</strong> for use with <strong>pre-C++20 common ranges</strong>.</p>&#13;
<p>We’ll focus mainly on the <strong>C++20 ranges versions</strong>.<sup><a id="ch14fn1a" href="ch14.xhtml#ch14fn1">1</a>,<a id="ch14fn2a" href="ch14.xhtml#ch14fn2">2</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn1" href="ch14.xhtml#ch14fn1a">1</a>. Tristan Brindle, “An Overview of Standard Ranges,” September 29, 2019. Accessed May 1, 2021. <code><a href="https://www.youtube.com/watch?v=SYLgG7Q5Zws">https://www.youtube.com/watch?v=SYLgG7Q5Zws</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn2" href="ch14.xhtml#ch14fn2a">2</a>. Tristan Brindle, “C++20 Ranges in Practice,” October 8, 2020. Accessed May 1, 2021. <code><a href="https://www.youtube.com/watch?v=d_E-VLyUnzc">https://www.youtube.com/watch?v=d_E-VLyUnzc</a></code>.</p>&#13;
<h5 class="h5" id="ch14lev3sec3">Lambdas, Function Pointers and Function Objects</h5>&#13;
<p><a href="ch06.xhtml#ch06lev2sec2">Section 6.14.2</a> introduced <strong>lambda expressions</strong>. In <a href="ch14.xhtml#sec14_3">Section 14.3</a>, we’ll revisit them and introduce additional details. As you’ll see, various algorithms can receive a <strong>lambda</strong>, a <strong>function pointer</strong> or a <strong>function object</strong> as an argument. Most examples in this chapter use <strong>lambdas</strong> because they’re convenient for expressing small tasks. In <a href="ch14.xhtml#sec14_5">Section 14.5</a>, you’ll see that a <strong>lambda expression</strong> often is interchangeable with a <strong>function pointer</strong> or a <strong>function object</strong> (also called a <strong>functor</strong>). A function object’s class overloads the <strong><code>operator()</code> function</strong>, allowing the object’s name to be used as a function name, as in <em>objectName</em><code>(</code><em>arguments</em><code>)</code>. <strong>Lambdas</strong> that use variables from their enclosing scope are converted to function objects by the compiler.</p>&#13;
<h5 class="h5" id="ch14lev3sec4">C++20 Views and Functional-Style Programming with Lazy Evaluation</h5>&#13;
<p>Like many modern languages, C++ offers <strong>functional-style programming</strong> capabilities, which we began introducing in <a href="ch06.xhtml#ch06lev2sec3">Section 6.14.3</a>. In particular, we demonstrated <strong>functional-syle filter</strong>, <strong>map and reduce operations</strong>. In <a href="ch14.xhtml#sec14_7">Section 14.7</a>, we’ll continue our presentation of functional-style programming with C++20’s new <strong><code>&lt;ranges&gt;</code> library</strong>.</p>&#13;
<h5 class="h5" id="ch14lev3sec5">Parallel Algorithms</h5>&#13;
<p>C++17 introduced new parallel overloads for 69 standard library algorithms in the header <strong><code>&lt;algorithm&gt;</code></strong>, enabling you to take advantage of <strong>multi-core architectures</strong> to enhance program performance. <a href="ch14.xhtml#sec14_8">Section 14.8</a> briefly overviews the parallel overloads. We enumerate the algorithms with parallel versions in <a href="ch14.xhtml#sec14_9">Section 14.9</a>’s standard-library-algorithms summary tables. <a href="ch16.xhtml#ch16">Chapter 16</a> demonstrates several parallel algorithms. In that chapter, we’ll use features from the <code>&lt;chrono&gt;</code> header to time standard library algorithms running sequentially on a single core and running parallel on multiple cores so you can see the performance improvement.</p>&#13;
<h5 class="h5" id="ch14lev3sec6">Looking Ahead to Ranges in C++23</h5>&#13;
<p>Some C++20 algorithms—including those in the <strong><code>&lt;numeric&gt;</code> header</strong> and the parallel algorithms in the <strong><code>&lt;algorithm&gt;</code> header</strong>—do not have <code>std::ranges</code> overloads. <a href="ch14.xhtml#sec14_7">Section 14.7</a> overviews updates expected in C++23 and mentions the <strong>open-source project <code>ranges-next</code></strong>,<sup><a id="ch14fn3a" href="ch14.xhtml#ch14fn3">3</a></sup> which contains implementations for some of the proposed updates.</p>&#13;
<p class="footnote"><a id="ch14fn3" href="ch14.xhtml#ch14fn3a">3</a>. Corentin Jabot, “Ranges For C++23.” Accessed April 30, 2021. <code><a href="https://github.com/cor3ntin/rangesnext">https://github.com/cor3ntin/rangesnext</a></code>.</p>&#13;
<h3 class="h3" id="sec14_2"><span class="size">20</span> <span class="violet">14.2</span> Algorithm Requirements: C++20 Concepts</h3>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The C++ standard library separates containers from the algorithms that manipulate the containers. Most algorithms operate on container elements indirectly via iterators. <strong>This architecture makes it easier to write generic algorithms applicable to a variety of containers</strong>. This is a strength of the STL.</p>&#13;
<p>Container class templates and their corresponding iterator class templates typically reside in the same header. For example, the <strong><code>&lt;array&gt;</code></strong> header contains the templates for class <strong><code>array</code></strong> and its iterator class. A container internally creates objects of its iterator class and returns them via container member functions, such as <strong><code>begin</code></strong>, <strong><code>end</code></strong>, <strong><code>cbegin</code></strong> and <strong><code>cend</code></strong>.</p>&#13;
<h5 class="h5" id="ch14lev3sec7">Iterator Requirements</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> For maximum reuse, <strong>each algorithm can operate portably on any container that meets the algorithm’s minimum iterator requirements</strong>.<sup><a id="ch14fn4a" href="ch14.xhtml#ch14fn4">4</a></sup> So, an algorithm that requires <strong>forward iterators</strong> can operate on any container that provides <strong><em>at least</em> forward iterators</strong>.</p>&#13;
<p class="footnote"><a id="ch14fn4" href="ch14.xhtml#ch14fn4a">4</a>. Alexander Stepanov and Meng Lee, “The Standard Template Library, Section 2: Structure of the Library,” October 31, 1995. Accessed May 10, 2021. <code><a href="http://stepanovpapers.com/STL/DOC.PDF">http://stepanovpapers.com/STL/DOC.PDF</a></code>.</p>&#13;
<p>The <code>vector</code> and <code>array</code> containers support <strong>random-access iterators</strong>. These provide every iterator operation discussed in <a href="ch13.xhtml#sec13_3">Section 13.3</a>. This means <strong>all standard library algorithms can operate on <code>vector</code>s</strong>, and <strong>all algorithms that do not modify a container’s size can operate on <code>array</code>s</strong>.</p>&#13;
<p>Before C++20,</p>&#13;
<p class="bull">• each container’s documentation mentioned the iterator level it supported, and</p>&#13;
<p class="bull">• each algorithm’s documentation mentioned its minimum iterator requirements.</p>&#13;
<p>Programmers were expected to adhere to an algorithm’s documented requirements by using only containers with iterators that satisfied those requirements. The compiler could not prevent you from passing incorrect iterators to an algorithm, so it was easy to pass the wrong kinds of iterators. The compiler would then substitute those incorrect iterators’ types throughout the algorithm’s template definition. Bjarne Stroustrup observed that this led to “spectacularly bad error messages.”<sup><a id="ch14fn5a" href="ch14.xhtml#ch14fn5">5</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn5" href="ch14.xhtml#ch14fn5a">5</a>. Bjarne Stroustrup, “Concepts: The Future of Generic Programming—1. A bit of background,” January 31, 2017. Accessed May 8, 2021. <code><a href="http://wg21.link/p0557r0">http://wg21.link/p0557r0</a></code>.</p>&#13;
<h5 class="h5" id="ch14lev3sec8"><span class="size">20</span> C++20 Concepts</h5>&#13;
<p>One of the “big four” C++20 features is <strong>concepts</strong>—a technology for restricting the types used with templates. Stroustrup points out that “Concepts complete C++ templates as originally envisioned”<sup><a id="ch14fn6a" href="ch14.xhtml#ch14fn6">6</a></sup> decades ago. Each concept specifies a type’s requirements or a relationship between types.<sup><a id="ch14fn7a" href="ch14.xhtml#ch14fn7">7</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn6" href="ch14.xhtml#ch14fn6a">6</a>. Bjarne Stroustrup, “Concepts: The Future of Generic Programming—Conclusion,” January 31, 2017. Accessed May 8, 2021. <code><a href="http://wg21.link/p0557r0">http://wg21.link/p0557r0</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn7" href="ch14.xhtml#ch14fn7a">7</a>. Bjarne Stroustrup, “Concepts: The Future of Generic Programming—3.1 Specifying template interfaces,” January 31, 2017. Accessed May 8, 2021. <code><a href="http://wg21.link/p0557r0">http://wg21.link/p0557r0</a></code>.</p>&#13;
<p>When a concept is applied to an algorithm’s parameter, the compiler can check the requirements in the algorithm’s call before substituting the argument’s type throughout the function template. If your argument’s type does not satisfy the concept’s requirements, a benefit of concepts is that the compiler produces many fewer and much clearer error messages than for the older <strong>common-range algorithms</strong>. This makes it easier for you to understand the errors and correct your code.</p>&#13;
<p><span class="size">20</span> This chapter’s primary focus is <strong>C++20’s new range-based algorithms</strong>, which are <strong>constrained with many C++20 predefined concepts</strong>. There are 76 predefined concepts<sup><a id="ch14fn8a" href="ch14.xhtml#ch14fn8">8</a>,<a id="ch14fn9a" href="ch14.xhtml#ch14fn9">9</a></sup> in the standard. Though we’ve used standard library templates extensively in <a href="ch06.xhtml#ch06">Chapters 6</a> and <a href="ch13.xhtml#ch13">13</a> and will do so again here, we have not used concepts in the code, nor will we in this chapter. The programmers responsible for creating <strong>C++20’s range-based algorithms</strong> used concepts in the algorithms’ prototypes to specify the algorithms’ iterator and range requirements.</p>&#13;
<p class="footnote"><a id="ch14fn8" href="ch14.xhtml#ch14fn8a">8</a>. “Index of library concepts.” Accessed May 10, 2021. <code><a href="https://eel.is/c++draft/conceptindex">https://eel.is/c++draft/conceptindex</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn9" href="ch14.xhtml#ch14fn9a">9</a>. The standard also specifies 30 “exposition-only” concepts which are used for discussion purposes. “Exposition-only in the C++ standard?” Answered December 28, 2015. Accessed May 10, 2021. <code><a href="https://stackoverflow.com/questions/34493104/exposition-only-in-the-c-standard">https://stackoverflow.com/questions/34493104/exposition-only-in-the-c-standard</a></code>.</p>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> When invoking <strong>C++20’s range-based algorithms</strong>, you must pass container and iterator arguments that meet the algorithms’ requirements. So, for the algorithms we present in this chapter, we’ll mention the predefined concept names specified in the algorithms’ prototypes, and we’ll briefly explain how they constrain the algorithms’ arguments. We’ll call out the concepts with the icon you see in the margin next to this paragraph. In <a href="ch15.xhtml#ch15">Chapter 15</a>, we’ll take a template developer’s viewpoint as we demonstrate implementing custom templates with concepts.</p>&#13;
<h5 class="h5" id="ch14lev3sec9">C++20 Iterator Concepts</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> As you view the <strong>C++20 range-based algorithms</strong>’ documentation, you’ll often see in their prototypes the following <strong>C++20 iterator concepts</strong>, which are defined in namespace <code>std</code> in the <strong><code>&lt;iterator&gt;</code> header</strong>:</p>&#13;
<p class="bull">• <strong><code>input_iterator</code></strong></p>&#13;
<p class="bull">• <strong><code>output_iterator</code></strong></p>&#13;
<p class="bull">• <strong><code>forward_iterator</code></strong></p>&#13;
<p class="bull">• <strong><code>bidirectional_iterator</code></strong></p>&#13;
<p class="bull">• <strong><code>random_access_iterator</code></strong></p>&#13;
<p class="bull">• <strong><code>contiguous_iterator</code></strong></p>&#13;
<p>These specify the type requirements for the <strong>iterator categories</strong> we introduced in <a href="ch13.xhtml#ch13">Chapter 13</a>. As we present constrained algorithms here in <a href="ch14.xhtml#ch14">Chapter 14</a>, we’ll briefly introduce these concepts and others that place additional restrictions on <strong>iterators</strong>, including</p>&#13;
<p class="bull">• <strong><code>indirectly_copyable</code></strong>,</p>&#13;
<p class="bull">• <strong><code>indirectly_readable</code></strong>,</p>&#13;
<p class="bull">• <strong><code>indirectly_writable</code></strong> and</p>&#13;
<p class="bull">• <strong><code>weakly_incrementable</code></strong>.</p>&#13;
<p>For a complete list of <strong>iterator concepts</strong>, see the “C++20 iterator concepts” section at:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p755pro01" id="p755pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/iterator</pre>&#13;
<h5 class="h5" id="ch14lev3sec10"><span class="size">20</span> C++20 Range Concepts</h5>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong><code>range</code> concept</strong> describes a type with a <strong>begin iterator</strong> and an <strong>end sentinel</strong>, possibly of different types. You’ll often see the following <strong>C++20 ranges concepts</strong> in the <strong>C++20 range-based algorithms</strong>’ prototypes:</p>&#13;
<p class="bull">• <strong><code>input_range</code></strong>—a range that supports <strong><code>input_iterator</code></strong>s.</p>&#13;
<p class="bull">• <strong><code>output_range</code></strong>—a range that supports <strong><code>ouput_iterator</code></strong>s.</p>&#13;
<p class="bull">• <strong><code>forward_range</code></strong>—a range that supports <strong><code>forward_iterator</code></strong>s.</p>&#13;
<p class="bull">• <strong><code>bidirectional_range</code></strong>—a range that supports <strong><code>bidirectional_iterator</code></strong>s.</p>&#13;
<p class="bull">• <strong><code>random_access_range</code></strong>—a range that supports <strong><code>random_access_iterator</code></strong>s.</p>&#13;
<p class="bull">• <strong><code>contiguous_range</code></strong>—a range that supports <strong><code>contiguous_iterator</code></strong>s.</p>&#13;
<p>These are defined in the <strong><code>std::ranges</code> namespace</strong> in the <strong><code>&lt;ranges&gt;</code></strong> header. They specify the requirements for <strong>ranges</strong> supporting the <strong>iterator categories</strong> discussed in <a href="ch13.xhtml#ch13">Chapter 13</a>. We’ll discuss other concepts as we encounter them in the coming chapters.</p>&#13;
<h3 class="h3" id="sec14_3"><span class="violet">14.3</span> Lambdas and Algorithms</h3>&#13;
<p>You can customize the behavior of many standard library algorithms by passing a function as an argument. You saw in <a href="ch06.xhtml#ch06lev2sec2">Section 6.14.2</a> that <strong>lambda expressions define anonymous functions</strong> inside other functions and that they can manipulate the enclosing function’s local variables. Throughout this chapter, we’ll typically pass <strong>lambdas</strong> to standard library algorithms because they’re convenient for expressing small tasks.</p>&#13;
<p><a href="ch14.xhtml#fig14_1">Figure 14.1</a> revisits the standard library’s <strong><code>copy</code></strong> and <strong><code>for_each</code> algorithms</strong>, this time using the versions from <strong>C++20’s <code>std::ranges</code> namespace</strong>. Recall that <strong><code>for_each</code></strong> receives as one of its arguments a function specifying a task to perform on each container element.</p>&#13;
<div class="group" id="fig14_1">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro01" id="p14pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_01.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Lambda expressions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::array values{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>}; <span class="lgreen">// initialixze values</span>&#13;
<span class="cviolet"><strong>10</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      std::cout &lt;&lt; <span class="green">"values contains: "</span>;&#13;
<span class="cviolet"><strong>13</strong></span>      <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<pre class="pre1"><code>values contains: 1 2 3 4</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.1</strong></span> | Lambda expressions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec11">Algorithm <code>copy</code> and Common Ranges Iterator Requirements vs. C++20 Ranges Iterator Requirements</h5>&#13;
<p><span class="size">20</span> Line 9 creates an array of <code>int</code> values, which line 13 displays using an <code>ostream_iterator</code> and the <span class="violet"><strong><code>copy</code></strong></span><strong><span class="violet"> algorithm</span></strong><sup><a id="ch14fn10a" href="ch14.xhtml#ch14fn10">10</a></sup> from <strong>C++20’s <code>std::ranges</code> namespace</strong>. <a href="ch13.xhtml#sec13_6_2">Section 13.6.2</a> called the <strong>common ranges <code>std::copy</code></strong> algorithm as follows:</p>&#13;
<p class="footnote"><a id="ch14fn10" href="ch14.xhtml#ch14fn10a">10</a>. “<code>std::ranges::copy</code>, <code>std::ranges::copy_if</code>, <code>std::ranges::copy_result</code>, <code>std::rang-es::copy_if_result</code>.” Accessed April 28, 2021. <code><a href="https://en.cppreference.com/w/cpp/algorithm/ranges/copy">https://en.cppreference.com/w/cpp/algorithm/ranges/copy</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p757pro01" id="p757pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">std::copy(integers.cbegin(), integers.cend(), output);</pre>&#13;
<p>This algorithm’s documentation states that the first two arguments must be <strong>input iterators</strong> designating the beginning and end of the <strong>common range</strong> to copy. The third argument was an <strong>output iterator</strong> indicating where to copy the elements.</p>&#13;
<p>Line 13 calls the <code>std::ranges</code> version of <strong><code>copy</code></strong> with just two arguments—the <code>values</code> container and an <strong><code>ostream_iterator</code></strong>. This version of <strong><code>copy</code></strong> determines <code>values</code>’ beginning and end for you by calling</p>&#13;
<pre class="pre">std::ranges::begin(values)</pre>&#13;
<p>and</p>&#13;
<pre class="pre">std::ranges::end(values)</pre>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <strong>Any container that supports <code>begin</code> and <code>end</code> iterators can be treated as a C++20 range.</strong> The first argument to the <strong><code>std::ranges::copy</code> algorithm</strong> must be an <strong><code>input_range</code></strong>. The second must be a <strong><code>weakly_incrementable</code> output iterator</strong>—that is, it supports the <strong><code>++</code> operator</strong> for moving to the next element and can be used to output elements. Here, we write to the standard output stream, but we also could write into another <strong>range</strong>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">20</span> <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <strong>Use C++20’s range-based algorithms rather than the older common-ranges algorithms. Passing an entire container, rather than begin and end iterators, simplifies your code and eliminates accidentally mismatched iterators—that is, a begin iterator that points to one container and an end iterator that points to a different container.</strong></p>&#13;
<h5 class="h5" id="ch14lev3sec12">Algorithm <code>for_each</code></h5>&#13;
<p><span class="size">20</span> This example uses the <span class="violet"><strong><code>for_each</code></strong></span><strong><span class="violet"> algorithm</span></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong> twice. The first call in line 17 multiples each <code>values</code> element by 2 and displays the result:</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p757pro02" id="p757pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// output each element multiplied by two</span>&#13;
<span class="cviolet"><strong>16</strong></span>   std::cout &lt;&lt; <span class="green">"\nDisplay each element multiplied by two: "</span>;&#13;
<span class="cviolet"><strong>17</strong></span>   std::ranges::for_each(values, [](<span class="blue">auto</span> i) {std::cout &lt;&lt; i * <span class="green">2</span> &lt;&lt; <span class="green">" "</span>;});&#13;
<span class="cviolet"><strong>18</strong></span></pre>&#13;
<pre class="pre1"><code>Display each element multiplied by two: 2 4 6 8</code></pre>&#13;
</div>&#13;
<p><a href="ch11.xhtml#sec11_6_13">Section 11.6.13</a> called the <strong>common ranges <code>std::for_each</code> algorithm</strong> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p757pro03" id="p757pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">for_each(begin(items), end(items), [](<span class="blue">auto</span>&amp; item){++item;});</pre>&#13;
<p>In that call, the first two arguments are <strong>input iterators</strong> designating the beginning and end of a <strong>common range</strong> of elements to process. The third is a <strong>lambda</strong> specifying the task to perform on each element.</p>&#13;
<p>Line 17 calls the <strong><code>std::ranges::for_each</code> algorithm</strong>, which has <strong>two arguments</strong>:</p>&#13;
<p class="bull"><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> • an <strong><code>input_range</code></strong> (<code>values</code>) containing the elements to copy, and</p>&#13;
<p class="bull"><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> • a function with one argument, which is allowed, but not required, to modify its argument in the range. The <strong><code>for_each</code> algorithm</strong> describes this parameter with the concept <strong><code>indirectly_unary_invocable</code></strong>, meaning <strong>a function that accesses a value indirectly by dereferencing the function’s iterator argument</strong>.</p>&#13;
<p>The <strong><code>for_each</code> algorithm</strong> repeatedly calls the function in its second argument, passing one element at a time from its <strong><code>input_range</code></strong> argument. For a complete list of <strong>indirect callable concepts</strong> like <strong><code>indirectly_unary_invocable</code></strong>, see the “Algorithm concepts and utilities” section at:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p758pro01" id="p758pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/iterator</pre>&#13;
<h5 class="h5" id="ch14lev3sec13">Lambda with an Empty Introducer</h5>&#13;
<p>The <strong>lambda</strong> in line 17 multiplies its parameter <code>i</code> by 2 and displays the result. Recall that <strong>lambdas</strong> begin with the <strong>lambda introducer (<code>[]</code>)</strong>, followed by a parameter list and function body. <strong>This lambda introducer is empty, so it does not capture any of <code>main</code>’s local variables</strong>. The parameter’s type is <code>auto</code>, so this is a generic lambda for which the compiler infers the type, based on the context. Since <code>values</code> contains <code>int</code>s, the compiler infers parameter <code>i</code>’s type as <code>int</code>.</p>&#13;
<p>The line 17 lambda is similar to the standalone function</p>&#13;
<pre class="pre"><span class="blue">void</span> timesTwo(<span class="blue">int</span> i) {&#13;
   cout &lt;&lt; i * <span class="green">2</span> &lt;&lt; <span class="green">" "</span>;&#13;
}</pre>&#13;
<p>Had we defined this function, we could have passed it to <strong><code>for_each</code></strong>, as in</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p758pro02" id="p758pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">std::ranges::for_each(values, timesTwo);</pre>&#13;
<h5 class="h5" id="ch14lev3sec14">Lambda with a Nonempty Introducer—Capturing Local Variables</h5>&#13;
<p>Line 21 calls <strong><code>for_each</code></strong> to total the elements of <code>values</code>. The <strong>lambda introducer <code>[&amp;sum]</code></strong> in</p>&#13;
<pre class="pre">[&amp;sum](<span class="blue">auto</span> i) {sum += i;}</pre>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <strong>captures</strong><sup><a id="ch14fn11a" href="ch14.xhtml#ch14fn11">11</a></sup> <strong>the local variable <code>sum</code></strong> (defined in line 20) <strong>by reference</strong><sup><a id="ch14fn12a" href="ch14.xhtml#ch14fn12">12</a></sup> (<code>&amp;</code>), so the lambda can modify <code>sum</code>’s value. The <strong><code>for_each</code> algorithm</strong> passes each element of <code>values</code> to the lambda, which adds the element to the <code>sum</code>. Line 22 displays the <code>sum</code>. <strong>Without the ampersand, <code>sum</code> would be captured by value,</strong><sup><a id="ch14fn13a" href="ch14.xhtml#ch14fn13">13</a></sup> <strong>so lambda would not modify the local variable in the enclosing function’s scope</strong>.</p>&#13;
<p class="footnote"><a id="ch14fn11" href="ch14.xhtml#ch14fn11a">11</a>. “F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function).” Accessed April 30, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-capture-vs-overload">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-capture-vs-overload</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn12" href="ch14.xhtml#ch14fn12a">12</a>. “F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms.” Accessed April 30, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-reference-capture">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-reference-capture</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn13" href="ch14.xhtml#ch14fn13a">13</a>. “F.53: Avoid capturing by reference in lambdas that will be used non-locally, including returned, stored on the heap, or passed to another thread.” Accessed April 30, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-value-capture">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-value-capture</a></code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p759pro01" id="p759pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>19</strong></span>      <span class="lgreen">// add each element to sum</span>&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">int</span> sum{<span class="green">0</span>}; <span class="lgreen">// initialize sum to zero</span>&#13;
<span class="cviolet"><strong>21</strong></span>      std::ranges::for_each(values, [&amp;sum](<span class="blue">auto</span> i) {sum += i;});&#13;
<span class="cviolet"><strong>22</strong></span>      std::cout &lt;&lt; <span class="green">"\nSum of value's elements is: "</span> &lt;&lt; sum &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>23</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Sum of values</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec15">Lambda Introducers <code>[&amp;]</code> and <strong><code>[=]</code></strong></h5>&#13;
<p>A <strong>lambda introducer</strong> can capture multiple variables from the enclosing function’s scope by providing a comma-separated list of variables. You also may capture multiple variables using <strong>lambda introducers</strong> of the form <code>[&amp;]</code> or <code>[=]</code>:</p>&#13;
<p class="bull">• The <strong><span class="violet">lambda introducer</span></strong> <span class="violet"><strong><code>[&amp;]</code></strong></span> indicates that every variable from the enclosing scope used in the <strong>lambda’s body</strong> should be captured <strong>by reference</strong>.</p>&#13;
<p class="bull">• The <strong><span class="violet">lambda introducer</span></strong> <span class="violet"><strong><code>[=]</code></strong></span> indicates that every variable from the enclosing scope used in the <strong>lambda’s body</strong> should be captured <strong>by value</strong>.</p>&#13;
<h5 class="h5" id="ch14lev3sec16">Lambda Return Types</h5>&#13;
<p>The compiler can infer a <strong>lambda’s return type</strong> if the body contains a statement of the form</p>&#13;
<pre class="pre"><span class="blue">return</span> <em>expression</em><code>;</code></pre>&#13;
<p>Otherwise, the <strong>lambda’s return type</strong> is <code>void</code> unless you explicitly specify a return type using C++11’s <strong><span class="violet">trailing return type</span></strong> syntax (<code>-&gt;</code> <em>type</em>), as in</p>&#13;
<pre class="pre"><code>[](</code><em>parameterList</em><code>) -&gt;</code> <em>type</em> <code>{</code><em>lambdaBody</em><code>}</code></pre>&#13;
<p>The trailing return type is placed between the parameter list’s closing right parenthesis and the lambda’s body.</p>&#13;
<h3 class="h3" id="sec14_4"><span class="violet">14.4</span> Algorithms<sup><a id="ch14fn14a" href="ch14.xhtml#ch14fn14">14</a></sup></h3>&#13;
<p class="footnote"><a id="ch14fn14" href="ch14.xhtml#ch14fn14a">14</a>. Most of the algorithms we present are the new C++20 <code>std::ranges</code> versions.</p>&#13;
<p><a href="ch14.xhtml#sec14_4_1">Sections 14.4.1</a>–<a href="ch14.xhtml#sec14_4_12">14.4.12</a> demonstrate many of the standard library algorithms.</p>&#13;
<h4 class="h4" id="sec14_4_1">14.4.1 <code>fill</code>, <code>fill_n</code>, <code>generate</code> and <code>generate_n</code></h4>&#13;
<p><span class="size">20</span> <a href="ch14.xhtml#fig14_2">Figure 14.2</a> demonstrates algorithms <strong><code>fill</code></strong>, <strong><code>fill_n</code></strong>, <strong><code>generate</code></strong> and <strong><code>generate_n</code></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong>:</p>&#13;
<p class="bull">• Algorithms <span class="violet"><strong><code>fill</code></strong></span> and <span class="violet"><strong><code>fill_n</code></strong></span> set every element in a range of container elements to a specific value.</p>&#13;
<p class="bull">• Algorithms <span class="violet"><strong><code>generate</code></strong></span> and <span class="violet"><strong><code>generate_n</code></strong></span> use a <strong><span class="violet">generator function</span></strong> to create values for every element in a range of container elements. The generator function takes no arguments and returns a value.</p>&#13;
<p>Lines 9–12 define a generator function <code>nextLetter</code> as a standalone function. We’ll also implement this as a lambda, so you can see the similarities. Line 15 defines a 10-element <code>char</code> array <code>chars</code> that we’ll manipulate in this example.</p>&#13;
<div class="group" id="fig14_2">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro02" id="p14pro02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_02.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms fill, fill_n, generate and generate_n.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt; <span class="lgreen">// algorithm definitions</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt; <span class="lgreen">// array class-template definition</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// generator function returns next letter (starts with A)</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">char</span> nextLetter() {&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">static char</span> letter{<span class="green">'A'</span>};&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">return</span> letter++;&#13;
<span class="cviolet"><strong>12</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>15</strong></span>      std::array&lt;<span class="blue">char</span>, <span class="green">10</span>&gt; chars{};<br/></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.2</strong></span> | Algorithms <code>fill</code>, <code>fill_n</code>, <code>generate</code> and <code>generate_n</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec17"><code>fill</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Line 16 uses the <strong>C++20</strong> <code><strong>std::ranges::</strong><span class="violet"><strong>fill algorithm</strong></span></code> to place the character in every <code>chars</code> element. The first argument must be an <strong><code>output_range</code></strong> so that the algorithm can</p>&#13;
<p class="bull">• iterate from the beginning to the end of the <strong>range</strong> by incrementing its <strong>iterator</strong> with <code>++</code>, and</p>&#13;
<p class="bull">• <strong>dereference the iterator</strong> to write a new value into the current element.</p>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> An <code>array</code> has <strong><code>contiguous_iterator</code>s</strong>, which support all <strong>iterator</strong> operations. So, <strong><code>fill</code></strong> can increment the iterators with ++. Also, the array <code>chars</code> is non-<code>const</code>, so <strong><code>fill</code></strong> can <strong>dereference the iterators</strong> to write values into the <strong>range</strong>. Line 20 displays <code>chars</code>’ elements. We used bold text in the outputs to highlight the changes made to <code>chars</code> by each algorithm.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p760pro01" id="p760pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>16</strong></span>   std::ranges::fill(chars, <span class="green">'5'</span>); <span class="lgreen">// fill chars with 5s</span>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>   std::cout &lt;&lt; <span class="green">"chars after filling with 5s: "</span>;&#13;
<span class="cviolet"><strong>19</strong></span>   std::ostream_iterator&lt;<span class="blue">char</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>20</strong></span>   <code>std::ranges::copy(chars, output);</code>&#13;
<span class="cviolet"><strong>21</strong></span></pre>&#13;
<pre class="pre1"><code>chars after filling with 5s:</code> <strong><code>5 5 5 5 5 5 5 5 5 5</code></strong></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec18"><code>fill_n</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Line 23 uses the <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">fill_n algorithm</span></strong></code> to place the character (the third argument) in <code>chars</code>’ first five elements (specified by the second argument). The first argument must be at least an <strong><code>output_iterator</code></strong>. <code>array</code>s support <strong><code>contiguous_iterator</code>s</strong> and <code>chars</code> is non-<code>const</code>, so calling <code>chars.begin()</code> returns an <strong>iterator</strong> that can be used to write values into the <strong>range</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p761pro01" id="p761pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>22</strong></span>   <span class="lgreen">// fill first five elements of chars with 'A's</span>&#13;
<span class="cviolet"><strong>23</strong></span>   std::ranges::fill_n(chars.begin(), <span class="green">5</span>, <span class="green">'A'</span>);&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>   std::cout &lt;&lt; <span class="green">"\nchars after filling five elements with 'A's: "</span>;&#13;
<span class="cviolet"><strong>26</strong></span>   <code>std::ranges::copy(chars, output);</code>&#13;
<span class="cviolet"><strong>27</strong></span></pre>&#13;
<pre class="pre1"><code>chars after filling five elements with</code> <strong><code>A A A A A</code></strong> <code>5 5 5 5 5</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec19"><code>generate</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Line 29 uses the <strong>C++20 <code>std::ranges::</code></strong> <span class="violet"><strong><code>generate algorithm</code></strong></span> to place the result of a call to <strong>generator function</strong> <code>nextLetter</code> in every element of <code>chars</code>. The first argument must be an <strong><code>output_range</code></strong>. Function <code>nextLetter</code> (lines 9–12) defines a <code>static</code> local <code>char</code> variable <code>letter</code> and initializes it to . Line 11 returns the current <code>letter</code> value, postincrementing it for use in the next call to the function.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p761pro02" id="p761pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>28</strong></span>   <span class="lgreen">// generate values for all elements of chars with nextLetter</span>&#13;
<span class="cviolet"><strong>29</strong></span>   <code>std::ranges::generate(chars, nextLetter);</code>&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>   std::cout &lt;&lt; <span class="green">"\nchars after generating letters A-J: "</span>;&#13;
<span class="cviolet"><strong>32</strong></span>   <code>std::ranges::copy(chars, output);</code>&#13;
<span class="cviolet"><strong>33</strong></span></pre>&#13;
<pre class="pre1"><code>chars after generating letters A-J:</code>  <strong>A B C D E F G H I J</strong></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec20"><code>generate_n</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Line 35 uses the <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">generate_n algorithm</span></strong></code> to place the result of each call to <strong>generator function</strong> <code>nextLetter</code> in five elements of <code>chars</code>, starting from <code>chars.begin()</code>. The first argument must be an <strong><code>input_or_output_iterator</code></strong>, which is an <strong>iterator</strong> that can be incremented with <code>++</code> and <strong>dereferenced with <code>*</code></strong>. All iterators satisfy this requirement. The first argument’s <strong>iterator</strong> also must be <strong><code>indirectly_writable</code></strong>—when the algorithm <strong>dereferences the iterator</strong>, it must be able to write a new value into the <strong>dereferenced element</strong> in the range.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p761pro03" id="p761pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>34</strong></span>   <span class="lgreen">// generate values for first five elements of chars with nextLetter</span>&#13;
<span class="cviolet"><strong>35</strong></span>   std::ranges::generate_n(chars.begin(), <span class="green">5</span>, nextLetter);&#13;
<span class="cviolet"><strong>36</strong></span>&#13;
<span class="cviolet"><strong>37</strong></span>   std::cout &lt;&lt; <span class="green">"\nchars after generating K-O into elements 0-4: "</span>;&#13;
<span class="cviolet"><strong>38</strong></span>   <code>std::ranges::copy(chars, output);</code>&#13;
<span class="cviolet"><strong>39</strong></span></pre>&#13;
<pre class="pre1"><code>chars after generating K-O into elements 0-4:</code> <strong><code>K L M N O</code></strong> <code>F G H I J</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec21">Using the <code>generate_n</code> Algorithm with a Lambda</h5>&#13;
<p><span class="size">20</span> Lines 41–46 once again use the <strong>C++20 <code>std::ranges::generate_n</code> algorithm</strong> to place the result of a <strong>generator function</strong> call into <code>chars</code> elements, starting from <code>chars.begin()</code>. In this case, the <strong>generator function</strong> is implemented as a lambda (lines 42–45) with no arguments—as specified by the empty parentheses—that returns a generated letter. For a lambda with no arguments, the parameter list’s parentheses are not required. The compiler infers from the <code>return</code> statement that the <strong>lambda’s return type</strong> is <code>char</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p762pro01" id="p762pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>40</strong></span>   <span class="lgreen">// generate values for first three elements of chars with a lambda</span>&#13;
<span class="cviolet"><strong>41</strong></span>      std::ranges::generate_n(chars.begin(), <span class="green">3</span>,&#13;
<span class="cviolet"><strong>42</strong></span>         [](){ <span class="lgreen">// lambda that takes no arguments</span>&#13;
<span class="cviolet"><strong>43</strong></span>               <span class="blue">static char</span> letter{<span class="green">'A'</span>};&#13;
<span class="cviolet"><strong>44</strong></span>               <span class="blue">return</span> letter++;&#13;
<span class="cviolet"><strong>45</strong></span>         <code>}</code>&#13;
<span class="cviolet"><strong>46</strong></span>      <code>);</code>&#13;
<span class="cviolet"><strong>47</strong></span>&#13;
<span class="cviolet"><strong>48</strong></span>      std::cout &lt;&lt; <span class="green">"\nchars after generating A-C into elements 0-2: "</span>;&#13;
<span class="cviolet"><strong>49</strong></span>      <code>std::ranges::copy(chars, output);</code>&#13;
<span class="cviolet"><strong>50</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>51</strong></span>   }</pre>&#13;
<pre class="pre1"><code>chars after generating A-C into elements 0-2:</code> <strong><code>A B C</code></strong> <code>N O F G H I J</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_2">14.4.2 <code>equal</code>, <code>mismatch</code> and <code>lexicographical_compare</code></h4>&#13;
<p><span class="size">20</span> <a href="ch14.xhtml#fig14_3">Figure 14.3</a> demonstrates comparing sequences of values for equality using algorithms <strong><code>equal</code></strong>, <strong><code>mismatch</code></strong> and <strong><code>lexicographical_compare</code></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong>. Lines 12–14 create and initialize three <code>array</code>s, then lines 17–22 display their contents.</p>&#13;
<div class="group" id="fig14_3">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro03" id="p14pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_03.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms equal, mismatch and lexicographical_compare.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt; <span class="lgreen">// algorithm definitions</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt; <span class="lgreen">// array class-template definition</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// C++20: This will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iomanip&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>12</strong></span>      std::array a1{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>, <span class="green">7</span>, <span class="green">8</span>, <span class="green">9</span>, <span class="green">10</span>};&#13;
<span class="cviolet"><strong>13</strong></span>      std::array a2{a1}; <span class="lgreen">// initializes a2 with copy of a1</span>&#13;
<span class="cviolet"><strong>14</strong></span>      std::array a3{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">1000</span>, <span class="green">6</span>, <span class="green">7</span>, <span class="green">8</span>, <span class="green">9</span>, <span class="green">10</span>};&#13;
<span class="cviolet"><strong>15</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      std::cout &lt;&lt; <span class="green">"a1 contains: "</span>;&#13;
<span class="cviolet"><strong>18</strong></span>      <code>std::ranges::copy(a1, output);</code>&#13;
<span class="cviolet"><strong>19</strong></span>      std::cout &lt;&lt; <span class="green">"\na2 contains: "</span>;&#13;
<span class="cviolet"><strong>20</strong></span>      <code>std::ranges::copy(a2, output);</code>&#13;
<span class="cviolet"><strong>21</strong></span>      std::cout &lt;&lt; <span class="green">"\na3 contains: "</span>;&#13;
<span class="cviolet"><strong>22</strong></span>      <code>std::ranges::copy(a3, output);</code>&#13;
<span class="cviolet"><strong>23</strong></span><br/></pre>&#13;
<pre class="pre1"><code>a1 contains: 1 2 3 4 5 6 7 8 9 10</code>&#13;
<code>a2 contains: 1 2 3 4 5 6 7 8 9 10</code>&#13;
<code>a3 contains: 1 2 3 4 1000 6 7 8 9 10</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.3</strong></span> | Algorithms <code>equal</code>, <code>mismatch</code> and <code>lexicographical_compare</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec22"><code>equal</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Lines 26 and 30 use the <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">equal algorithm</span></strong></code> to compare two <strong><code>input_range</code></strong>s for equality. The algorithm returns <code>false</code> if the sequences are not the same length. Otherwise, it compares each <strong>range</strong>’s corresponding elements with the <code>== operator</code>, returning <code>true</code> if they’re all equal and <code>false</code> otherwise. Line 26 compares the elements in <code>a1</code> to the elements in <code>a2</code>. In this example, <code>a1</code> and <code>a2</code> are equal. Line 30 compares <code>a1</code> and <code>a3</code>, which are not equal.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p763pro01" id="p763pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>24</strong></span>   <span class="lgreen">// compare a1 and a2 for equality</span>&#13;
<span class="cviolet"><strong>25</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"\n\na1 is equal to a2: {}\n"</span>,&#13;
<span class="cviolet"><strong>26</strong></span>                   <code>std::ranges::equal(a1, a2));</code>&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="lgreen">// compare a1 and a3 for equality</span>&#13;
<span class="cviolet"><strong>29</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"a1 is equal to a3: {}\n"</span>,&#13;
<span class="cviolet"><strong>30</strong></span>                   <code>std::ranges::equal(a1, a3));</code>&#13;
<span class="cviolet"><strong>31</strong></span></pre>&#13;
<pre class="pre1"><code>a1 is equal to a2: true</code>&#13;
<code>a1 is equal to a3: false</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec23"><code>equal</code> Algorithm with Binary Predicate Function</h5>&#13;
<p>Many standard library algorithms that compare elements enable you to pass a function that customizes how elements are compared. For example, you can pass to the <strong><code>equal</code> algorithm</strong> a function that receives as arguments the two elements <code>equal</code> is comparing and returns a <code>bool</code> value telling <code>equal</code> whether those elements are equal. Because the function receives two arguments and returns a <code>bool</code>, it’s referred to as a <strong>binary predicate function</strong>. This can be useful in ranges containing objects for which an <code>==</code> operator is not defined or containing pointers. For example, you can compare <code>Employee</code> objects for age, ID number, or location rather than comparing entire objects. You can compare what pointers refer to rather than comparing the addresses stored in the pointers.</p>&#13;
<p><span class="size">20</span> The <strong>C++20 <code>std::ranges</code> algorithms</strong> also support <strong>projections</strong>, which enable algorithms to process subsets of each object in a <strong>range</strong>. For example, to sort <code>Employee</code> objects by their salaries, you can use a <strong>projection</strong> that selects each <code>Employee</code>’s salary. While sorting the <code>Employee</code>s, they’d be compared only by their salaries to determine sort order and the <code>Employee</code> objects would be arranged accordingly. We’ll perform this sort in <a href="ch14.xhtml#sec14_6">Section 14.6</a>.</p>&#13;
<h5 class="h5" id="ch14lev3sec24"><code>mismatch</code> Algorithm</h5>&#13;
<p><span class="size">20</span> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">mismatch algorithm</span></strong></code> (line 33) compares two <strong><code>input_range</code></strong>s. The algorithm returns a <code>std::ranges::</code><span class="violet"><strong><code>mismatch_result</code></strong></span>, which contains <strong>iterators</strong> named <code>in1</code> and <code>in2</code>, pointing to the mismatched elements in each <strong>range</strong>. If all the elements match, the <code>in1</code> is equal to the first <strong>range</strong>’s <strong>sentinel</strong>, and <code>in2</code> is equal to the second <strong>range</strong>’s <strong>sentinel</strong>. We infer the variable <code>location</code>’s type with <code>auto</code> (line 33). Line 35 determines the index of the mismatch with the expression</p>&#13;
<pre class="pre"><code>location.in1 - a1.begin()</code></pre>&#13;
<p>which evaluates to the number of elements between the <strong>iterators</strong>—this is analogous to pointer arithmetic (<a href="ch07.xhtml#ch07">Chapter 7</a>). Like <code>equal</code>, <code>mismatch</code> can receive a <strong>binary predicate function</strong> to customize the comparisons (<a href="ch14.xhtml#sec14_6">Section 14.6</a>).</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p764pro01" id="p764pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>32</strong></span>   <span class="lgreen">// check for mismatch between a1 and a3</span>&#13;
<span class="cviolet"><strong>33</strong></span>   <span class="blue">auto</span> location{std::ranges::mismatch(a1, a3)};&#13;
<span class="cviolet"><strong>34</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"a1 and a3 mismatch at index {} ({} vs. {})\n"</span>,&#13;
<span class="cviolet"><strong>35</strong></span>                   <code>(location.in1 - a1.begin()),</code>&#13;
<span class="cviolet"><strong>36</strong></span>                   <code>*location.in1, *location.in2);</code>&#13;
<span class="cviolet"><strong>37</strong></span></pre>&#13;
<pre class="pre1"><code>a1 and a3 mismatch at index 4 (5 vs. 1000)</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec25">A Note Regarding <code>auto</code> and Algorithm Return Types</h5>&#13;
<p>Template type declarations can become complex and error-prone quickly, as is commonly the case for standard library <strong>algorithm</strong> return types. Throughout this chapter, when we initialize a variable with an <strong>algorithm</strong>’s return value (as in line 33), we’ll use <strong><code>auto</code></strong> to infer the variable’s type. To help you understand why, consider the return type for the <strong><code>std::ranges::mismatch</code> algorithm</strong> used in line 33:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p764pro02" id="p764pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>std::ranges::mismatch_result&lt;borrowed_iterator_t&lt;R1&gt;,</code>&#13;
   <code>borrowed_iterator_t&lt;R2&gt;&gt;</code></pre>&#13;
<p><code>R1</code> and <code>R2</code> are the types of the <strong>ranges</strong> passed to <code>mismatch</code>. Based on the declarations of <code>a1</code> and <code>a3</code>, the algorithm’s return type in line 33 is</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p764pro03" id="p764pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">std::ranges::mismatch_result&lt;borrowed_iterator_t&lt;array&lt;<span class="blue">int</span>, <span class="green">10</span>&gt;&gt;,&#13;
   borrowed_iterator_t&lt;array&lt;i<span class="blue">nt,</span> <span class="green">10</span>&gt;&gt;&gt;</pre>&#13;
<p>As you can see, it’s much more convenient to simply say <strong><code>auto</code></strong> and let the compiler determine this complex declaration for you.</p>&#13;
<h5 class="h5" id="ch14lev3sec26"><code>lexicographical_compare</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">lexicographical_compare algorithm</span></strong></code> (lines 42–43) compares the contents of two <strong><code>input_range</code></strong>s—in this case, <code>string</code>s. Like containers, <strong><code>string</code>s have iterators that enable them to be treated as C++20 ranges</strong>. While iterating through the <strong>ranges</strong>, if there is a mismatch between their corresponding elements and the element in the first <strong>range</strong> is <strong>less than</strong> the corresponding element in the second, the algorithm returns <code>true</code>. Otherwise, the algorithm returns <code>false</code>. This algorithm can be used to arrange sequences lexicographically. It also can receive a <strong>binary predicate function</strong> that returns true if its first argument is less than its second.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p764pro04" id="p764pro04a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>38</strong></span>   std::string s1{<span class="green">"HELLO"</span>};&#13;
<span class="cviolet"><strong>39</strong></span>   std::string s2{<span class="green">"BYE BYE"</span>};&#13;
<span class="cviolet"><strong>40</strong></span>&#13;
<span class="cviolet"><strong>41</strong></span>   <span class="lgreen">// perform lexicographical comparison of c1 and c2</span>&#13;
<span class="cviolet"><strong>42</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"\"{}\" &lt; \"{}\": {}\n"</span>, s1, s2,&#13;
<span class="cviolet"><strong>43</strong></span>                   <code>std::ranges::lexicographical_compare(s1, s2));</code>&#13;
<span class="cviolet"><strong>44</strong></span>   }</pre>&#13;
<pre class="pre1"><code>"HELLO" &lt; "BYE BYE": false</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_3">14.4.3 <code>remove</code>, <code>remove_if</code>, <code>remove_copy</code> and <code>remove_copy_if</code></h4>&#13;
<p><a href="ch14.xhtml#fig14_4">Figure 14.4</a><sup><a id="ch14fn15a" href="ch14.xhtml#ch14fn15">15</a></sup> demonstrates removing values from a sequence with algorithms <strong><code>remove</code></strong>, <strong><code>remove_if</code></strong>, <strong><code>remove_copy</code></strong> and <strong><code>remove_copy_if</code></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong>. Line 9 creates a <code>vector&lt;int&gt;</code> that we’ll use to initialize other <code>vector</code>s in this example.</p>&#13;
<p class="footnote"><a id="ch14fn15" href="ch14.xhtml#ch14fn15a">15</a>. As of May 2021, <code>std::ranges::remove</code> did not compile on the most recent <code>clang++</code> compiler.</p>&#13;
<div class="group" id="fig14_4">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro04" id="p14pro04a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_04.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms remove, remove_if, remove_copy and remove_copy_if.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt; <span class="lgreen">// algorithm definitions</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::vector init{<span class="green">10</span>, <span class="green">2</span>, <span class="green">15</span>, <span class="green">4</span>, <span class="green">10</span>, <span class="green">6</span>};&#13;
<span class="cviolet"><strong>10</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>11</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.4</strong></span> | Algorithms <code>remove</code>, <code>remove_if</code>, <code>remove_copy</code> and <code>remove_copy_if</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec27"><code>remove</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Lines 12–14 create initialize the vector <code>v1</code> with a copy of <code>init</code>’s elements, then output <code>v1</code>’s contents. Line 17 uses the <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">remove algorithm</span></strong></code> to eliminate from <code>v1</code> all elements with the value <code>10</code>. The first argument must be a <strong><code>forward_range</code></strong>—a range that supports <strong><code>forward_iterator</code></strong>s. A <code>vector</code> supports more powerful <strong><code>random_access_iterator</code></strong>s, so a <code>vector</code> can work with this algorithm and any other algorithm that requires lesser iterators. This algorithm does not modify the container’s number of elements and does not destroy the eliminated elements. Instead, it places at the beginning of the container all elements that are not eliminated. It returns an <strong>iterator/sentinel pair</strong> representing the subrange of container’s elements that are no longer valid. <strong>Those elements should not be used, so they’re commonly erased from the container</strong>, as we’ll discuss momentarily.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p765pro01" id="p765pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>12</strong></span>   std::vector v1{init}; <span class="lgreen">// initialize with copy of init</span>&#13;
<span class="cviolet"><strong>13</strong></span>   std::cout &lt;&lt; <span class="green">"v1: "</span>;&#13;
<span class="cviolet"><strong>14</strong></span>   <code>std::ranges::copy(v1, output);</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="lgreen">// remove all 10s from v1</span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="blue">const auto</span>&amp; [begin1, end1]{std::ranges::remove(v1, <span class="green">10</span>)};&#13;
<span class="cviolet"><strong>18</strong></span>   <code>v1.erase(begin1, end1);</code>&#13;
<span class="cviolet"><strong>19</strong></span>   std::cout &lt;&lt; <span class="green">"\nv1 after removing 10s: "</span>;&#13;
<span class="cviolet"><strong>20</strong></span>   <code>std::ranges::copy(v1, output);</code>&#13;
<span class="cviolet"><strong>21</strong></span></pre>&#13;
<pre class="pre1"><code>v1: 10 2 15 4 10 6</code>&#13;
<code>v1 after removing 10s: 2 15 4 6</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec28"><span class="size">17</span> C++17 Structured Bindings</h5>&#13;
<p>Line 17 uses the <strong>iterator/sentinel pair</strong> returned by <code>remove</code> to initialize the reference (<code>&amp;</code>) variables <code>begin1</code> and <code>end1</code> using a C++17 <strong><span class="violet">structured binding declaration</span></strong>.<sup><a id="ch14fn16a" href="ch14.xhtml#ch14fn16">16</a>,<a id="ch14fn17a" href="ch14.xhtml#ch14fn17">17</a></sup> This is sometimes referred to as <strong><span class="violet">unpacking the elements</span></strong> and can be used to extract into individual variables the elements of a built-in array, <code>array</code> object or tuple. Here, the <strong>iterator</strong> is assigned to <code>begin1</code> and the <strong>sentinel</strong> to <code>end1</code>. <strong>Structured bindings</strong> also can be used to unpack the <code>public</code> data members of a <code>struct</code> or class <code>object</code> and the elements of any container with a size that’s known at compile-time, such as an <code>array</code> or <code>tuple</code>.</p>&#13;
<p class="footnote"><a id="ch14fn16" href="ch14.xhtml#ch14fn16a">16</a>. “Structured binding declaration.” Accessed May 1, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/structured_binding">https://en.cppreference.com/w/cpp/language/structured_binding</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn17" href="ch14.xhtml#ch14fn17a">17</a>. Dominik Berner, “Quick and easy unpacking in C++ with structured bindings.” May 24, 2018. Accessed May 4, 2021. <code><a href="https://dominikberner.ch/structured-bindings/">https://dominikberner.ch/structured-bindings/</a></code>.</p>&#13;
<h5 class="h5" id="ch14lev3sec29"><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Erase/Remove Idiom</h5>&#13;
<p>Line 18 uses the <strong><code>vector</code></strong>’s <strong><code>erase</code></strong> member function to delete the <strong><code>vector</code></strong> elements that are no longer valid—this reduces the <strong><code>vector</code></strong>’s size to its actual number of elements. Line 20 outputs the updated contents of <code>v1</code>.</p>&#13;
<p>The <code>&lt;vector&gt;</code> header contains common-range algorithms for removing elements from a <strong><code>vector</code></strong> and reducing the <strong><code>vector</code></strong>’s size—<strong><code>std::erase</code></strong> and <strong><code>std::erase_if</code></strong>. Each suffers from a performance problem. As each removes a vector element, it immediately shifts the remaining elements to the beginning of the <strong><code>vector</code></strong> and resizes the <strong><code>vector</code></strong>. This occurs for every item removed, resulting in many additional passes of the <strong><code>vector</code></strong>.</p>&#13;
<p>When eliminating elements from a <strong><code>vector</code></strong>, it’s a good practice to use the <strong><span class="violet">erase-remove idiom</span></strong>.<sup><a id="ch14fn18a" href="ch14.xhtml#ch14fn18">18</a></sup> You remove elements via the <strong><code>remove</code></strong> or <strong><code>remove_if</code></strong> algorithms, then call the <strong><code>vector</code></strong>’s <strong><code>erase</code></strong> member function to reduce the container’s size. Though the <strong><code>remove</code></strong> or <strong><code>remove_if</code></strong> algorithms also shift the <strong><code>vector</code></strong>’s remaining elements to the beginning of the container, <strong>they do so in a single pass</strong>, rather than multiple passes, making them more efficient than <strong><code>std::erase</code></strong> and <strong><code>std::erase_if</code></strong>. You can then pass the <strong>iterators</strong> that <strong><code>remove</code></strong> or <strong><code>remove_if</code></strong> return to the <strong><code>vector</code></strong>’s <strong><code>erase</code></strong> member function remove the invalid <strong><code>vector</code></strong> elements all at once, rather than once per item erased.</p>&#13;
<p class="footnote"><a id="ch14fn18" href="ch14.xhtml#ch14fn18a">18</a>. “Erase–remove idiom.” Accessed May 5, 2021. <code><a href="https://en.wikipedia.org/wiki/Erase-remove_idiom">https://en.wikipedia.org/wiki/Erase-remove_idiom</a>.</code></p>&#13;
<p>The <strong>common-range <code>std::remove</code></strong> or <strong><code>std::remove_if</code> algorithms</strong> each return a single <strong>iterator</strong> pointing to the first invalid element in the <strong><code>vector</code></strong>. When using these <strong>common-range algorithms</strong>, you can perform the <strong>erase-remove idiom</strong> in one statement, as in:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p766pro01" id="p766pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">v1.erase(std::remove(v1.begin(), v1.end(), <span class="green">10</span>), v1.end());</pre>&#13;
<p>Unfortunately, container member functions like <strong><code>erase</code></strong> do not yet support C++20 ranges. So, when working with <strong><code>std::ranges::remove</code></strong> and <strong><code>std::ranges::remove_if</code></strong>, which return <strong>iterator pairs</strong> representing a <strong>range</strong> of invalid elements, you perform the <strong>erase-remove idiom</strong> in two statements (as in lines 17–18).</p>&#13;
<h5 class="h5" id="ch14lev3sec30"><code>remove_copy</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Line 28 uses the <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">remove_copy algorithm</span></strong></code> to copy all of <code>v2</code>’s elements that do not have the value <code>10</code> into the vector <code>c1</code>. The first argument must be an <strong><code>input_range</code></strong>, which supports <strong><code>input_iterator</code></strong>s for reading from a range. Again, a <code>vector</code> supports more powerful <strong><code>random_access_iterator</code></strong>s, so it meets <strong><code>remove_copy</code></strong>’s minimum requirements. We’ll discuss the second argument in a moment. Line 30 outputs all of <code>c1</code>’s elements.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p767pro01" id="p767pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>22</strong></span>   std::vector v2{init}; <span class="lgreen">// initialize with copy of init</span>&#13;
<span class="cviolet"><strong>23</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nv2: "</span>;&#13;
<span class="cviolet"><strong>24</strong></span>   <code>std::ranges::copy(v2, output);</code>&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="lgreen">// copy from v2 to c1, removing 10s in the process</span>&#13;
<span class="cviolet"><strong>27</strong></span>   std::vector&lt;<span class="blue">int</span>&gt; c1{};&#13;
<span class="cviolet"><strong>28</strong></span>   std::ranges::remove_copy(v2, std::back_inserter(c1), <span class="green">10</span>);&#13;
<span class="cviolet"><strong>29</strong></span>   std::cout &lt;&lt; <span class="green">"\nc1 after copying v2 without 10s: "</span>;&#13;
<span class="cviolet"><strong>30</strong></span>   <code>std::ranges::copy(c1, output);</code>&#13;
<span class="cviolet"><strong>31</strong></span></pre>&#13;
<pre class="pre1"><code>v2: 10 2 15 4 10 6</code>&#13;
<code>c1 after copying v2 without 10s: 2 15 4 6</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec31">Iterator Adapters: <code>back_inserter</code>, <strong><code>front_inserter</code></strong> and <strong><code>inserter</code></strong></h5>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The second argument specifies an <strong><code>output_iterator</code></strong> indicating where the copied elements will be written. The <strong><code>remove_copy</code> algorithm</strong> does not check whether the target container has enough room to store all the copied elements. So the <strong>iterator</strong> in the second argument must refer to a container with enough room for all the elements. If you do not want to preallocate memory in advance, you can use an <strong><span class="violet">iterator adaptor</span></strong> with a <strong>dynamically growable container</strong>, like a <code>vector</code>, to insert elements and allow the container to allocate more elements as necessary. In line 28, the expression <code>std::back_inserter(c1)</code> uses the <span class="violet"><strong><code>back_inserter</code></strong></span> <strong><span class="violet">iterator adaptor</span></strong> (header <strong><code>&lt;iterator&gt;</code></strong>) to call the container’s <strong><code>push_back</code> function</strong>, which inserts an element at the end of the container. If the container needs more space, it grows to accommodate the new element. <strong>A <code>back_inserter</code> cannot be used with <code>array</code>s because they are fixed-size containers and do not have a <code>push_back</code> function.</strong></p>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong><code>remove_copy</code> algorithm</strong> expects as its second argument a <strong><code>weakly_incrementable</code> iterator</strong>—that is, the <strong>iterator</strong> must support <code>++</code> and must allow writing values into the output target, which typically is another container. A <strong><code>back_inserter</code></strong> supports these operations.</p>&#13;
<p>There are two other <strong>inserters</strong>:</p>&#13;
<p class="bull">• a <span class="violet"><strong><code>front_inserter</code></strong></span> uses the container’s <strong><code>push_front</code></strong> member function to insert an element at the beginning of its container argument, and</p>&#13;
<p class="bull">• an <span class="violet"><strong><code>inserter</code></strong></span> uses the container’s <strong><code>insert</code></strong> member function to insert an element into the container specified in its first argument at the location specified by the <strong>iterator</strong> in its second argument.</p>&#13;
<h5 class="h5" id="ch14lev3sec32"><code>remove_if</code> Algorithm</h5>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">remove_if algorithm</span></strong></code> (line 38) deletes from <code>v3</code> all elements for which the <strong>unary predicate function <code>greaterThan9</code></strong> returns <code>true</code>. The first argument must be a <strong><code>forward_range</code></strong> that enables <strong><code>remove_if</code></strong> to read the elements in the range. A <strong>unary predicate function</strong> must receive one parameter and return a <code>bool</code> value.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p768pro01" id="p768pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>32</strong></span>   std::vector v3{init}; <span class="lgreen">// initialize with copy of init</span>&#13;
<span class="cviolet"><strong>33</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nv3: "</span>;&#13;
<span class="cviolet"><strong>34</strong></span>   <code>std::ranges::copy(v3, output);</code>&#13;
<span class="cviolet"><strong>35</strong></span>&#13;
<span class="cviolet"><strong>36</strong></span>   <span class="lgreen">// remove elements greater than 9 from a3</span>&#13;
<span class="cviolet"><strong>37</strong></span>   <span class="blue">auto</span> greaterThan9 = [](<span class="blue">auto</span> x) {<span class="blue">return</span> x &gt; <span class="green">9</span>;};&#13;
<span class="cviolet"><strong>38</strong></span>   <span class="blue">const auto</span>&amp; [first2, last2]{std::ranges::remove_if(v3, greaterThan9)};&#13;
<span class="cviolet"><strong>39</strong></span>   <code>v3.erase(first2, last2);</code>&#13;
<span class="cviolet"><strong>40</strong></span>   std::cout &lt;&lt; <span class="green">"\nv3 after removing elements greater than 9: "</span>;&#13;
<span class="cviolet"><strong>41</strong></span>   <code>std::ranges::copy(v3, output);</code>&#13;
<span class="cviolet"><strong>42</strong></span></pre>&#13;
<pre class="pre1"><code>v3: 10 2 15 4 10 6</code>&#13;
<code>v3 after removing elements greater than 9: 2 4 6</code></pre>&#13;
</div>&#13;
<p>Line 37 defines a <strong>unary predicate function</strong> as the generic lambda:</p>&#13;
<pre class="pre">[](<span class="blue">auto</span> x){<span class="blue">return</span> x &gt; <span class="green">9</span>;}</pre>&#13;
<p>which returns <code>true</code> if its argument is greater than 9; otherwise, it returns <code>false</code>. The compiler uses <code>auto</code> type inference for both the <strong>lambda</strong>’s parameter and return types:</p>&#13;
<p class="bull">• The <code>vector</code> contains <code>int</code>s, so the compiler infers the parameter’s type as <code>int</code>.</p>&#13;
<p class="bull">• The <strong>lambda</strong> returns the result of evaluating a condition, so the compiler infers the return type as <code>bool</code>.</p>&#13;
<p>Like <strong><code>remove</code></strong>, <strong><code>remove_if</code></strong> does not modify the number of elements in the container. Instead, it places at the beginning of the container all elements that are not eliminated. It returns an <strong>iterator/sentinel pair</strong> representing the <strong>subrange</strong> of elements that are no longer valid. We use that <strong>iterator/sentinel pair</strong> in line 39 to erase those elements in <code>v3</code>. Line 41 outputs the updated contents of <code>v3</code>.</p>&#13;
<h5 class="h5" id="ch14lev3sec33"><code>remove_copy_if Algorithm</code></h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">remove_copy_if algorithm</span></strong></code> (line 49) copies the elements from its <strong><code>input_range</code></strong> argument <code>v4</code> for which a <strong>unary predicate function</strong> (the <strong>lambda</strong> at line 37) returns <code>true</code>. The algorithm’s first argument must be an <strong><code>input_range</code></strong> so the algorithm can read the <strong>range</strong>’s elements. The second argument must be a <strong><code>weakly_incrementable</code> iterator</strong> so the element being copied can be written into the destination container. Here, we again use a <strong><code>back_inserter</code></strong> to insert the copied elements into a <code>vector</code> (<code>v4</code>). Line 51 outputs the contents of <code>c2</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p768pro02" id="p768pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>43</strong></span>      std::vector v4{init}; <span class="lgreen">// initialize with copy of init</span>&#13;
<span class="cviolet"><strong>44</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nv4: "</span>;&#13;
<span class="cviolet"><strong>45</strong></span>      <code>std::ranges::copy(v4, output);</code>&#13;
<span class="cviolet"><strong>46</strong></span>      &#13;
<span class="cviolet"><strong>47</strong></span>      <span class="lgreen">// copy elements from v4 to c2, removing elements greater than 9</span>&#13;
<span class="cviolet"><strong>48</strong></span>      std::vector&lt;<span class="blue">int</span>&gt; c2{}; <span class="lgreen">// initialize to 0s</span>&#13;
<span class="cviolet"><strong>49</strong></span>      <code>std::ranges::remove_copy_if(v4, std::back_inserter(c2), greaterThan9);</code>&#13;
<span class="cviolet"><strong>50</strong></span>      std::cout &lt;&lt; <span class="green">"\nc2 after copying v4 without elements greater than 9: "</span>;&#13;
<span class="cviolet"><strong>51</strong></span>      <code>std::ranges::copy(c2, output);</code>&#13;
<span class="cviolet"><strong>52</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>53</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1"><code>v4: 10 2 15 4 10 6</code>&#13;
<code>c2 after copying v4 without elements greater than 9: 2 4 6</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_4">14.4.4 <code>replace</code>, <code>replace_if</code>, <code>replace_copy</code> and <code>replace_copy_if</code></h4>&#13;
<p><a href="ch14.xhtml#fig14_5">Figure 14.5</a> demonstrates replacing values from a sequence using algorithms <strong><code>replace</code></strong>, <strong><code>replace_if</code></strong>, <strong><code>replace_copy</code></strong> and <strong><code>replace_copy_if</code></strong> from <strong>C++20’s <code>std::ranges</code> name-space</strong>.</p>&#13;
<div class="group" id="fig14_5">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro05" id="p14pro05a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_05.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms replace, replace_if, replace_copy and replace_copy_if.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>10</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.5</strong></span> | Algorithms <code>replace</code>, <code>replace_if</code>, <code>replace_copy</code> and <code>replace_copy_if</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec34"><code>replace</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges::</strong> <span class="violet">replace algorithm</span></code> (line 16) replaces all elements with the value <code>10</code> in the <strong><code>input_range</code></strong> <code>a1</code>. The first argument must support <strong><code>indirectly_writeable</code> iterators</strong>, so <strong><code>replace</code></strong> can <strong>dereference the iterators</strong> to assign new values to the <strong>range</strong>’s elements. The <code>array a1</code> is non-<code>const</code>, so its <strong>iterators</strong> can be used to write into the <code>array</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p769pro01" id="p769pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>11</strong></span>   std::array a1{<span class="green">10</span>, <span class="green">2</span>, <span class="green">15</span>, <span class="green">4</span>, <span class="green">10</span>, <span class="green">6</span>};&#13;
<span class="cviolet"><strong>12</strong></span>   std::cout &lt;&lt; <span class="green">"a1: "</span>;&#13;
<span class="cviolet"><strong>13</strong></span>   <code>std::ranges::copy(a1, output);</code>&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// replace all 10s in a1 with 100</span>&#13;
<span class="cviolet"><strong>16</strong></span>   std::ranges::replace(a1, <span class="green">10</span>, <span class="green">100</span>);&#13;
<span class="cviolet"><strong>17</strong></span>   std::cout &lt;&lt; <span class="green">"\na1 after replacing 10s with 100s: "</span>;&#13;
<span class="cviolet"><strong>18</strong></span>   <code>std::ranges::copy(a1, output);</code>&#13;
<span class="cviolet"><strong>19</strong></span></pre>&#13;
<pre class="pre1"><code>a1: 10 2 15 4 10 6</code>&#13;
<code>a1 after replacing 10s with 100s: 100 2 15 4 100 6</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec35"><code>replace_copy</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">replace_copy algorithm</span></strong></code> (line 26) copies all elements in the <strong><code>input_range</code></strong> <code>a2</code>, replacing each <code>10</code> with <code>100</code>. The first argument must support <strong><code>indirect-ly_copyable</code> iterators</strong>, so <strong><code>replace_copy</code> can dereference them to copy to the range’s elements</strong>. The array <code>a2</code> supports <strong><code>random_access_iterator</code></strong>s, so its <strong>iterators can be dereferenced</strong> to copy the elements. The second argument must be an <strong><code>output_iterator</code></strong> so each element can be written into the destination container. The <code>array c1</code> is non-<code>const</code> and supports more powerful <strong><code>random_access_iterator</code></strong>s, so <strong><code>replace_copy</code></strong> can write into <code>c1</code>. The algorithm copies or replaces every element in the <strong><code>input_range</code></strong>, so we allocated <code>c1</code> with the same number of elements as <code>a2</code>. As shown earlier, we could have used an empty <code>vector</code> as the target container and used a <strong><code>back_inserter</code></strong> to append elements to the <code>vector</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p770pro01" id="p770pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>20</strong></span>   std::array a2{<span class="green">10</span>, <span class="green">2</span>, <span class="green">15</span>, <span class="green">4</span>, <span class="green">10</span>, <span class="green">6</span>};&#13;
<span class="cviolet"><strong>21</strong></span>   std::array&lt;<span class="blue">int</span>, a2.size()&gt; c1{};&#13;
<span class="cviolet"><strong>22</strong></span>   std::cout &lt;&lt; <span class="green">"\n\na2: "</span>;&#13;
<span class="cviolet"><strong>23</strong></span>   <code>std::ranges::copy(a2, output);</code>&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="lgreen">// copy from a2 to c1, replacing 10s with 100s</span>&#13;
<span class="cviolet"><strong>26</strong></span>   std::ranges::replace_copy(a2, c1.begin(), <span class="green">10</span>, <span class="green">100</span>);&#13;
<span class="cviolet"><strong>27</strong></span>   std::cout &lt;&lt; <span class="green">"\nc1 after replacing a2's 10s with 100s: "</span>;&#13;
<span class="cviolet"><strong>28</strong></span>   <code>std::ranges::copy(c1, output);</code>&#13;
<span class="cviolet"><strong>29</strong></span></pre>&#13;
<pre class="pre1"><code>a2: 10 2 15 4 10 6</code>&#13;
<code>c1 after replacing a2</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec36"><code>replace_if</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">replace_if algorithm</span></strong></code> (line 36) replaces each element in the <strong><code>input_range</code></strong> <code>a3</code> for which a <strong>unary predicate function</strong> (the <strong>lambda <code>greaterThan9</code></strong> in line 35) returns <code>true</code>. The first argument must support <strong><code>indirectly_writeable</code> iterators</strong>, so <strong><code>replace_if</code></strong> can <strong>dereference the iterators</strong> to assign new values to the <strong>range</strong>’s elements. Here, we replace each value greater than 9 with 100.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p770pro02" id="p770pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>30</strong></span>   std::array a3{<span class="green">10</span>, <span class="green">2</span>, <span class="green">15</span>, <span class="green">4</span>, <span class="green">10</span>, <span class="green">6</span>};&#13;
<span class="cviolet"><strong>31</strong></span>   std::cout &lt;&lt; <span class="green">"\n\na3: "</span>;&#13;
<span class="cviolet"><strong>32</strong></span>   <code>std::ranges::copy(a3, output);</code>&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>   <span class="lgreen">// replace values greater than 9 in a3 with 100</span>&#13;
<span class="cviolet"><strong>35</strong></span>   <span class="blue">constexpr auto</span> greaterThan9 = [](<span class="blue">auto</span> x) {<span class="blue">return</span> x &gt; <span class="green">9</span>;};&#13;
<span class="cviolet"><strong>36</strong></span>   std::ranges::replace_if(a3, greaterThan9, <span class="green">100</span>);&#13;
<span class="cviolet"><strong>37</strong></span>   std::cout &lt;&lt; <span class="green">"\na3 after replacing values greater than 9 with 100s: "</span>;&#13;
<span class="cviolet"><strong>38</strong></span>   <code>std::ranges::copy(a3, output);</code>&#13;
<span class="cviolet"><strong>39</strong></span></pre>&#13;
<pre class="pre1"><code>a3: 10 2 15 4 10 6</code>&#13;
<code>a3 after replacing values greater than 9 with 100s: 100 2 100 4 100 6</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec37"><code>replace_copy_if</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">replace_copy_if algorithm</span></strong></code> (line 46) copies all elements in the <strong><code>input_range</code></strong> <code>a4</code> for which a <strong>unary predicate function</strong> returns <code>true</code>. Again we replace values greater than 9 with the value <code>100</code>. The copied or replaced elements are placed in <code>c2</code>, starting at position <code>c2.begin()</code>, which must be an <strong><code>output_iterator</code></strong>. The <code>array c2</code> is non-<code>const</code> and supports more powerful <strong><code>random_access_iterator</code></strong>s, so <strong><code>replace_copy_if</code></strong> can output into <code>c2</code>. The algorithm copies or replaces every element in the <strong><code>input_range</code></strong>, so we allocated <code>c2</code> with the same number of elements as <code>a4</code>. The first argument must support <strong><code>indirectly_copyable</code> iterators</strong>, so <strong><code>replace_copy_if</code></strong> can <strong>dereference</strong> them to copy to the range’s elements.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p771pro01" id="p771pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>40</strong></span>      std::array a4{<span class="green">10</span>, <span class="green">2</span>, <span class="green">15</span>, <span class="green">4</span>, <span class="green">10</span>, <span class="green">6</span>};&#13;
<span class="cviolet"><strong>41</strong></span>      std::array&lt;<span class="blue">int</span>, a4.size()&gt; c2{};&#13;
<span class="cviolet"><strong>42</strong></span>      std::cout &lt;&lt; <span class="green">"\n\na4: "</span>;&#13;
<span class="cviolet"><strong>43</strong></span>      <code>std::ranges::copy(a4, output);</code>&#13;
<span class="cviolet"><strong>44</strong></span>&#13;
<span class="cviolet"><strong>45</strong></span>      <span class="lgreen">// copy a4 to c2, replacing elements greater than 9 with 100</span>&#13;
<span class="cviolet"><strong>46</strong></span>      std::ranges::replace_copy_if(a4, c2.begin(), greaterThan9, <span class="green">100</span>);&#13;
<span class="cviolet"><strong>47</strong></span>      std::cout &lt;&lt; <span class="green">"\nc2 after replacing a4's values "</span>&#13;
<span class="cviolet"><strong>48</strong></span>      &lt;&lt; <span class="green">"greater than 9 with 100s: "</span>;&#13;
<span class="cviolet"><strong>49</strong></span>      <code>std::ranges::copy(c2, output);</code>&#13;
<span class="cviolet"><strong>50</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>51</strong></span>   }</pre>&#13;
<pre class="pre1"><code>a4: 10 2 15 4 10 6</code>&#13;
<code>c2 after replacing a4</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_5">14.4.5 Mathematical Algorithms</h4>&#13;
<p><span class="size">20</span> <span class="size">23</span> <a href="ch14.xhtml#fig14_6">Figure 14.6</a> demonstrates several common mathematical algorithms, including <strong><code>shuffle</code></strong>, <strong><code>count</code></strong>, <strong><code>count_if</code></strong>, <strong><code>min_element</code></strong>, <strong><code>max_element</code></strong>, <strong><code>minmax_element</code></strong> and <strong><code>transform</code></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong>. There are other mathematical algorithms in the <strong><code>&lt;numeric&gt;</code> header</strong>, such as the <strong><code>accumulate</code></strong> algorithm, which we introduced in <a href="ch08.xhtml#ch08lev2sec3">Section 8.19.2</a>. The algorithms in that header use <strong>common ranges</strong> and are expected to be updated to <strong>C++20 ranges</strong> in C++23.<sup><a id="ch14fn19a" href="ch14.xhtml#ch14fn19">19</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn19" href="ch14.xhtml#ch14fn19a">19</a>. Barry Revzin, Conor Hoekstra and Tim Song, “A Plan for C++23 Ranges,” October 14, 2020. Accessed May 4, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2214r0.html#algorithms">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2214r0.html#algorithms</a></code>.</p>&#13;
<div class="group" id="fig14_6">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro06" id="p14pro06a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_06.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Mathematical algorithms of the standard library.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;numeric&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;random&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>11</strong></span>      std::array a1{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>, <span class="green">7</span>, <span class="green">8</span>, <span class="green">9</span>, <span class="green">10</span>};&#13;
<span class="cviolet"><strong>12</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      std::cout &lt;&lt; <span class="green">"a1: "</span>;&#13;
<span class="cviolet"><strong>15</strong></span>      <code>std::ranges::copy(a1, output);</code>&#13;
<span class="cviolet"><strong>16</strong></span></pre>&#13;
<pre class="pre1"><code>a1: 1 2 3 4 5 6 7 8 9 10</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.6</strong></span> | Mathematical algorithms of the standard library. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec38"><code>shuffle</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">11</span> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">shuffle algorithm</span></strong></code> (line 19) randomly reorders the elements in <code>a1</code>, which must be a <strong><code>random_access_range</code></strong> that supports <strong><code>random_access_iterator</code></strong>s. The algorithm’s declaration indicates that the <strong>range</strong>’s <strong>iterators</strong> must be <strong><code>permutable</code></strong>, which permits operations such as swapping and moving elements—<code>a1</code> is non-<code>const</code>, so <strong><code>shuffle</code></strong> can perform such operations on the <code>array</code>. The <strong><code>shuffle</code></strong> algorithm’s second argument is a <strong>C++11 random-number-generator engine</strong>. Line 18</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p772pro01" id="p772pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">default_random_engine randomEngine{random_device{}()};</pre>&#13;
<p><span class="size">11</span> <span class="size">Sec</span><img class="inline" src="Images/sec.jpg" alt="Images" width="28" height="31"/> creates a <strong><code>default_random_engine</code></strong> and initializes it with a C++11 <span class="violet"><strong><code>random_device</code></strong></span> object, which seeds the random-number generator—typically with a nondeterministic seed, which cannot be predicted.<sup><a id="ch14fn20a" href="ch14.xhtml#ch14fn20">20</a></sup> In the expression</p>&#13;
<p class="footnote"><a id="ch14fn20" href="ch14.xhtml#ch14fn20a">20</a>. “Nondeterministic algorithm.” Accessed May 2, 2021. <code><a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">https://en.wikipedia.org/wiki/Nondeterministic_algorithm</a></code>.</p>&#13;
<pre class="pre">random_device{}()</pre>&#13;
<p>the braces initialize the <code>random_device</code> object, and the parentheses call its overloaded parentheses operator to get the seed. Line 21 displays the shuffled results.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p772pro02" id="p772pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// create random-number engine and use it to help shuffle a1</span>&#13;
<span class="cviolet"><strong>18</strong></span>   <code>std::default_random_engine randomEngine{std::random_device{}()};</code>&#13;
<span class="cviolet"><strong>19</strong></span>   std::ranges::shuffle(a1, randomEngine); <span class="lgreen">// randomly order elements</span>&#13;
<span class="cviolet"><strong>20</strong></span>   std::cout &lt;&lt; <span class="green">"\na1 shuffled: "</span>;&#13;
<span class="cviolet"><strong>21</strong></span>   <code>std::ranges::copy(a1, output);</code>&#13;
<span class="cviolet"><strong>22</strong></span></pre>&#13;
<pre class="pre1"><code>a1 shuffled: 5 4 7 6 3 9 1 8 10 2</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec39"><code>count</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">count algorithm</span></strong></code> (line 28) counts the elements with a specific value (in this case, <code>8</code>) in <code>a2</code>, which must be an <strong><code>input_range</code></strong>, so <strong><code>count</code></strong> can read elements in the range.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p772pro03" id="p772pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>23</strong></span>   std::array a2{<span class="green">100</span>, <span class="green">2</span>, <span class="green">8</span>, <span class="green">1</span>, <span class="green">50</span>, <span class="green">3</span>, <span class="green">8</span>, <span class="green">8</span>, <span class="green">9</span>, <span class="green">10</span>};&#13;
<span class="cviolet"><strong>24</strong></span>   std::cout &lt;&lt; <span class="green">"\n\na2: "</span>;&#13;
<span class="cviolet"><strong>25</strong></span>   <code>std::ranges::copy(a2, output);</code>&#13;
<span class="cviolet"><strong>26</strong></span>   &#13;
<span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// count number of elements in a2 with value 8</span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">auto</span> result1{std::ranges::count(a2, <span class="green">8</span>)};&#13;
<span class="cviolet"><strong>29</strong></span>   std::cout &lt;&lt; <span class="green">"\nCount of 8s in a2: "</span> &lt;&lt; result1;&#13;
<span class="cviolet"><strong>30</strong></span></pre>&#13;
<pre class="pre1"><code>a2: 100 2 8 1 50 3 8 8 9 10</code>&#13;
<code>Count of 8s in a2: 3</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec40"><code>count_if</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">count_if algorithm</span></strong></code> (line 32) counts in its argument <code>a2</code> elements for which a <strong>unary predicate</strong> function returns <code>true</code>. Once again, we used a <strong>lambda</strong> to define a <strong>unary predicate</strong> that returns <code>true</code> for a value greater than 9. The first argument must be an <strong><code>input_range</code></strong>, so the algorithm can read elements in the range.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p773pro01" id="p773pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>31</strong></span>   <span class="lgreen">// count number of elements in a2 that are greater than 9</span>&#13;
<span class="cviolet"><strong>32</strong></span>   <span class="blue">auto</span> result2{std::ranges::count_if(a2, [](<span class="blue">auto</span> x){<span class="blue">return</span> x &gt; <span class="green">9</span>;})};&#13;
<span class="cviolet"><strong>33</strong></span>   std::cout &lt;&lt; <span class="green">"\nCount of a2 elements greater than 9: "</span> &lt;&lt; result2;&#13;
<span class="cviolet"><strong>34</strong></span></pre>&#13;
<pre class="pre1"><code>Count of a2 elements greater than 9: 3</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec41"><code>min_element</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">min_element algorithm</span></strong></code> (line 37) locates the smallest element in its <strong><code>forward_range</code></strong> argument <code>a2</code>. Such a <strong>range</strong> supports <strong><code>forward_iterators</code></strong>, which allow <strong><code>min_element</code></strong> to read elements from the <strong>range</strong>. The algorithm returns an <strong>iterator</strong> located at the first occurrence of the <strong>range</strong>’s smallest element or the <strong>range</strong>’s <strong>sentinel</strong> if the <strong>range</strong> is empty. As with many algorithms that compare elements, you can provide a custom <strong>binary predicate function</strong> that specifies how to compare the elements and returns <code>true</code> if the first argument is less than the second. Before <strong>dereferencing an iterator</strong> that might represent a <strong>range</strong>’s <strong>sentinel</strong>, you should check that it does not match the <strong>sentinel</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p773pro02" id="p773pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>35</strong></span>   <span class="lgreen">// locate minimum element in a2</span>&#13;
<span class="cviolet"><strong>36</strong></span>   std::cout &lt;&lt; <span class="green">"\n\na2 minimum element: "</span>&#13;
<span class="cviolet"><strong>37</strong></span>      <code>&lt;&lt; *(std::ranges::min_element(a2));</code>&#13;
<span class="cviolet"><strong>38</strong></span></pre>&#13;
<pre class="pre1"><code>a2 minimum element: 1</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec42"><code>max_element</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">max_element algorithm</span></strong></code> (line 41) locates the largest element in its <strong><code>forward_range</code></strong> argument <code>a2</code>. Such a <strong>range</strong> supports <strong><code>forward_iterators</code></strong>, which allow <strong><code>max_element</code></strong> to read elements from the <strong>range</strong>. The algorithm returns an <strong>iterator</strong> located at the first occurrence of the <strong>range</strong>’s largest element or the <strong>range</strong>’s <strong>sentinel</strong> if the <strong>range</strong> is empty. You can provide a custom <strong>binary predicate function</strong> that specifies how to compare the elements and returns <code>true</code> if the first argument is less than the second.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p773pro03" id="p773pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>39</strong></span>   <span class="lgreen">// locate maximum element in a2</span>&#13;
<span class="cviolet"><strong>40</strong></span>   std::cout &lt;&lt; <span class="green">"\na2 maximum element: "</span>&#13;
<span class="cviolet"><strong>41</strong></span>      <code>&lt;&lt; *(std::ranges::max_element(a2));</code>&#13;
<span class="cviolet"><strong>42</strong></span></pre>&#13;
<pre class="pre1"><code>a2 maximum element: 100</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec43"><code>minmax_element</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">minmax_element algorithm</span></strong></code> (line 44) locates the smallest and largest elements in its <strong><code>forward_range</code></strong> argument <code>a2</code>. It returns an <strong>iterator pair</strong> aimed at the smallest and largest elements, respectively. If there are duplicate smallest elements, the first <strong>iterator</strong> is located at the <strong>first of the smallest values</strong>. Similarly, if there are duplicate largest elements, the second <strong>iterator</strong> is aimed at the <strong>last of the largest values</strong>. You can provide a custom <strong>binary predicate function</strong> that specifies how to compare the elements and returns <code>true</code> if the first argument is less than the second.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p774pro01" id="p774pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>43</strong></span>   <span class="lgreen">// locate minimum and maximum elements in a2</span>&#13;
<span class="cviolet"><strong>44</strong></span>   <span class="blue">const auto</span>&amp; [min, max]{std::ranges::minmax_element(a2)};&#13;
<span class="cviolet"><strong>45</strong></span>   std::cout &lt;&lt; <span class="green">"\na2 minimum and maximum elements: "</span>&#13;
<span class="cviolet"><strong>46</strong></span>      &lt;&lt; *min &lt;&lt; <span class="green">" and "</span> &lt;&lt; *max;&#13;
<span class="cviolet"><strong>47</strong></span></pre>&#13;
<pre class="pre1"><code>a2 minimum and maximum elements: 1 and 100</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec44"><code>transform</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Lines 50–51 use the <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">transform algorithm</span></strong></code> to transform the elements of its <strong><code>input_range</code></strong> <code>a1</code> to new values. Each new value is written into the container specified by the algorithm’s second argument, which must be an <code><strong>indirectly_writeable</strong></code> <strong>iterator</strong> and can point to the same container as the <strong><code>input_range</code></strong> or a different container. The function provided as <strong><code>transform</code></strong>’s third argument receives a value and returns a new value and must not modify the elements in the range.<sup><a id="ch14fn21a" href="ch14.xhtml#ch14fn21">21</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn21" href="ch14.xhtml#ch14fn21a">21</a>. “Algorithms library—Mutating sequence operations—Transform.” Accessed May 1, 2021. <code><a href="https://eel.is/c++draft/alg.transform">https://eel.is/c++draft/alg.transform</a></code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p774pro02" id="p774pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>48</strong></span>      <span class="lgreen">// calculate cube of each element in a1; place results in cubes</span>&#13;
<span class="cviolet"><strong>49</strong></span>      std::array&lt;<span class="blue">int</span>, a1.size()&gt; cubes{};&#13;
<span class="cviolet"><strong>50</strong></span>      <code>std::ranges::transform(a1, cubes.begin(),</code>&#13;
<span class="cviolet"><strong>51</strong></span>         [](aut<span class="blue">o</span> x){<span class="blue">return</span> x * x * x;});&#13;
<span class="cviolet"><strong>52</strong></span>      std::cout &lt;&lt; <span class="green">"\n\na1 values cubed: "</span>;&#13;
<span class="cviolet"><strong>53</strong></span>      <code>std::ranges::copy(cubes, output);</code>&#13;
<span class="cviolet"><strong>54</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>55</strong></span>   }</pre>&#13;
<pre class="pre1"><code>a1 values cubed: 125 64 343 216 27 729 1 512 1000 8</code></pre>&#13;
</div>&#13;
<p><span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> A <strong><code>transform</code></strong> overload accepts two <strong><code>input_range</code></strong>s, an <strong><code>indirectly_writeable</code> iterator</strong> and a function that takes two arguments and returns a result. This version of <strong><code>transform</code></strong> passes corresponding elements from each <strong><code>input_range</code></strong> to its function argument, then outputs the function’s result via the <strong><code>indirectly_writeable</code> iterator</strong>.</p>&#13;
<h4 class="h4" id="sec14_4_6">14.4.6 Searching and Sorting Algorithms</h4>&#13;
<p><a href="ch14.xhtml#fig14_7">Figure 14.7</a> demonstrates some basic searching and sorting algorithms, including <strong><code>find</code></strong>, <strong><code>find_if</code></strong>, <strong><code>sort</code></strong>, <strong><code>binary_search</code></strong>, <strong><code>all_of</code></strong>, <strong><code>any_of</code></strong>, <strong><code>none_of</code></strong> and <strong><code>find_if_not</code></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong>.</p>&#13;
<div class="group" id="fig14_7">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro07" id="p14pro07a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_07.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library search and sort algorithms.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt; <span class="lgreen">// algorithm definitions</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt; <span class="lgreen">// array class-template definition</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::array values{<span class="green">10</span>, <span class="green">2</span>, <span class="green">17</span>, <span class="green">5</span>, <span class="green">16</span>, <span class="green">8</span>, <span class="green">13</span>, <span class="green">11</span>, <span class="green">20</span>, <span class="green">7</span>};&#13;
<span class="cviolet"><strong>10</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      std::cout &lt;&lt; <span class="green">"values contains: "</span>;&#13;
<span class="cviolet"><strong>13</strong></span>      std::ranges::copy(values, output); <span class="lgreen">// display output vector</span>&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<pre class="pre1"><code>values contains: 10 2 17 5 16 8 13 11 20 7</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.7</strong></span> | Standard library search and sort algorithms.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec45"><code>find</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">find algorithm</span></strong></code> (line 16) <strong>performs an <em>O</em>(<em>n</em>) linear search</strong> to find a value (<code>16</code>) in its <strong><code>input_range</code></strong> argument (<code>values</code>). The algorithm returns an <strong>iterator</strong> that’s either positioned at the first element containing the value or indicates the range’s <strong>sentinel</strong> (as demonstrated by lines 26–33). We use the returned <strong>iterator</strong> in line 19 to calculate the index position at which the value was found.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p775pro01" id="p775pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// locate first occurrence of 16 in values</span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">auto</span> loc1{std::ranges::find(values, <span class="green">16</span>)};&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">if</span> (loc1 != values.cend()) { <span class="lgreen">// found 16</span>&#13;
<span class="cviolet"><strong>19</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nFound 16 at index: "</span> &lt;&lt; (loc1 - values.cbegin());&#13;
<span class="cviolet"><strong>20</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">else</span> { <span class="lgreen">// 16 not found</span>&#13;
<span class="cviolet"><strong>22</strong></span>      std::cout &lt;&lt; <span class="green">"\n\n16 not found"</span>;&#13;
<span class="cviolet"><strong>23</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>24</strong></span>   &#13;
<span class="cviolet"><strong>25</strong></span>   <span class="lgreen">// locate first occurrence of 100 in values</span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="blue">auto</span> loc2{std::ranges::find(values, <span class="green">100</span>)};&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">if</span> (loc2 != values.cend()) { <span class="lgreen">// found 100</span>&#13;
<span class="cviolet"><strong>29</strong></span>      std::cout &lt;&lt; <span class="green">"\nFound 100 at index: "</span> &lt;&lt; (loc2 - values.cbegin());&#13;
<span class="cviolet"><strong>30</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>31</strong></span>   <span class="blue">else</span> { <span class="lgreen">// 100 not found</span>&#13;
<span class="cviolet"><strong>32</strong></span>      std::cout &lt;&lt; <span class="green">"\n100 not found"</span>;&#13;
<span class="cviolet"><strong>33</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>34</strong></span></pre>&#13;
<pre class="pre1"><code>Found 16 at index:</code>&#13;
<code>4 100 not found</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec46"><code>find_if</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">find_if algorithm</span></strong></code> (line 39) <strong>performs an <em>O</em>(<em>n</em>) linear search</strong> to locate the first value in its <strong><code>input_range</code></strong> argument (<code>values</code>) for which a <strong>unary predicate function</strong> returns <code>true</code>. In this case, we use the <strong>lambda <code>isGreaterThan10</code></strong> defined in line 36. The algorithm returns an <strong>iterator</strong> that’s positioned at the first element containing a value for which the <strong>predicate function</strong> returns <code>true</code> or that indicates the sequence’s <strong>sentinel</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p776pro01" id="p776pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>35</strong></span>   <span class="lgreen">// create variable to store lambda for reuse later</span>&#13;
<span class="cviolet"><strong>36</strong></span>   <span class="blue">constexpr</span> <span class="blue">auto</span> isGreaterThan10{[](<span class="blue">auto</span> x){<span class="blue">return</span> x &gt; <span class="green">10</span>;}};&#13;
<span class="cviolet"><strong>37</strong></span>&#13;
<span class="cviolet"><strong>38</strong></span>   <span class="lgreen">// locate first occurrence of value greater than 10 in values</span>&#13;
<span class="cviolet"><strong>39</strong></span>   <span class="blue">auto</span> loc3{std::ranges::find_if(values, isGreaterThan10)};&#13;
<span class="cviolet"><strong>40</strong></span>&#13;
<span class="cviolet"><strong>41</strong></span>   <span class="blue">if</span> (loc3 != values.cend()) { <span class="lgreen">// found value greater than 10</span>&#13;
<span class="cviolet"><strong>42</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nFirst value greater than 10: "</span> &lt;&lt; *loc3&#13;
<span class="cviolet"><strong>43</strong></span>         &lt;&lt; <span class="green">"\nfound at index: "</span> &lt;&lt; (loc3 - values.cbegin());&#13;
<span class="cviolet"><strong>44</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>45</strong></span>   <span class="blue">else</span> { <span class="lgreen">// value greater than 10 not found</span>&#13;
<span class="cviolet"><strong>46</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nNo values greater than 10 were found"</span>;&#13;
<span class="cviolet"><strong>47</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>48</strong></span></pre>&#13;
<pre class="pre1"><code>First value greater than 10: 17</code>&#13;
<code>found at index: 2</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec47"><code>sort</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">sort algorithm</span></strong></code> (line 50) performs an <strong>performs an <em>O</em>(<em>n</em> log <em>n</em>) sort</strong>m that arranges the elements in its argument <code>values</code> into ascending order. The argument must be a <strong><code>random_access_range</code></strong>, which supports <strong><code>random_access_iterator</code></strong>s and thus can be used with the standard library containers <strong><code>array</code></strong>, <strong><code>vector</code></strong> and <strong><code>deque</code></strong> (and builtin arrays). This algorithm also can receive a <strong>binary predicate function</strong> taking two arguments and returning a <code>bool</code> indicating the <strong>sorting order</strong>. The predicate compares two values from the sequence being sorted. If the return value is <code>true</code>, the two elements are already in sorted order; otherwise, the two elements need to be reordered in the sequence.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p776pro02" id="p776pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>49</strong></span>   <span class="lgreen">// sort elements of a</span>&#13;
<span class="cviolet"><strong>50</strong></span>   <code>std::ranges::sort(values);</code>&#13;
<span class="cviolet"><strong>51</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nvalues after sort: "</span>;&#13;
<span class="cviolet"><strong>52</strong></span>   <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>53</strong></span></pre>&#13;
<pre class="pre1"><code>values after sort: 2 5 7 8 10 11 13 16 17 20</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec48"><code>binary_search</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">binary_search algorithm</span></strong></code> <strong>performs an <em>O</em>(log <em>n</em>) binary search</strong> to determine whether a value (<code>13</code>) is in its <strong><code>forward_range</code></strong> argument (<code>values</code>). The <strong>range</strong> must be <strong>sorted in ascending order</strong>. The algorithm returns a <code>bool</code> indicating whether the value was found in the sequence. Line 63 demonstrates a call to <code>binary_search</code> for which the value is not found. This algorithm also can receive a <strong>binary predicate function</strong> with two arguments and returning a <code>bool</code>. The function should return <code>true</code> if the two elements being compared are in sorted order. <strong>If you need to know the search key’s location in the container, use the <code>lower_bound</code> or <code>find</code> algorithms rather than <code>binary_search</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p777pro01" id="p777pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>54</strong></span>   <span class="lgreen">// use binary_search to check whether 13 exists in values</span>&#13;
<span class="cviolet"><strong>55</strong></span>   <span class="blue">if</span> (std::ranges::binary_search(values, <span class="green">13</span>)) {&#13;
<span class="cviolet"><strong>56</strong></span>      std::cout &lt;&lt; <span class="green">"\n\n13 was found in values"</span>;&#13;
<span class="cviolet"><strong>57</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>58</strong></span>   <span class="blue">else</span> {&#13;
<span class="cviolet"><strong>59</strong></span>      std::cout &lt;&lt; <span class="green">"\n\n13 was not found in values"</span>;&#13;
<span class="cviolet"><strong>60</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>61</strong></span>&#13;
<span class="cviolet"><strong>62</strong></span>   <span class="lgreen">// use binary_search to check whether 100 exists in values</span>&#13;
<span class="cviolet"><strong>63</strong></span>   <span class="blue">if</span> (std::ranges::binary_search(values, <span class="green">100</span>)) {&#13;
<span class="cviolet"><strong>64</strong></span>      std::cout &lt;&lt; <span class="green">"\n100 was found in values"</span>;&#13;
<span class="cviolet"><strong>65</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>66</strong></span>   <span class="blue">else</span> {&#13;
<span class="cviolet"><strong>67</strong></span>      std::cout &lt;&lt; <span class="green">"\n100 was not found in values"</span>;&#13;
<span class="cviolet"><strong>68</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>69</strong></span></pre>&#13;
<pre class="pre1"><code>13 was found in values</code>&#13;
<code>100 was not found in values</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec49"><code>all_of</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">all_of algorithm</span></strong></code> (line 71) <strong>performs an <em>O</em>(<em>n</em>) linear search</strong> to determine whether the <strong>unary predicate function</strong> in its second argument (in this case, the <strong>lambda <code>isGreaterThan10</code></strong>) returns <code>true</code> for <strong>all of the elements</strong> in its <strong><code>input_range</code></strong> argument (<code>values)</code>. If so, <strong><code>all_of</code></strong> returns <code>true</code>; otherwise, it returns <code>false</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p777pro02" id="p777pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>70</strong></span>   <span class="lgreen">// determine whether all of values' elements are greater than 10</span>&#13;
<span class="cviolet"><strong>71</strong></span>   <span class="blue">if</span> (std::ranges::all_of(values, isGreaterThan10)) {&#13;
<span class="cviolet"><strong>72</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nAll values elements are greater than 10"</span>;&#13;
<span class="cviolet"><strong>73</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>74</strong></span>   <span class="blue">else</span> {&#13;
<span class="cviolet"><strong>75</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nSome values elements are not greater than 10"</span>;&#13;
<span class="cviolet"><strong>76</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>77</strong></span></pre>&#13;
<pre class="pre1"><code>Some values elements are not greater than 10</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec50"><code>any_of</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">any_of algorithm</span></strong></code> (line 79) <strong>performs an <em>O</em>(<em>n</em>) linear search</strong> to determine whether the <strong>unary predicate function</strong> in its second argument (in this case, the <strong>lambda <code>isGreaterThan10</code></strong>) returns <code>true</code> for <strong>at least one of the elements</strong> in its <strong><code>input_range</code></strong> argument (<code>values</code>). If so, <strong><code>any_of</code></strong> returns <code>true</code>; otherwise, it returns <code>false</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p778pro01" id="p778pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>78</strong></span>   <span class="lgreen">// determine whether any of values' elements are greater than 10</span>&#13;
<span class="cviolet"><strong>79</strong></span>   <span class="blue">if</span> (std::ranges::any_of(values, isGreaterThan10)) {&#13;
<span class="cviolet"><strong>80</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nSome values elements are greater than 10"</span>;&#13;
<span class="cviolet"><strong>81</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>82</strong></span>   <span class="blue">else</span> {&#13;
<span class="cviolet"><strong>83</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nNo values elements are greater than 10"</span>;&#13;
<span class="cviolet"><strong>84</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>85</strong></span></pre>&#13;
<pre class="pre1"><code>Some values elements are greater than 10</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec51"><code>none_of</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">none_of algorithm</span></strong></code> (line 87) <strong>performs an <em>O</em>(<em>n</em>) linear search</strong> to determine whether the <strong>unary predicate function</strong> in its second argument (in this case, the <strong>lambda <code>isGreaterThan10</code></strong>) returns <code>false</code> for <strong>all of the elements</strong> in its <strong><code>input_range</code></strong> argument (<code>values</code>). If so, <strong><code>none_of</code></strong> returns <code>true</code>; otherwise, it returns <code>false</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p778pro02" id="p778pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>86</strong></span>   <span class="lgreen">// determine whether none of values' elements are greater than 10</span>&#13;
<span class="cviolet"><strong>87</strong></span>   <span class="blue">if</span> (std::ranges::none_of(values, isGreaterThan10)) {&#13;
<span class="cviolet"><strong>88</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nNo values elements are greater than 10"</span>;&#13;
<span class="cviolet"><strong>89</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>90</strong></span>   <span class="blue">else</span> {&#13;
<span class="cviolet"><strong>91</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nSome values elements are greater than 10"</span>;&#13;
<span class="cviolet"><strong>92</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>93</strong></span></pre>&#13;
<pre class="pre1"><code>Some values elements are greater than 10</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec52"><code>find_if_not</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">find_if_not algorithm</span></strong></code> (line 95) <strong>performs an <em>O</em>(<em>n</em>) linear search</strong> to locate the first value in its <strong><code>input_range</code></strong> argument (<code>values</code>) for which a <strong>unary predicate function</strong> (the <strong>lambda <code>isGreaterThan10</code></strong>) returns <code>false</code>. The algorithm returns an <strong>iterator</strong> that’s either positioned at the first element containing a value for which the <strong>predicate function</strong> returns <code>false</code> or indicates the <strong>range</strong>’s <strong>sentinel</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p778pro03" id="p778pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>94</strong></span>      <span class="lgreen">// locate first occurrence of value that</span>&#13;
<span class="cviolet"><strong>95</strong></span>      <span class="blue">auto</span> loc4{std::ranges::find_if_not(values, isGreaterThan10)};&#13;
<span class="cviolet"><strong>96</strong></span>&#13;
<span class="cviolet"><strong>97</strong></span>      <span class="blue">if</span> (loc4 != values.cend()) { <span class="lgreen">// found a value less than or equal to 10</span>&#13;
<span class="cviolet"><strong>98</strong></span>         std::cout &lt;&lt; <span class="green">"\n\nFirst value not greater than 10: "</span> &lt;&lt; *loc4&#13;
<span class="cviolet"><strong>99</strong></span>            &lt;&lt; <span class="green">"\nfound at index: "</span> &lt;&lt; (loc4 - values.cbegin());&#13;
<span class="cviolet"><strong>100</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>101</strong></span>      <span class="blue">else</span> { <span class="lgreen">// no values less than or equal to 10 were found</span>&#13;
<span class="cviolet"><strong>102</strong></span>         std::cout &lt;&lt; <span class="green">"\n\nOnly values greater than 10 were found"</span>;&#13;
<span class="cviolet"><strong>103</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>104</strong></span>&#13;
<span class="cviolet"><strong>105</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>106</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1"><code>First value not greater than 10: 2</code>&#13;
<code>found at index: 0</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_7">14.4.7 <code>swap</code>, <code>iter_swap</code> and <code>swap_ranges</code></h4>&#13;
<p><span class="size">20</span> <a href="ch14.xhtml#fig14_8">Figure 14.8</a> demonstrates algorithms for swapping elements—<strong><code>swap</code></strong> and <strong><code>iter_swap</code></strong> from the <code>std</code> namespace and algorithm <strong><code>swap_ranges</code></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong>.</p>&#13;
<div class="group" id="fig14_8">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro08" id="p14pro08a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_08.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms swap, iter_swap and swap_ranges.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::array values{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>, <span class="green">7</span>, <span class="green">8</span>, <span class="green">9</span>, <span class="green">10</span>};&#13;
<span class="cviolet"><strong>10</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      std::cout &lt;&lt; <span class="green">"values contains: "</span>;&#13;
<span class="cviolet"><strong>13</strong></span>      <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<pre class="pre1"><code>values contains: 1 2 3 4 5 6 7 8 9 10</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.8</strong></span> | Algorithms <code>swap</code>, <code>iter_swap</code> and <code>swap_ranges</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec53"><code>swap</code> Algorithm</h5>&#13;
<p>Line 15 uses the <code>std::</code><span class="violet"><strong><code>swap</code></strong></span> <strong><span class="violet">algorithm</span></strong> to exchange its two arguments’ values—this is not a range or common-range algorithm. The function takes as arguments simply references to two values being exchanged. In this case, we pass references to the <code>array</code>’s first and second elements.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p779pro01" id="p779pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>15</strong></span>   std::swap(values[<span class="green">0</span>], values[<span class="green">1</span>]); <span class="lgreen">// swap elements at index 0 and 1</span>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>   std::cout &lt;&lt; <span class="green">"\nvalues after swapping a[0] and a[1] with swap: "</span>;&#13;
<span class="cviolet"><strong>18</strong></span>   <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>19</strong></span></pre>&#13;
<pre class="pre1"><code>values after swapping a[0] and a[1] with swap:</code> <strong><code>2 1</code></strong> <code>3 4 5 6 7 8 9 10</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec54"><code>iter_swap</code> Algorithm</h5>&#13;
<p>Line 21 uses the <code>std::</code><span class="violet"><strong><code>iter_swap</code></strong></span> <strong><span class="violet">algorithm</span></strong> to exchange the two elements specified by its <strong>common-range forward iterator</strong> arguments. The iterators can refer to any two elements of the same type.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p780pro01" id="p780pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>20</strong></span>   <span class="lgreen">// use iterators to swap elements at locations 0 and 1</span>&#13;
<span class="cviolet"><strong>21</strong></span>   std::iter_swap(values.begin(), values.begin() + <span class="green">1</span>);&#13;
<span class="cviolet"><strong>22</strong></span>   std::cout &lt;&lt; <span class="green">"\nvalues after swapping a[0] and a[1] with iter_swap: "</span>;&#13;
<span class="cviolet"><strong>23</strong></span>   <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>24</strong></span></pre>&#13;
<pre class="pre1"><code>values after swapping a[0] and a[1] with iter_swap:</code> <strong><code>1 2</code></strong> <code>3 4 5 6 7 8 9 10</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec55"><code>swap_ranges</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Line 31 uses the <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">swap_ranges algorithm</span></strong></code> to exchange the elements of its two <strong><code>input_range</code></strong> arguments. If the <strong>ranges</strong> are not the same length, the algorithm swaps the shorter sequence with the corresponding elements in the longer sequence. The <strong>ranges</strong> also must support <strong><code>indirectly_swappable</code> iterators</strong>, so the algorithm can <strong>dereference the iterators</strong> to swap to the corresponding elements in each <strong>range</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p780pro02" id="p780pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>25</strong></span>   <span class="lgreen">// swap values and values2</span>&#13;
<span class="cviolet"><strong>26</strong></span>   std::array values2{<span class="green">10</span>, <span class="green">9</span>, <span class="green">8</span>, <span class="green">7</span>, <span class="green">6</span>, <span class="green">5</span>, <span class="green">4</span>, <span class="green">3</span>, <span class="green">2</span>, <span class="green">1</span>};&#13;
<span class="cviolet"><strong>27</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nBefore swap_ranges\nvalues contains: "</span>;&#13;
<span class="cviolet"><strong>28</strong></span>   <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>29</strong></span>   std::cout &lt;&lt; <span class="green">"\nvalues2 contains: "</span>;&#13;
<span class="cviolet"><strong>30</strong></span>   <code>std::ranges::copy(values2, output);</code>&#13;
<span class="cviolet"><strong>31</strong></span>   <code>std::ranges::swap_ranges(values, values2);</code>&#13;
<span class="cviolet"><strong>32</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nAfter swap_ranges\nvalues contains: "</span>;&#13;
<span class="cviolet"><strong>33</strong></span>   <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>34</strong></span>   std::cout &lt;&lt; <span class="green">"\nvalues2 contains: "</span>;&#13;
<span class="cviolet"><strong>35</strong></span>   <code>std::ranges::copy(values2, output);</code>&#13;
<span class="cviolet"><strong>36</strong></span></pre>&#13;
<pre class="pre1"><code>Before swap_ranges</code>&#13;
<code>values contains: 1 2 3 4 5 6 7 8 9 10</code>&#13;
<code>values2 contains: 10 9 8 7 6 5 4 3 2 1</code>&#13;
&#13;
<code>After swap_ranges</code>&#13;
<code>values contains: 10 9 8 7 6 5 4 3 2 1</code>&#13;
<code>values2 contains: 1 2 3 4 5 6 7 8 9 10</code></pre>&#13;
</div>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> Lines 38–39 use the <strong>C++20 <code>std::ranges::swap_ranges</code></strong> overload that enables you to specify the portions of two <strong><code>input_range</code></strong>s to swap. Here, we swap <code>values</code>’s first five elements with its last five elements, specifying the two ranges to swap as <strong>iterator pairs</strong>:</p>&#13;
<p class="bull">• <code>values.begin()</code> and <code>values.begin() + 5</code> indicate the first five elements, and</p>&#13;
<p class="bull">• <code>values.begin() + 5</code> and <code>values.end()</code> indicate the last five elements.</p>&#13;
<p>Specifying <strong>iterator pairs</strong> also works with the <strong>common ranges version</strong> in the <code>std</code> name-space. In fact, <strong>most common ranges algorithms require iterator pairs</strong>. In this example, the two <strong>ranges</strong> are in the same container, but <strong>the ranges can be from different containers</strong>. <strong>The ranges must not overlap</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p781pro01" id="p781pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>37</strong></span>      <span class="lgreen">// swap first five elements of values and values2</span>&#13;
<span class="cviolet"><strong>38</strong></span>      std::ranges::swap_ranges(values.begin(), values.begin() + <span class="green">5</span>,&#13;
<span class="cviolet"><strong>39</strong></span>         values2.begin(), values2.begin() + <span class="green">5</span>);&#13;
<span class="cviolet"><strong>40</strong></span>&#13;
<span class="cviolet"><strong>41</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nAfter swap_ranges for 5 elements"</span>&#13;
<span class="cviolet"><strong>42</strong></span>         &lt;&lt; <span class="green">"\nvalues contains: "</span>;&#13;
<span class="cviolet"><strong>43</strong></span>      <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>44</strong></span>      std::cout &lt;&lt; <span class="green">"\nvalues2 contains: "</span>;&#13;
<span class="cviolet"><strong>45</strong></span>      <code>std::ranges::copy(values2, output);</code>&#13;
<span class="cviolet"><strong>46</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>47</strong></span>   }</pre>&#13;
<pre class="pre1"><code>After swap_ranges for 5 elements</code>&#13;
<code>values contains: 1 2 3 4 5 5 4 3 2 1</code>&#13;
<code>values2 contains: 10 9 8 7 6 6 7 8 9 10</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_8">14.4.8 <code>copy_backward</code>, <code>merge</code>, <code>unique</code>, <code>reverse</code>, <code>copy_if</code> and <code>copy_n</code></h4>&#13;
<p><span class="size">20</span> <a href="ch14.xhtml#fig14_9">Figure 14.9</a><sup><a id="ch14fn22a" href="ch14.xhtml#ch14fn22">22</a></sup> demonstrates algorithms <strong><code>copy_backward</code></strong>, <strong><code>merge</code></strong>, <strong><code>unique</code></strong>, <strong><code>reverse</code></strong>, <strong><code>copy_if</code></strong> and <strong><code>copy_n</code></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong>.</p>&#13;
<p class="footnote"><a id="ch14fn22" href="ch14.xhtml#ch14fn22a">22</a>. As of May 2021, <code>std::ranges::unique</code> did not compile on the most recent <code>clang++</code> compiler.</p>&#13;
<div class="group" id="fig14_9">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro09" id="p14pro09a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_09.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms copy_backward, merge, unique, reverse, copy_if and copy_n.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      std::array a1{<span class="green">1</span>, <span class="green">3</span>, <span class="green">5</span>, <span class="green">7</span>, <span class="green">9</span>};&#13;
<span class="cviolet"><strong>11</strong></span>      std::array a2{<span class="green">2</span>, <span class="green">4</span>, <span class="green">5</span>, <span class="green">7</span>, <span class="green">9</span>};&#13;
<span class="cviolet"><strong>12</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      std::cout &lt;&lt; <span class="green">"array a1 contains: "</span>;&#13;
<span class="cviolet"><strong>15</strong></span>      std::ranges::copy(a1, output); <span class="lgreen">// display a1</span>&#13;
<span class="cviolet"><strong>16</strong></span>      std::cout &lt;&lt; <span class="green">"\narray a2 contains: "</span>;&#13;
<span class="cviolet"><strong>17</strong></span>      std::ranges::copy(a2, output); <span class="lgreen">// display a2</span>&#13;
<span class="cviolet"><strong>18</strong></span></pre>&#13;
<pre class="pre1"><code>array a1 contains: 1 3 5 7 9</code>&#13;
<code>array a2 contains: 2 4 5 7 9</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.9</strong></span> | Algorithms <code>copy_backward</code>, <code>merge</code>, <code>unique</code> and <code>reverse</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec56"><code>copy_backward</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">copy_backward algorithm</span></strong></code> (line 21) copies its first argument’s <strong><code>bidirectional_range</code></strong> (<code>a1</code>) into the destination specified by its second argument, which indicates the <strong>end of the target container</strong> (<code>results.end()</code>). The algorithm copies the original elements in reverse order, placing each element into the target container, <strong>starting from the element before <code>results.end()</code> and working toward the beginning of the container</strong>. The <strong>iterator</strong> specified by the second argument must be <strong><code>indirectly_copyable</code></strong>, so <strong><code>copy_backward</code></strong> can <strong>dereference the iterator</strong> to copy the value it references. The algorithm returns an <strong>iterator pair</strong> in which the first is positioned at <code>a1.end()</code>, and the second is positioned at the last element copied into the target container—that is, the beginning of <code>results</code> because the copy is performed backwards. Though the elements are copied in reverse order, they’re placed in <code>results</code> in the same order as <code>a1</code>. One difference between <strong><code>copy</code></strong> and <strong><code>copy_backward</code></strong> is that</p>&#13;
<p class="bull">• the <strong>iterator</strong> returned from <strong><code>copy</code></strong> is positioned <em>after</em> the last element copied, and</p>&#13;
<p class="bull">• the one returned from <strong><code>copy_backward</code></strong> is positioned <em>at</em> the last element copied (i.e., the first element in the sequence).</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p782pro01" id="p782pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>19</strong></span>   <span class="lgreen">// place elements of a1 into results in reverse order</span>&#13;
<span class="cviolet"><strong>20</strong></span>   std::array&lt;<span class="blue">int</span>, a1.size()&gt; results{};&#13;
<span class="cviolet"><strong>21</strong></span>   <code>std::ranges::copy_backward(a1, results.end());</code>&#13;
<span class="cviolet"><strong>22</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nAfter copy_backward, results contains: "</span>;&#13;
<span class="cviolet"><strong>23</strong></span>   <code>std::ranges::copy(results, output);</code>&#13;
<span class="cviolet"><strong>24</strong></span></pre>&#13;
<pre class="pre1"><code>After copy_backward, results contains: 1 3 5 7 9</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec57"><code>move</code> and <strong><code>move_backward</code></strong> Algorithm</h5>&#13;
<p><span class="size">20</span> You can use <strong>move semantics</strong> with ranges of elements. The <strong>C++20 <code>std::ranges</code> algorithms</strong> <span class="violet"><strong><code>move</code></strong></span> and <span class="violet"><strong><code>move_backward</code></strong></span> (from header <code>&lt;algorithm&gt;</code>) work like the <strong><code>copy</code></strong> and <strong><code>copy_backward</code> algorithms</strong>, but move the elements in the specified ranges rather than copying them.</p>&#13;
<h5 class="h5" id="ch14lev3sec58"><code>merge</code> Algorithm</h5>&#13;
<p><span class="size">20</span> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">merge algorithm</span></strong></code> (line 27) combines two <strong><code>input_range</code></strong>s that are each <strong>sorted in ascending order</strong> to the target container specified by the third argument’s <strong><code>weakly_incrementable</code> output iterator</strong>. After this operation, <code>results2</code> contains both <strong>ranges</strong>’ values in sorted order. A second version of <strong><code>merge</code></strong> takes <strong>iterator/sentinel pairs</strong> rep-resenting the two <strong>ranges</strong>. Both versions allow you to provide a <strong>binary predicate function</strong> that specifies the sorting order by comparing its two arguments and returning <code>true</code> if the first is less than the second.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p782pro02" id="p782pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>25</strong></span>   <span class="lgreen">// merge elements of a1 and a2 into results2 in sorted order</span>&#13;
<span class="cviolet"><strong>26</strong></span>   std::array&lt;<span class="blue">int</span>, a1.size() + a2.size()&gt; results2{};&#13;
<span class="cviolet"><strong>27</strong></span>   <code>std::ranges::merge(a1, a2, results2.begin());</code>&#13;
<span class="cviolet"><strong>28</strong></span>&#13;
<span class="cviolet"><strong>29</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nAfter merge of a1 and a2, results2 contains: "</span>;&#13;
<span class="cviolet"><strong>30</strong></span>   <code>std::ranges::copy(results2, output);</code>&#13;
<span class="cviolet"><strong>31</strong></span>   </pre>&#13;
<pre class="pre1"><code>After merge of a1 and a2, results2 contains: 1 2 3 4 5 5 7 7 9 9</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec59"><code>unique</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">unique algorithm</span></strong></code> (line 34) determines the unique values in the sorted range of values specified by its <strong><code>forward_range</code></strong> argument. After <strong><code>unique</code></strong> is applied to a <strong>sorted range</strong> with duplicate values, a single copy of each value remains in the <strong>range</strong>. The algorithm returns an <strong>iterator pair</strong>. The first is positioned <em>after</em> the last unique value, and the second is positioned <em>at</em> the end of the original <strong>range</strong>. <strong>The values of all elements in the container after the last unique value are undefined. They should not be used, so this is another case in which you can erase the unused elements</strong> (line 35). You also may provide a <strong>binary predicate function</strong> specifying how to compare two elements for equality.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p783pro01" id="p783pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>32</strong></span>   <span class="lgreen">// eliminate duplicate values from v</span>&#13;
<span class="cviolet"><strong>33</strong></span>   <code>std::vector v(results2.begin(), results2.end());</code>&#13;
<span class="cviolet"><strong>34</strong></span>   <span class="blue">const auto</span>&amp; [first, last]{std::ranges::unique(v)};&#13;
<span class="cviolet"><strong>35</strong></span>   v.erase(first, last); <span class="lgreen">// remove elements that no longer contain values</span>&#13;
<span class="cviolet"><strong>36</strong></span>&#13;
<span class="cviolet"><strong>37</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nAfter unique v contains: "</span>;&#13;
<span class="cviolet"><strong>38</strong></span>   <code>std::ranges::copy(v, output);</code>&#13;
<span class="cviolet"><strong>39</strong></span></pre>&#13;
<pre class="pre1"><code>After unique, v contains: 1 2 3 4 5 7 9</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec60"><code>reverse</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">reverse algorithm</span></strong></code> (line 41) reverses the elements in its argument—a <strong><code>bidirectional_range</code></strong> that supports <strong><code>bidirectional_iterators</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p783pro02" id="p783pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>40</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nAfter reverse, a1 contains: "</span>;&#13;
<span class="cviolet"><strong>41</strong></span>   std::ranges::reverse(a1); <span class="lgreen">// reverse elements of a1</span>&#13;
<span class="cviolet"><strong>42</strong></span>   <code>std::ranges::copy(a1, output);</code>&#13;
<span class="cviolet"><strong>43</strong></span></pre>&#13;
<pre class="pre1"><code>After reverse, a1 contains: 9 7 5 3 1</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec61"><code>copy_if</code> Algorithm</h5>&#13;
<p><span class="size">11</span> <span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> C++11 added the copy algorithms <strong><code>copy_if</code></strong> and <strong><code>copy_n</code></strong>, and C++20 added <strong>ranges</strong> versions of each. The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">copy_if algorithm</span></strong></code> (lines 47–48) receives as arguments an <strong><code>input_range</code></strong>, a <strong><code>weakly_incrementable</code> output iterator</strong> and a <strong>unary predicate function</strong>. The algorithm calls the <strong>unary predicate function</strong> for each element in the <strong><code>input_range</code></strong> and copies only those elements for which the function returns <code>true</code>. The <strong>output iterator</strong> specifies where to output elements—in this case, we use a <strong><code>back_inserter</code></strong> to add elements to a <code>vector</code>. The algorithm returns an <strong>iterator pair</strong>—the first is positioned <em>at</em> the end of the <strong><code>input_range</code></strong>, and the second is positioned <em>after</em> the last element copied into the output container.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p784pro01" id="p784pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>44</strong></span>   <span class="lgreen">// copy odd elements of a2 into v2</span>&#13;
<span class="cviolet"><strong>45</strong></span>   std::vector&lt;<span class="blue">int</span>&gt; v2{};&#13;
<span class="cviolet"><strong>46</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nAfter copy_if, v2 contains: "</span>;&#13;
<span class="cviolet"><strong>47</strong></span>   <code>std::ranges::copy_if(a2, std::back_inserter(v2),</code>&#13;
<span class="cviolet"><strong>48</strong></span>      [](<span class="blue">auto</span> x){<span class="blue">return</span> x % <span class="green">2</span> == <span class="green">0</span>;});&#13;
<span class="cviolet"><strong>49</strong></span>   <code>std::ranges::copy(v2, output);</code>&#13;
<span class="cviolet"><strong>50</strong></span></pre>&#13;
<pre class="pre1"><code>After copy_if, v2 contains: 2 4</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec62"><code>copy_n</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">copy_n algorithm</span></strong></code> (line 54) copies from the location specified by the <strong><code>input_iterator</code></strong> in its first argument (<code>a2.begin()</code>) the number of elements specified by its second argument (<code>3</code>). The elements are output to the location specified by the <strong><code>weakly_incrementable</code> output iterator</strong> in the third argument—in this case, we use a <strong><code>back_inserter</code></strong> to add elements to a <code>vector</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p784pro02" id="p784pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>51</strong></span>      <span class="lgreen">// copy three elements of a2 into v3</span>&#13;
<span class="cviolet"><strong>52</strong></span>      std::vector&lt;<span class="blue">int</span>&gt; v3{};&#13;
<span class="cviolet"><strong>53</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nAfter copy_n, v3 contains: "</span>;&#13;
<span class="cviolet"><strong>54</strong></span>      std::ranges::copy_n(a2.begin(), <span class="green">3</span>, std::back_inserter(v3));&#13;
<span class="cviolet"><strong>55</strong></span>      <code>std::ranges::copy(v3, output);</code>&#13;
<span class="cviolet"><strong>56</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>57</strong></span>   }</pre>&#13;
<pre class="pre1"><code>After copy_n, v3 contains: 2 4 5</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_9">14.4.9 <code>inplace_merge</code>, <code>unique_copy</code> and <code>reverse_copy</code></h4>&#13;
<p><a href="ch14.xhtml#fig14_10">Figure 14.10</a><sup><a id="ch14fn23a" href="ch14.xhtml#ch14fn23">23</a></sup> demonstrates algorithms <strong><code>inplace_merge</code></strong>, <strong><code>unique_copy</code></strong> and <strong><code>reverse_copy</code></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong>.</p>&#13;
<p class="footnote"><a id="ch14fn23" href="ch14.xhtml#ch14fn23a">23</a>. As of May 2021, <code>std::ranges::unique_copy</code> did not compile on the most recent Visual C++ compiler.</p>&#13;
<div class="group" id="fig14_10">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro10" id="p14pro10a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_10.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms inplace_merge, reverse_copy and unique_copy.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      std::array a1{<span class="green">1</span>, <span class="green">3</span>, <span class="green">5</span>, <span class="green">7</span>, <span class="green">9</span>, <span class="green">1</span>, <span class="green">3</span>, <span class="green">5</span>, <span class="green">7</span>, <span class="green">9</span>};&#13;
<span class="cviolet"><strong>11</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output(std::cout, <span class="green">" ")</span>;&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      std::cout &lt;&lt; <span class="green">"array a1 contains: "</span>;&#13;
<span class="cviolet"><strong>14</strong></span>      <code>std::ranges::copy(a1, output);</code>&#13;
<span class="cviolet"><strong>15</strong></span></pre>&#13;
<pre class="pre1"><code>array a1 contains: 1 3 5 7 9 1 3 5 7 9</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.10</strong></span> | Algorithms <code>inplace_merge</code>, <code>reverse_copy</code> and <code>unique_copy</code>. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec63"><code>inplace_merge</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">inplace_merge algorithm</span></strong></code> (line 18) merges two sorted sequences of elements in its <strong><code>bidirectional_range</code></strong> argument. This example processes the <strong>range</strong> <code>a1</code> (the first argument), <strong>merging</strong> the elements from <code>a1.begin()</code> up to, but not including, <code>a1.begin() + 5</code> (the second argument) with the elements starting from <code>a1.begin() + 5</code> (the second argument) up to, but not including the end of the <strong>range</strong>. You also can pass a <strong>binary predicate function</strong> that compares elements in the two <strong>subranges</strong> and returns <code>true</code> if the first is less than the second.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p785pro01" id="p785pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>16</strong></span>   <span class="lgreen">// merge first half of a1 with second half of a1 such that</span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// a1 contains sorted set of elements after merge</span>&#13;
<span class="cviolet"><strong>18</strong></span>   std::ranges::inplace_merge(a1, a1.begin() + <span class="green">5</span>);&#13;
<span class="cviolet"><strong>19</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter inplace_merge, a1 contains: "</span>;&#13;
<span class="cviolet"><strong>20</strong></span>   <code>std::ranges::copy(a1, output);</code>&#13;
<span class="cviolet"><strong>21</strong></span></pre>&#13;
<pre class="pre1"><code>After inplace_merge, a1 contains: 1 1 3 3 5 5 7 7 9 9</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec64"><code>unique_copy</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">unique_copy algorithm</span></strong></code> (line 24) copies the unique elements in its first argument’s sorted <strong><code>input_range</code></strong>. The <strong><code>weakly_incrementable</code> output iterator</strong> supplied as the second argument specifies where to place the copied elements—in this case, the <strong><code>back_inserter</code></strong> adds new elements in the <code>vector results1</code>, growing it as necessary. You also can pass a <strong>binary predicate function</strong> for comparing elements for equality.</p>&#13;
<div class="group" id="fig14_10a">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p785pro02" id="p785pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>22</strong></span>   <span class="lgreen">// copy only unique elements of a1 into results1</span>&#13;
<span class="cviolet"><strong>23</strong></span>   std::vector&lt;<span class="blue">int</span>&gt; results1{};&#13;
<span class="cviolet"><strong>24</strong></span>   <code>std::ranges::unique_copy(a1, std::back_inserter(results1));</code>&#13;
<span class="cviolet"><strong>25</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter unique_copy, results1 contains: "</span>;&#13;
<span class="cviolet"><strong>26</strong></span>   <code>std::ranges::copy(results1, output);</code>&#13;
<span class="cviolet"><strong>27</strong></span></pre>&#13;
<pre class="pre1"><code>After unique_copy results1 contains: 1 3 5 7 9</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.10</strong></span> | Algorithms <code>inplace_merge</code>, <code>reverse_copy</code> and <code>unique_copy</code>. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec65"><code>reverse_copy</code> Algorithm</h5>&#13;
<p><span class="size">20</span> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">reverse_copy algorithm</span></strong></code> (line 30) makes a reversed copy of its first argument’s <strong><code>bidirectional_range</code></strong>. The <strong><code>weakly_incrementable</code> output iterator</strong> supplied as the second argument specifies where to place the copied elements—in this case, the <strong><code>back_inserter</code></strong> adds new elements in the <code>vector results2</code>, growing it as necessary.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p786pro01" id="p786pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>28</strong></span>      <span class="lgreen">// copy elements of a1 into results2 in reverse order</span>&#13;
<span class="cviolet"><strong>29</strong></span>      std::vector&lt;<span class="blue">int</span>&gt; results2{};&#13;
<span class="cviolet"><strong>30</strong></span>      <code>std::ranges::reverse_copy(a1, std::back_inserter(results2));</code>&#13;
<span class="cviolet"><strong>31</strong></span>      std::cout &lt;&lt; <span class="green">"\nAfter reverse_copy, results2 contains: "</span>;&#13;
<span class="cviolet"><strong>32</strong></span>      <code>std::ranges::copy(results2, output);</code>&#13;
<span class="cviolet"><strong>33</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>34</strong></span>   }</pre>&#13;
<pre class="pre1"><code>After reverse_copy, results2 contains: 9 9 7 7 5 5 3 3 1 1</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_10">14.4.10 Set Operations</h4>&#13;
<p><span class="size">20</span> <a href="ch14.xhtml#fig14_11">Figure 14.11</a> demonstrates the <strong>C++20 <code>std::ranges</code> namespace’s</strong> set-manipulation <strong>algorithms <code>includes</code></strong>, <strong><code>set_difference</code></strong>, <strong><code>set_intersection</code></strong>, <strong><code>set_symmetric_difference</code></strong> and <strong><code>set_union</code></strong>. In addition to the capabilities described in this section, you can customize these algorithms’ element comparisons by passing a <strong>binary predicate function</strong> that compares two elements to determine whether the first is less than the second.</p>&#13;
<div class="group" id="fig14_11">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro11" id="p14pro11a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_11.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms includes, set_difference, set_intersection,</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// set_symmetric_difference and set_union.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// C++20: This will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>12</strong></span>      std::array a1{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>, <span class="green">7</span>, <span class="green">8</span>, <span class="green">9</span>, <span class="green">10</span>};&#13;
<span class="cviolet"><strong>13</strong></span>      std::array a2{<span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>, <span class="green">7</span>, <span class="green">8</span>};&#13;
<span class="cviolet"><strong>14</strong></span>      std::array a3{<span class="green">4</span>, <span class="green">5</span>, <span class="green">6</span>, <span class="green">11</span>, <span class="green">15</span>};&#13;
<span class="cviolet"><strong>15</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      std::cout &lt;&lt; <span class="green">"a1 contains: "</span>;&#13;
<span class="cviolet"><strong>18</strong></span>      std::ranges::copy(a1, output); <span class="lgreen">// display array a1</span>&#13;
<span class="cviolet"><strong>19</strong></span>      std::cout &lt;&lt; <span class="green">"\na2 contains: "</span>;&#13;
<span class="cviolet"><strong>20</strong></span>      std::ranges::copy(a2, output); <span class="lgreen">// display array a2</span>&#13;
<span class="cviolet"><strong>21</strong></span>      std::cout &lt;&lt; <span class="green">"\na3 contains: "</span>;&#13;
<span class="cviolet"><strong>22</strong></span>      std::ranges::copy(a3, output); <span class="lgreen">// display array a3</span>&#13;
<span class="cviolet"><strong>23</strong></span></pre>&#13;
<pre class="pre1"><code>a1 contains: 1 2 3 4 5 6 7 8 9 10</code>&#13;
<code>a2 contains: 4 5 6 7 8</code>&#13;
<code>a3 contains: 4 5 6 11 15</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.11</strong></span> <code>|</code> Algorithms <code>includes</code>, <code>set_difference</code>, <code>set_intersection</code>, <code>set_symmetric_difference</code> and <code>set_union</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec66"><code>includes</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">includes algorithm</span></strong></code> (lines 26 and 31) compares two sorted <strong><code>input_range</code></strong>s to determine whether every element of the second is in the first. The <strong>ranges must be sorted</strong> using the same <strong>comparison function</strong>. The algorithm returns <code>true</code> if all the second <strong>range</strong>’s elements are in the first; otherwise, it returns <code>false</code>. In line 26, <code>a2</code>’s elements are all in <code>a1</code>, so <code>includes</code> returns <code>true</code>. In line 31, <code>a3</code>’s elements are not all in <code>a1</code>, so the <strong><code>includes</code></strong> returns <code>false</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p787pro01" id="p787pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>24</strong></span>   <span class="lgreen">// determine whether a2 is completely contained in a1</span>&#13;
<span class="cviolet"><strong>25</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"\n\na1 {} a2"</span>,&#13;
<span class="cviolet"><strong>26</strong></span>                   std::ranges::includes(a1, a2) ?&#13;
<span class="cviolet"><strong>27</strong></span>                      <span class="green">"includes"</span> : <span class="green">"does not include"</span>);&#13;
<span class="cviolet"><strong>28</strong></span>   &#13;
<span class="cviolet"><strong>29</strong></span>   <span class="lgreen">// determine whether a3 is completely contained in a1</span>&#13;
<span class="cviolet"><strong>30</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"\n\na1 {} a3"</span>,&#13;
<span class="cviolet"><strong>31</strong></span>                   std::ranges::includes(a1, a3) ?&#13;
<span class="cviolet"><strong>32</strong></span>                      <span class="green">"includes"</span> : <span class="green">"does not include"</span>);&#13;
<span class="cviolet"><strong>33</strong></span></pre>&#13;
<pre class="pre1"><code>a1 includes a2</code>&#13;
<code>a1 does not include a3</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec67"><code>set_difference</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">set_difference algorithm</span></strong></code> (line 36) finds the elements from the first sorted <strong><code>input_range</code></strong> that are not in the second sorted <strong><code>input_range</code></strong>. The <strong>ranges</strong> must be sorted using the same <strong>comparison function</strong>. The elements that differ are copied to the location specified by the <strong><code>weakly_incrementable</code> output iterator</strong> supplied as the third argument—in this case, a <strong><code>back_inserter</code></strong> adds them to the <code>vector difference</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p787pro02" id="p787pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>34</strong></span>   <span class="lgreen">// determine elements of a1 not in a2</span>&#13;
<span class="cviolet"><strong>35</strong></span>   std::vector&lt;<span class="blue">int</span>&gt; difference{};&#13;
<span class="cviolet"><strong>36</strong></span>   <code>std::ranges::set_difference(a1, a2, std::back_inserter(difference));</code>&#13;
<span class="cviolet"><strong>37</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nset_difference of a1 and a2 is: "</span>;&#13;
<span class="cviolet"><strong>38</strong></span>   <code>std::ranges::copy(difference, output);</code>&#13;
<span class="cviolet"><strong>39</strong></span></pre>&#13;
<pre class="pre1"><code>set_difference of a1 and a2 is: 1 2 3 9 10</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec68"><code>set_intersection</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">set_intersection algorithm</span></strong></code> (lines 42–43) determines the elements from the first sorted <strong><code>input_range</code></strong> that are in the second sorted <strong><code>input_range</code></strong>. The <strong>ranges</strong> must be sorted using the same <strong>comparison function</strong>. The elements common to both are copied to the location specified by the <strong><code>weakly_incrementable</code> output iterator</strong> supplied as the third argument—in this case, a <strong><code>back_inserter</code></strong> adds them to the <code>vector intersection</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p788pro01" id="p788pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>40</strong></span>   <span class="lgreen">// determine elements in both a1 and a2</span>&#13;
<span class="cviolet"><strong>41</strong></span>   std::vector&lt;<span class="blue">int</span>&gt; intersection{};&#13;
<span class="cviolet"><strong>42</strong></span>   <code>std::ranges::set_intersection(a1, a2,</code>&#13;
<span class="cviolet"><strong>43</strong></span>      <code>std::back_inserter(intersection));</code>&#13;
<span class="cviolet"><strong>44</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nset_intersection of a1 and a2 is: "</span>;&#13;
<span class="cviolet"><strong>45</strong></span>   <code>std::ranges::copy(intersection, output);</code>&#13;
<span class="cviolet"><strong>46</strong></span></pre>&#13;
<pre class="pre1"><code>set_intersection of a1 and a2 is: 4 5 6 7 8</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec69"><code>set_symmetric_difference</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">set_symmetric_difference algorithm</span></strong></code> (lines 50–51) determines the elements in the first sorted <strong><code>input_range</code></strong> that are not in the second sorted <strong><code>input_range</code></strong> and the elements in the second <strong>range</strong> that are not in the first. The <strong>ranges</strong> must be sorted using the same <strong>comparison function</strong>. Each <strong><code>input_range</code></strong>’s elements that are different are copied to the location specified by the <strong><code>weakly_incrementable</code> output iterator</strong> supplied as the third argument—in this case, a <strong><code>back_inserter</code></strong> adds them to <code>symmetricDifference</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p788pro02" id="p788pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>47</strong></span>   <span class="lgreen">// determine elements of a1 that are not in a3 and</span>&#13;
<span class="cviolet"><strong>48</strong></span>   <span class="lgreen">// elements of a3 that are not in a1</span>&#13;
<span class="cviolet"><strong>49</strong></span>   std::vector&lt;<span class="blue">int</span>&gt; symmetricDifference{};&#13;
<span class="cviolet"><strong>50</strong></span>   <code>std::ranges::set_symmetric_difference(a1, a3,</code>&#13;
<span class="cviolet"><strong>51</strong></span>      <code>std::back_inserter(symmetricDifference));</code>&#13;
<span class="cviolet"><strong>52</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nset_symmetric_difference of a1 and a3 is: "</span>;&#13;
<span class="cviolet"><strong>53</strong></span>   <code>std::ranges::copy(symmetricDifference, output);</code>&#13;
<span class="cviolet"><strong>54</strong></span></pre>&#13;
<pre class="pre1"><code>set_symmetric_difference of a1 and a3 is: 1 2 3 7 8 9 10 11 15</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec70"><code>set_union</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">set_union algorithm</span></strong></code> (line 57) creates a set of all the elements that are in either or both of its two sorted <strong><code>input_range</code></strong>s, which must be sorted using the same <strong>comparison function</strong>. The elements are copied to the location specified by the <strong><code>weak-ly_incrementable</code> output iterator</strong> supplied as the third argument—in this case, a <strong><code>back_inserter</code></strong> adds them to <code>unionSet</code>. Elements that appear in both sets are copied only from the first set.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p788pro03" id="p788pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>55</strong></span>      <span class="lgreen">// determine elements that are in either or both sets</span>&#13;
<span class="cviolet"><strong>56</strong></span>      std::vector&lt;<span class="blue">int</span>&gt; unionSet{};&#13;
<span class="cviolet"><strong>57</strong></span>      <code>std::ranges::set_union(a1, a3, std::back_inserter(unionSet));</code>&#13;
<span class="cviolet"><strong>58</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nset_union of a1 and a3 is: "</span>;&#13;
<span class="cviolet"><strong>59</strong></span>      <code>std::ranges::copy(unionSet, output);</code>&#13;
<span class="cviolet"><strong>60</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>61</strong></span>   }</pre>&#13;
<pre class="pre1"><code>set_union of a1 and a3 is: 1 2 3 4 5 6 7 8 9 10 11 15</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_11">14.4.11 <code>lower_bound</code>, <code>upper_bound</code> and <code>equal_range</code></h4>&#13;
<p><a href="ch14.xhtml#fig14_12">Figure 14.12</a><sup><a id="ch14fn24a" href="ch14.xhtml#ch14fn24">24</a></sup> demonstrates the algorithms <strong><code>lower_bound</code></strong>, <strong><code>upper_bound</code></strong> and <strong><code>equal_range</code></strong> from <strong>C++20’s <code>std::ranges</code> namespace</strong>. In addition to the capabilities described in this section, you can customize these algorithms’ element comparisons by passing a <strong>binary predicate function</strong> that compares two elements to determine whether the first is less than the second.</p>&#13;
<p class="footnote"><a id="ch14fn24" href="ch14.xhtml#ch14fn24a">24</a>. As of May 2021, <code>std::ranges::equal_range</code> did not compile on the most recent Clang compiler.</p>&#13;
<div class="group" id="fig14_12">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro12" id="p14pro12a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_12.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms lower_bound, upper_bound and</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// equal_range for a sorted sequence of values.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      std::array values{<span class="green">2</span>, <span class="green">2</span>, <span class="green">4</span>, <span class="green">4</span>, <span class="green">4</span>, <span class="green">6</span>, <span class="green">6</span>, <span class="green">6</span>, <span class="green">6</span>, <span class="green">8</span>};&#13;
<span class="cviolet"><strong>11</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      std::cout &lt;&lt; <span class="green">"values contains: "</span>;&#13;
<span class="cviolet"><strong>14</strong></span>      <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>15</strong></span></pre>&#13;
<pre class="pre1"><code>Array a contains: 2 2 4 4 4 6 6 6 6 8</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.12</strong></span> | Algorithms <code>lower_bound</code>, <code>upper_bound</code> and <code>equal_range</code> for a sorted sequence of values.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec71"><code>lower_bound</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">lower_bound algorithm</span></strong></code> (line 17) finds in a <strong>sorted <code>forward_range</code></strong> the first location at which the second argument could be inserted such that the <strong>range</strong> would still be <strong>sorted in ascending order</strong>. The algorithm returns an <strong>iterator</strong> pointing to that location.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p789pro01" id="p789pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>16</strong></span>   <span class="lgreen">// determine lower-bound insertion point for 6 in values</span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="blue">auto</span> lower{std::ranges::lower_bound(values, <span class="green">6</span>)};&#13;
<span class="cviolet"><strong>18</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nLower bound of 6 is index: "</span>&#13;
<span class="cviolet"><strong>19</strong></span>      <code>&lt;&lt; (lower - values.begin());</code>&#13;
<span class="cviolet"><strong>20</strong></span></pre>&#13;
<pre class="pre1"><code>Lower bound of 6 is element 5 of array a</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec72"><code>upper_bound</code> Algorithm</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">upper_bound algorithm</span></strong></code> (line 22) finds in a <strong>sorted <code>forward_range</code></strong> the last location at which the second argument could be inserted such that the range would still be <strong>sorted in ascending order</strong>. The algorithm returns an <strong>iterator</strong> pointing to that location.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p790pro01" id="p790pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>21</strong></span>   <span class="lgreen">// determine upper-bound insertion point for 6 in values</span>&#13;
<span class="cviolet"><strong>22</strong></span>   <span class="blue">auto</span> upper{std::ranges::upper_bound(values, <span class="green">6</span>)};&#13;
<span class="cviolet"><strong>23</strong></span>   std::cout &lt;&lt; <span class="green">"\nUpper bound of 6 is index: "</span>&#13;
<span class="cviolet"><strong>24</strong></span>      <code>&lt;&lt; (upper - values.begin());</code>&#13;
<span class="cviolet"><strong>25</strong></span></pre>&#13;
<pre class="pre1"><code>Upper bound of 6 is element 9 of array a</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec73"><code>equal_range</code> Algorithm</h5>&#13;
<p><span class="size">20</span> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">equal_range algorithm</span></strong></code> (line 27) returns a <code>subrange</code> (name-space <code>std::ranges</code>) containing two <strong>iterators</strong> representing the results of performing both a <strong><code>lower_bound</code></strong> and an <strong><code>upper_bound</code></strong> operation. Line 27 uses <strong>structured bindings</strong> to unpack these <strong>iterators</strong> into <code>first</code> and <code>last</code>, which we use to calculate the corresponding index positions in <code>values</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p790pro02" id="p790pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>26</strong></span>   <span class="lgreen">// use equal_range to determine the lower and upper bound of 6</span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="blue">const auto</span>&amp; [first, last]{std::ranges::equal_range(values, <span class="green">6</span>)};&#13;
<span class="cviolet"><strong>28</strong></span>   std::cout &lt;&lt; <span class="green">"\nUsing equal_range:\n Lower bound of 6 is index: "</span>&#13;
<span class="cviolet"><strong>29</strong></span>      <code>&lt;&lt; (first - values.begin());</code>&#13;
<span class="cviolet"><strong>30</strong></span>   std::cout &lt;&lt; <span class="green">"\n Upper bound of 6 is index: "</span>&#13;
<span class="cviolet"><strong>31</strong></span>      <code>&lt;&lt; (last - values.begin());</code>&#13;
<span class="cviolet"><strong>32</strong></span></pre>&#13;
<pre class="pre1"><code>Using equal_range:</code>&#13;
<code>   Lower bound of 6 is element 5 of array a</code>&#13;
<code>   Upper bound of 6 is element 9 of array a</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec74">Locating Insertion Points in Sorted Sequences</h5>&#13;
<p>Algorithms <strong><code>lower_bound</code></strong>, <strong><code>upper_bound</code></strong> and <strong><code>equal_range</code></strong> are often used to locate a new value’s insertion point in a sorted sequence. Line 36 uses <strong><code>lower_bound</code></strong> to locate the first position at which <code>3</code> can be inserted in order in <code>values</code>. Line 43 uses <strong><code>upper_bound</code></strong> to locate the last point at which <code>7</code> can be inserted in order in <code>values</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p790pro03" id="p790pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>33</strong></span>      <span class="lgreen">// determine lower-bound insertion point for 3 in values</span>&#13;
<span class="cviolet"><strong>34</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nUse lower_bound to locate the first point "</span>&#13;
<span class="cviolet"><strong>35</strong></span>         &lt;&lt; <span class="green">"at which 3 can be inserted in order"</span>;&#13;
<span class="cviolet"><strong>36</strong></span>      lower = std::ranges::lower_bound(values, <span class="green">3</span>);&#13;
<span class="cviolet"><strong>37</strong></span>      std::cout &lt;&lt; <span class="green">"\n Lower bound of 3 is index: "</span>&#13;
<span class="cviolet"><strong>38</strong></span>         <code>&lt;&lt; (lower - values.begin());</code>&#13;
<span class="cviolet"><strong>39</strong></span>&#13;
<span class="cviolet"><strong>40</strong></span>      <span class="lgreen">// determine upper-bound insertion point for 7 in values</span>&#13;
<span class="cviolet"><strong>41</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nUse upper_bound to locate the last point\n"</span>&#13;
<span class="cviolet"><strong>42</strong></span>         &lt;&lt; <span class="green">"at which 7 can be inserted in order"</span>;&#13;
<span class="cviolet"><strong>43</strong></span>      upper = std::ranges::upper_bound(values, <span class="green">7</span>);&#13;
<span class="cviolet"><strong>44</strong></span>      std::cout &lt;&lt; <span class="green">"\n Upper bound of 7 is index: "</span>&#13;
<span class="cviolet"><strong>45</strong></span>         <code>&lt;&lt; (upper - values.begin());</code>&#13;
<span class="cviolet"><strong>46</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Use lower_bound to locate the first point</code>&#13;
<code>at which 5 can be inserted in order</code>&#13;
<code>   Lower bound of 5 is element 5 of array a</code>&#13;
&#13;
<code>Use upper_bound to locate the last point</code>&#13;
<code>at which 7 can be inserted in order</code>&#13;
   <code>Upper bound of 7 is element 9 of array a</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_12">14.4.12 <code>min</code>, <code>max</code> and <code>minmax</code></h4>&#13;
<p><span class="size">20</span> <a href="ch14.xhtml#fig14_13">Figure 14.13</a> demonstrates algorithms <strong><code>min</code></strong>, <strong><code>max</code></strong> and <strong><code>minmax</code></strong> from the <code>std</code> namespace and the <code>minmax</code> overload from <strong>C++20’s <code>std::ranges</code> namespace</strong>. Unlike the algorithms we presented in <a href="ch14.xhtml#sec14_4_5">Section 14.4.5</a>, which operated on <strong>ranges</strong>, the <code>std</code> namespace’s <strong><code>min</code></strong>, <strong><code>max</code></strong> and <strong><code>minmax</code></strong> algorithms operate on two values passed as arguments. The <strong><code>std::ranges::minmax</code></strong> algorithm returns the minimum and maximum values in a <strong>range</strong>.</p>&#13;
<h5 class="h5" id="ch14lev3sec75">Algorithms <code>min</code> and <strong><code>max</code></strong> with Two Parameters</h5>&#13;
<p>The <span class="violet"><strong><code>min</code></strong></span> and <span class="violet"><strong><code>max</code></strong></span> <strong><span class="violet">algorithms</span></strong> (demonstrated in lines 8–12) each receive two arguments and return the minimum or maximum value. Note that capital is <em>less than</em> lowercase .</p>&#13;
<div class="group" id="fig14_13">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro13" id="p14pro13a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_13.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms min, max, minmax and minmax_element.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>8</strong></span>      std::cout &lt;&lt; <span class="green">"Minimum of 12 and 7 is: "</span> &lt;&lt; std::min(<span class="green">12</span>, <span class="green">7</span>)&#13;
<span class="cviolet"> <strong>9</strong></span>         &lt;&lt; <span class="green">"\nMaximum of 12 and 7 is: "</span> &lt;&lt; std::max(<span class="green">12</span>, <span class="green">7</span>)&#13;
<span class="cviolet"><strong>10</strong></span>         &lt;&lt; <span class="green">"\nMinimum of 'G' and 'Z' is: '"</span> &lt;&lt; std::min(<span class="green">'G'</span>, <span class="green">'Z'</span>) &lt;&lt; <span class="green">"'"</span>&#13;
<span class="cviolet"><strong>11</strong></span>         &lt;&lt; <span class="green">"\nMaximum of 'G' and 'Z' is: '"</span> &lt;&lt; std::max(<span class="green">'G'</span>, <span class="green">'Z'</span>) &lt;&lt; <span class="green">"'"</span>&#13;
<span class="cviolet"><strong>12</strong></span>         &lt;&lt; <span class="green">"\nMinimum of 'z' and 'Z' is: '"</span> &lt;&lt; std::min(<span class="green">'z'</span>, <span class="green">'Z'</span>) &lt;&lt; <span class="green">"'"</span>;&#13;
<span class="cviolet"><strong>13</strong></span></pre>&#13;
<pre class="pre1"><code>Minimum of 12 and 7 is: 7</code>&#13;
<code>Maximum of 12 and 7 is: 12</code>&#13;
<code>Minimum of</code>&#13;
<code>Maximum of</code>&#13;
<code>Minimum of</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.13</strong></span> | Algorithms <code>min</code>, <code>max</code>, <code>minmax</code> and <code>minmax_element</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec76">C++11 <code>minmax</code> Algorithm with Two Arguments</h5>&#13;
<p><span class="size">11</span> C++11 added the two-argument <span class="violet"><strong><code>minmax</code></strong></span> <strong><span class="violet">algorithm</span></strong> (line 15), which returns a <strong>pair of values</strong> containing the smaller and larger item, respectively. Here we used <strong>structured bindings</strong> to unpack the values into <code>smaller</code> and <code>larger</code>. A second version of <strong><code>minmax</code></strong> takes as a third argument a <strong>binary predicate function</strong> for performing a <strong>custom comparison</strong> that determines whether the first argument is less than the second.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p792pro01" id="p792pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>14</strong></span>   <span class="lgreen">// determine which argument is the min and which is the max</span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">auto</span> [smaller, larger]{std::minmax(<span class="green">12</span>, <span class="green">7</span>)};&#13;
<span class="cviolet"><strong>16</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nMinimum of 12 and 7 is: "</span> &lt;&lt; smaller&#13;
<span class="cviolet"><strong>17</strong></span>       &lt;&lt; <span class="green">"\nMaximum of 12 and 7 is: "</span> &lt;&lt; larger;&#13;
<span class="cviolet"><strong>18</strong></span></pre>&#13;
<pre class="pre1"><code>The minimum of 12 and 7 is: 7</code>&#13;
<code>The maximum of 12 and 7 is: 12</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec77"><code>minmax</code> Algorithm for C++20 Ranges</h5>&#13;
<p><span class="size">20</span> <span class="size">Concepts</span><img class="inline" src="Images/concepts.jpg" alt="Images" width="32" height="32"/> The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">minmax algorithm</span></strong></code> (line 25) returns a pair of values containing the minimum and maximum items in its <strong><code>input_range</code></strong> or <strong><code>initializer_list</code></strong> argument. Here, we used <strong>structured bindings</strong> to unpack these values into <code>smallest</code> and <code>largest</code>, respectively. You also can pass as a second argument a <strong>binary predicate function</strong> for comparing elements to determine whether the first is less than the second.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p792pro02" id="p792pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>19</strong></span>      std::array items{<span class="green">3</span>, <span class="green">100</span>, <span class="green">52</span>, <span class="green">77</span>, <span class="green">22</span>, <span class="green">31</span>, <span class="green">1</span>, <span class="green">98</span>, <span class="green">13</span>, <span class="green">40</span>};&#13;
<span class="cviolet"><strong>20</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nitems: "</span>;&#13;
<span class="cviolet"><strong>23</strong></span>      <code>std::ranges::copy(items, output);</code>&#13;
<span class="cviolet"><strong>24</strong></span>      &#13;
<span class="cviolet"><strong>25</strong></span>      <span class="blue">const auto</span>&amp; [smallest, largest]{std::ranges::minmax(items)};&#13;
<span class="cviolet"><strong>26</strong></span>      std::cout &lt;&lt; <span class="green">"\nMinimum value in items: "</span> &lt;&lt; smallest&#13;
<span class="cviolet"><strong>27</strong></span>         &lt;&lt; <span class="green">"\nMaximum value in items is: "</span> &lt;&lt; largest &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>28</strong></span>   }</pre>&#13;
<pre class="pre1"><code>items: 3 100 52 77 22 31 1 98 13 40</code>&#13;
<code>Minimum value in items: 1</code>&#13;
<code>Maximum value in items is: 100</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec14_4_13">14.4.13 Algorithms <code>gcd</code>, <code>lcm</code>, <code>iota</code>, <code>reduce</code> and <code>partial_sum</code> from Header <code>&lt;numeric&gt;</code></h4>&#13;
<p>We’ve introduced the <strong><code>accumulate</code></strong> algorithm from <strong>header <code>&lt;numeric&gt;</code></strong>. <a href="ch14.xhtml#fig14_14">Figure 14.14</a> demonstrates several additional <strong><code>&lt;numeric&gt;</code> algorithms</strong>—<strong><code>gcd</code></strong>, <strong><code>lcm</code></strong>, <strong><code>iota</code></strong>, <strong><code>reduce</code></strong> and <strong><code>partial_sum</code></strong>. This header’s algorithms do not yet have <strong>C++20 <code>std::ranges</code> versions</strong>.</p>&#13;
<h5 class="h5" id="ch14lev3sec78"><code>gcd</code> Algorithm</h5>&#13;
<p>The <span class="violet"><strong><code>gcd</code></strong></span> <strong><span class="violet">algorithm</span></strong> (lines 14 and 15) receives two integer arguments and returns their greatest common divisor.</p>&#13;
<div class="group" id="fig14_14">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro14" id="p14pro14a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_14.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating algorithms gcd, lcm, iota, reduce and partial_sum.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;functional&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;numeric&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>11</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="lgreen">// calculate the greatest common divisor of two integers</span>&#13;
<span class="cviolet"><strong>14</strong></span>      std::cout &lt;&lt; <span class="green">"std::gcd(75, 20): "</span> &lt;&lt; std::gcd(<span class="green">75</span>, <span class="green">20</span>)&#13;
<span class="cviolet"><strong>15</strong></span>         &lt;&lt; <span class="green">"\nstd::gcd(17, 13): "</span> &lt;&lt; std::gcd(<span class="green">75</span>, <span class="green">13</span>);&#13;
<span class="cviolet"><strong>16</strong></span></pre>&#13;
<pre class="pre1"><code>std::gcd(75, 20): 5</code>&#13;
<code>std::gcd(17, 13): 1</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.14</strong></span> | Demonstrating algorithms <code>gcd</code>, <code>lcm</code>, <code>iota</code>, <code>reduce</code> and <code>partial_sum</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec79"><code>lcm</code> Algorithm</h5>&#13;
<p>The <span class="violet"><strong><code>lcm</code></strong></span> <strong><span class="violet">algorithm</span></strong> (lines 18 and 19) receives two integer arguments and returns their least common multiple.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p793pro01" id="p793pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// calculate the least common multiple of two integers</span>&#13;
<span class="cviolet"><strong>18</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nstd::lcm(3, 5): "</span> &lt;&lt; std::lcm(<span class="green">3</span>, <span class="green">5</span>)&#13;
<span class="cviolet"><strong>19</strong></span>      &lt;&lt; <span class="green">"\nstd::lcm(12, 9): "</span> &lt;&lt; std::lcm(<span class="green">12</span>, <span class="green">9</span>);&#13;
<span class="cviolet"><strong>20</strong></span></pre>&#13;
<pre class="pre1"><code>std::lcm(3, 5): 15</code>&#13;
<code>std::lcm(12, 9): 36</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec80"><code>iota</code> Algorithm</h5>&#13;
<p>The <span class="violet"><strong><code>iota</code></strong></span> <strong><span class="violet">algorithm</span></strong> (line 23) fills a <strong>common range</strong> with a sequence if values starting with the value in the third argument. The first two arguments must be <strong>forward iterators</strong> indicating the beginning and end of a <strong>common range</strong> in which the element type (in this case, <code>int</code>) must support incrementing values with <code>++</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p793pro02" id="p793pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>21</strong></span>   <span class="lgreen">// fill an array with integers using the std::iota algorithm;</span>&#13;
<span class="cviolet"><strong>22</strong></span>   std::array&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; ints{};&#13;
<span class="cviolet"><strong>23</strong></span>   std::iota(ints.begin(), ints.end(), <span class="green">1</span>);&#13;
<span class="cviolet"><strong>24</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nints: "</span>;&#13;
<span class="cviolet"><strong>25</strong></span>   <code>std::ranges::copy(ints, output);</code>&#13;
<span class="cviolet"><strong>26</strong></span></pre>&#13;
<pre class="pre1"><code>ints: 1 2 3 4 5</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec81"><code>reduce</code> Algorithm</h5>&#13;
<p>The <span class="violet"><strong><code>reduce</code></strong></span> <strong><span class="violet">algorithm</span></strong> (lines 29 and 31) enables you to reduce a <strong>common range</strong>’s elements to a single value. The first and second arguments must be <strong>input iterators</strong>. The call in line 29 implicitly adds the <strong>common range</strong>’s elements. The call in line 31 enables you to provide a custom initializer value (<code>1</code>) and a <strong>binary function</strong> that specifies how to perform the <strong>reduction</strong>. In this case, we used <strong><code>std::multiplies{}</code></strong>—a predefined <strong>binary function object</strong><sup><a id="ch14fn25a" href="ch14.xhtml#ch14fn25">25</a></sup> from the header <strong><code>&lt;functional&gt;</code></strong> that multiplies its two arguments and returns the result. The <code>{}</code> create a temporary <strong><code>std::multiplies</code></strong> object and call its constructor. Every <strong>function object</strong> has an <strong>overloaded <code>operator()</code> function</strong>. Inside the <strong><code>reduce</code></strong> algorithm, it calls function <strong><code>operator()</code></strong> on the <strong>function object</strong> to produce a result. Any binary function that takes two values of the same type and returns a result of that type can be passed as the fourth argument. As you’ll see in <a href="ch14.xhtml#sec14_5">Section 14.5</a>, header <strong><code>&lt;functional&gt;</code></strong> defines <strong>binary function objects</strong> for addition, subtraction, multiplication, division and modulus, among others.</p>&#13;
<p class="footnote"><a id="ch14fn25" href="ch14.xhtml#ch14fn25a">25</a>. We say more about the predefined function objects in <a href="ch14.xhtml#sec14_5">Section 14.5</a>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p794pro01" id="p794pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// reduce elements of a container to a single value</span>&#13;
<span class="cviolet"><strong>28</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nsum of ints: "</span>&#13;
<span class="cviolet"><strong>29</strong></span>      <code>&lt;&lt; std::reduce(ints.begin(), ints.end())</code>&#13;
<span class="cviolet"><strong>30</strong></span>      &lt;&lt; <span class="green">"\nproduct of ints: "</span>&#13;
<span class="cviolet"><strong>31</strong></span>      &lt;&lt; std::reduce(ints.begin(), ints.end(), <span class="green">1</span>, std::multiplies{});&#13;
<span class="cviolet"><strong>32</strong></span></pre>&#13;
<pre class="pre1"><code>sum of ints: 15</code>&#13;
<code>product of ints: 120</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec82"><code>reduce</code> vs. <strong><code>accumulate</code></strong></h5>&#13;
<p>The <strong><code>reduce</code></strong> algorithm is similar to the <strong><code>accumulate</code></strong> algorithm <strong>but does not guarantee the order in which the elements are processed</strong>—in <a href="ch17.xhtml#ch17">Chapter 17</a>, you’ll see that <strong>this difference in operation is why the <code>reduce</code> algorithm can be parallelized for better performance, but the <code>accumulate</code> algorithm cannot</strong>.<sup><a id="ch14fn26a" href="ch14.xhtml#ch14fn26">26</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn26" href="ch14.xhtml#ch14fn26a">26</a>. Sy Brand, “<code>std::accumulate</code> vs. <code>std::reduce</code>,” May 15, 2018. Accessed May 6, 2021. <code><a href="https://blog.tartanllama.xyz/accumulate-vs-reduce/">https://blog.tartanllama.xyz/accumulate-vs-reduce/</a></code>.</p>&#13;
<h5 class="h5" id="ch14lev3sec83"><code>partial_sum</code> Algorithm</h5>&#13;
<p>The <span class="violet"><strong><code>partial_sum</code></strong></span> <strong><span class="violet">algorithm</span></strong> (lines 37 and 39) calculates a partial sum of its <strong>common range</strong>’s elements from the start of the range through the current element. By default, this version of <strong><code>partial_sum</code></strong> uses the <strong><code>std::plus</code> function object</strong>, which adds its two arguments and returns their sum. For <code>ints</code>, which line 23 filled with the values 1, 2, 3, 4 and 5, the call in line 37 outputs the following sums:</p>&#13;
<p class="bull">• 1 (this is simply the value of <code>ints</code>’ first element),</p>&#13;
<p class="bull">• 3 (the sum 1 + 2),</p>&#13;
<p class="bull">• 6 (the sum 1 + 2 + 3),</p>&#13;
<p class="bull">• 10 (the sum 1 + 2 + 3 + 4), and</p>&#13;
<p class="bull">• 15 (the sum 1 + 2 + 3 + 4 + 5).</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p795pro01" id="p795pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>33</strong></span>      <span class="lgreen">// calculate the partial sums of ints' elements</span>&#13;
<span class="cviolet"><strong>34</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nints: "</span>;&#13;
<span class="cviolet"><strong>35</strong></span>      <code>std::ranges::copy(ints, output);</code>&#13;
<span class="cviolet"><strong>36</strong></span>      std::cout &lt;&lt; <span class="green">"\n\npartial_sum of ints using std::plus by default: "</span>;&#13;
<span class="cviolet"><strong>37</strong></span>      <code>std::partial_sum(ints.begin(), ints.end(), output);</code>&#13;
<span class="cviolet"><strong>38</strong></span>      std::cout &lt;&lt; <span class="green">"\npartial_sum of ints using std::multiplies: "</span>;&#13;
<span class="cviolet"><strong>39</strong></span>      <code>std::partial_sum(ints.begin(), ints.end(), output, std::multiplies{});</code>&#13;
<span class="cviolet"><strong>40</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>41</strong></span>   }</pre>&#13;
<pre class="pre1"><code>ints: 1 2 3 4 5</code>&#13;
&#13;
<code>partial_sum of ints using std::plus by default: 1 3 6 10 15</code>&#13;
&#13;
<code>partial_sum of ints using std::multiplies: 1 2 6 24 120</code></pre>&#13;
</div>&#13;
<p>The second call (line 39) uses the <strong><code>partial_sum</code></strong> overload that receives a <strong>binary function</strong> specifying how to perform partial calculations. In this case, we used the predefined <strong>binary function object <code>std::multiplies{}</code></strong>, resulting in the products of the values from the beginning of the container to the current element:</p>&#13;
<p class="bull">• 1 (this is simply the value of <code>ints</code>’ first element),</p>&#13;
<p class="bull">• 2 (the product 1 * 2)</p>&#13;
<p class="bull">• 6 (the product 1 * 2 * 3)</p>&#13;
<p class="bull">• 24 (the product 1 * 2 * 3 * 4)</p>&#13;
<p class="bull">• 120 (the product 1 * 2 * 3 * 4 * 5)</p>&#13;
<p>Because <code>ints</code> contains the values 1–5, the result of this <code>partial_sum</code> call is actually calculating 1!, 2!, 3!, 4! and 5! (that is, the factorials of 1–5).</p>&#13;
<h4 class="h4" id="sec14_4_14">14.4.14 Heapsort and Priority Queues</h4>&#13;
<p><a href="ch13.xhtml#sec13_10_3">Section 13.10.3</a> introduced the <strong><code>priority_queue</code> container adaptor</strong>. Elements added to a <strong><code>priority_queue</code></strong> are stored in a manner that enables removing them in <strong>priority order</strong>. The highest-priority element—that is, the one with the largest value—is always removed first. This can be done efficiently by arranging the elements in a data structure called a <strong>heap</strong>— not to be confused with the heap C++ maintains for dynamic memory allocation. A common uses of priority queues are in operating system process scheduling, triaging hospital emergency room patients and vaccination scheduling during the Covid-19 pandemic.</p>&#13;
<h5 class="h5" id="ch14lev3sec84">Heap Data Structure</h5>&#13;
<p>A <strong>heap</strong> is commonly implemented as a <strong>binary tree data structure</strong>. A <strong><span class="violet">max heap</span></strong> stores its largest value in the root node, and <strong>any given child node’s value is less than or equal to its parent node’s value</strong>. Heaps may contain duplicate values. A <strong>heap</strong> also can be a <strong><span class="violet">min heap</span></strong> in which the smallest value is in the root node, and any given child node’s value is greater than or equal to its parent node’s value. The following diagram shows a binary tree representing a <strong>max heap</strong>:</p>&#13;
<div class="image"><img src="Images/796fig01.jpg" alt="Images" width="363" height="142"/></div>&#13;
<p>A <strong>heap</strong> is typically stored in an array-like data structure, such as an <strong><code>array</code></strong>, <strong><code>vector</code></strong> or <strong><code>deque</code></strong>, each of which uses <strong>random-access iterators</strong>. The following diagram shows the preceding diagram’s max heap represented as an array:</p>&#13;
<div class="image"><img src="Images/796fig02.jpg" alt="Images" width="515" height="64"/></div>&#13;
<p>You can confirm that this array represents a max heap. For any given array index <code>n</code>, you can find the parent node’s array index by calculating</p>&#13;
<pre class="pre"><code>(n - 1) / 2</code></pre>&#13;
<p>using integer arithmetic. Then you can confirm that the child node’s value is less than or equal to the parent node’s value. A <strong>max heap</strong>’s largest value is always at the top of the binary tree, which corresponds to the array’s first element.</p>&#13;
<h5 class="h5" id="ch14lev3sec85">Heap-Related Algorithms</h5>&#13;
<p><span class="size">20</span> <a href="ch14.xhtml#fig14_15">Figure 14.15</a> demonstrates four <strong>C++20 <code>std::ranges</code> namespace</strong> algorithms related to <strong>heaps</strong>. First, we show <strong><code>make_heap</code></strong> and <strong><code>heap_sort</code></strong>, which implement the two steps in the <strong><span class="violet">heapsort algorithm</span></strong>, which has a worst-case runtime of <em>O</em>(<em>n</em> log <em>n</em>):<sup><a id="ch14fn27a" href="ch14.xhtml#ch14fn27">27</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn27" href="ch14.xhtml#ch14fn27a">27</a>. “Heapsort.” Accessed May 8, 2021. <code><a href="https://en.wikipedia.org/wiki/Heapsort">https://en.wikipedia.org/wiki/Heapsort</a></code>.</p>&#13;
<p class="bull">• arranging the elements of a container into a <strong>heap</strong>, then</p>&#13;
<p class="bull">• removing the elements from the <strong>heap</strong> to produce a sorted sequence.</p>&#13;
<p>Then, we show <strong><code>push_heap</code></strong> and <strong><code>pop_heap</code></strong>, which the <strong><code>priority_queue</code> container adaptor</strong><sup><a id="ch14fn28a" href="ch14.xhtml#ch14fn28">28</a></sup> uses “under the hood” to maintain its elements in a <strong>heap</strong> as elements are added and removed.</p>&#13;
<p class="footnote"><a id="ch14fn28" href="ch14.xhtml#ch14fn28a">28</a>. You can see the open source Microsoft C++ standard library implementation of <code>priority_queue</code> using <code>push_heap</code> and <code>pop_heap</code> at <code><a href="https://github.com/microsoft/STL/blob/main/stl/inc/queue">https://github.com/microsoft/STL/blob/main/stl/inc/queue</a></code>. Accessed May 10, 2021.</p>&#13;
<div class="group" id="fig14_15">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro15" id="p14pro15a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_15.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Algorithms push_heap, pop_heap, make_heap and sort_heap.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output(std::cout, <span class="green">" "</span>);&#13;
<span class="cviolet"><strong>11</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.15</strong></span> | Algorithms <code>push_heap</code>, <code>pop_heap</code>, <code>make_heap</code> and <code>sort_heap</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec86">Initializing and Displaying <code>heapArray</code></h5>&#13;
<p>Line 12 creates and initializes the <code>array heapArray</code> with 10 different unsorted integers. Line 14 displays <code>heapArray</code> before we convert its contents to a <strong>heap</strong> and <strong>sort</strong> the elements.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p797pro01" id="p797pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>12</strong></span>   std::array heapArray{<span class="green">3</span>, <span class="green">100</span>, <span class="green">52</span>, <span class="green">77</span>, <span class="green">22</span>, <span class="green">31</span>, <span class="green">1</span>, <span class="green">98</span>, <span class="green">13</span>, <span class="green">40</span>};&#13;
<span class="cviolet"><strong>13</strong></span>   std::cout &lt;&lt; <span class="green">"heapArray before make_heap:\n"</span>;&#13;
<span class="cviolet"><strong>14</strong></span>   <code>std::ranges::copy(heapArray, output);</code>&#13;
<span class="cviolet"><strong>15</strong></span></pre>&#13;
<pre class="pre1"><code>heapArray before make_heap:</code>&#13;
<code>3 100 52 77 22 31 1 98 13 40</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec87"><code>make_heap</code> Algorithm</h5>&#13;
<p>The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">make_heap algorithm</span></strong></code> (line 16) arranges the elements of its <strong><code>random_access_range</code></strong> argument into a <strong>heap</strong>, which can then be used with <strong><code>sort_heap</code></strong> to produce a sorted sequence. Line 18 displays <code>heapArray</code> with its elements arranged in a <strong>heap</strong>. A <strong><code>random_access_range</code></strong> supports <strong><code>random_access_iterator</code></strong>s, so this algorithm works with <strong><code>array</code></strong>s, <strong><code>vector</code></strong>s and <strong><code>deque</code></strong>s.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p797pro02" id="p797pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>16</strong></span>   std::ranges::make_heap(heapArray); <span class="lgreen">// create heap from heapArray</span>&#13;
<span class="cviolet"><strong>17</strong></span>   std::cout &lt;&lt; <span class="green">"\nheapArray after make_heap:\n"</span>;&#13;
<span class="cviolet"><strong>18</strong></span>   <code>std::ranges::copy(heapArray, output);</code>&#13;
<span class="cviolet"><strong>19</strong></span></pre>&#13;
<pre class="pre1"><code>heapArray after make_heap:</code>&#13;
<code>100 98 52 77 40 31 1 3 13 22</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec88"><code>sort_heap</code> Algorithm</h5>&#13;
<p>The <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">sort_heap algorithm</span></strong></code> (line 20) sorts the elements of its <strong><code>random_access_range</code></strong> argument. The <strong>range</strong> must already be a <strong>heap</strong>. Line 22 displays the sorted <code>heapArray</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p797pro03" id="p797pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>20</strong></span>   std::ranges::sort_heap(heapArray); <span class="lgreen">// sort elements with sort_heap</span>&#13;
<span class="cviolet"><strong>21</strong></span>   std::cout &lt;&lt; <span class="green">"\nheapArray after sort_heap:\n"</span>;&#13;
<span class="cviolet"><strong>22</strong></span>   <code>std::ranges::copy(heapArray, output);</code>&#13;
<span class="cviolet"><strong>23</strong></span></pre>&#13;
<pre class="pre1"><code>heapArray after sort_heap:</code>&#13;
<code>1 3 13 22 31 40 52 77 98 100</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec89">Using <code>push_heap</code> and <strong><code>pop_heap</code></strong> to Maintain a Heap</h5>&#13;
<p>Next, we’ll demonstrate the algorithms a <strong><code>priority_queue</code></strong> uses “under the hood” to <strong>insert a new item in a heap</strong> and <strong>remove an item from a heap</strong>. Both operations are <em>O</em>(log <em>n</em>).<sup><a id="ch14fn29a" href="ch14.xhtml#ch14fn29">29</a></sup> Lines 25–33 define the lambda <code>push</code>, which adds one <code>int</code> value to a heap that’s stored in a <code>vector</code>. To do so, <code>push</code> performs the following tasks:</p>&#13;
<p class="footnote"><a id="ch14fn29" href="ch14.xhtml#ch14fn29a">29</a>. “Binary heap.” Accessed May 10, 2021. <code><a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a></code>.</p>&#13;
<p class="bull">• Line 28 appends one <code>int</code> to the <code>vector</code> argument <code>heap</code>.</p>&#13;
<p class="bull"><span class="size">20</span> • Line 29 calls the <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">push_heap algorithm</span></strong></code>, which takes the last element of its <strong><code>random_access_range</code></strong> argument (<code>heap</code>) and inserts it into the <strong>heap data structure</strong>. Each time <strong><code>push_heap</code></strong> is called, it assumes that the <strong>range</strong>’s last element is the one being added to the <strong>heap</strong> and that the <strong>range</strong>’s other elements are already arranged as a <strong>heap</strong>. If the element appended in line 28 is the <strong>range</strong>’s only element, the <strong>range</strong> is already a heap. Otherwise, <strong><code>push_heap</code></strong> rear-ranges the elements into a heap.</p>&#13;
<p class="bull">• Line 31 displays the updated <strong>heap data structure</strong> after each value is added.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p798pro01" id="p798pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>24</strong></span>   <span class="lgreen">// lambda to add an int to a heap</span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="blue">auto</span> push{&#13;
<span class="cviolet"><strong>26</strong></span>      [&amp;](std::vector&lt;int<span class="blue">&gt;&amp;</span> heap, <span class="blue">int</span> value) {&#13;
<span class="cviolet"><strong>27</strong></span>         std::cout &lt;&lt; <span class="green">"\n\npushing "</span> &lt;&lt; value &lt;&lt; <span class="green">" onto heap"</span>;&#13;
<span class="cviolet"><strong>28</strong></span>         heap.push_back(value); <span class="lgreen">// add value to the heap</span>&#13;
<span class="cviolet"><strong>29</strong></span>         std::ranges::push_heap(heap); <span class="lgreen">// insert last element into heap</span>&#13;
<span class="cviolet"><strong>30</strong></span>         std::cout &lt;&lt; <span class="green">"\nheap: "</span>;&#13;
<span class="cviolet"><strong>31</strong></span>         <code>std::ranges::copy(heap, output);</code>&#13;
<span class="cviolet"><strong>32</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>33</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>34</strong></span></pre>&#13;
</div>&#13;
<p>Lines 36–44 define the lambda <code>pop</code>, which removes the largest value from the heap data structure. To do so, <code>pop</code> performs the following tasks:</p>&#13;
<p class="bull"><span class="size">20</span> • Line 38 uses the <strong>C++20</strong> <code><strong>std::ranges:: <span class="violet">pop_heap algorithm</span></strong></code> to remove the largest value from the heap. The algorithm assumes that its <code><strong>random_access_range</strong></code> argument’s elements represent a <strong>heap data structure</strong>. First, it swaps the largest <strong>heap</strong> element (located at <code>heap.begin()</code>) with the last heap element (the one before <code>heap.end()</code>). Then, it ensures that the elements from the <strong>range</strong>’s beginning up to, but not including, the <strong>range</strong>’s last element still form a <strong>heap</strong>. <strong>The <code>pop_heap</code> algorithm does not modify the number of elements in the range.</strong></p>&#13;
<p class="bull">• Line 39 displays the value of the <strong><code>vector</code></strong>’s last element—the value that was just removed from the <strong>heap</strong> but still remains in the <strong><code>vector</code></strong>.</p>&#13;
<p class="bull">• Line 40 removes the <strong><code>vector</code></strong>’s last element, leaving only the <strong><code>vector</code></strong> elements that still represent a <strong>heap data structure</strong>.</p>&#13;
<p class="bull">• Line 42 shows the current <strong>heap data structure</strong> contents</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p798pro02" id="p798pro02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>35</strong></span>   <span class="lgreen">// lambda to remove an item from the heap</span>&#13;
<span class="cviolet"><strong>36</strong></span>   <span class="blue">auto</span> pop{&#13;
<span class="cviolet"><strong>37</strong></span>      [&amp;](std::vector&lt;int<span class="blue">&gt;&amp;</span> heap) {&#13;
<span class="cviolet"><strong>38</strong></span>         std::ranges::pop_heap(heap); <span class="lgreen">// remove max item from heap</span>&#13;
<span class="cviolet"><strong>39</strong></span>         std::cout &lt;&lt; <span class="green">"\n\npopping highest priority item: "</span> &lt;&lt; heap.back();&#13;
<span class="cviolet"><strong>40</strong></span>         heap.pop_back(); <span class="lgreen">// remove vector's last element</span>&#13;
<span class="cviolet"><strong>41</strong></span>         std::cout &lt;&lt; <span class="green">"\nheap: "</span>;&#13;
<span class="cviolet"><strong>42</strong></span>         <code>std::ranges::copy(heap, output);</code>&#13;
<span class="cviolet"><strong>43</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>44</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>45</strong></span></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec90">Demonstrating a Heap Data Structure</h5>&#13;
<p>Line 46 defines an empty <code>vector&lt;int&gt;</code> in which we’ll maintain the <strong>heap data structure</strong>. Lines 49–51 call the <strong><code>push</code> lambda</strong> to add the values <code>3</code>, <code>100</code> and <code>52</code> to the heap. As we add each value, note that the largest value is always stored in the <strong><code>vector</code></strong>’s first element and that the elements are not stored in sorted order.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p799pro01" id="p799pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>46</strong></span>   std::vector&lt;<span class="blue">int</span>&gt; heapVector{};&#13;
<span class="cviolet"><strong>47</strong></span>&#13;
<span class="cviolet"><strong>48</strong></span>   <span class="lgreen">// place five integers into heapVector, maintaining it as a heap</span>&#13;
<span class="cviolet"><strong>49</strong></span>   <span class="blue">for</span> (<span class="blue">auto</span> value : {<span class="green">3</span>, <span class="green">52</span>, <span class="green">100</span>}) {&#13;
<span class="cviolet"><strong>50</strong></span>      <code>push(heapVector, value);</code>&#13;
<span class="cviolet"><strong>51</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>52</strong></span></pre>&#13;
<pre class="pre1"><code>pushing 3 onto heap</code>&#13;
<code>heap: 3</code>&#13;
&#13;
<code>pushing 52 onto heap</code>&#13;
<code>heap: 52 3</code>&#13;
&#13;
<code>pushing 100 onto heap</code>&#13;
<code>heap: 100 3 52</code></pre>&#13;
</div>&#13;
<p>Next, line 53 calls the <strong><code>pop</code> lambda</strong> removes the highest-priority item (<code>100</code>) from the <strong>heap</strong>. Note that the largest remaining value (<code>52</code>) is now in the <strong><code>vector</code></strong>’s first element. Line 54 adds the value <code>22</code> to the <strong>heap</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p799pro02" id="p799pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>53</strong></span>   pop(heapVector); <span class="lgreen">// remove max item</span>&#13;
<span class="cviolet"><strong>54</strong></span>   push(heapVector, <span class="green">22</span>); <span class="lgreen">// add new item to heap</span>&#13;
<span class="cviolet"><strong>55</strong></span></pre>&#13;
<pre class="pre1"><code>popping highest priority item: 100</code>&#13;
<code>heap: 52 3</code>&#13;
&#13;
<code>pushing 22 onto heap</code>&#13;
<code>heap: 52 3 22</code></pre>&#13;
</div>&#13;
<p>Next, line 56 removes the highest-priority item (<code>52</code>) from the <strong>heap</strong>. Again, the largest remaining value (<code>22</code>) is now in the <strong><code>vector</code></strong>’s first element. Line 57 adds the value <code>77</code> to the <strong>heap</strong>. This is now the largest value, so it becomes the <strong><code>vector</code></strong>’s first element.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p799pro03" id="p799pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>56</strong></span>   pop(heapVector); <span class="lgreen">// remove max item</span>&#13;
<span class="cviolet"><strong>57</strong></span>   push(heapVector, <span class="green">77</span>); <span class="lgreen">// add new item to heap</span>&#13;
<span class="cviolet"><strong>58</strong></span></pre>&#13;
<pre class="pre1"><code>popping highest priority item: 52</code>&#13;
<code>heap: 22 3</code>&#13;
&#13;
<code>pushing 77 onto heap</code>&#13;
<code>heap: 77 3 22</code></pre>&#13;
</div>&#13;
<p>Finally, lines 59–61 remove the three remaining items in the <strong>heap</strong>. Note that after line 59 executes, the largest remaining element (22) becomes the <strong><code>vector</code></strong>’s first element.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p800pro01" id="p800pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>59</strong></span>      pop(heapVector); <span class="lgreen">// remove max item</span>&#13;
<span class="cviolet"><strong>60</strong></span>      pop(heapVector); <span class="lgreen">// remove max item</span>&#13;
<span class="cviolet"><strong>61</strong></span>      pop(heapVector); <span class="lgreen">// remove max item</span>&#13;
<span class="cviolet"><strong>62</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>63</strong></span>   }</pre>&#13;
<pre class="pre1"><code>popping highest priority item: 77</code>&#13;
<code>heap: 22 3</code>&#13;
&#13;
<code>popping highest priority item: 22</code>&#13;
<code>heap: 3</code>&#13;
&#13;
<code>popping highest priority item: 3</code>&#13;
<code>heap:</code></pre>&#13;
</div>&#13;
<h3 class="h3" id="sec14_5"><span class="violet">14.5</span> Function Objects (Functors)</h3>&#13;
<p>As we’ve shown, many standard library algorithms allow you to pass a <strong>lambda</strong> or a <strong>function pointer</strong> into the algorithm to help it perform its task. <strong>Any algorithm that can receive a lambda or function pointer can also receive an object of a class that overloads the function-call operator (parentheses) with a function named <code>operator()</code>, provided that the overloaded operator meets the algorithm’s requirements for number of parameters and return type</strong>. For instance, the <strong><code>transform</code> algorithm</strong> requires a <strong>unary function</strong> that has a single parameter and returns the transformed value.</p>&#13;
<p>An object of a class that overloads function <strong><code>operator()</code></strong> is known as a <strong><span class="violet">function object</span></strong> or a <strong><span class="violet">functor</span></strong> and can be used syntactically and semantically like a <strong>lambda</strong> or a <strong>function pointer</strong>. The <strong><code>operator()</code> function</strong> is invoked by using the object’s name followed by parentheses containing the arguments. <strong>Most algorithms can use lambdas, function pointers and function objects interchangeably</strong>.</p>&#13;
<h5 class="h5" id="ch14lev3sec91">Benefits of Function Objects</h5>&#13;
<p><strong>Function objects</strong> provide several benefits over functions and pointers to functions:</p>&#13;
<p class="bull">• A <strong>function object</strong> is an object of a class. As such, it can have non-<code>static</code> data members to maintain state for a specific <strong>function object</strong>, or <code>static</code> data members to maintain state shared by all function objects of that class type. Also, the class type of a <strong>function object</strong> can be used as a default type argument for template type parameters.<sup><a id="ch14fn30a" href="ch14.xhtml#ch14fn30">30</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn30" href="ch14.xhtml#ch14fn30a">30</a>. “Function Objects in the C++ Standard Library.” March 15, 2019. Accessed May 6, 2021. <code><a href="https://docs.microsoft.com/en-us/cpp/standard-library/function-objects-in-the-stl">https://docs.microsoft.com/en-us/cpp/standard-library/function-objects-in-the-stl</a></code>.</p>&#13;
<p class="bull"><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> • Perhaps most importantly, the compiler can inline <strong>function objects</strong> for performance. A <strong>function object’s <code>operator()</code></strong> function typically is defined in its class’s body, making it implicitly <code>inline</code>. When defined outside its class’s body, function <strong><code>operator()</code></strong> can be declared <code>inline</code> explicitly. Compilers also convert <strong>lambdas</strong> to <strong>function objects</strong>, so these, too, can be inlined. On the other hand, compilers typically do not inline functions invoked via function pointers—such pointers could be aimed at any function with the appropriate parameters and return type, so a compiler does not know which function to inline.<sup><a id="ch14fn31a" href="ch14.xhtml#ch14fn31">31</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn31" href="ch14.xhtml#ch14fn31a">31</a>. Meyers, <em>Scott. Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library</em>. p.201–202: Pearson Education, 2001.</p>&#13;
<h5 class="h5" id="ch14lev3sec92">Predefined Function Objects of the Standard Template Library</h5>&#13;
<p><span class="size">20</span> Many <strong>predefined function objects</strong> can be found in the header <span class="violet"><strong><code>&lt;functional&gt;</code></strong></span>. Each is implemented as a class template. The following table lists some of the commonly used standard library <strong>function objects</strong>. Each of the <strong>relational function objects</strong> has a corresponding one of the same name in the <strong>C++20 <code>std::ranges</code> namespace</strong>.</p>&#13;
<div class="image"><img src="Images/801tab01.jpg" alt="Images" width="585" height="303"/></div>&#13;
<p>Most <strong>function objects</strong> in the preceding table are <strong>binary function objects</strong> that receive two arguments and return a result—<code>logical_not</code> and <code>negate</code> are <strong>unary function objects</strong> that receive one argument and return a result. For example, consider the following function object for comparing two <code>int</code> values:</p>&#13;
<pre class="pre">std::less&lt;<span class="blue">int</span>&gt; smaller{};</pre>&#13;
<p>We can use the object’s name (<code>smaller</code>) to call its <strong><code>operator()</code> function</strong>, as follows:</p>&#13;
<pre class="pre">smaller(<span class="green">10</span>, <span class="green">7</span>)</pre>&#13;
<p>Here, <code>smaller</code> would return <code>false</code> because <code>10</code> is not less than <code>7</code>—an algorithm like <strong><code>sort</code></strong> would use this information to reorder these values. A <strong>unary function object’s <code>operator()</code> function</strong> receives only one argument.</p>&#13;
<p>You can see the complete list of <strong>function objects</strong> in the <strong><code>&lt;functional&gt;</code> header</strong> at</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p801pro01" id="p801pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>https://en.cppreference.com/w/cpp/utility/functional</code></pre>&#13;
<p>and in the “Function Objects” section of the C++ standard.<sup><a id="ch14fn32a" href="ch14.xhtml#ch14fn32">32</a></sup> We used the <strong>function object <code>less&lt;T&gt;</code></strong> in <a href="ch13.xhtml#sec13_9">Section 13.9</a>’s presentations of <strong><code>set</code></strong> and <strong><code>multiset</code></strong> to specify the sorting order for elements in a container. The <strong><code>std::ranges</code> algorithms</strong> that compare elements for ordering use as their <strong>default predicate function argument</strong> the <strong>function object <code>less&lt;T&gt;</code></strong>. Recall that many of the overloaded standard library algorithms that perform comparisons can receive a <strong>binary function</strong> that determines whether its first argument is less than its second—exactly the purpose of the <strong><code>less&lt;T&gt;</code> function object</strong>.</p>&#13;
<p class="footnote"><a id="ch14fn32" href="ch14.xhtml#ch14fn32a">32</a>. “General utilities library—Function objects.” Accessed May 2, 2021. <code><a href="https://eel.is/c++draft/function.objects">https://eel.is/c++draft/function.objects</a></code>.</p>&#13;
<h5 class="h5" id="ch14lev3sec93">Using the <code>accumulate</code> Algorithm</h5>&#13;
<p><a href="ch14.xhtml#fig14_16">Figure 14.16</a> uses the <code>std::</code><strong><code>accumulate</code> numeric algorithm</strong> (<strong>header <code>&lt;numeric&gt;</code></strong>) to calculate the sum of the squares of an <code>array</code>’s elements. The <strong><code>&lt;numeric&gt;</code></strong> algorithms do not have <strong>C++20 <code>std::ranges</code> overloads</strong>, so they use <strong>common ranges</strong>—<strong><code>std::ranges</code> overloads</strong> of these algorithms are proposed for C++23.<sup><a id="ch14fn33a" href="ch14.xhtml#ch14fn33">33</a></sup> The <strong><code>accumulate</code> algorithm</strong> has two overloads. The three-argument version adds the <strong>common range</strong>’s elements by default. The four-argument version receives as its last argument a <strong>binary function</strong> that customizes how to perform the calculation. That argument can be supplied as:</p>&#13;
<p class="footnote"><a id="ch14fn33" href="ch14.xhtml#ch14fn33a">33</a>. Christopher Di Bella, “A Concept Design for the Numeric Algorithms,” August 2, 2019. Accessed May 5, 2021. <code><a href="http://wg21.link/p1813r0">http://wg21.link/p1813r0</a></code>.</p>&#13;
<p class="bull">• a <strong>function pointer</strong> to a <strong>binary function</strong> that takes two parameters of the <strong>common range</strong>’s type and returns a result of that type,</p>&#13;
<p class="bull">• a <strong><span class="violet">binary function object</span></strong> in which the <strong><code>operator()</code></strong> function takes two parameters of the <strong>common range</strong>’s type and returns a result of that type, or</p>&#13;
<p class="bull">• a <strong>lambda</strong> that takes two parameters of the <strong>common range</strong>’s type and returns a result of that type.</p>&#13;
<p>This example calls <strong><code>accumulate</code></strong> with a <strong>function pointer</strong>, then a <strong>function object</strong> and then a <strong>lambda</strong>.</p>&#13;
<div class="group" id="fig14_16">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro16" id="p14pro16a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_1<em>6</em>.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating function objects.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;functional&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;numeric&gt;&#13;
<span class="cviolet"> <strong>9</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.16</strong></span> | Demonstrating function objects.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec94">Function <code>sumSquares</code></h5>&#13;
<p>Lines 12–14 define a <strong>function <code>sumSquares</code></strong> that takes two arguments of the same type and returns a value of that type—the requirements for the <strong>binary function</strong> that <strong><code>accumulate</code></strong> can receive as an argument. The <code>sumSquares</code> function returns the sum of its first argument <code>total</code> and the square of its second argument <code>value</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p802pro01" id="p802pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>10</strong></span>   <span class="lgreen">// binary function returns the sum of its first argument total</span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="lgreen">// and the square of its second argument value</span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">int</span> sumSquares(<span class="blue">int</span> total, <span class="blue">int</span> value) {&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">return</span> total + value * value;&#13;
<span class="cviolet"><strong>14</strong></span>   } <span class="lgreen"/>&#13;
<span class="cviolet"><strong>15</strong></span></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec95">Class <code>SumSquaresClass</code></h5>&#13;
<p>Lines 19–25 define the <strong>class <code>SumSquaresClass</code></strong>.<sup><a id="ch14fn34a" href="ch14.xhtml#ch14fn34">34</a></sup> Its <strong>overloaded <code>operator()</code> function</strong> has two <code>int</code> parameters and returns an <code>int</code>. This meets requirements for the <strong>binary function</strong> that <strong><code>accumulate</code></strong> can call when processing a <strong>common range</strong> of <code>int</code> values. The <strong><code>operator()</code> function</strong> returns the sum of its first argument <code>total</code> and the square of its second argument <code>value</code>.</p>&#13;
<p class="footnote"><a id="ch14fn34" href="ch14.xhtml#ch14fn34a">34</a>. This class handles only <code>int</code> values, but could be implemented as a class template that handles many types—we’ll define custom class templates in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p803pro01" id="p803pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>16</strong></span>   <span class="lgreen">// class SumSquaresClass defines overloaded operator()</span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// that returns the sum of its first argument total</span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="lgreen">// and the square of its second argument value</span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="blue">class</span> SumSquaresClass {&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="lgreen">// add square of value to total and return result</span>&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">int</span> operator()(<span class="blue">int</span> total, <span class="blue">int</span> value) {&#13;
<span class="cviolet"><strong>23</strong></span>         <span class="blue">return</span> total + value * value;&#13;
<span class="cviolet"><strong>24</strong></span>      } <span class="lgreen"/>&#13;
<span class="cviolet"><strong>25</strong></span>   }; <span class="lgreen"/>&#13;
<span class="cviolet"><strong>26</strong></span></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec96">Calling Algorithm <code>accumulate</code></h5>&#13;
<p>We call <strong><code>accumulate</code></strong> three times:</p>&#13;
<p class="bull">• Lines 36–37 call <strong><code>accumulate</code></strong> with a <strong>pointer to function</strong> <code>sumSquares</code> as its last argument.</p>&#13;
<p class="bull">• Lines 44–45 call <strong><code>accumulate</code></strong> with a <strong>function object of class <code>SumSquaresClass</code></strong> as the last argument. The expression <strong><code>SumSquaresClass{}</code></strong> in line 45 creates a <strong>temporary <code>SumSquaresClass</code> object</strong> and calls its constructor. That <strong>function object</strong> is then passed to <strong><code>accumulate</code></strong>, which calls the <strong><code>SumSquaresClass</code> object’s <code>operator()</code> function</strong>.</p>&#13;
<p class="bull">• Lines 50–51 call <strong><code>accumulate</code></strong> with an equivalent <strong>lambda</strong>. The <strong>lambda</strong> performs the same tasks as the <strong>function <code>sumSquares</code></strong> and the overloaded <strong><code>operator()</code> function in <code>SumSquaresClass</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p803pro02" id="p803pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>27</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>28</strong></span>      std::array integers{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>};&#13;
<span class="cviolet"><strong>29</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>      std::cout &lt;&lt; <span class="green">"array integers contains: "</span>;&#13;
<span class="cviolet"><strong>32</strong></span>      <code>std::ranges::copy(integers, output);</code>&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>      <span class="lgreen">// calculate sum of squares of elements of array integers</span>&#13;
<span class="cviolet"><strong>35</strong></span>      <span class="lgreen">// using binary function sumSquares</span>&#13;
<span class="cviolet"><strong>36</strong></span>      <span class="blue">int</span> result{std::accumulate(integers.cbegin(), integers.cend(),&#13;
<span class="cviolet"><strong>37</strong></span>         <span class="green">0</span>, sumSquares)};&#13;
<span class="cviolet"><strong>38</strong></span>&#13;
<span class="cviolet"><strong>39</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nSum of squares\n"</span>&#13;
<span class="cviolet"><strong>40</strong></span>         &lt;&lt; <span class="green">"via binary function sumSquares: "</span> &lt;&lt; result;&#13;
<span class="cviolet"><strong>41</strong></span>&#13;
<span class="cviolet"><strong>42</strong></span>      <span class="lgreen">// calculate sum of squares of elements of array integers</span>&#13;
<span class="cviolet"><strong>43</strong></span>      <span class="lgreen">// using binary function object</span>&#13;
<span class="cviolet"><strong>44</strong></span>      <code>result = std::accumulate(integers.cbegin(), integers.cend(),</code>&#13;
<span class="cviolet"><strong>45</strong></span>         <span class="green">0</span>, SumSquaresClass{});&#13;
<span class="cviolet"><strong>46</strong></span>&#13;
<span class="cviolet"><strong>47</strong></span>      std::cout &lt;&lt; <span class="green">"\nvia a SumSquaresClass function object: "</span> &lt;&lt; result;&#13;
<span class="cviolet"><strong>48</strong></span>&#13;
<span class="cviolet"><strong>49</strong></span>      <span class="lgreen">// calculate sum of squares array</span>&#13;
<span class="cviolet"><strong>50</strong></span>      <code>result = std::accumulate(integers.cbegin(), integers.cend(),</code>&#13;
<span class="cviolet"><strong>51</strong></span>          <span class="green">0</span>, [](<span class="blue">auto</span> total, <span class="blue">auto</span> value){<span class="blue">return</span> total + value * value;});&#13;
<span class="cviolet"><strong>52</strong></span>&#13;
<span class="cviolet"><strong>53</strong></span>      std::cout &lt;&lt; <span class="green">"\nvia a lambda: "</span> &lt;&lt; result &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>54</strong></span>      }</pre>&#13;
<pre class="pre1"><code>array integers contains: 1 2 3 4</code>&#13;
&#13;
<code>Sum of squares</code>&#13;
<code>via binary function sumSquares: 30</code>&#13;
<code>via a SumSquaresClass function object: 30</code>&#13;
<code>via a lambda: 30</code></pre>&#13;
</div>&#13;
<p>In each of the three calls to <strong><code>accumulate</code></strong>, it uses its function argument as follows:</p>&#13;
<p class="bull">• On the first call to its function argument, <strong><code>accumulate</code></strong> passes its third argument’s value (<code>0</code> in this example) and the value of <code>integers</code>’ first element (<code>1</code> in this example). This calculates and returns the result of <code>0 + 1 * 1</code>, which is <code>1</code>.</p>&#13;
<p class="bull">• On the second call to its function argument, <strong><code>accumulate</code></strong> passes the preceding result (<code>1</code>) and the value of <code>integers</code>’ next element (<code>2</code>). This calculates and returns the result of <code>1 + 2 * 2</code>, which is <code>5</code>.</p>&#13;
<p class="bull">• On the third call to its function argument, <strong><code>accumulate</code></strong> passes the preceding result (<code>5</code>) and the value of <code>integers</code>’ next element (<code>3</code>). This calculates and returns the result of <code>5 + 3 * 3</code>, which is <code>14</code>.</p>&#13;
<p class="bull">• On the last call to its function argument, <strong><code>accumulate</code></strong> passes the preceding result (<code>14</code>) and the value of <code>integers</code>’ next element (<code>4</code>). This calculates and returns the result of <code>14 + 16</code>, which is <code>30</code>.</p>&#13;
<p>At this point <strong><code>accumulate</code></strong> reaches the end of the <strong>common range</strong> specified by its first two arguments, so it returns the result (<code>30</code>) of the last call to its function argument.</p>&#13;
<h3 class="h3" id="sec14_6"><span class="violet">14.6</span> Projections</h3>&#13;
<p><span class="size">20</span> When working on objects that each contain multiple data items, each <strong>C++20 <code>std::ranges</code> algorithm</strong> can use a <strong><span class="violet">projection</span></strong> to select a narrower part of each object to process. Consider <code>Employee</code> objects that each have a first name, a last name and a salary. Rather than sorting <code>Employee</code>s based on all three data members, <strong>you can sort them using only their salaries</strong>. <a href="ch14.xhtml#fig14_17">Figure 14.17</a> sorts an <code>array</code> of <code>Employee</code> objects by salary—first in <strong>ascending order</strong>, then in <strong>descending order</strong>. Lines 11–22 define class <code>Employee</code>. Lines 25–29 provide an <strong>overloaded <code>operator&lt;&lt;</code> function</strong> for <code>Employee</code>s so we can output them conveniently.</p>&#13;
<div class="group" id="fig14_17">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro17" id="p14pro17a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_17.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating projections with C++20 range algorithms.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">class</span> Employee {&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>13</strong></span>      Employee(std::string_view first, std::string_view last, <span class="blue">int</span> salary)&#13;
<span class="cviolet"><strong>14</strong></span>         <code>: m_first{first}, m_last{last}, m_salary{salary} {}</code>&#13;
<span class="cviolet"><strong>15</strong></span>      std::string getFirst() <span class="blue">const</span> {<span class="blue">return</span> m_first;}&#13;
<span class="cviolet"><strong>16</strong></span>      std::string getLast() <span class="blue">const</span> {<span class="blue">return</span> m_last;}&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">int</span> getSalary() <span class="blue">const</span> {<span class="blue">return</span> m_salary;}&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>19</strong></span>      <code>std::string m_first;</code>&#13;
<span class="cviolet"><strong>20</strong></span>      <code>std::string m_last;</code>&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">int</span> m_salary;&#13;
<span class="cviolet"><strong>22</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>   <span class="lgreen">// operator&lt;&lt; for an Employee</span>&#13;
<span class="cviolet"><strong>25</strong></span>   std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, <span class="blue">const</span> Employee&amp; e) {&#13;
<span class="cviolet"><strong>26</strong></span>      out &lt;&lt; fmt::format(<span class="green">"{:10}{:10}{}"</span>,&#13;
<span class="cviolet"><strong>27</strong></span>                <code>e.getLast(), e.getFirst(), e.getSalary());</code>&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="blue">return</span> out;&#13;
<span class="cviolet"><strong>29</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>30</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.17</strong></span> | Demonstrating projections with C++20 range algorithms.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec97">Defining and Displaying an <code>array&lt;Employee&gt;</code></h5>&#13;
<p>Lines 32–36 define an <code>array&lt;Employee&gt;</code> and line 41 displays its contents, so we can confirm later that the <code>Employee</code>s are sorted properly.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p805pro01" id="p805pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>31</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>32</strong></span>      <code>std::array employees{</code>&#13;
<span class="cviolet"><strong>33</strong></span>         Employee{<span class="green">"Jason"</span>, <span class="green">"Red"</span>, <span class="green">5000</span>},&#13;
<span class="cviolet"><strong>34</strong></span>         Employee{<span class="green">"Ashley"</span>, <span class="green">"Green"</span>, <span class="green">7600</span>},&#13;
<span class="cviolet"><strong>35</strong></span>         Employee{<span class="green">"Matthew"</span>, <span class="green">"Indigo"</span>, <span class="green">3587</span>}&#13;
<span class="cviolet"><strong>36</strong></span>      <code>};</code>&#13;
<span class="cviolet"><strong>37</strong></span>&#13;
<span class="cviolet"><strong>38</strong></span>      std::ostream_iterator&lt;Employee&gt; output{std::cout, <span class="green">"\n"</span>};&#13;
<span class="cviolet"><strong>39</strong></span>&#13;
<span class="cviolet"><strong>40</strong></span>      std::cout &lt;&lt; <span class="green">"Employees:\n"</span>;&#13;
<span class="cviolet"><strong>41</strong></span>      <code>std::ranges::copy(employees, output);</code>&#13;
<span class="cviolet"><strong>42</strong></span></pre>&#13;
<pre class="pre1"><code>Employees:</code>&#13;
Red       Jason     5000&#13;
Green     Ashley    7600&#13;
Indigo    Matthew   3587</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec98">Using a Projection to Sort the <code>array&lt;Employee&gt;</code> in Ascending Order</h5>&#13;
<p><span class="size">20</span> Lines 45–46 calls the <strong><code>std::ranges::sort</code> algorithm</strong>, passing three arguments:</p>&#13;
<p class="bull">• The first argument (<code>employees</code>) is the <strong>range</strong> to <strong>sort</strong>.</p>&#13;
<p class="bull">• The second argument (<code>{}</code>) is the <strong>binary predicate function</strong> that the <strong><code>sort</code> algorithm</strong> uses to compare elements when determining their <strong>sort order</strong>. The notation <strong><code>{}</code></strong> indicates that <code>sort</code> should use the <strong>default binary predicate function</strong> specified in <code>sort</code>’s definition—the <strong><code>std::ranges::less</code> function object</strong>. This causes <strong><code>sort</code></strong> to arrange the elements in <strong>ascending order</strong>. The <strong><code>less</code> function object</strong> compares its two arguments and returns <code>true</code> if the first is less than the second. If <strong><code>less</code></strong> returns <code>false</code>, the two salaries are not in ascending order, so <strong><code>sort</code></strong> reorders the corresponding <code>Employee</code> objects.</p>&#13;
<p class="bull">• The last argument specifies the <strong>projection</strong>. This <strong>unary function</strong> receives an element from the <strong>range</strong> and returns a portion of that element. Here, we implemented the <strong>unary function</strong> as a <strong>lambda</strong> that returns its <code>Employee</code> argument’s salary. The <strong>projection</strong> is applied <em>before</em> <strong><code>sort</code></strong> compares the elements, so rather than comparing entire <code>Employee</code> objects to determine their sort order, <strong><code>sort</code></strong> com-pares only the <code>Employee</code>s’ salaries.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p806pro01" id="p806pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>43</strong></span>     <span class="lgreen">// sort Employees by salary; {} indicates that the algorithm should</span>&#13;
<span class="cviolet"><strong>44</strong></span>     <span class="lgreen">// use its default comparison function</span>&#13;
<span class="cviolet"><strong>45</strong></span>     <code>std::ranges::sort(employees, {},</code>&#13;
<span class="cviolet"><strong>46</strong></span>        [](<span class="blue">const auto</span>&amp; e) {<span class="blue">return</span> e.getSalary();});&#13;
<span class="cviolet"><strong>47</strong></span>     std::cout &lt;&lt; <span class="green">"\nEmployees sorted in ascending order by salary:\n"</span>;&#13;
<span class="cviolet"><strong>48</strong></span>     <code>std::ranges::copy(employees, output);</code>&#13;
<span class="cviolet"><strong>49</strong></span></pre>&#13;
<pre class="pre1"><code>Employees sorted in ascending order by salary:&#13;
Indigo    Matthew   3587&#13;
Red       Jason     5000&#13;
Green     Ashley    7600</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec99">Shorthand Notation for a Projection</h5>&#13;
<p>We can replace the unary function that we implemented as a <strong>lambda</strong> in line 46 with the shorthand notation</p>&#13;
<pre class="pre"><code>&amp;Employee::getSalary</code></pre>&#13;
<p>This creates a pointer to the <code>Employee</code> class’s <code>getSalary</code> member function, shortening lines 45–46 to:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p806pro02" id="p806pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>std::ranges::sort(employees, {}, &amp;Employee::getSalary);</code></pre>&#13;
<p>To be used as a <strong>projection</strong>, the member function must be <code>public</code> and must have no parameters, because the <strong><code>std::ranges</code> algorithms</strong> cannot receive additional arguments to pass to the member function specified in the <strong>projection</strong>.<sup><a id="ch14fn35a" href="ch14.xhtml#ch14fn35">35</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn35" href="ch14.xhtml#ch14fn35a">35</a>. “Under the hood,” <strong><code>sort</code></strong> uses the <strong><code>std::invoke</code></strong> function (header <strong><code>&lt;functional&gt;</code></strong>) to call <code>getSalary</code> on each <code>Employee</code> object.</p>&#13;
<h5 class="h5" id="ch14lev3sec100">A Projection Can Be a Pointer to a <code>public</code> Data Member</h5>&#13;
<p>If a class has a <code>public</code> data member, you can pass a pointer to it as the <strong>projection argument</strong>. For example, if our <code>Employee</code> class had a <code>public</code> data member named <code>salary</code>, we could specify <code>sort</code>’s <strong>projection argument</strong> as</p>&#13;
<pre class="pre"><code>&amp;Employee::salary</code></pre>&#13;
<h5 class="h5" id="ch14lev3sec101">Using a Projection to Sort the <code>array&lt;Employee&gt;</code> in Descending Order</h5>&#13;
<p>In algorithms like <code>sort</code> that have function arguments, you can combine custom functions and <strong>projections</strong>. For example, lines 51–52 specify both a <strong>binary predicate function object</strong> and a <strong>projection</strong> to <strong>sort</strong> <code>Employee</code>s in <strong>descending order</strong> by <code>salary</code>. Again, we pass three arguments:</p>&#13;
<p class="bull">• The first argument (<code>employees</code>) is the <strong>range</strong> to sort.</p>&#13;
<p class="bull">• The second argument creates a <strong><code>std::ranges::greater</code> function object</strong>. This causes <strong><code>sort</code></strong> to arrange the elements in <strong>descending order</strong>. The <strong><code>greater</code> function object</strong> compares its two arguments and returns <code>true</code> if the first is greater than the second. If <strong><code>greater</code></strong> returns <code>false</code>, the two salaries are not in descending order, so <strong><code>sort</code></strong> reorders the corresponding <code>Employee</code> objects.</p>&#13;
<p class="bull">• The last argument is the <strong>projection</strong>. So, the <strong><code>std::ranges::greater</code> function object</strong> will compare the <code>int</code> salaries of <code>Employee</code>s to <strong>determine the sort order</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p807pro01" id="p807pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>50</strong></span>      <span class="lgreen">// sort Employees by salary in descending order</span>&#13;
<span class="cviolet"><strong>51</strong></span>      <code>std::ranges::sort(employees, std::ranges::greater{},</code>&#13;
<span class="cviolet"><strong>52</strong></span>         <code>&amp;Employee::getSalary);</code>&#13;
<span class="cviolet"><strong>53</strong></span>      std::cout &lt;&lt; <span class="green">"\nEmployees sorted in descending order by salary:\n"</span>;&#13;
<span class="cviolet"><strong>54</strong></span>      <code>std::ranges::copy(employees, output);</code>&#13;
<span class="cviolet"><strong>55</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Employees sorted in descending order by salary:&#13;
Green     Ashley    7600&#13;
Red       Jason     5000&#13;
Indigo    Matthew   3587</code></pre>&#13;
</div>&#13;
<h3 class="h3" id="sec14_7"><span class="size">20</span> <span class="violet">14.7</span> C++20 Views and Functional-Style Programming</h3>&#13;
<p>In <a href="ch06.xhtml#ch06lev2sec3">Section 6.14.3</a>, we showed <strong>view</strong>s performing operations on <strong>ranges</strong>. We showed that <strong>views</strong> are <strong>composable</strong>, so you can <strong>chain them together</strong> to process a <strong>range</strong>’s elements through a <strong>pipeline of operations</strong>. A <strong>view</strong> does not have its own copy of a <strong>range</strong>’s elements—it simply moves the elements through a <strong>pipeline of operations</strong>. <strong>Views</strong> are one of <strong>C++20’s key functional-style programming</strong> capabilities.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> The algorithms we’ve presented in this chapter so far are <strong>greedy</strong>—when you call an algorithm, it immediately performs its specified task. You saw in <a href="ch06.xhtml#ch06lev2sec3">Section 6.14.3</a> that views are <strong>lazy</strong>—they do not produce results until you iterate over them in a loop or pass them to an algorithm that iterates over them. As we discussed in <a href="ch06.xhtml#ch06lev2sec3">Section 6.14.3</a>, lazy evaluation produces values on demand, which can reduce your program’s memory consumption and improve performance when all the values are not needed at once.</p>&#13;
<h4 class="h4" id="sec14_7_1">14.7.1 Range Adaptors</h4>&#13;
<p><a href="ch06.xhtml#ch06lev2sec3">Section 6.14.3</a> also demonstrated functional-style <strong>filter</strong> and <strong>map</strong> operations using:</p>&#13;
<p class="bull">• <strong><code>std::views::filter</code></strong> to keep only those <strong>view</strong> elements for which a <strong>predicate</strong></p>&#13;
<p><strong>function</strong> returns <code>true</code>, and</p>&#13;
<p class="bull">• <strong><code>std::views::transform</code></strong> to <strong>map</strong> each <strong>view</strong> element to a new value, possibly of a different type.</p>&#13;
<p><span class="size">20</span> These are each <strong><span class="violet">range adaptors</span></strong> (defined in the <strong>header <code>&lt;ranges&gt;</code></strong>). Each takes a <strong>range</strong> as an argument and returns a <code>std::ranges::</code><span class="violet"><strong><code>viewable_range</code></strong></span>, which is commonly referred to as a <strong>view</strong>. The following table lists all the C++20 <strong>range adaptors</strong>. These can be used with the <strong>functional-style programming</strong> techniques we introduced in <a href="ch06.xhtml#ch06lev1sec14">Section 6.14</a>. <strong>Range adaptors</strong> are defined in the <strong><code>&lt;ranges&gt;</code> header</strong> as part of the namespace <strong><code>std::ranges::views</code></strong>. The <strong><code>&lt;ranges&gt;</code> header</strong> also defines the alias <strong><code>std::views</code></strong> for <strong><code>std::ranges::views</code></strong>.</p>&#13;
<div class="image"><img src="Images/808tab01.jpg" alt="Images" width="796" height="839"/></div>&#13;
<h4 class="h4" id="sec14_7_2">14.7.2 Working with Range Adaptors and Views</h4>&#13;
<p><a href="ch14.xhtml#fig14_18">Figure 14.18</a> demonstrates several <strong><code>std::views</code></strong> from the preceding table and introduces the infinite version of the <strong><code>std::views::iota</code> range factory</strong>. Line 13 defines a <strong>lambda</strong> that returns <code>true</code> if its argument is an even integer. We’ll use this <strong>lambda</strong> in our <strong>pipelines</strong>.</p>&#13;
<div class="group" id="fig14_18">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p14pro18" id="p14pro18a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig14_18.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Working with C++20 std::views.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iterator&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;map&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;ranges&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>12</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">auto</span> isEven{[](<span class="blue">int</span> x) {<span class="blue">return</span> x % 2 == <span class="green">0</span>;}}; <span class="lgreen">// true if x is even</span>&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 14.18</strong></span> | Working with C++20 <code>std::views</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec102">Creating an Infinite Range With <code>std::views::iota</code></h5>&#13;
<p>In <a href="ch06.xhtml#fig6_13">Fig. 6.13</a>, we introduced <strong><code>std::views::iota</code></strong> which is known as a <strong>range factory</strong>—it’s a view that <strong>lazily creates a sequence of consecutive integers</strong> when you iterate over it. The version of <strong><code>iota</code></strong> in <a href="ch06.xhtml#fig6_13">Fig. 6.13</a> requires two arguments—the starting integer value and the value that’s one past the end of the sequence that <strong><code>iota</code></strong> should produce. Line 16 uses <strong><code>iota</code></strong>’s <strong><span class="violet">infinite range</span></strong> version, which receives only the starting integer (<code>0</code>) in the sequence and increments it by one until you tell it to stop—you’ll see how momentarily. The <strong>pipeline</strong> in line 16 creates a <strong>view</strong> that <strong><code>filter</code></strong>s the integers produced by <strong><code>iota</code></strong>, keeping only the integers for which the <strong>lambda <code>isEven</code></strong> returns <code>true</code>. At this point, no integers have been produced. Recall that <strong>views are lazy</strong>—they do not execute until you iterate through them with a loop or a standard library algorithm. Views are objects that you can store in variables so you can reuse their processing steps and even add more processing steps later. We store this <strong>view</strong> in <code>evens</code>. We’ll use <code>evens</code> to build several enhanced <strong>pipelines</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p810pro01" id="p810pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>15</strong></span>     <span class="lgreen">// infinite view of even integers starting at 0</span>&#13;
<span class="cviolet"><strong>16</strong></span>     <span class="blue">auto</span> evens{std::views::iota(<span class="green">0</span>) | std::views::filter(isEven)};&#13;
<span class="cviolet"><strong>17</strong></span></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec103"><code>take</code> Range Adaptor</h5>&#13;
<p>Though an <strong>infinite range</strong> is logically infinite,<sup><a id="ch14fn36a" href="ch14.xhtml#ch14fn36">36</a></sup> to process one in a loop or pass one to a standard library algorithm, <strong>you must first limit the number of elements the pipeline will produce</strong>; otherwise, your program will contain an <strong>infinite loop</strong>. There are several <strong>range adaptors</strong> that can limit the number of elements to process—they work with <strong>infinite ranges</strong> and <strong>fixed-size ranges</strong>. Line 19 uses the <span class="violet"><strong><code>take</code></strong></span> <strong><span class="violet">range adaptor</span></strong> to take only the first five values from the <strong><code>evens</code> pipeline</strong> that we defined in line 16. We pass the resulting <strong>view</strong> to <strong><code>std::ranges::copy</code></strong> (line 19), which iterates through the <strong>pipeline</strong>, causing it to execute its steps:</p>&#13;
<p class="footnote"><a id="ch14fn36" href="ch14.xhtml#ch14fn36a">36</a>. Jeff Garland, “Using C++20 Ranges Effectively,” Jun 18, 2019. Accessed May 2, 2021. <code><a href="https://www.youtube.com/watch?v=VmWS-9idT3s">https://www.youtube.com/watch?v=VmWS-9idT3s</a></code>.</p>&#13;
<p class="bull">• <strong><code>iota</code></strong> produces an integer,</p>&#13;
<p class="bull">• <strong><code>filter</code></strong> checks if it’s even and, if so,</p>&#13;
<p class="bull">• <strong><code>take</code></strong> passes that value to <strong><code>copy</code></strong>.</p>&#13;
<p>If the value <strong><code>iota</code></strong> produces is not even, <strong><code>filter</code></strong> discards that value, and <strong><code>iota</code></strong> produces the next value in the sequence. This process repeats until <strong><code>take</code></strong> has passed the specified number of elements to <strong><code>copy</code></strong>, which displays the results using the <code>ostream_iterator output</code>. <strong>You can take any number of items from an infinite range or up to the maximum number of items in a fixed-size range.</strong> For demonstration purposes, we’ll process just a few items in each of the subsequent pipelines we discuss.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p810pro02" id="p810pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>18</strong></span>   std::cout &lt;&lt; <span class="green">"First five even ints: "</span>;&#13;
<span class="cviolet"><strong>19</strong></span>   std::ranges::copy(evens | std::views::take(<span class="green">5</span>), output);&#13;
<span class="cviolet"><strong>20</strong></span></pre>&#13;
<pre class="pre1"><code>First five even ints: 0 2 4 6 8</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec104"><code>take_while</code> Range Adaptor</h5>&#13;
<p>Lines 22–23 create an enhanced <strong>pipeline</strong> that uses the <span class="violet"><strong><code>take_while</code></strong></span> <strong><span class="violet">range adaptor</span></strong> to limit the <strong><code>evens</code> infinite range</strong>. This <strong>range adaptor</strong> returns a <strong>view</strong> that takes elements from the earlier steps in the <strong>pipeline</strong> until <strong><code>take_while</code></strong>’s <strong>unary predicate</strong> returns <code>false</code>. In this case, we take even integers while those values are less than 12. The first value greater than or equal to 12 terminates the <strong>pipeline</strong>. We store the <strong>view</strong> returned by <strong><code>take_while</code></strong> in the variable <strong><code>lessThan12</code></strong> for use in subsequent statements. Line 24 passes <code>lessThan12</code> to <strong><code>std::ranges::copy</code></strong>, which iterates through the <strong>view</strong>—executing its <strong>pipeline</strong> steps—and displays the results.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p811pro01" id="p811pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>21</strong></span>   std::cout &lt;&lt; <span class="green">"\nEven ints less than 12: "</span>;&#13;
<span class="cviolet"><strong>22</strong></span>   <span class="blue">auto</span> lessThan12{&#13;
<span class="cviolet"><strong>23</strong></span>      evens | std::views::take_while([](<span class="blue">int</span> x) {<span class="blue">return</span> x &lt; <span class="green">12</span>;})};&#13;
<span class="cviolet"><strong>24</strong></span>   <code>std::ranges::copy(lessThan12, output);</code>&#13;
<span class="cviolet"><strong>25</strong></span></pre>&#13;
<pre class="pre1"><code>Even ints less than 12: 0 2 4 6 8 10</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec105"><code>reverse</code> Range Adaptor</h5>&#13;
<p>Line 27 uses the <span class="violet"><strong><code>reverse</code></strong></span> <strong><span class="violet">range adaptor</span></strong> to reverse the integers from the <strong>view</strong> <code>lessThan12</code> from lines 22–23. We pass the <strong>view</strong> returned by <strong><code>reverse</code></strong> to <strong><code>std::ranges::copy</code></strong>, which iterates through the <strong>view</strong>—executing its <strong>pipeline</strong> steps—and displays the results.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p811pro02" id="p811pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>26</strong></span>   std::cout &lt;&lt; <span class="green">"\nEven ints less than 12 reversed: "</span>;&#13;
<span class="cviolet"><strong>27</strong></span>   <code>std::ranges::copy(lessThan12 | std::views::reverse, output);</code>&#13;
<span class="cviolet"><strong>28</strong></span></pre>&#13;
<pre class="pre1"><code>Even ints less than 12 reversed: 10 8 6 4 2 0</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec106"><code>transform</code> Range Adaptor</h5>&#13;
<p>We introduced the <strong><code>transform</code> range adaptor</strong> in <a href="ch06.xhtml#fig6_13">Fig. 6.13</a>. The <strong>pipeline</strong> in lines 31–33 creates a <strong>view</strong> that gets the integers produced by <code>lessThan12</code>, reverses them then uses <strong><code>transform</code></strong> to square their values. We pass the resulting <strong>view</strong> to <strong><code>std::ranges::copy</code></strong>, which iterates through the <strong>view</strong>—executing its <strong>pipeline</strong> steps—and displays the results.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p811pro03" id="p811pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>29</strong></span>   std::cout &lt;&lt; <span class="green">"\nSquares of even ints less than 12 reversed: "</span>;&#13;
<span class="cviolet"><strong>30</strong></span>   <code>std::ranges::copy(</code>&#13;
<span class="cviolet"><strong>31</strong></span>      <code>lessThan12</code>&#13;
<span class="cviolet"><strong>32</strong></span>         <code>| std::views::reverse</code>&#13;
<span class="cviolet"><strong>33</strong></span>         | std::views::transform([](<span class="blue">int</span> x) {<span class="blue">return</span> x * x;}),&#13;
<span class="cviolet"><strong>34</strong></span>      <code>output);</code>&#13;
<span class="cviolet"><strong>35</strong></span></pre>&#13;
<pre class="pre1"><code>Squares of even ints less than 12 reversed: 100 64 36 16 4 0</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec107"><code>drop</code> Range Adaptor</h5>&#13;
<p>The <strong>pipeline</strong> in line 38 begins with the <strong>infinite sequence</strong> of even integers produced by <strong><code>evens</code></strong>, uses the <span class="violet"><strong><code>drop</code></strong></span> <strong><span class="violet">range adaptor</span></strong> to skip the first 1000 even integers, then uses the <strong><code>take</code> range adaptor</strong> to take the next five even integers in the sequence. We pass the resulting <strong>view</strong> to <strong><code>std::ranges::copy</code></strong>, which iterates through the <strong>view</strong>—executing its <strong>pipeline</strong> steps—and displays the results.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p811pro04" id="p811pro04a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>36</strong></span>   std::cout &lt;&lt; <span class="green">"\nSkip 1000 even ints, then take five: "</span>;&#13;
<span class="cviolet"><strong>37</strong></span>   <code>std::ranges::copy(</code>&#13;
<span class="cviolet"><strong>38</strong></span>      evens | std::views::drop(<span class="green">1000</span>) | std::views::take(<span class="green">5</span>),&#13;
<span class="cviolet"><strong>39</strong></span>      <code>output);</code>&#13;
<span class="cviolet"><strong>40</strong></span></pre>&#13;
<pre class="pre1"><code>Skip 1000 even ints, then take five: 2000 2002 2004 2006 2008</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec108"><code>drop_while</code> Range Adaptor</h5>&#13;
<p>You also can skip elements while a <strong>unary predicate</strong> remains true. The <strong>pipeline</strong> in lines 43– 45 begins with the <strong>infinite sequence</strong> of even integers produced by <strong><code>evens</code></strong>, uses the <span class="violet"><strong><code>drop_while</code></strong></span> <strong><span class="violet">range adaptor</span></strong> to skip even integers at the beginning of the <strong>infinite sequence</strong> that are less than or equal to 1000, then uses the <strong><code>take</code> range adaptor</strong> to take the next five even integers in the sequence. We pass the resulting <strong>view</strong> to <strong><code>std::ranges::copy</code></strong>, which iterates through the <strong>view</strong>—executing its <strong>pipeline</strong> steps—and displays the results.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p812pro01" id="p812pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>41</strong></span>   std::cout &lt;&lt; <span class="green">"\nFirst five even ints greater than 1000: "</span>;&#13;
<span class="cviolet"><strong>42</strong></span>   <code>std::ranges::copy(</code>&#13;
<span class="cviolet"><strong>43</strong></span>      <code>evens</code>&#13;
<span class="cviolet"><strong>44</strong></span>         | std::views::drop_while([](int x) {<span class="blue">return</span> x &lt;= <span class="green">1000</span>;})&#13;
<span class="cviolet"><strong>45</strong></span>         | std::views::take(<span class="green">5</span>),&#13;
<span class="cviolet"><strong>46</strong></span>      <code>output);</code>&#13;
<span class="cviolet"><strong>47</strong></span></pre>&#13;
<pre class="pre1"><code>First five even ints greater than 1000: 1002 1004 1006 1008 1010</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec109">Creating and Displaying a <code>map</code> of Roman Numerals and Their Decimal Values</h5>&#13;
<p>So far, we’ve focused on processing <strong>ranges</strong> of integers for simplicity, but you can process <strong>ranges</strong> of more complex types and process various <strong>containers</strong> as well. Next, we’ll process the <strong>key-value pairs</strong> in a <strong><code>map</code></strong> containing <code>string</code> objects as <strong>keys</strong> and <code>int</code>s as <strong>values</strong>. The <strong>keys</strong> are roman numerals and the <strong>values</strong> are their corresponding decimal values. The using declaration in line 49 enables us to use <strong><code>string</code> object literals</strong> as we build each <strong>key-value pair</strong> in line 52. For example, in the value <code>"I"s</code>, the <code>s</code> following the string literal designates that the literal is a <code>string</code> object. Lines 53–54 create a <strong>lambda</strong> that we use in line 56 with <strong><code>std::ranges::foreach</code></strong> to display each <strong>key-value pair</strong> in the <strong><code>map</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p812pro02" id="p812pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>48</strong></span>   <span class="lgreen">// allow std::string object literals</span>&#13;
<span class="cviolet"><strong>49</strong></span>   <span class="blue">using</span> namespace std::literals::string_literals;&#13;
<span class="cviolet"><strong>50</strong></span>&#13;
<span class="cviolet"><strong>51</strong></span>   std::map&lt;std::string, <span class="blue">int</span>&gt; romanNumerals{&#13;
<span class="cviolet"><strong>52</strong></span>      {<span class="green">"I"</span>s, <span class="green">1</span>}, {<span class="green">"II"</span>s, <span class="green">2</span>}, {<span class="green">"III"</span>s, <span class="green">3</span>}, {<span class="green">"IV"</span>s, <span class="green">4</span>}, {<span class="green">"V"</span>s, <span class="green">5</span>}};&#13;
<span class="cviolet"><strong>53</strong></span>   <span class="blue">auto</span> displayPair{[](const auto&amp; p) {&#13;
<span class="cviolet"><strong>54</strong></span>      std::cout &lt;&lt; p.first &lt;&lt; <span class="green">" = "</span> &lt;&lt; p.second &lt;&lt; <span class="green">"\n"</span>;}};&#13;
<span class="cviolet"><strong>55</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nromanNumerals:\n"</span>;&#13;
<span class="cviolet"><strong>56</strong></span>   <code>std::ranges::for_each(romanNumerals, displayPair);</code>&#13;
<span class="cviolet"><strong>57</strong></span></pre>&#13;
<pre class="pre1"><code>romanNumerals:&#13;
I = 1&#13;
II = 2&#13;
III = 3&#13;
IV = 4&#13;
V = 5&#13;
</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec110"><code>keys</code> and <strong><code>values</code></strong> Range Adaptors</h5>&#13;
<p>When working with <strong><code>map</code></strong>s in pipelines, each <strong>key-value pair</strong> is treated as a <strong><code>pair</code></strong> object containing a <strong>key</strong> and a <strong>value</strong>. You can use the <strong>range adaptors</strong> <span class="violet"><strong><code>keys</code></strong></span> (line 60) and <span class="violet"><strong><code>values</code></strong></span> (line 63) to get <strong>views</strong> of only the <strong>keys</strong> and <strong>values</strong>, respectively:</p>&#13;
<p class="bull">• <strong><code>keys</code></strong> creates a <strong>view</strong> that selects only the <em>first</em> item in each <strong><code>pair</code></strong>, and</p>&#13;
<p class="bull">• <strong><code>values</code></strong> creates a <strong>view</strong> that selects only the <em>second</em> item in each <strong><code>pair</code></strong>.</p>&#13;
<p>We pass each <strong>pipeline</strong> to <strong><code>std::ranges::copy</code></strong>, which iterates through the <strong>pipeline</strong> and displays the results</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p813pro01" id="p813pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>58</strong></span>   std::ostream_iterator&lt;std::string&gt; stringOutput{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>59</strong></span>   std::cout &lt;&lt; <span class="green">"\nKeys in romanNumerals: "</span>;&#13;
<span class="cviolet"><strong>60</strong></span>   <code>std::ranges::copy(romanNumerals | std::views::keys, stringOutput);</code>&#13;
<span class="cviolet"><strong>61</strong></span>&#13;
<span class="cviolet"><strong>62</strong></span>   std::cout &lt;&lt; <span class="green">"\nValues in romanNumerals: "</span>;&#13;
<span class="cviolet"><strong>63</strong></span>   <code>std::ranges::copy(romanNumerals | std::views::values, output);</code>&#13;
<span class="cviolet"><strong>64</strong></span></pre>&#13;
<pre class="pre1"><code>Keys in romanNumerals: I II III IV V</code>&#13;
<code>Values in romanNumerals: 1 2 3 4 5</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch14lev3sec111"><code>elements</code> Range Adaptor</h5>&#13;
<p>Interestingly, the <strong><code>keys</code></strong> and <strong><code>values</code> range adaptors</strong> also work with <strong>ranges</strong> in which each element is a <strong><code>tuple</code></strong> or an <strong><code>array</code></strong>. Even if they contain more than two elements each, <strong><code>keys</code></strong> always selects the <em>first</em> item and <strong><code>values</code></strong> always selects the <em>second</em>. If the <strong><code>tuple</code></strong> or <strong><code>array</code></strong> elements in the <strong>range</strong> have more than two elements, the <span class="violet"><strong><code>elements</code></strong></span> <strong><span class="violet">range adaptor</span></strong> can select items by index, as we demonstrate with <code>romanNumerals</code>’ <strong>key-value pairs</strong>. Line 67 selects only <em>element 0</em> from each <strong><code>pair</code></strong> object in the <strong>range</strong>, and line 68 selects only <em>element 1</em>. In both cases, we pass the pipeline to <strong><code>std::ranges::copy</code></strong>, which iterates through the pipelines and displays the results</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p813pro02" id="p813pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>65</strong></span>      std::cout &lt;&lt; <span class="green">"\nKeys in romanNumerals via std::views::elements: "</span>;&#13;
<span class="cviolet"><strong>66</strong></span>      <code>std::ranges::copy(</code>&#13;
<span class="cviolet"><strong>67</strong></span>         romanNumerals | std::views::elements&lt;<span class="green">0</span>&gt;, <span class="green"/>stringOutput);&#13;
<span class="cviolet"><strong>68</strong></span>&#13;
<span class="cviolet"><strong>69</strong></span>      std::cout &lt;&lt; <span class="green">"\nvalues in romanNumerals via std::views::elements: "</span>;&#13;
<span class="cviolet"><strong>70</strong></span>      std::ranges::copy(romanNumerals | std::views::elements&lt;<span class="green">1</span>&gt;, output);&#13;
<span class="cviolet"><strong>71</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>72</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Keys in romanNumerals via std::views::elements: I II III IV V&#13;
values in romanNumerals via std::views::elements: 1 2 3 4 5</code></pre>&#13;
</div>&#13;
<h3 class="h3" id="sec14_8"><span class="violet">14.8</span> Intro to Parallel Algorithms</h3>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> For decades, every couple of years, computer processing power approximately doubled inexpensively. This is known as <strong><span class="violet">Moore’s Law</span></strong>—named for Gordon Moore, co-founder of Intel and the person who identified this trend in the 1960s. Key executives at computer-processor companies NVIDIA and Arm have indicated that Moore’s Law no longer applies.<sup><a id="ch14fn37a" href="ch14.xhtml#ch14fn37">37</a>,<a id="ch14fn38a" href="ch14.xhtml#ch14fn38">38</a></sup> Computer processing power continues to increase, but hardware vendors now rely on new processor designs, such as <strong>multicore processors</strong>, which enable true parallel processing for better performance. C++ has always been focused on performance. However, its first standard support for parallelism was not added until C++11—32 years after the language’s inception.</p>&#13;
<p class="footnote"><a id="ch14fn37" href="ch14.xhtml#ch14fn37a">37</a>. Esther Shein, “Moore’s Law turns 55: Is it still relevant?” April 17, 2020. Accessed May 6, 2021. <code><a href="https://www.techrepublic.com/article/moores-law-turns-55-is-it-still-relevant">https://www.techrepublic.com/article/moores-law-turns-55-is-it-still-relevant</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn38" href="ch14.xhtml#ch14fn38a">38</a>. Nick Heath, “Moore’s Law is dead: Three predictions about the computers of tomorrow.” September 19, 2018. Accessed May 6, 2021. <code><a href="https://www.techrepublic.com/article/moores-law-is-dead-three-predictions-about-the-computers-of-tomorrow/">https://www.techrepublic.com/article/moores-law-is-dead-three-predictions-about-the-computers-of-tomorrow/</a></code>.</p>&#13;
<p>Parallelizing an algorithm is not as simple as “flipping a switch” to say, “I want to run this algorithm in parallel.” Parallelization is sensitive to what the algorithm does and which parts can truly run in parallel on multicore hardware. Programmers must carefully determine how to divide tasks for parallel execution. Such algorithms must be scalable to any number of cores—more or fewer cores might be available at a given time because they’re shared among all the computer’s tasks. In addition, the number of cores is increasing over time as computer architecture evolves, so algorithms should be flexible enough to take advantage of those additional cores. As challenging as it is to write parallel algorithms, the incentive is high to maximize application performance.</p>&#13;
<p><span class="size">17</span> Over the years, it has become clear that designing algorithms capable of executing on multiple cores is complex and error-prone. So many programming languages now provide built-in library capabilities that offer “canned” parallelism features. C++ already has a collection of valuable algorithms. To help programmers avoid “reinventing the wheel,” C++17 introduced <strong>parallel overloads</strong> for <strong>69 common-ranges algorithms</strong>, enabling them to take advantage of multicore architectures and the high-performance “vector mathematics” operations available on today’s CPUs and GPUs. Vector operations can perform the same operation on many data items at the same time.<sup><a id="ch14fn39a" href="ch14.xhtml#ch14fn39">39</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn39" href="ch14.xhtml#ch14fn39a">39</a>. “General utilities library—Execution policies—Unsequenced execution policy.” Accessed May 3, 2021. <code><a href="https://eel.is/c++draft/execpol.unseq">https://eel.is/c++draft/execpol.unseq</a></code>.</p>&#13;
<p><span class="size">17</span> In addition, C++17 added seven new parallel algorithms:</p>&#13;
<p class="bull">• <code>for_each_n</code></p>&#13;
<p class="bull">• <code>exclusive_scan</code></p>&#13;
<p class="bull">• <code>inclusive_scan</code></p>&#13;
<p class="bull">• <code>transform_exclusive_scan</code></p>&#13;
<p class="bull">• <code>transform_inclusive_scan</code></p>&#13;
<p class="bull">• <code>reduce</code></p>&#13;
<p class="bull">• <code>transform_reduce</code></p>&#13;
<p><span class="size">23</span> The algorithm overloads take the burden of parallel programming largely off programmers’ shoulders and place it on the prepackaged library algorithms, leveraging the programming process. Unfortunately, the <strong>C++20 <code>std::ranges</code> algorithms</strong> are not yet parallelized, though they might be for C++23.<sup><a id="ch14fn40a" href="ch14.xhtml#ch14fn40">40</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn40" href="ch14.xhtml#ch14fn40a">40</a>. Barry Revzin, Conor Hoekstra and Tim Song, “A Plan for C++23 Ranges,” October 14, 2020. Accessed May 5, 2021. <code><a href="https://wg21.link/p2214r0">https://wg21.link/p2214r0</a></code>.</p>&#13;
<p><a href="ch17.xhtml#ch17">Chapter 17</a>, Concurrency, Parallelism, C++20 Coroutines and the Parallel STL will:</p>&#13;
<p class="bull">• overview the parallel algorithms,</p>&#13;
<p class="bull"><span class="size">17</span> <span class="size">20</span> • discuss the four “execution policies” (three from C++17 and one from C++20) that determine how a parallel algorithm uses a system’s parallel processing capabilities to perform a task,</p>&#13;
<p class="bull">• demonstrate how to invoke parallel algorithms, and</p>&#13;
<p class="bull">• use functions from the <code>&lt;chrono&gt;</code> header to time how long it takes to execute standard library algorithms running sequentially on a single core vs. running in parallel on multiple cores, so you can see the difference in performance.</p>&#13;
<p><span class="size">20</span> You’ll see that the parallel versions of algorithms do not always run faster than sequential versions—and we’ll explain why. We’ll also introduce the various standard library headers containing C++’s concurrency and parallel-programming capabilities, and introduce C++20’s new coroutines feature.</p>&#13;
<h3 class="h3" id="sec14_9"><span class="violet">14.9</span> Standard Library Algorithm Summary</h3>&#13;
<p>The C++ standard specifies 117 algorithms—many overloaded with two or more versions. The standard separates the algorithms into several categories:</p>&#13;
<p class="bull">• mutating sequence algorithms (<code>&lt;algorithm&gt;</code>),</p>&#13;
<p class="bull">• nonmodifying sequence algorithms (<code>&lt;algorithm&gt;</code>),</p>&#13;
<p class="bull">• sorting and related algorithms (<code>&lt;algorithm&gt;</code>),</p>&#13;
<p class="bull">• generalized numeric operations (<code>&lt;numeric&gt;</code>), and</p>&#13;
<p class="bull">• specialized memory operations (<code>&lt;memory&gt;</code>).</p>&#13;
<p>To learn about algorithms we did not present in this chapter, visit sites such as</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p815pro01" id="p815pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>https://en.cppreference.com/w/cpp/algorithm&#13;
https://docs.microsoft.com/en-us/cpp/standard-library/algorithm</code></pre>&#13;
<p>Throughout this section’s tables:</p>&#13;
<p class="bull">• Algorithms we present in this chapter are grouped at the top of each table and shown in <strong><code>bold</code></strong>.</p>&#13;
<p class="bull">• Algorithms that have a <strong>C++20 <code>std::ranges</code> overload</strong> are marked with a superscript “R.” You can see the list of <strong><code>std::ranges</code> algorithms</strong> at:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p815pro02" id="p815pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>https://en.cppreference.com/w/cpp/algorithm/ranges</code></pre>&#13;
<p class="bull">• Algorithms that have a parallel version are marked with a superscript “P.” You can see the list of parallelized algorithms at:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p815pro03" id="p815pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>https://en.cppreference.com/w/cpp/experimental/parallelism</code></pre>&#13;
<p class="bull">• Algorithms that were added in C++ versions 11, 17 and 20 are marked with the superscript version number.</p>&#13;
<p>For example, the algorithm <strong><code>copy</code></strong> is marked with “PR,” meaning it has a parallelized version and a <code>std::ranges</code> version, and the algorithm <strong><code>is_sorted_until</code></strong> is marked with “PR11,” meaning it has a parallelized version and a <code>std::ranges</code> version and it was introduced to the standard library in C++11.</p>&#13;
<h5 class="h5" id="ch14lev3sec112">Mutating Sequence Algorithms</h5>&#13;
<p><span class="size">Sec</span><img class="inline" src="Images/sec.jpg" alt="Images" width="28" height="31"/> The following table shows many of the <strong><span class="violet">mutating-sequence algorithms</span></strong>—i.e., algorithms that modify the containers on which they operate. The <code>shuffle</code> algorithm replaced the less-secure <code>random_shuffle</code> algorithm. “Under the hood” <code>random_shuffle</code> used function <code>rand</code>—which was inherited into C++ from the C standard library. C’s <code>rand</code> does not have “good statistical properties” and can be predictable,<sup><a id="ch14fn41a" href="ch14.xhtml#ch14fn41">41</a></sup> making programs that use <code>rand</code> less secure. The newer <strong><code>shuffle</code></strong> algorithm uses the <strong>C++11 nondeterministic random-number generation</strong> capabilities.</p>&#13;
<p class="footnote"><a id="ch14fn41" href="ch14.xhtml#ch14fn41a">41</a>. “Do not use the <code>rand()</code> function for generating pseudorandom numbers.” Last modified April 23, 2021. Accessed May 5, 2021. <code><a href="https://wiki.sei.cmu.edu/confluence/display/c/MSC30-C.+Do+not+use+the+rand%28%29+function+for+generating+pseudorandom+numbers">https://wiki.sei.cmu.edu/confluence/display/c/MSC30-C.+Do+not+use+the+rand%28%29+function+for+generating+pseudorandom+numbers</a></code>.</p>&#13;
<div class="image"><img src="Images/816tab01.jpg" alt="Images" width="813" height="322"/></div>&#13;
<h5 class="h5" id="ch14lev3sec113">Nonmodifying Sequence Algorithms</h5>&#13;
<p>The following table shows the <strong><span class="violet">nonmodifying sequence algorithms</span></strong>—i.e., algorithms that do not modify the containers they operate on.</p>&#13;
<div class="image"><img src="Images/816tab02.jpg" alt="Images" width="813" height="237"/></div>&#13;
<h5 class="h5" id="ch14lev3sec114">Sorting and Related Algorithms</h5>&#13;
<p>The following table shows the sorting and related algorithms.</p>&#13;
<div class="image"><img src="Images/817tab01.jpg" alt="Images" width="813" height="491"/></div>&#13;
<h5 class="h5" id="ch14lev3sec115">Numerical Algorithms</h5>&#13;
<p><span class="size">23</span> The following table shows the numerical algorithms of the header <span class="violet"><strong><code>&lt;numeric&gt;</code></strong></span>. The algorithms in this header have not yet been updated for C++20 ranges, though they are being worked on for inclusion in C++23.<sup><a id="ch14fn42a" href="ch14.xhtml#ch14fn42">42</a>,<a id="ch14fn43a" href="ch14.xhtml#ch14fn43">43</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn42" href="ch14.xhtml#ch14fn42a">42</a>. Christopher Di Bella, “A Concept Design for the Numeric,” August 2, 2019. Accessed May 2, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1813r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1813r0.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn43" href="ch14.xhtml#ch14fn43a">43</a>. Tristan Brindle, “Numeric Range Algorithms for C++20,” May 19, 2020. Accessed May 2, 2021. <code><a href="https://tristanbrindle.com/posts/numeric-ranges-for-cpp20">https://tristanbrindle.com/posts/numeric-ranges-for-cpp20</a></code>.</p>&#13;
<div class="image"><img src="Images/817tab02.jpg" alt="Images" width="813" height="238"/></div>&#13;
<h5 class="h5" id="ch14lev3sec116">Specialized Memory Operations</h5>&#13;
<p>The following table shows the specialized memory algorithms of the header <span class="violet"><strong><code>&lt;memory&gt;</code></strong></span>, which contains features for dynamic memory management that are beyond this book’s scope. For an overview of the header and these algorithms, see:</p>&#13;
<p class="codelink"><a href="Images/ch14_images.xhtml#p817pro01" id="p817pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>https://en.cppreference.com/w/cpp/header/memory</code><strong/></pre>&#13;
<div class="image"><img src="Images/818tab01.jpg" alt="Images" width="699" height="275"/></div>&#13;
<h3 class="h3" id="sec14_10"><span class="size">23</span> <span class="violet">14.10</span> A Look Ahead to C++23 Ranges</h3>&#13;
<p>Though many algorithms have overloads in the <strong>C++20 <code>std::ranges</code> namespace</strong>, various C++20 algorithms—including those in the <code>&lt;numeric&gt;</code> header and the parallel algorithms in the <code>&lt;algorithm&gt;</code> header—do not yet have C++20 <strong><code>std::ranges</code></strong> overloads. There are standard committee proposals for various additional ranges library features that might be part of C++23. Some of these capabilities are under development and can be used now via the open-source project <code>rangesnext</code>.<sup><a id="ch14fn44a" href="ch14.xhtml#ch14fn44">44</a></sup> C++20’s ranges functionality and many of the new features proposed for C++23 are based on capabilities found in the open-source project <strong>range-v3</strong>.<sup><a id="ch14fn45a" href="ch14.xhtml#ch14fn45">45</a></sup></p>&#13;
<p class="footnote"><a id="ch14fn44" href="ch14.xhtml#ch14fn44a">44</a>. Corentin Jabot, “Ranges For C++23.” Accessed May 5, 2021. <code><a href="https://github.com/cor3ntin/rangesnext">https://github.com/cor3ntin/rangesnext</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn45" href="ch14.xhtml#ch14fn45a">45</a>. Eric Niebler, “range-v3.” Accessed May 5, 2021. <code><a href="https://github.com/ericniebler/range-v3">https://github.com/ericniebler/range-v3</a></code>.</p>&#13;
<h5 class="h5" id="ch14lev3sec117">“A Plan for C++23 Ranges”<sup><a id="ch14fn46a" href="ch14.xhtml#ch14fn46">46</a></sup></h5>&#13;
<p class="footnote"><a id="ch14fn46" href="ch14.xhtml#ch14fn46a">46</a>. Barry Revzin, Conor Hoekstra and Tim Song, “A Plan for C++23 Ranges,” October 14, 2020. Accessed May 5, 2021. <code><a href="https://wg21.link/p2214r0">https://wg21.link/p2214r0</a></code>.</p>&#13;
<p>This paper provides an overview of the general plan for <strong>C++23 ranges</strong>, plus details on many possible new ranges features. The proposed features are categorized by importance into three tiers, with Tier 1 containing the most important features. After a brief introduction, the paper discusses four categories of possible additions:</p>&#13;
<p class="bull">• <strong>View adjuncts</strong>: This section briefly discusses two key features—the <strong>overloaded <code>ranges::to</code> function</strong> for converting views to various container types and the ability to format views and ranges for convenient output. These are discussed in detail in the papers “<code>ranges::to</code>: A function to convert any range to a container”<sup><a id="ch14fn47a" href="ch14.xhtml#ch14fn47">47</a></sup> and “Formatting Ranges,”<sup><a id="ch14fn48a" href="ch14.xhtml#ch14fn48">48</a></sup> respectively.</p>&#13;
<p class="footnote"><a id="ch14fn47" href="ch14.xhtml#ch14fn47a">47</a>. Corentin Jabot, Eric Niebler and Casey Carter, “<code>ranges::to</code>: A function to convert any range to a container,” November 22, 2021. Accessed May 5, 2021. <code><a href="https://wg21.link/p1206r3">https://wg21.link/p1206r3</a></code>.</p>&#13;
<p class="footnote"><a id="ch14fn48" href="ch14.xhtml#ch14fn48a">48</a>. Barry Revzin, “Formatting Ranges,” February 19, 2021. Accessed May 5, 2021. <code><a href="https://wg21.link/p2286">https://wg21.link/p2286</a></code>.</p>&#13;
<p class="bull">• <strong>Algorithms</strong>: This section overviews potential new <strong><code>std::ranges</code> overloads</strong> for various <strong><code>&lt;numeric&gt;</code> algorithms</strong>, which are discussed in more detail in the paper “A Concept Design for the Numeric Algorithms.”<sup><a id="ch14fn49a" href="ch14.xhtml#ch14fn49">49</a></sup> This section also briefly overviews potential issues with producing <strong><code>std::ranges</code> overloads</strong> of C++17’s parallel algorithms. The paper “Introduce Parallelism to the Ranges TS” provides more in-depth discussions of these issues.</p>&#13;
<p class="footnote"><a id="ch14fn49" href="ch14.xhtml#ch14fn49a">49</a>. Christopher Di Bella, “A Concept Design for the Numeric Algorithms,” August 2, 2019. Accessed May 5, 2021. <code><a href="http://wg21.link/p1813r0">http://wg21.link/p1813r0</a></code>.</p>&#13;
<p class="bull">• <strong>Actions</strong>: These are a third category of capabilities separate from ranges and views in the <strong>range-v3 project</strong>. Actions, like <strong>views</strong>, are composable with the <strong><code>|</code> operator</strong>, but, like the <strong><code>std::ranges</code> algorithms</strong>, actions are <strong>greedy</strong>, so they immediately produce results. According to this section, though actions would make some coding more convenient, adding them is a low priority because you can perform the same tasks by calling existing <code>std::ranges</code> algorithms in multiple statements.</p>&#13;
<h3 class="h3" id="sec14_11"><span class="violet">14.11</span> Wrap-Up</h3>&#13;
<p>In this chapter, we demonstrated many of the standard library algorithms, including filling containers with values, generating values, comparing elements or entire containers, removing elements, replacing elements, mathematical operations, searching, sorting, swapping, copying, merging, set operations, determining boundaries, and calculating minimums and maximums. We focused primarily on the C++20 <code>std::ranges</code> versions of these algorithms.</p>&#13;
<p>You saw that the standard library’s algorithms specify various minimum requirements that help you determine which containers, iterators and functions can be passed to each algorithm. We overviewed some named requirements used by the common-ranges algorithms, then indicated that the C++20 range-based algorithms use C++20 concepts to specify their requirements, which are checked at compile time. We briefly introduced the C++20 concepts specified for each range-based algorithm we presented. Not all algorithms have a range-based version.</p>&#13;
<p>We revisited lambdas and introduced additional capabilities for capturing the enclosing scope’s variables. You saw that many algorithms can receive a lambda, a function pointer or a function object as an argument, and call them to customize the algorithms’ behaviors.</p>&#13;
<p>We continued our discussion of C++’s functional-style programming. We showed how to create a logically infinite sequence of values and how to use range adaptors to limit the total number of elements processed through a pipeline. We saved views in variables for later use and added more steps to a previously saved pipeline. We introduced range adaptors for manipulating the keys and values in key-value pairs, and showed a similar range adaptor for selecting any indexed element from fixed-size objects, like <code>pair</code>s, <code>tuple</code>s and <code>array</code>s.</p>&#13;
<p>You learned that C++17 introduced new parallel overloads for 69 standard library algorithms in the <code>&lt;algorithm&gt;</code> header. As you’ll see in <a href="ch16.xhtml#ch16">Chapter 16</a>, these will enable you to take advantage of your computer’s multi-core hardware to enhance program performance. In <a href="ch16.xhtml#ch16">Chapter 16</a>, we’ll demonstrate several parallel algorithms and use the <code>&lt;chrono&gt;</code> header’s capabilities to time sequential and parallel algorithm calls, so you can see the performance differences. We’ll explain why parallel algorithms do not always run faster than their sequential counterparts, so it’s not always worthwhile to use the parallel versions.</p>&#13;
<p>You saw that various C++20 algorithms, including those in the <code>&lt;numeric&gt;</code> header and the parallel algorithms in the <code>&lt;algorithm&gt;</code> header, do not have <code>std::ranges</code> overloads. We mentioned the updates expected in C++23 and pointed you to the GitHub project <code>rangesnext</code>, which contains implementations for many of the proposed updates.</p>&#13;
<p>In the next chapter, we’ll build a simple container, simple iterator and a simple algorithm using custom templates, using C++20 concepts in our templates as appropriate.</p>&#13;
</div></body>
</html>