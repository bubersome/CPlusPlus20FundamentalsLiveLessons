<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch12">Chapter 12. Exceptions and a Look Forward to Contracts</h2>&#13;
<div class="image"><img src="Images/common.jpg" alt="Images" width="370" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Understand the exception-handling flow of control with <code>try</code>, <code>catch</code> and <code>throw</code>.</p>&#13;
<p class="squ"><span class="red">■</span> Provide exception guarantees for your code.</p>&#13;
<p class="squ"><span class="red">■</span> Understand the standard library exception hierarchy.</p>&#13;
<p class="squ"><span class="red">■</span> Define a custom exception class.</p>&#13;
<p class="squ"><span class="red">■</span> Understand how stack unwinding enables exceptions not caught in one scope to be caught in an enclosing scope.</p>&#13;
<p class="squ"><span class="red">■</span> Handle <code>new</code> dynamic memory allocation failures.</p>&#13;
<p class="squ"><span class="red">■</span> Catch exceptions of any type with <code>catch(...)</code>.</p>&#13;
<p class="squ"><span class="red">■</span> Understand what happens with uncaught exceptions.</p>&#13;
<p class="squ"><span class="red">■</span> Understand which exceptions should not be handled and which cannot be handled.</p>&#13;
<p class="squ"><span class="red">■</span> Understand why some organizations disallow exceptions and the impact that can have on software-development efforts.</p>&#13;
<p class="squ"><span class="red">■</span> Understand the performance costs of exception handling.</p>&#13;
<p class="squ"><span class="red">■</span> Look ahead to how contracts can eliminate many use cases of exceptions, enabling more functions to be <code>noexcept</code>.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_1"><span class="violet"><strong>12.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_2"><span class="violet"><strong>12.2</strong></span> Exception-Handling Flow of Control; Defining an Exception Class</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_2_1">12.2.1 Defining an Exception Class to Represent the Type of Problem That Might Occur</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_2_2">12.2.2 Demonstrating Exception Handling</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_2_3">12.2.3 Enclosing Code in a <code>try</code> Block</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_2_4">12.2.4 Defining a <code>catch</code> Handler for <code>DivideByZeroException</code>s</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_2_5">12.2.5 Termination Model of Exception Handling</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_2_6">12.2.6 Flow of Control When the User Enters a Nonzero Denominator</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_2_7">12.2.7 Flow of Control When the User Enters a Zero Denominator</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_3"><span class="violet"><strong>12.3</strong></span> Exception Safety Guarantees and <code>noexcept</code></a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_4"><span class="violet"><strong>12.4</strong></span> Rethrowing an Exception</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_5"><span class="violet"><strong>12.5</strong></span> Stack Unwinding and Uncaught Exceptions</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_6"><span class="violet"><strong>12.6</strong></span> When to Use Exception Handling</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_6_1">12.6.1  <code>assert</code> Macro</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_6_2">12.6.2 Failing Fast</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_7"><span class="violet"><strong>12.7</strong></span> Constructors, Destructors and Exception Handling</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_7_1">12.7.1 Throwing Exceptions from Constructors</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_7_2">12.7.2 Catching Exceptions in Constructors Via Function <code>try</code> Blocks</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_7_3">12.7.3 Exceptions and Destructors; Revisiting <code>noexcept(false)</code></a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_8"><span class="violet"><strong>12.8</strong></span> Processing <code>new</code> Failures</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_8_1">12.8.1  <code>new</code> Throwing <code>bad_alloc</code> on Failure</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_8_2">12.8.2  <code>new</code> Returning <code>nullptr</code> on Failure</a></p>&#13;
<p class="chap-lev2"><a href="ch12.xhtml#sec12_8_3">12.8.3 Handling <code>new</code> Failures Using Function <code>set_new_handler</code></a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_9"><span class="violet"><strong>12.9</strong></span> Standard Library Exception Hierarchy</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_10"><span class="violet"><strong>12.10</strong></span> C++’s Alternative to the <code>finally</code> Block</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_11"><span class="violet"><strong>12.11</strong></span> Libraries Often Support Both Exceptions and Error Codes</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_12"><span class="violet"><strong>12.12</strong></span> Logging</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_13"><span class="violet"><strong>12.13</strong></span> Looking Ahead to Contracts</a></p>&#13;
<p class="chap-lev1"><a href="ch12.xhtml#sec12_14"><span class="violet"><strong>12.14</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="sec12_1"><span class="violet">12.1</span> Introduction</h3>&#13;
<p>C++ is used to build real-world, mission-critical and business-critical software. Bjarne Stroustrup (C++’s creator) maintains on his website an extensive list<sup><a id="ch12fn1a" href="ch12.xhtml#ch12fn1">1</a></sup> of about 150 applications and systems written partially or entirely in C++. Here are just a few:</p>&#13;
<p class="footnote"><a id="ch12fn1" href="ch12.xhtml#ch12fn1a">1</a>. Bjarne Stroustrup, “C++ Applications,” October 27, 2020. Accessed March 29, 2021. <code><a href="https://www.stroustrup.com/applications.html">https://www.stroustrup.com/applications.html</a></code>.</p>&#13;
<p class="bull">• portions of most major operating systems, like Apple macOS and Microsoft Windows,</p>&#13;
<p class="bull">• all the compilers we use in this book (GNU g++, Clang and Visual C++),</p>&#13;
<p class="bull">• Amazon.com,</p>&#13;
<p class="bull">• aspects of Facebook that require high performance and reliability,</p>&#13;
<p class="bull">• Bloomberg’s real-time financial information systems,</p>&#13;
<p class="bull">• many of Adobe’s authoring, graphics and multimedia applications,</p>&#13;
<p class="bull">• various database systems, such as MongoDB and MySQL,</p>&#13;
<p class="bull">• many NASA projects, including aspects of the software in the Mars rovers,</p>&#13;
<p class="bull">• and much more.</p>&#13;
<p>For another extensive list of over 100 applications and systems, see <em>The Programming Languages Beacon</em>.<sup><a id="ch12fn2a" href="ch12.xhtml#ch12fn2">2</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn2" href="ch12.xhtml#ch12fn2a">2</a>. Vincent Lextrait, “The Programming Languages Beacon v16 - March 2016.” Accessed March 29, 2021. <code><a href="https://www.mentofacturing.com/vincent/implementations.html">https://www.mentofacturing.com/vincent/implementations.html</a></code>.</p>&#13;
<p>Many of these systems are massive—consider some statistics from the “Codebases: Millions of Lines of Code infographic” (which is not C++ specific):<sup><a id="ch12fn3a" href="ch12.xhtml#ch12fn3">3</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn3" href="ch12.xhtml#ch12fn3a">3</a>. “Codebases: Millions of Lines of Code infographic.” Accessed March 27, 2021. <code><a href="https://www.informationisbeautiful.net/visualizations/million-lines-of-code/">https://www.informationisbeautiful.net/visualizations/million-lines-of-code/</a></code>. For a spreadsheet of the infographic’s data sources, see <code><a href="http://bit.ly/CodeBasesInfographicData">http://bit.ly/CodeBasesInfographicData</a></code>.</p>&#13;
<p class="bull">• A Boeing 787 aircraft’s avionics and online support systems have 6.5 million lines of code, and its flight software is 14 million lines of code.</p>&#13;
<p class="bull">• The F-35 Fighter Jet has 24 million lines of code.</p>&#13;
<p class="bull">• The Large Hadron Collider—the world’s largest particle accelerator<sup><a id="ch12fn4a" href="ch12.xhtml#ch12fn4">4</a></sup>—in Geneva, Switzerland, has 50 million lines of code.</p>&#13;
<p class="footnote"><a id="ch12fn4" href="ch12.xhtml#ch12fn4a">4</a>. “The Large Hadron Collider.” Accessed March 27, 2021. <code><a href="https://home.cern/science/accelerators/large-hadron-collider">https://home.cern/science/accelerators/large-hadron-collider</a></code>.</p>&#13;
<p class="bull">• Facebook has 62 million lines of code.</p>&#13;
<p class="bull">• An average modern high-end car has 100 million lines of code<sup><a id="ch12fn5a" href="ch12.xhtml#ch12fn5">5</a></sup>—across hundreds of processors and controllers.<sup><a id="ch12fn6a" href="ch12.xhtml#ch12fn6">6</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn5" href="ch12.xhtml#ch12fn5a">5</a>. Hans Greimel, “Automakers rush to take back their software codes,” October 12, 2020. Accessed March 27, 2021. <code><a href="https://www.autonews.com/technology/automakers-rush-take-back-their-software-codes">https://www.autonews.com/technology/automakers-rush-take-back-their-software-codes</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn6" href="ch12.xhtml#ch12fn6a">6</a>. Ferenc Valenta’s answer to “How many lines of code are in a car?” January 10, 2019. Accessed March 27, 2021. <code><a href="https://www.quora.com/How-many-lines-of-code-are-in-a-car/answer/FerencValenta">https://www.quora.com/How-many-lines-of-code-are-in-a-car/answer/FerencValenta</a></code>.</p>&#13;
<p><strong>Self-driving cars are expected to require one billion lines of code.</strong><sup><a id="ch12fn7a" href="ch12.xhtml#ch12fn7">7</a></sup> For large and small codebases alike, it’s essential to eliminate bugs during development and handle problems that may occur once the software is deployed in real products. That is the focus of this chapter.</p>&#13;
<p class="footnote"><a id="ch12fn7" href="ch12.xhtml#ch12fn7a">7</a>. “Jaguar Land Rover Finds the Teenagers Writing the Code for a Self-driving Future.” April 15, 2019. Accessed March 28, 2021. <code><a href="https://media.jaguarlandrover.com/news/2019/04/jaguar-land-rover-finds-teenagers-writing-code-self-driving-future">https://media.jaguarlandrover.com/news/2019/04/jaguar-land-rover-finds-teenagers-writing-code-self-driving-future</a></code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec1">Exceptions and Exception Handling</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> As you know, an <strong><span class="violet">exception</span></strong> is an indication of a problem that occurs during a program’s execution. Exceptions may surface through</p>&#13;
<p class="bull">• explicitly mentioned code in a <code>try</code> block,</p>&#13;
<p class="bull">• calls to other functions (including library calls), and</p>&#13;
<p class="bull">• operator errors, like <code>new</code> failing to acquire additional memory at execution time (<a href="ch12.xhtml#sec12_8">Section 12.8</a>).</p>&#13;
<p><strong><span class="violet">Exception handling</span></strong> helps you write robust, <strong><span class="violet">fault-tolerant programs</span></strong> that catch infrequent problems and:</p>&#13;
<p class="bull">• deal with them and continue executing,</p>&#13;
<p class="bull">• perform appropriate cleanup for exceptions that cannot or should not be handled and terminate gracefully, or</p>&#13;
<p class="bull">• terminate abruptly in the case of unanticipated exceptions—a concept called failing fast, which we discuss in <a href="ch12.xhtml#sec12_6_2">Section 12.6.2</a>.</p>&#13;
<h5 class="h5" id="ch12lev3sec2">Exception-Handling, Stack Unwinding and Rethrowing Exceptions</h5>&#13;
<p>You’ve seen exceptions get thrown (<a href="ch06.xhtml#ch06lev1sec15">Section 6.15</a>) and how to use <code>try</code>…<code>catch</code> to handle them (<a href="ch09.xhtml#ch09lev2sec14">Section 9.7.12</a>). This chapter reviews these exception-handling concepts in an example that demonstrates the flows of control:</p>&#13;
<p class="bull">• when a program executes successfully, and</p>&#13;
<p class="bull">• when an exception occurs.</p>&#13;
<p>We discuss use-cases for catching then rethrowing exceptions and show how C++ handles an exception that is not caught in a particular scope. We introduce logging exceptions into a file or database that developers can review later for debugging purposes.</p>&#13;
<h5 class="h5" id="ch12lev3sec3">When to Use Exceptions and Exception Safety Guarantees</h5>&#13;
<p>Exceptions are not for all types of error handling, so we discuss when and when not to use them. We also introduce the exception safety guarantees you can provide in your code— from none at all to indicating with <code>noexcept</code> that your code does not throw exceptions.</p>&#13;
<h5 class="h5" id="ch12lev3sec4">Exceptions in the Context of Constructors and Destructors</h5>&#13;
<p>We discuss why exceptions are used to indicate errors during construction and why destructors should not throw exceptions. We also demonstrate how to use function <code>try</code> blocks to catch exceptions from a constructor’s member-initializer list.</p>&#13;
<h5 class="h5" id="ch12lev3sec5">Handling Dynamic Memory Allocation Failures</h5>&#13;
<p>By default, operator <code>new</code> throws exceptions when dynamic memory allocation fails. We demonstrate how to catch such <code>bad_alloc</code> exceptions. We also show how dynamic memory allocation failures were handled in legacy code before <code>bad_alloc</code> was added to C++.</p>&#13;
<h5 class="h5" id="ch12lev3sec6">Standard Library Exception Hierarchy and Custom Exception Classes</h5>&#13;
<p>We introduce the C++ standard library exception-handling class hierarchy. We create a custom exception class that inherits from one of the C++ standard-library exception classes. You’ll see why it’s important to catch exceptions by reference to enable exception handlers to catch exception types related by inheritance.</p>&#13;
<h5 class="h5" id="ch12lev3sec7">Exceptions Are Not Universally Used</h5>&#13;
<p>Most C++ features have a zero-overhead principle in which you do not pay a price for a given feature unless you use it.<sup><a id="ch12fn8a" href="ch12.xhtml#ch12fn8">8</a></sup> Exceptions violate this principle—programs with exception handling have a larger memory footprint. Some organizations disallow exception handling for this and other reasons. We’ll discuss why some libraries provide dual interfaces, enabling developers to choose whether to use versions of functions that throw exceptions or versions that set error codes.</p>&#13;
<p class="footnote"><a id="ch12fn8" href="ch12.xhtml#ch12fn8a">8</a>. Herb Sutter, “De-fragmenting C++: Making Exceptions and RTTI More Affordable and Usable,” September 23, 2021. Accessed March 29, 2021. <code><a href="https://www.youtube.com/watch?v=ARYP83yNAWk">https://www.youtube.com/watch?v=ARYP83yNAWk</a></code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec8">Looking Ahead to Contracts</h5>&#13;
<p>The chapter concludes with an introduction to contracts. This feature was originally targeted for C++20 but has been delayed to a future version. We’ll introduce preconditions, postconditions and assertions, which you’ll see are implemented as contracts tested at runtime. If such conditions fail, a contract violation occurs and, by default, the code terminates immediately, enabling you to find errors faster, eliminate them during development and, hopefully, create more robust code for deployment. You’ll test the example code using an GCC’s experimental contracts implementation on the website <code>godbolt.org</code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec9">Exceptions Enable You to Separate Error Handling from Program Logic</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Exception handling provides a standard mechanism for processing errors. This is especially important when working on a large project. As you’ll see, using <code>try</code>…<code>catch</code> lets you separate the successful path of execution from the error path of execution,<sup><a id="ch12fn9a" href="ch12.xhtml#ch12fn9">9</a>,<a id="ch12fn10a" href="ch12.xhtml#ch12fn10">10</a></sup> making your code easier to read and maintain.<sup><a id="ch12fn11a" href="ch12.xhtml#ch12fn11">11</a></sup> Also, once an exception occurs, it cannot be ignored— in <a href="ch12.xhtml#sec12_5">Section 12.5</a> you’ll see that ignoring an exception can lead to program termination.<sup><a id="ch12fn12a" href="ch12.xhtml#ch12fn12">12</a>,<a id="ch12fn13a" href="ch12.xhtml#ch12fn13">13</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn9" href="ch12.xhtml#ch12fn9a">9</a>. “Technical Report on C++ Performance,” February 15, 2006. Accessed March 26, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf</a></code> (page 34).</p>&#13;
<p class="footnote"><a id="ch12fn10" href="ch12.xhtml#ch12fn10a">10</a>. “What does it mean that exceptions separate the good path (or happy path) from the bad path?” Accessed March 24, 2021. <code><a href="https://isocpp.org/wiki/faq/exceptions#exceptions-separate-good-and-bad-path">https://isocpp.org/wiki/faq/exceptions#exceptions-separate-good-and-bad-path</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn11" href="ch12.xhtml#ch12fn11a">11</a>. “C++ Exception Handling: Try, Catch, throw Example.” Accessed March 24, 2021. <code><a href="https://www.guru99.com/cpp-exceptions-handling.html">https://www.guru99.com/cpp-exceptions-handling.html</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn12" href="ch12.xhtml#ch12fn12a">12</a>. “Technical Report on C++ Performance,” February 15, 2006. Accessed March 26, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf</a></code> (page 34).</p>&#13;
<p class="footnote"><a id="ch12fn13" href="ch12.xhtml#ch12fn13a">13</a>. Manoj Piyumal, "Some Useful Facts to Know Before Using C++ Exceptions," December 5, 2017. Accessed March 26, 2021. <code><a href="https://dzone.com/articles/some-useful-facts-to-know-when-using-c-exceptions">https://dzone.com/articles/some-useful-facts-to-know-when-using-c-exceptions</a></code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec10">Indicating Errors Via Return Values</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Without exception handling, it’s common for a function to calculate and return a value on success or return an error indicator on failure:</p>&#13;
<p class="bull">• A problem with this architecture is using the return value in a subsequent calculation without first checking whether the value is the error indicator.</p>&#13;
<p class="bull">• Also, there are cases in which returning error codes is not possible, such as in constructors and overloaded operators.</p>&#13;
<p>Exception handling eliminates these problems.</p>&#13;
<h3 class="h3" id="sec12_2"><span class="violet">12.2</span> Exception-Handling Flow of Control; Defining an Exception Class</h3>&#13;
<p>Let’s demonstrate the flow of control:</p>&#13;
<p class="bull">• when a program executes successfully and</p>&#13;
<p class="bull">• when an exception occurs.</p>&#13;
<p>For demo purposes, Figs. 12.1–12.3 show how to deal with a common arithmetic problem—division-by-zero. In C++, division-by-zero in both integer and floating-point arithmetic is undefined behavior. Each of our preferred compilers issues warnings or errors if they detect integer division-by-zero at compile time. Visual C++ also issues an error if it detects floating-point division-by-zero. At runtime, integer division-by-zero usually causes a program to crash. Some C++ implementations allow floating-point division-by-zero and produce positive or negative infinity—displayed as <code>inf</code> or <code>-inf</code>, respectively. This is true for each of our preferred compilers.</p>&#13;
<p>The example consists of two files:</p>&#13;
<p class="bull">• <code>DivideByZeroException.h</code> (<a href="ch12.xhtml#fig12_1">Fig. 12.1</a>) defines a <strong>custom exception class</strong> (also called a user-defined exception type) representing the type of the problem that might occur in the example, and</p>&#13;
<p class="bull">• <code>fig12_02.cpp</code> (<a href="ch12.xhtml#fig12_3">Fig. 12.3</a>) defines the <code>quotient</code> function and the <code>main</code> function that calls it—we’ll use these to explain the exception-handling flow of control.</p>&#13;
<h4 class="h4" id="sec12_2_1">12.2.1 Defining an Exception Class to Represent the Type of Problem That Might Occur</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <a href="ch12.xhtml#fig12_1">Figure 12.1</a> defines a custom exception class <code>DivideByZeroException</code> that our program will throw when it detects attempts to divide by zero. We defined this as a derived class of standard library class <span class="violet"><strong><code>runtime_error</code></strong></span> (from header <span class="violet"><strong><code>&lt;stdexcept&gt;</code></strong></span>). Generally, you should derive your custom exception classes from those in the C++ standard library and name your class so it’s clear what problem occurred. The C++ Core Guidelines indicate that such exception classes are less likely to be confused with exceptions thrown by other libraries, like the C++ standard library.<sup><a id="ch12fn14a" href="ch12.xhtml#ch12fn14">14</a></sup> We’ll say more about the standard exception classes in <a href="ch12.xhtml#sec12_9">Section 12.9</a>.</p>&#13;
<p class="footnote"><a id="ch12fn14" href="ch12.xhtml#ch12fn14a">14</a>. “<strong>E.14: Use purpose-designed user-defined types as exceptions (not built-in types).</strong>” Accessed March 13, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-exception-types">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-exception-types</a></code>.</p>&#13;
<div class="group" id="fig12_1">&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p12pro01" id="p12pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 12.1: DivideByZeroException.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Class DivideByZeroException definition.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt; <span class="lgreen">// stdexcept header contains runtime_error</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="lgreen">// DivideByZeroException objects should be thrown</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="lgreen">// by functions upon detecting division-by-zero</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">class</span> DivideByZeroException : <span class="blue">public</span> std::runtime_error {&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// constructor specifies default error message</span>&#13;
<span class="cviolet"><strong>10</strong></span>      <code>DivideByZeroException()</code>&#13;
<span class="cviolet"><strong>11</strong></span>         : std::runtime_error{<span class="green">"attempted to divide by zero"</span>} {}&#13;
<span class="cviolet"><strong>12</strong></span>   };</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 12.1</strong></span> | Class <code>DivideByZeroException</code> definition.</p>&#13;
</div>&#13;
<p>A typical derived class of <code>runtime_error</code> defines only a constructor (e.g., lines 10–11) that passes an error-message string to the base-class constructor. You’ll soon see that you can process exceptions polymorphically by catching base-class references.</p>&#13;
<h4 class="h4" id="sec12_2_2">12.2.2 Demonstrating Exception Handling</h4>&#13;
<p><a href="ch12.xhtml#fig12_3">Figure 12.3</a> uses exception handling to wrap code that might throw a <code>DivideByZeroException</code> and to handle that exception, should one occur. Our <code>quotient</code> function receives two <code>double</code>s, divides the first by the second and returns the <code>double</code> result. Function <code>quotient</code> treats all attempts to divide by zero as errors. If it determines the second argument is zero, it <strong>throws a <code>DivideByZeroException</code></strong> (line 13) to indicate this problem to the caller. <strong>The operand of a <code>throw</code> can be of <em>any</em> copy-constructible type</strong> (not just derived classes of <code>exception</code>). Copy-constructible types are required because the exception mechanism copies the exception into a temporary exception object.<sup><a id="ch12fn15a" href="ch12.xhtml#ch12fn15">15</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn15" href="ch12.xhtml#ch12fn15a">15</a>. “<code>throw</code> expression.” Accessed March 13, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/throw">https://en.cppreference.com/w/cpp/language/throw</a></code>.</p>&#13;
<div class="group" id="fig12_2">&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p12pro02" id="p12pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig12_02.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Example that throws an exception on</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// an attempt to divide by zero.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"DivideByZeroException.h"</span> <span class="lgreen">// DivideByZeroException class</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// perform division and throw DivideByZeroException object if</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="lgreen">// divide-by-zero exception occurs</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">double</span> quotient(<span class="blue">double</span> numerator, <span class="blue">double</span> denominator) {&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="lgreen">// throw DivideByZeroException if trying to divide by zero</span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">if</span> (denominator == <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>13</strong></span>         <span class="blue">throw</span> DivideByZeroException{}; <span class="lgreen">// terminate function</span>&#13;
<span class="cviolet"><strong>14</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="lgreen">// return division result</span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">return</span> numerator / denominator;&#13;
<span class="cviolet"><strong>18</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">int</span> number1{<span class="green">0</span>}; <span class="lgreen">// user-specified numerator</span>&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">int</span> number2{<span class="green">0</span>}; <span class="lgreen">// user-specified denominator</span>&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>      cout &lt;&lt; <span class="green">"Enter two integers (end-of-file to end): "</span>;&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>      <span class="lgreen">// enable user to enter two integers to divide</span>&#13;
<span class="cviolet"><strong>27</strong></span>      <span class="blue">while</span> (cin &gt;&gt; number1 &gt;&gt; number2) {&#13;
<span class="cviolet"><strong>28</strong></span>         <span class="lgreen">// try block contains code that might throw exception</span>&#13;
<span class="cviolet"><strong>29</strong></span>         <span class="lgreen">// and code that will not execute if an exception occurs</span>&#13;
<span class="cviolet"><strong>30</strong></span>         <span class="blue">try</span> {&#13;
<span class="cviolet"><strong>31</strong></span>            <span class="blue">double</span> result{quotient(number1, number2)};&#13;
<span class="cviolet"><strong>32</strong></span>            cout &lt;&lt; <span class="green">"The quotient is: "</span> &lt;&lt; result &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>33</strong></span>         <code>}</code>&#13;
<span class="cviolet"><strong>34</strong></span>         <span class="blue">catch</span> (<span class="blue">const</span> DivideByZeroException&amp; divideByZeroException) {&#13;
<span class="cviolet"><strong>35</strong></span>            cout &lt;&lt; <span class="green">"Exception occurred: "</span>&#13;
<span class="cviolet"><strong>36</strong></span>               &lt;&lt; divideByZeroException.what() &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>37</strong></span>         <code>}</code>&#13;
<span class="cviolet"><strong>38</strong></span>&#13;
<span class="cviolet"><strong>39</strong></span>            cout &lt;&lt; <span class="green">"\nEnter two integers (end-of-file to end): "</span>;&#13;
<span class="cviolet"><strong>40</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>41</strong></span>&#13;
<span class="cviolet"><strong>42</strong></span>      cout &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>43</strong></span>   }</pre>&#13;
<pre class="pre1">Enter two integers (end-of-file to end): <strong>100 7</strong>&#13;
The quotient is: 14.2857&#13;
&#13;
Enter two integers (end-of-file to end): <strong>100 0</strong>&#13;
Exception occurred: attempted to divide by zero&#13;
&#13;
Enter two integers (end-of-file to end): <strong>^Z</strong></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 12.2</strong></span> | Example that throws an exception on an attempt to divide by zero. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>Assuming that the user does not specify <code>0</code> as the denominator for the division, function <code>quotient</code> returns the division result. If the user inputs <code>0</code> for the denominator, <code>quotient</code> throws an exception. In this case, <code>main</code> handles the exception, then asks the user to enter two new values before calling <code>quotient</code> again. In this way, the program can continue executing even after an improper value is entered, <strong>making the program more robust</strong>. In the sample output, the first two lines show a successful calculation, and the next two show a failure due to an attempt to divide by zero. After we discuss the code, we’ll consider the user inputs and flows of control that yield the outputs shown in <a href="ch12.xhtml#fig12_3">Fig. 12.3</a>.</p>&#13;
<h4 class="h4" id="sec12_2_3">12.2.3 Enclosing Code in a <code>try</code> Block</h4>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The program prompts the user to enter two integers, then inputs them in the <code>while</code> loop’s condition (line 27). Line 31 passes the values to <code>quotient</code> (lines 10–18), which either divides the integers and returns a result or <strong>throws an exception</strong> if the user attempts to divide by zero. Line 13 in <code>quotient</code> is known as the <strong><span class="violet">throw point</span></strong>. Exception handling is geared to situations where the function that detects an error cannot perform its task.<sup><a id="ch12fn16a" href="ch12.xhtml#ch12fn16">16</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn16" href="ch12.xhtml#ch12fn16a">16</a>. “<strong>E.2: Throw an exception to signal that a function can’t perform its assigned task.</strong>” Accessed March 13, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-throw">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-throw</a></code>.</p>&#13;
<p>The <code>try</code> block in lines 30–33 encloses two statements:</p>&#13;
<p class="bull">• the <code>quotient</code> function call (line 31), which can throw an exception, and</p>&#13;
<p class="bull">• the statement that displays the division result (line 32).</p>&#13;
<p>Line 32 executes <em>only</em> if <code>quotient</code> successfully returns a result.</p>&#13;
<h4 class="h4" id="sec12_2_4">12.2.4 Defining a <code>catch</code> Handler for <code>DivideByZeroException</code>s</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> At least one <code>catch</code> handler (lines 34–37) <em>must</em> immediately follow each <code>try</code> block. <strong>An exception parameter should be declared as a <code>const</code> <em>reference</em></strong><sup><a id="ch12fn17a" href="ch12.xhtml#ch12fn17">17</a></sup> <strong>to the type the <code>catch</code> handler processes</strong>—in this case, a <code>DivideByZeroException</code>). <strong>This has two key benefits:</strong></p>&#13;
<p class="footnote"><a id="ch12fn17" href="ch12.xhtml#ch12fn17a">17</a>. You could use a non-<code>const</code> reference if you need to modify the caught exception object. Typically, you’d do this only with custom exception classes—the standard ones do not provide any member functions that enable you to modify exception objects.</p>&#13;
<p class="bull">• <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <strong>It prevents copying the exception as part of the <code>catch</code> operation, which increases performance.</strong></p>&#13;
<p class="bull">• <strong>It enables catching derived-class exceptions</strong>.</p>&#13;
<h5 class="h5" id="ch12lev3sec11"><code>catch</code>ing By Reference Avoids Slicing</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> When an exception occurs in a <code>try</code> block, <strong>the <code>catch</code> handler that executes is the first one in which the <code>catch</code>’s parameter type is either the same as, or a base-class of, the thrown exception’s type</strong>. <strong>Always catch exceptions by reference</strong>. If a base-class <code>catch</code> handler catches a derived-class exception object <em>by value</em>, only the base-class portion of the derived-class exception object will be copied into the exception parameter. This is a logic error known as <strong><span class="violet">slicing</span></strong>, which occurs when you copy or assign a derived-class object into a base-class object.</p>&#13;
<h5 class="h5" id="ch12lev3sec12"><code>catch</code> Parameter Name</h5>&#13;
<p>An exception parameter that includes the <em>optional</em> parameter name (as in line 34) enables the <code>catch</code> handler to interact with the caught exception—e.g., calling its <span class="violet"><strong><code>what</code></strong></span> member function (as in line 36) to get the exception’s error message.</p>&#13;
<h5 class="h5" id="ch12lev3sec13">Tasks Performed in <code>catch</code> Handlers</h5>&#13;
<p>Typical tasks performed by <code>catch</code> handlers include:</p>&#13;
<p class="bull">• reporting the error to the user,</p>&#13;
<p class="bull">• logging errors to a file that developers can study for debugging purposes,</p>&#13;
<p class="bull">• terminating the program gracefully,</p>&#13;
<p class="bull">• trying an alternate strategy to accomplish the failed task,</p>&#13;
<p class="bull">• rethrowing the exception to the current function’s caller, or</p>&#13;
<p class="bull">• throwing a different exception type.</p>&#13;
<p>In this example, the <code>catch</code> handler simply reports that the user attempted to divide by zero. Then the program prompts the user to enter two new integer values.</p>&#13;
<h5 class="h5" id="ch12lev3sec14">Common Errors When Defining <code>catch</code> Handlers</h5>&#13;
<p>Programmers new to exception handling should be aware of several common coding errors:</p>&#13;
<p class="bull">• <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/>  It’s a syntax error to place code between a <code>try</code> block and its corresponding <code>catch</code> handlers or between its <code>catch</code> handlers.</p>&#13;
<p class="bull">• <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/>  Each <code>catch</code> handler can have only one parameter—specifying a comma-separated list of exception parameters is a syntax error.</p>&#13;
<p class="bull">• <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/>  It’s a compilation error to catch the same type in multiple <code>catch</code> handlers following a single <code>try</code> block.</p>&#13;
<p class="bull">• <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/>  It’s a logic error to catch a base-class exception before a derived-class exception— compilers typically warn you when this occurs.</p>&#13;
<h4 class="h4" id="sec12_2_5">12.2.5 Termination Model of Exception Handling</h4>&#13;
<p>If no exceptions occur in a <code>try</code> block, program control continues with the first statement after the last <code>catch</code> following that <code>try</code> block. If an exception does occur, the <code>try</code> block terminates immediately—any local variables defined in that block go out of scope. <strong>This is a strength of exception handling—destructors for the <code>try</code> block’s local variables are guaranteed to run, minimizing resource leaks.</strong><sup><a id="ch12fn18a" href="ch12.xhtml#ch12fn18">18</a></sup> Next, the program searches for and executes the first matching <code>catch</code> handler. If execution reaches that <code>catch</code> handler’s closing right brace (<code>}</code>), the exception is considered handled. Any local variables in the <code>catch</code> handler, including the <code>catch</code> parameter, go out of scope.</p>&#13;
<p class="footnote"><a id="ch12fn18" href="ch12.xhtml#ch12fn18a">18</a>. “Technical Report on C++ Performance,” February 15, 2006. Accessed March 26, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf</a></code> (page 34).</p>&#13;
<p>C++ uses the <strong><span class="violet">termination model of exception handling</span></strong> in which <strong>program control cannot return to the throw point</strong>. Instead, control resumes with the first statement (line 39) after the <code>try</code> block’s last <code>catch</code> handler.</p>&#13;
<p>If an exception occurs in a function and is not caught there, the function terminates immediately. The program attempts to locate an enclosing <code>try</code> block in the calling function. This process, called <strong><span class="violet">stack unwinding</span></strong>, is discussed in <a href="ch12.xhtml#sec12_5">Section 12.5</a>.</p>&#13;
<h4 class="h4" id="sec12_2_6">12.2.6 Flow of Control When the User Enters a Nonzero Denominator</h4>&#13;
<p>Consider the flow of control in <a href="ch12.xhtml#fig12_3">Fig. 12.3</a> when the user inputs the numerator <code>100</code> and the denominator <code>7</code>. In line 12, <code>quotient</code> determines that the <code>denominator</code> is not <code>0</code>, so line 17 performs the division and returns the result (<code>14.2857</code>) to line 31. Program control continues sequentially from line 31, so line 32 displays the division result, and control reaches the <code>try</code> block’s ending brace. In this case, the <code>try</code> block completed successfully, so program control skips the <code>catch</code> handler (lines 34–37) and continues with line 39.</p>&#13;
<h4 class="h4" id="sec12_2_7">12.2.7 Flow of Control When the User Enters a Zero Denominator</h4>&#13;
<p>Now consider the flow of control in which the user inputs the numerator <code>100</code> and the denominator <code>0</code>. In line 12, <code>quotient</code> determines that the <code>denominator</code> is <code>0</code>, so line 13 uses keyword <code>throw</code> to create and throw a <code>DivideByZeroException</code> object. This calls the <code>DivideByZeroException</code> constructor to initialize the exception object. Our exception class’s constructor does not have parameters. For exception constructors that do, you’d pass the argument(s) in the <code>throw</code> statement as you create the object, as in:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p654pro01" id="p654pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">throw</span> out_of_range{<span class="green">"Index out of range"</span>};</pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> When the exception is thrown, <code>quotient</code> exits immediately—<em>before</em> it can perform the division. If you explicitly throw an exception from your own code, you generally do so <em>before</em> the error has an opportunity to occur. That’s not always possible. For example, your function might call another function, which encounters an error and throws an exception.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Because we enclosed the <code>quotient</code> call (line 31) in a <code>try</code> block, program control enters the first matching <code>catch</code> handler (lines 34–37) that immediately follows the <code>try</code> block. In this program, that handler catches <code>DivideByZeroException</code>s—the type thrown by <code>quotient</code>—then prints the error message returned by function <code>what</code>. Associating each type of runtime error with an appropriately named exception type improves program clarity.</p>&#13;
<h3 class="h3" id="sec12_3"><span class="violet">12.3</span> Exception Safety Guarantees and <code>noexcept</code></h3>&#13;
<p>Client-code programmers need to know what to expect when using your code. Is there a potential for exceptions? If so, what will the program’s state be if an exception occurs? When you design your code, consider what <strong><span class="violet">exception safety guarantees</span></strong><sup><a id="ch12fn19a" href="ch12.xhtml#ch12fn19">19</a>,<a id="ch12fn20a" href="ch12.xhtml#ch12fn20">20</a></sup> you’ll make:</p>&#13;
<p class="footnote"><a id="ch12fn19" href="ch12.xhtml#ch12fn19a">19</a>. Klaus Iglberger, “Back to Basics: Exceptions,” CPPCON, October 5, 2020, <code><a href="https://www.youtube.com/watch?v=0ojB8c0xUd8">https://www.youtube.com/watch?v=0ojB8c0xUd8</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn20" href="ch12.xhtml#ch12fn20a">20</a>. “Exceptions.” Accessed March 20, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></code>.</p>&#13;
<p class="bull">• <strong><span class="violet"> No guarantee</span></strong>—If an exception occurs, the program may be in an invalid state and resources, like dynamically allocated memory, could be leaked.</p>&#13;
<p class="bull">• <strong><span class="violet"> Basic exception guarantee</span></strong>—<strong>If an exception occurs, objects’ states remain valid but possibly modified, and no resources are leaked.</strong> Generally, code that can cause exceptions should provide at least a basic exception guarantee.</p>&#13;
<p class="bull">• <strong><span class="violet"> Strong exception guarantee</span></strong>—<strong>If an exception occurs, objects’ states remain unmodified or, if objects were modified, they’re returned to their original states prior to the operation that caused the exception.</strong> We implemented the copy assignment operator in <a href="ch11.xhtml#ch11">Chapter 11</a>’s <code>MyArray</code> class with a strong exception guarantee via the copy-and-swap idiom. The operator first copies its argument, which could fail to allocate resources. In that case, the assignment fails without modifying the original object; otherwise, the assignment completes successfully.</p>&#13;
<p class="bull">• <strong><span class="violet"> No throw exception guarantee</span></strong>—<strong>The operation does not throw exceptions.</strong> For example, in <a href="ch11.xhtml#ch11">Chapter 11</a>, the <code>MyArray</code> class’s move constructor, copy constructor and <code>swap</code> functions were declared <code>noexcept</code>. They work with existing resources, rather than allocating new ones, so they cannot fail. Only functions that truly cannot fail should be declared <code>noexcept</code>. If an exception occurs in such a function, the program terminates immediately.</p>&#13;
<h3 class="h3" id="sec12_4"><span class="violet">12.4</span> Rethrowing an Exception</h3>&#13;
<p>A function might use a <strong>resource</strong>, like a file, and might want to <strong>release the resource</strong> (i.e., close the file) <strong>if an exception occurs</strong>. Upon receiving an exception, an exception handler can release the resource then notify its caller that an exception occurred by <strong><span class="violet">rethrowing</span> <span class="violet">the exception</span></strong> with the following statement in a <code>catch</code> handler:</p>&#13;
<pre class="pre"><span class="blue">throw</span>;</pre>&#13;
<p>The next enclosing <code>try</code> block detects the rethrown exception, so a <code>catch</code> handler listed after that <code>try</code> block attempts to handle the exception.</p>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Executing the preceding statement outside a <code>catch</code> handler terminates the program immediately. If the <code>catch</code> handler has a parameter name for the exception it catches, such as <code>ex</code>, you can rethrow the exception with</p>&#13;
<pre class="pre"><span class="blue">throw</span> ex;</pre>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> However, this unnecessarily copies the original exception object. This also can be a logic error—if the exception handler’s type is a base class of the rethrown exception, <strong>slicing</strong> occurs. For this reason, <code>throw;</code> is preferred.</p>&#13;
<h5 class="h5" id="ch12lev3sec15">Use Cases for Rethrowing an Exception</h5>&#13;
<p>There are various use-cases for rethrowing exceptions:</p>&#13;
<p class="bull">• You might want to log to a file where each exception occurs for future debugging. In this case, you’d catch the exception, log it, then rethrow the exception for further processing in an enclosing scope. We discuss logging in <a href="ch12.xhtml#sec12_12">Section 12.12</a>.</p>&#13;
<p class="bull">• <span class="size">11</span> You might want to throw a different exception type that’s more specific to your library or application. In this scenario, you might wrap the original exception into the new exception by using the C++11 <code>nested_exception</code> class.<sup><a id="ch12fn21a" href="ch12.xhtml#ch12fn21">21</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn21" href="ch12.xhtml#ch12fn21a">21</a>. “<code>std::nested_exception</code>.” Accessed March 26, 2021. <code><a href="https://en.cppreference.com/w/cpp/error/nested_exception">https://en.cppreference.com/w/cpp/error/nested_exception</a></code>.</p>&#13;
<p class="bull">• You do partial processing of an exception, such as releasing a resource, then rethrow the exception for further processing in a <code>catch</code> of an enclosing <code>try</code> block.</p>&#13;
<p class="bull">• In some cases, exceptions are implicitly rethrown, such as in function <code>try</code> blocks for constructors and destructors, which we discuss in <a href="ch12.xhtml#sec12_7_2">Section 12.7.2</a>.</p>&#13;
<h5 class="h5" id="ch12lev3sec16">Demonstrating Rethrowing an Exception</h5>&#13;
<p><a href="ch12.xhtml#fig12_3">Figure 12.3</a> demonstrates <em>rethrowing</em> an exception. In <code>main</code>’s <code>try</code> block (lines 25–29), line 27 calls function <code>throwException</code> (lines 8–21). The <code>throwException</code> function also contains a <code>try</code> block (lines 10–13) from which the <code>throw</code> statement in line 12 throws an <code>exception</code> object. Function <code>throwException</code>’s <code>catch</code> handler (lines 14–18) catches this exception, prints an error message (lines 15–16) and rethrows the exception (line 17). This terminates the function and returns control to line 27 in the <code>try</code> block in <code>main</code>. The <code>try</code> block <em>terminates</em> (so line 28 does <em>not</em> execute), and the <code>catch</code> handler in <code>main</code> (lines 30–32) catches this exception and prints an error message (line 31). Since we do not use the exception parameters in this example’s <code>catch</code> handlers, we omit the exception parameter names and specify only the type of exception to catch (lines 14 and 30).</p>&#13;
<div class="group" id="fig12_3">&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p12pro03" id="p12pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig12_03.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Rethrowing an exception.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;exception&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="lgreen">// throw, catch and rethrow exception</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">void</span> throwException() {&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// throw exception and catch it immediately</span>&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">try</span> {&#13;
<span class="cviolet"><strong>11</strong></span>         cout &lt;&lt; <span class="green">" Function throwException throws an exception\n"</span>;&#13;
<span class="cviolet"><strong>12</strong></span>         <span class="blue">throw</span> exception{}; <span class="lgreen">// generate exception</span>&#13;
<span class="cviolet"><strong>13</strong></span>      }&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">catch</span> (<span class="blue">const</span> exception&amp;) { <span class="lgreen">// handle exception</span>&#13;
<span class="cviolet"><strong>15</strong></span>         cout &lt;&lt; <span class="green">" Exception handled in function throwException"</span>&#13;
<span class="cviolet"><strong>16</strong></span>            &lt;&lt; <span class="green">"\n Function throwException rethrows exception"</span>;&#13;
<span class="cviolet"><strong>17</strong></span>         <span class="blue">throw</span>; <span class="lgreen">// rethrow exception for further processing</span>&#13;
<span class="cviolet"><strong>18</strong></span>      }&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>      cout &lt;&lt; <span class="green">"This should not print\n"</span>;&#13;
<span class="cviolet"><strong>21</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="lgreen">// throw exception</span>&#13;
<span class="cviolet"><strong>25</strong></span>      <span class="blue">try</span> {&#13;
<span class="cviolet"><strong>26</strong></span>         cout &lt;&lt; <span class="green">"\nmain invokes function throwException\n"</span>;&#13;
<span class="cviolet"><strong>27</strong></span>         <code>throwException();</code>&#13;
<span class="cviolet"><strong>28</strong></span>         cout &lt;&lt; <span class="green">"This should not print\n"</span>;&#13;
<span class="cviolet"><strong>29</strong></span>      }&#13;
<span class="cviolet"><strong>30</strong></span>      <span class="blue">catch</span> (<span class="blue">const</span> exception&amp;) { <span class="lgreen">// handle exception</span>&#13;
<span class="cviolet"><strong>31</strong></span>         cout &lt;&lt; <span class="green">"\n\nException handled in main\n"</span>;&#13;
<span class="cviolet"><strong>32</strong></span>      }&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>      cout &lt;&lt; <span class="green">"Program control continues after catch in main\n"</span>;&#13;
<span class="cviolet"><strong>35</strong></span>   }</pre>&#13;
<pre class="pre1">main invokes function throwException&#13;
  Function throwException throws an exception&#13;
  Exception handled in function throwException&#13;
  Function throwException rethrows exception&#13;
&#13;
Exception handled in main&#13;
Program control continues after catch in main</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 12.3</strong></span> | Rethrowing an exception. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h3 class="h3" id="sec12_5"><span class="violet">12.5</span> Stack Unwinding and Uncaught Exceptions</h3>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> When you do not catch an exception in a particular scope, the function-call stack “unwinds” in an attempt to catch the exception in a <code>catch</code> block of the next outer <code>try</code> block—that is, an <strong><span class="violet">enclosing scope</span></strong>. You can nest <code>try</code> blocks, in which case, the next outer <code>try</code> block could be in the same function. When <code>try</code> blocks are not nested stack unwinding occurs. The function in which the exception was not caught terminates, and its existing local variables go out of scope. During stack unwinding, control returns to the statement that invoked the function. If that statement is in a <code>try</code> block, that block terminates, and an attempt is made to <code>catch</code> the exception. If the statement is not in a <code>try</code> block or the exception is not caught, stack unwinding continues. <strong>In fact, this mechanism is one reason that you should not wrap a <code>try</code>…<code>catch</code> around every function call that might throw an exception</strong><sup><a id="ch12fn22a" href="ch12.xhtml#ch12fn22">22</a></sup><strong>—sometimes it’s more appropriate to let an earlier function in the call chain deal with the problem.</strong> The program of <a href="ch12.xhtml#fig12_4">Fig. 12.4</a> demonstrates stack unwinding.</p>&#13;
<p class="footnote"><a id="ch12fn22" href="ch12.xhtml#ch12fn22a">22</a>. “<strong>E.17: Don’t try to catch every exception in every function.</strong>” Accessed March 13, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-not-always">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-not-always</a></code>.</p>&#13;
<div class="group" id="fig12_4">&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p12pro04" id="p12pro04a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig12_04.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating stack unwinding.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="lgreen">// function3 throws runtime error</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">void</span> function3() {&#13;
<span class="cviolet"> <strong>9</strong></span>      cout &lt;&lt; <span class="green">"In function 3\n"</span>;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="lgreen">// no try block, stack unwinding occurs, return control to function2</span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">throw</span> runtime_error{<span class="green">"runtime_error in function3"</span>}; <span class="lgreen">// no print</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// function2 invokes function3</span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">void</span> function2() {&#13;
<span class="cviolet"><strong>17</strong></span>      cout &lt;&lt; <span class="green">"function3 is called inside function2\n"</span>;&#13;
<span class="cviolet"><strong>18</strong></span>      function3(); <span class="lgreen">// stack unwinding occurs, return control to function1</span>&#13;
<span class="cviolet"><strong>19</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="lgreen">// function1 invokes function2</span>&#13;
<span class="cviolet"><strong>22</strong></span>   <span class="blue">void</span> function1() {&#13;
<span class="cviolet"><strong>23</strong></span>      cout &lt;&lt; <span class="green">"function2 is called inside function1\n"</span>;&#13;
<span class="cviolet"><strong>24</strong></span>      function2(); <span class="lgreen">// stack unwinding occurs, return control to main</span>&#13;
<span class="cviolet"><strong>25</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// demonstrate stack unwinding</span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="lgreen">// invoke function1</span>&#13;
<span class="cviolet"><strong>30</strong></span>      <span class="blue">try</span> {&#13;
<span class="cviolet"><strong>31</strong></span>         cout &lt;&lt; <span class="green">"function1 is called inside main\n"</span>;&#13;
<span class="cviolet"><strong>32</strong></span>         function1(); <span class="lgreen">// call function1 which throws runtime_error</span>&#13;
<span class="cviolet"><strong>33</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>34</strong></span>      <span class="blue">catch</span> (<span class="blue">const</span> runtime_error&amp; error) { <span class="lgreen">// handle runtime error</span>&#13;
<span class="cviolet"><strong>35</strong></span>         cout &lt;&lt; <span class="green">"Exception occurred: "</span> &lt;&lt; error.what()&#13;
<span class="cviolet"><strong>36</strong></span>            &lt;&lt; <span class="green">"\nException handled in main\n"</span>;&#13;
<span class="cviolet"><strong>37</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>38</strong></span>   }</pre>&#13;
<pre class="pre1">function1 is called inside main&#13;
function2 is called inside function1&#13;
function3 is called inside function2&#13;
In function 3&#13;
Exception occurred: runtime_error in function3&#13;
Exception handled in main</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 12.4</strong></span> | Demonstrating stack unwinding. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>In <code>main</code>, line 32 in the <code>try</code> block calls <code>function1</code> (lines 22–25), then <code>function1</code> calls <code>function2</code> (lines 16–19), which in turn calls <code>function3</code> (lines 8–13). Line 12 of <code>function3</code> throws a <code>runtime_error</code> object—this is the throw point. At this point, control proceeds as follows:</p>&#13;
<p class="bull">• No <code>try</code> block encloses line 12, so stack unwinding begins. <code>function3</code> terminates at line 12, returning control to the <code>function2</code> statement that called <code>function3</code> (i.e., line 18).</p>&#13;
<p class="bull">• No <code>try</code> block encloses line 18, so stack unwinding continues. <code>function2</code> terminates at line 18, returning control to the statement in <code>function1</code> that invoked <code>function2</code> (i.e., line 24).</p>&#13;
<p class="bull">• Again, no <code>try</code> block encloses line 24, so stack unwinding occurs one more time. <code>function1</code> terminates at line 24 and returns control to the statement in <code>main</code> that invoked <code>function1</code> (i.e., line 32).</p>&#13;
<p class="bull">• The <code>try</code> block of lines 30–33 encloses this statement, so the <code>try</code> block’s first matching <code>catch</code> handler (line 34–37) catches and processes the exception by displaying the exception message.</p>&#13;
<h5 class="h5" id="ch12lev3sec17">Uncaught Exceptions</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <strong>If an exception is not caught during stack unwinding, C++ calls the standard library function</strong> <span class="violet"><strong><code>terminate</code></strong></span><strong>, which calls <code>abort</code> to terminate the program.</strong> To demonstrate this, we removed <code>main</code>’s <code>try</code>…<code>catch</code> in <code>fig12_04.cpp</code>, keeping only lines 31–32 from the <code>try</code> block in <a href="ch12.xhtml#fig12_4">Fig. 12.4</a>. The modified version, <code>fig12_04modified.cpp</code>, is in the <code>fig12_04</code> example folder. When you execute this modified version of the program and the exception is not caught in <code>main</code>, the program terminates. The following shows the output when we executed the program using GNU C++—note that the output mentions <code>terminate</code> was called:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p659pro01" id="p659pro01a">Click here to view code image</a></p>&#13;
<pre class="pre1">function1 is called inside main&#13;
function2 is called inside function1&#13;
function3 is called inside function2&#13;
In function 3&#13;
terminate called after throwing an instance of 'std::runtime_error'&#13;
  what():  runtime_error in function3&#13;
Aborted (core dumped)</pre>&#13;
<h3 class="h3" id="sec12_6"><span class="violet">12.6</span> When to Use Exception Handling</h3>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Exception handling is designed to process infrequent <strong><span class="violet">synchronous errors</span></strong>, which occur when a statement executes even if your code is correct<sup><a id="ch12fn23a" href="ch12.xhtml#ch12fn23">23</a></sup>, such as</p>&#13;
<p class="footnote"><a id="ch12fn23" href="ch12.xhtml#ch12fn23a">23</a>. “Modern C++ best practices for exceptions and error handling.” Accessed March 26, 2021. <code><a href="https://docs.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp">https://docs.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp</a></code>.</p>&#13;
<p class="bull">• accessing a web service that’s temporarily unavailable,</p>&#13;
<p class="bull">• attempting to read from a file that does not exist,</p>&#13;
<p class="bull">• attempting to access a file for which you do not have appropriate permissions,</p>&#13;
<p class="bull">• dynamic memory allocation failures, and more.</p>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Exception handling is not designed to process errors associated with <strong><span class="violet">asynchronous events</span></strong>, which occur in parallel with and independent of the program’s flow of control. Examples of these include <strong>I/O completions</strong>, <strong>network message arrivals</strong>, <strong>mouse clicks</strong> and <strong>keystrokes</strong>.</p>&#13;
<p>Complex applications usually consist of <strong>predefined software components</strong> (such as standard library classes) and <strong>application-specific components</strong> that use the predefined ones. When a predefined component encounters a problem, it needs to communicate the problem to the application-specific component—<strong>the predefined component cannot know how each application will process a problem</strong><em>.</em> Sometimes, that problem must be communicated to a function several calls earlier in the function-call chain that led to the exception.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> Exception handling provides a single, uniform technique for processing problems. This helps programmers on large projects understand each other’s error-processing code. It also enables predefined software components (such as standard library classes) to communicate problems to application-specific components. You should incorporate your exception-handling strategy into your system from its inception<sup><a id="ch12fn24a" href="ch12.xhtml#ch12fn24">24</a></sup>—doing so after a system has been implemented can be difficult.</p>&#13;
<p class="footnote"><a id="ch12fn24" href="ch12.xhtml#ch12fn24a">24</a>. “<strong>E.1: Develop an error-handling strategy early in a design.</strong>” Accessed March 13, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-design">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-design</a></code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec18">When Not to Use Exception Handling</h5>&#13;
<p>The ISO C++ FAQ section on exceptions lists several scenarios in which you should <em>avoid</em> using exceptions.<sup><a id="ch12fn25a" href="ch12.xhtml#ch12fn25">25</a></sup> These include:</p>&#13;
<p class="footnote"><a id="ch12fn25" href="ch12.xhtml#ch12fn25a">25</a>. “What shouldn’t I use exceptions for?” Accessed March 22, 2021. <code><a href="https://isocpp.org/wiki/faq/exceptions#why-not-exceptions">https://isocpp.org/wiki/faq/exceptions#why-not-exceptions</a></code>.</p>&#13;
<p class="bull">• <strong>cases in which failures are expected</strong>, such as converting incorrectly formatted strings to numeric values where the strings might not have the correct format, out-of-range array indexes and division-by-zero;</p>&#13;
<p class="bull">• <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <strong>applications that have strict performance requirements where the overhead of throwing exceptions and stack unwinding is unacceptable</strong>, such as the real-time systems used in the United States Joint Strike Fighter plane—for which there is a C++ coding standard;<sup><a id="ch12fn26a" href="ch12.xhtml#ch12fn26">26</a></sup> and</p>&#13;
<p class="footnote"><a id="ch12fn26" href="ch12.xhtml#ch12fn26a">26</a>. “Joint Strike Fighter Air Vehicle C++ Coding Standards.” December 2005. Accessed March 22, 2021. <code><a href="https://www.stroustrup.com/JSF-AV-rules.pdf">https://www.stroustrup.com/JSF-AV-rules.pdf</a></code>.</p>&#13;
<p class="bull">• <strong>frequent errors that should not happen in code</strong>, such as <strong>accessing out-of-range array elements</strong>, <strong>dereferencing a null pointer</strong> and <strong>division by zero</strong>. Its interesting that the C++ standard includes the <code>out_of_range</code> exception class, and various C++ standard library classes, such as <code>array</code> and <code>vector</code>, have member functions that throw <code>out_of_range</code> exceptions.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <strong>Exception handling can increase the executable size of your program</strong><sup><a id="ch12fn27a" href="ch12.xhtml#ch12fn27">27</a></sup><strong>, which may be unacceptable in memory-constrained devices, such as embedded systems.</strong> According to the ISO C++ FAQ on exception handling, however, “… exception handling is extremely cheap when you don’t throw an exception. It costs nothing on some implementations. All the cost is incurred when you throw an exception: that is, normal code is faster than code using error-return codes and tests. You incur cost only when you have an error.”<sup><a id="ch12fn28a" href="ch12.xhtml#ch12fn28">28</a></sup> For a detailed discussion of exception-handling performance, see <a href="ch05.xhtml#ch05lev1sec4">Section 5.4</a> of the <strong><em>Technical Report on C++ Performance</em></strong>.<sup><a id="ch12fn29a" href="ch12.xhtml#ch12fn29">29</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn27" href="ch12.xhtml#ch12fn27a">27</a>. Vishal Chovatiya, “C++ Exception Handling Best Practices: 7 Things To Know.” <code><a href="http://www.vishalchovatiya.com/7-best-practices-for-exception-handling-in-cpp-with-example/">http://www.vishalchovatiya.com/7-best-practices-for-exception-handling-in-cpp-with-example/</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn28" href="ch12.xhtml#ch12fn28a">28</a>. “Why use exceptions?” Accessed March 26, 2021. <code><a href="https://isocpp.org/wiki/faq/exceptions#why-exceptions">https://isocpp.org/wiki/faq/exceptions#why-exceptions</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn29" href="ch12.xhtml#ch12fn29a">29</a>. “Technical Report on C++ Performance.” February 15, 2006. Accessed March 29, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf</a></code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Functions with common error conditions generally should return <code>nullptr</code>, <code>0</code> or other appropriate values, such as <code>bool</code>s, rather than throw exceptions. A program calling such a function can check the return value to determine whether the function call succeeded or failed. Herb Sutter—the ISO C++ language standards committee (WG21) Convener and a Software Architect at Microsoft—indicates, “Programs bugs are not recoverable runtime errors and so should not be reported as exceptions or error codes.” He goes on to say that the process is already underway to migrate the C++ standard libraries away from throwing exceptions for such errors.<sup><a id="ch12fn30a" href="ch12.xhtml#ch12fn30">30</a></sup> In <a href="ch12.xhtml#sec12_13">Section 12.13</a>, Looking Ahead to Contracts, we’ll see that the new contracts capabilities, originally scheduled to be included in C++20 and now deferred until at least C++23, can help reduce the need for exceptions in the standard library.</p>&#13;
<p class="footnote"><a id="ch12fn30" href="ch12.xhtml#ch12fn30a">30</a>. Herb Sutter, “Zero-overhead deterministic exceptions: Throwing values,” August 4, 2019. Accessed March 26, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf</a></code>.</p>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The C++ Core Guidelines indicate that using lots of <code>try</code>…<code>catch</code> statements in your code can be a sign that you’re doing too much low-level resource management.<sup><a id="ch12fn31a" href="ch12.xhtml#ch12fn31">31</a></sup> In this case, they recommend designing your classes to use <strong>RAII (Resource Acquisition Is Initialization)</strong>, which we introduced in <a href="ch11.xhtml#ch11">Chapter 11</a>.</p>&#13;
<p class="footnote"><a id="ch12fn31" href="ch12.xhtml#ch12fn31a">31</a>. “<strong>E.18: Minimize the use of explicit <code>try</code>/<code>catch</code>.</strong>” Accessed March 13, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch</a></code>.</p>&#13;
<h4 class="h4" id="sec12_6_1">12.6.1 <code>assert</code> Macro</h4>&#13;
<p>When implementing and debugging programs, it’s sometimes useful to state conditions that should be true at a particular point in a function. These conditions, called <strong><span class="violet">assertions</span></strong>, help ensure a program’s validity by catching potential bugs and identifying possible logic errors during development. An assertion is a runtime check for a condition that should always be true if your code is correct. If the condition is false, the program terminates immediately, displaying an error message that includes the filename and line number where the problem occurred and the condition that failed. You implement an assertion using the <span class="violet"><strong><code>assert</code></strong></span><strong><span class="violet"> macro</span></strong><sup><a id="ch12fn32a" href="ch12.xhtml#ch12fn32">32</a></sup> from the <span class="violet"><strong><code>&lt;cassert&gt;</code></strong></span> <strong><span class="violet">header</span></strong>, as in:</p>&#13;
<p class="footnote"><a id="ch12fn32" href="ch12.xhtml#ch12fn32a">32</a>. “<code>assert</code>.” Accessed March 27, 2021. <code><a href="https://en.cppreference.com/w/cpp/error/assert">https://en.cppreference.com/w/cpp/error/assert</a></code>.</p>&#13;
<p class="pren"><code>assert(</code><em>condition</em><code>);</code></p>&#13;
<p>Assertions are primarily a development-time aid<sup><a id="ch12fn33a" href="ch12.xhtml#ch12fn33">33</a></sup> that is meant to deal with coding errors that need to be fixed, not something that can be corrected at runtime. For example, you might use an assertion in a function that processes arrays to ensure that the array indexes are greater than 0 and less than the array’s length. Once you’re done debugging, you can disable assertions by adding the following preprocessor directive before the <code>#include</code> for the <code>&lt;cassert&gt;</code> header</p>&#13;
<p class="footnote"><a id="ch12fn33" href="ch12.xhtml#ch12fn33a">33</a>. “Modern C++ best practices for exceptions and error handling.” August 24, 2020. Accessed March 27, 2021. <code><a href="https://docs.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp">https://docs.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp</a></code>.</p>&#13;
<pre class="pre"><span class="blue">#define</span> <span class="green">NDEBUG</span></pre>&#13;
<h4 class="h4" id="sec12_6_2">12.6.2 Failing Fast</h4>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The C++ Core Guidelines suggest that “If you can’t throw exceptions, consider failing fast.”<sup><a id="ch12fn34a" href="ch12.xhtml#ch12fn34">34</a></sup> <strong><span class="violet">Fail-fast</span></strong><sup><a id="ch12fn35a" href="ch12.xhtml#ch12fn35">35</a></sup> is a development style in which, rather than catching an exception, processing it and leaving your program in a state where it might fail later, the program terminates immediately. This seems counterintuitive. The idea is that failing fast actually helps you build more robust software, because you might be able to find and fix errors sooner during development. Fewer errors are likely to make their way into the final product.<sup><a id="ch12fn36a" href="ch12.xhtml#ch12fn36">36</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn34" href="ch12.xhtml#ch12fn34a">34</a>. “E.26: If you can’t throw exceptions, consider failing fast.” Accessed March 27, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-no-throw-crash">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-no-throw-crash</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn35" href="ch12.xhtml#ch12fn35a">35</a>. “Fail-fast.” Accessed March 27, 2021. <code><a href="https://en.wikipedia.org/wiki/Fail-fast">https://en.wikipedia.org/wiki/Fail-fast</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn36" href="ch12.xhtml#ch12fn36a">36</a>. Jim Shore, “Fail Fast [Software Debugging].” IEEE Software 21, no. 5 (September/October 2004): 21–25. Edited by Martin Fowler. <code><a href="https://martinfowler.com/ieeeSoftware/failFast.pdf">https://martinfowler.com/ieeeSoftware/failFast.pdf</a></code>.</p>&#13;
<h3 class="h3" id="sec12_7"><span class="violet">12.7</span> Constructors, Destructors and Exception Handling</h3>&#13;
<p>There are some subtle issues regarding exceptions in the context of constructors and destructors. In this section, you’ll see</p>&#13;
<p class="bull">• why constructors should throw exceptions when they encounter errors,</p>&#13;
<p class="bull">• how to catch exceptions that occur in a constructor’s member initializer, and</p>&#13;
<p class="bull">• why destructors should not throw exceptions.</p>&#13;
<h4 class="h4" id="sec12_7_1">12.7.1 Throwing Exceptions from Constructors</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> First, consider an issue we’ve mentioned but not yet resolved. What happens when an error is detected in a constructor? For example, how should an object’s constructor respond when it receives invalid data? Because <strong>the constructor cannot return a value to indicate an error</strong>, we must somehow indicate that the object has not been constructed properly. One scheme is to return the improperly constructed object and hope that anyone using it would make appropriate tests to determine that it’s in an inconsistent state. Another is to set a variable outside the constructor, such as a global error variable, but that’s considered poor software engineering. The preferred alternative is to require the constructor to <code>throw</code> an exception that contains the error information.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Do not throw exceptions from the constructor of a global object or a <code>static</code> local object. Such exceptions cannot be caught because they’re constructed <em>before</em> <code>main</code> executes.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> A constructor should throw an exception if a problem occurs while initializing an object. Before doing so, the constructor should release any dynamically allocated memory to prevent memory leaks.</p>&#13;
<h4 class="h4" id="sec12_7_2">12.7.2 Catching Exceptions in Constructors Via Function <code>try</code> Blocks</h4>&#13;
<p>Recall that base-class initializers and member initializers execute <em>before</em> the constructor’s body. So, if you want to catch exceptions thrown by those initializers, you cannot simply wrap a constructor’s body statements in a <code>try</code> block. Instead, you must use a <strong><span class="violet">function</span></strong> <span class="violet"><strong><code>try</code></strong></span> <strong><span class="violet">block</span></strong>, which we demonstrate in <a href="ch12.xhtml#fig12_5">Fig. 12.5</a>.</p>&#13;
<div class="group" id="fig12_5">&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p12pro05" id="p12pro05a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig12_05.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating a function try block.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;limits&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// class Integer purposesly throws an exception from it's constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">class</span> Integer {&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">explicit</span> Integer(<span class="blue">int</span> i) : value{i} {&#13;
<span class="cviolet"><strong>12</strong></span>         cout &lt;&lt; <span class="green">"Integer constructor: "</span> &lt;&lt; value&#13;
<span class="cviolet"><strong>13</strong></span>            &lt;&lt; <span class="green">"\nPurposely throwing exception from Integer constructor\n"</span>;&#13;
<span class="cviolet"><strong>14</strong></span>         <span class="blue">throw</span> runtime_error(<span class="green">"Integer constructor failed"</span>);&#13;
<span class="cviolet"><strong>15</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">int</span> value{};&#13;
<span class="cviolet"><strong>18</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="blue">class</span> ResourceManager {&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>22</strong></span>      ResourceManager(int i) <span class="blue">try</span> : myInteger(i) {&#13;
<span class="cviolet"><strong>23</strong></span>         cout &lt;&lt; <span class="green">"ResourceManager constructor called\n"</span>;&#13;
<span class="cviolet"><strong>24</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>25</strong></span>      <span class="blue">catch</span> (runtime_error&amp; ex) {&#13;
<span class="cviolet"><strong>26</strong></span>         cout &lt;&lt; <span class="green">"Exception while constructing ResourceManager: "</span>&#13;
<span class="cviolet"><strong>27</strong></span>            &lt;&lt; ex.what() &lt;&lt; <span class="green">"\nAutomatically rethrowing the exception\n"</span>;&#13;
<span class="cviolet"><strong>28</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>29</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>30</strong></span>      <code>Integer myInteger;</code>&#13;
<span class="cviolet"><strong>31</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>32</strong></span>&#13;
<span class="cviolet"><strong>33</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>34</strong></span>      <span class="blue">try</span> {&#13;
<span class="cviolet"><strong>35</strong></span>         <span class="blue">const</span> ResourceManager resource{<span class="green">7</span>};&#13;
<span class="cviolet"><strong>36</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>37</strong></span>      <span class="blue">catch</span> (<span class="blue">const</span> runtime_error&amp; ex) {&#13;
<span class="cviolet"><strong>38</strong></span>         cout &lt;&lt; <span class="green">"Rethrown exception caught in main: "</span> &lt;&lt; ex.what() &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>39</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>40</strong></span>   }</pre>&#13;
<pre class="pre1">Integer constructor: 7&#13;
Purposely throwing exception from Integer constructor&#13;
Exception while constructing ResourceManager: Integer constructor failed&#13;
Automatically rethrowing the exception&#13;
Rethrown exception caught in main: Integer constructor failed</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 12.5</strong></span> | Demonstrating a function <code>try</code> block.</p>&#13;
</div>&#13;
<p>Our class <code>Integer</code> (lines 9–18) will simulate failing to “acquire a resource.” This class’s constructor purposely throws an exception (line 14) to help demonstrate a function <code>try</code> block in action. Class <code>ResourceManager</code> (lines 20–31) contains an object of class <code>Integer</code> (line 30), which will be initialized in the <code>ResourceManager</code> constructor’s member-initializer list.</p>&#13;
<p>In a constructor, you define a function <code>try</code> block by placing the <code>try</code> keyword <em>after</em> the constructor’s parameter list and <em>before</em> the colon (<code>:</code>) that introduces the member initializer list (line 22). The member initializer list is followed by the constructor’s body (lines 22– 24). Any exceptions that occur in the member initializer list or in the constructor’s body can be handled by <code>catch</code> blocks that follow the constructor’s body—in this example, the <code>catch</code> block at lines 25–28. The flow of control in this example is as follows:</p>&#13;
<p class="bull">• Line 35 in <code>main</code> creates an object of our <code>ResourceManager</code> class, which calls the class’s constructor.</p>&#13;
<p class="bull">• Line 22 in the constructor calls class <code>Integer</code>’s constructor (lines 11–15) to initialize the <code>myInteger</code> object, producing the first two lines of output. Line 14 purposely throws an exception so we can demonstrate the <code>ResourceManager</code> constructor’s function <code>try</code> block. This terminates class <code>Integer</code>’s constructor and throws the exception back to the base-class initializer in line 22, which is in the <code>ResourceManager</code> constructor’s function <code>try</code> block.</p>&#13;
<p class="bull">• The function <code>try</code> block, which also includes the constructor’s body, terminates.</p>&#13;
<p class="bull">• The <code>ResourceManager</code> constructor’s <code>catch</code> handler at lines 25–28 catches the exception and displays the next two lines of output.</p>&#13;
<p class="bull">• <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The primary purpose of a constructor’s function <code>try</code> block is to enable you to do initial exception processing, such as logging the exception or throwing a different exception that’s more appropriate for your code. <strong>Your object cannot be fully constructed, so each <code>catch</code> handler that follows a function <code>try</code> block is required to either throw a new exception, or rethrow the existing one—explicitly or implicitly</strong>.<sup><a id="ch12fn37a" href="ch12.xhtml#ch12fn37">37</a></sup> Our <code>catch</code> handler does not explicitly contain a <code>throw</code> statement, so the <code>catch</code> handler implicitly rethrows the exception. This terminates the <code>ResourceManager</code> constructor and throws the exception back to line 35 in <code>main</code>.</p>&#13;
<p class="footnote"><a id="ch12fn37" href="ch12.xhtml#ch12fn37a">37</a>. “Function-<code>try</code>-block.” Accessed March 22, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/function-try-block">https://en.cppreference.com/w/cpp/language/function-try-block</a></code>.</p>&#13;
<p class="bull">• Line 35 is in a <code>try</code> block, so that block terminates, and the <code>catch</code> handler in lines 37–39 handles the exception, displaying the last line of the output.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Function <code>try</code> blocks also may be used with other functions, as in:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p664pro01" id="p664pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">void</span> myFunction() <span class="blue">try</span> {&#13;
   <span class="lgreen">// do something</span>&#13;
}&#13;
<span class="blue">catch</span> (<span class="blue">const</span> <em>ExceptionType</em>&amp; ex) {&#13;
   <span class="lgreen">// exception processing</span>&#13;
}</pre>&#13;
<p>However, for a regular function, a function <code>try</code> block does not provide any additional benefit over simply placing the entire <code>try</code>…<code>catch</code> sequence in the function’s body, as in:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p665pro01" id="p665pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">void</span> myFunction() {&#13;
   <span class="blue">try</span> {&#13;
      <span class="lgreen">// do something</span>&#13;
   }&#13;
   <span class="blue">catch</span> (<span class="blue">const</span> <em>ExceptionType</em>&amp; ex) {&#13;
      <span class="lgreen">// exception processing</span>&#13;
   }&#13;
}</pre>&#13;
<h4 class="h4" id="sec12_7_3">12.7.3 Exceptions and Destructors; Revisiting <code>noexcept(false)</code></h4>&#13;
<p><span class="size">11</span> As of C++11, the compiler implicitly declares all destructors <code>noexcept</code>, unless</p>&#13;
<p class="bull">• you say otherwise by declaring a destructor <code>noexcept(false)</code>, or</p>&#13;
<p class="bull">• a direct or indirect base class’s destructor is declared <code>noexcept(false)</code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> If your destructor calls functions that might throw exceptions, you should catch and handle those exceptions, even if that simply means logging the exception and terminating the program in a controlled manner.<sup><a id="ch12fn38a" href="ch12.xhtml#ch12fn38">38</a></sup> During destruction of a derived class object, if it’s possible for a base-class destructor to throw an exception, you can use a function <code>try</code> block on your derived-class destructor to ensure that you have the opportunity to catch the exception.</p>&#13;
<p class="footnote"><a id="ch12fn38" href="ch12.xhtml#ch12fn38a">38</a>. “<strong>C.36: A destructor must not fail.</strong>” Accessed March 22, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-fail">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-fail</a></code>.</p>&#13;
<p>If an exception occurs during object construction, destructors may be called:</p>&#13;
<p class="bull">• If an exception is thrown before an object is fully constructed, destructors will be called for any member objects constructed so far.</p>&#13;
<p class="bull">• If an array of objects has been partially constructed when an exception occurs, only the destructors for the array’s constructed objects will be called.</p>&#13;
<p>Stack unwinding is guaranteed to have been completed at the point that a <code>catch</code> handler begins executing. <strong>If a destructor invoked as a result of stack unwinding throws an exception, the program terminates.</strong> According to the ISO C++ FAQ<sup><a id="ch12fn39a" href="ch12.xhtml#ch12fn39">39</a></sup>, the choice to terminate the program in this scenario is because C++ does not know whether to:</p>&#13;
<p class="footnote"><a id="ch12fn39" href="ch12.xhtml#ch12fn39a">39</a>. “How can I handle a destructor that fails?” Accessed March 25, 2021. <code><a href="https://isocpp.org/wiki/faq/exceptions#dtors-shouldnt-throw">https://isocpp.org/wiki/faq/exceptions#dtors-shouldnt-throw</a></code>.</p>&#13;
<p class="bull">• continue processing the exception that led to stack unwinding in the first place or</p>&#13;
<p class="bull">• process the new exception thrown from the destructor.</p>&#13;
<h3 class="h3" id="sec12_8"><span class="violet">12.8</span> Processing <code>new</code> Failures</h3>&#13;
<p><a href="ch11.xhtml#sec11_4">Section 11.4</a> demonstrated dynamically allocating memory with <code>new</code>. Then, <a href="ch11.xhtml#sec11_5">Section 11.5</a> showed modern C++ memory management using <strong>RAII (Resource Acquisition Is Initialization)</strong>, class template <code>unique_ptr</code> and function template <code>make_unique</code>, which uses operator <code>new</code> “under the hood.” If <code>new</code> fails to allocate the requested memory, it <code>throw</code>s a <span class="violet"><strong><code>bad_alloc</code></strong></span> exception (defined in header <code>&lt;new&gt;</code>).</p>&#13;
<p>In this section, Figs. 12.6–12.7 present two examples of <code>new</code> failing—each attempts to acquire large amounts of dynamically allocated memory:</p>&#13;
<p class="bull">• The first example demonstrates <code>new</code> throwing a <code>bad_alloc</code> exception.</p>&#13;
<p class="bull">• The second uses function <span class="violet"><strong><code>set_new_handler</code></strong></span> to specify a function to call when <code>new</code> fails. <strong>This technique is mainly used in legacy C++ code that was written before compilers supported throwing a <code>bad_alloc</code> exceptions.</strong></p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> When an exception is thrown from the constructor for an object that’s created in a <code>new</code> expression, the dynamically allocated memory for that object is released.</p>&#13;
<h5 class="h5" id="ch12lev3sec19">Do Not Throw Exceptions While Holding a Raw Pointer to Dynamically Allocated Memory</h5>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <a href="ch11.xhtml#sec11_5">Section 11.5</a> showed that a <code>unique_ptr</code> enables you to ensure dynamically allocated memory is properly deallocated regardless of whether the <code>unique_ptr</code> goes out of scope due to the normal flow of control or due to an exception. <strong>When managing dynamically allocated memory via old-style raw pointers (as might be the case in legacy C++ code), it’s critical that you do not allow exceptions to occur before you release the memory.</strong><sup><a id="ch12fn40a" href="ch12.xhtml#ch12fn40">40</a></sup> For example, if a function contained the following series of statements:</p>&#13;
<p class="footnote"><a id="ch12fn40" href="ch12.xhtml#ch12fn40a">40</a>. “<strong>E.13: Never throw while being the direct owner of an object.</strong>” Accessed March 13, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-throw">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-throw</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p666pro01" id="p666pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span>* ptr{<span class="blue">new</span> <span class="blue">int</span>[<span class="green">100</span>]}; <span class="lgreen">// acquire dynamically allocated memory</span>&#13;
processArray(ptr); <span class="lgreen">// assume this function might thrown an exception</span>&#13;
<span class="blue">delete</span>[] ptr; <span class="lgreen">// return the memory to the system</span>&#13;
<span class="lgreen">// ...</span></pre>&#13;
<p>a <strong>memory leak</strong> would occur if <code>processArray</code> throws an exception—the code would not reach the <code>delete[]</code> statement. To prevent this leak, you’d have to catch the exception and delete the memory before allowing the exception to propagate back to the caller. Instead, you should manage memory with <code>unique_ptr</code>, as in:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p666pro02" id="p666pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">std::unique_ptr&lt;<span class="blue">int</span>[]&gt; ptr{std::make_unique&lt;<span class="blue">int</span>&gt;(<span class="green">100</span>)};&#13;
processArray(ptr); <span class="lgreen">// possible exception here</span>&#13;
<span class="lgreen">// ...</span></pre>&#13;
<p>If <code>processArray</code> throws an exception, the <code>unique_ptr</code> will go out of scope and automatically return the memory to the system.</p>&#13;
<h4 class="h4" id="sec12_8_1">12.8.1 <code>new</code> Throwing <code>bad_alloc</code> on Failure</h4>&#13;
<p><a href="ch12.xhtml#fig12_6">Figure 12.6</a> demonstrates <code>new</code> <em>implicitly</em> throwing <code>bad_alloc</code> when <code>new</code> fails to allocate memory. The <code>for</code> statement (lines 15–18) inside the <code>try</code> block iterates through the <code>array</code> of <code>unique_ptr</code> objects named <code>items</code> and allocated to each element an array of 500,000,000 <code>double</code>s. Our test computer has 32 GB of RAM and eight TB of disk space. We had to allocate enormous numbers of elements to force dynamic memory allocation to fail. You might be able to specify fewer than 500,000,000 on your system. If <code>new</code> fails during a call to <code>make_unique</code> and throws a <code>bad_alloc</code> exception, the loop terminates. The program continues in line 20, where the <code>catch</code> handler catches and processes the exception. Lines 21–22 print <code>"Exception occurred:"</code>, followed by the message returned from the base-class-<code>exception</code> version of function <code>what</code>. Typically, this is an implementation-defined exception-specific message, such as <code>"bad allocation"</code> or <code>"std::bad_alloc"</code>. The output shows that the program performed only ten iterations of the loop before <code>new</code> failed and threw the <code>bad_alloc</code> exception. Your output might differ based on your system’s physical memory, the disk space available for virtual memory on your system and the compiler you’re using.</p>&#13;
<div class="group" id="fig12_6">&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p12pro06" id="p12pro06a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig12_06.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating standard new throwing bad_alloc when memory</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// cannot be allocated.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;memory&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;new&gt; <span class="lgreen">// bad_alloc class is defined here</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>11</strong></span>      array&lt;unique_ptr&lt;<span class="blue">double</span>[]&gt;, 1000&gt; items{};&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="lgreen">// aim each unique_ptr at a big block of memory</span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">try</span> {&#13;
<span class="cviolet"><strong>15</strong></span>         <span class="blue">for</span> (<span class="blue">int</span> i{0}; <span class="blue">auto</span>&amp; item : items) {&#13;
<span class="cviolet"><strong>16</strong></span>            item = make_unique&lt;<span class="blue">double</span>[]&gt;(<span class="green">500'000'000</span>);&#13;
<span class="cviolet"><strong>17</strong></span>            cout &lt;&lt; <span class="green">"items["</span> &lt;&lt; i++ &lt;&lt; <span class="green">"] points to 500,000,000 doubles\n"</span>;&#13;
<span class="cviolet"><strong>18</strong></span>         <code>}</code>&#13;
<span class="cviolet"><strong>19</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">catch</span> (<span class="blue">const</span> bad_alloc&amp; memoryAllocationException) {&#13;
<span class="cviolet"><strong>21</strong></span>         cerr &lt;&lt; <span class="green">"Exception occurred: "</span>&#13;
<span class="cviolet"><strong>22</strong></span>            &lt;&lt; memoryAllocationException.what() &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>23</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>24</strong></span>   }</pre>&#13;
<pre class="pre1">items[0] points to 500,000,000 doubles&#13;
items[1] points to 500,000,000 doubles&#13;
items[2] points to 500,000,000 doubles&#13;
items[3] points to 500,000,000 doubles&#13;
items[4] points to 500,000,000 doubles&#13;
items[5] points to 500,000,000 doubles&#13;
items[6] points to 500,000,000 doubles&#13;
items[7] points to 500,000,000 doubles&#13;
items[8] points to 500,000,000 doubles&#13;
items[9] points to 500,000,000 doubles&#13;
Exception occurred: bad allocation</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 12.6</strong></span> | <code>new</code> throwing <code>bad_alloc</code> on failure.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec12_8_2">12.8.2 <code>new</code> Returning <code>nullptr</code> on Failure</h4>&#13;
<p>The C++ standard specifies that programmers can use an older version of <code>new</code> that returns <code>nullptr</code> upon failure. For this purpose, header <code>&lt;new&gt;</code> defines object <span class="violet"><strong><code>nothrow</code></strong></span> (of type <span class="violet"><strong><code>nothrow_t</code></strong></span>), which is used as follows:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p667pro01" id="p667pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">unique_ptr&lt;<span class="blue">double</span>[]&gt; ptr{<span class="blue">new</span>(<span class="blue">nothrow</span>) <span class="blue">double</span>[<span class="green">500'000'000</span>]};</pre>&#13;
<p><span class="size">Sec</span><img class="inline" src="Images/sec.jpg" alt="Images" width="28" height="31"/> Unfortunately, we cannot use <code>make_unique</code> in this scenario because it uses the default version of <code>new</code>. To make programs more robust, use the version of <code>new</code> that throws <code>bad_alloc</code> exceptions on failure.</p>&#13;
<h4 class="h4" id="sec12_8_3">12.8.3 Handling <code>new</code> Failures Using Function <code>set_new_handler</code></h4>&#13;
<p>In <strong>legacy C++ code</strong>, you might encounter another feature for handling <code>new</code> failures—the <span class="violet"><strong><code>set_new_handler</code></strong></span> function (header <code>&lt;new&gt;</code>). This function takes as its argument either:</p>&#13;
<p class="bull">• a pointer to a function that takes no arguments and returns <code>void</code>, or</p>&#13;
<p class="bull">• a lambda that takes no arguments and does not return a value.</p>&#13;
<p>The function or lambda is called if <code>new</code> fails. This provides a uniform approach to handling all <code>new</code> failures, regardless of where a failure occurs in the program. <strong>Once <code>set_new_handler</code> registers a</strong> <span class="violet"><strong><code>new</code></strong></span> <span class="violet"><strong>handler</strong></span> <strong>in the program, operator <code>new</code> does <em>not</em> throw <code>bad_alloc</code> on failure. Instead, it delegates the error handling to the <code>new</code>-handler function.</strong></p>&#13;
<p>If <code>new</code> allocates memory successfully, it returns a pointer to that memory. If <code>new</code> fails to allocate memory and <code>set_new_handler</code> did not register a <code>new</code>-handler function, <code>new</code> throws a <code>bad_alloc</code> exception. If <code>new</code> fails to allocate memory and a <code>new</code>-handler function has been registered, the <code>new</code>-handler function is called.</p>&#13;
<p>The <code>new</code>-handler function should perform one of the following tasks:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> Make more memory available by deleting other dynamically allocated memory or telling the user to close other applications, then try allocating memory again.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> Throw an exception of type <code>bad_alloc</code>.</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> Call function <code>abort</code> or <code>exit</code> (both found in header <code>&lt;cstdlib&gt;</code>) to terminate the program. <strong>The <code>abort</code> function terminates a program immediately, whereas <code>exit</code> executes destructors for global objects and local <code>static</code> objects before terminating the program. Non-<code>static</code> local objects are not destructed when either of these functions is called.</strong></p>&#13;
<p><a href="ch12.xhtml#fig12_7">Figure 12.7</a> demonstrates <code>set_new_handler</code>. Function <code>customNewHandler</code> (lines 10– 13) prints an error message (line 11), then calls <code>exit</code> (line 12) to terminate the program. The constant <code>EXIT_FAILURE</code> is defined in the header <code>&lt;cstdlib&gt;</code>, which is included in many C++ standard library headers. The output shows that the loop iterated nine times before <code>new</code> failed and invoked function <code>customNewHandler</code>. Your output might differ based on your compiler, and the physical memory and disk space available for virtual memory on your system.</p>&#13;
<div class="group" id="fig12_7">&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p12pro07" id="p12pro07a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig12_07.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating set_new_handler.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;array&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;memory&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;new&gt; <span class="lgreen">// set_new_handler is defined here</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="lgreen">// handle memory allocation failure</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">void</span> customNewHandler() {&#13;
<span class="cviolet"><strong>11</strong></span>      cerr &lt;&lt; <span class="green">"customNewHandler was called\n"</span>;&#13;
<span class="cviolet"><strong>12</strong></span>      exit(<span class="green">EXIT_FAILURE</span>);&#13;
<span class="cviolet"><strong>13</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>16</strong></span>      array&lt;unique_ptr&lt;<span class="blue">double</span>[]&gt;, <span class="green">1000</span>&gt; items{};&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="lgreen">// specify that customNewHandler should be called on</span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="lgreen">// memory allocation failure</span>&#13;
<span class="cviolet"><strong>20</strong></span>      <code>set_new_handler(customNewHandler);</code>&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="lgreen">// aim each unique_ptr at a big block of memory</span>&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">0</span>}; <span class="blue">auto</span>&amp; item : items) {&#13;
<span class="cviolet"><strong>24</strong></span>         item = make_unique&lt;<span class="blue">double</span>[]&gt;(<span class="green">500'000'000</span>);&#13;
<span class="cviolet"><strong>25</strong></span>         cout &lt;&lt; <span class="green">"items["</span> &lt;&lt; i++ &lt;&lt; <span class="green">"] points to 500,000,000 doubles\n"</span>;&#13;
<span class="cviolet"><strong>26</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>27</strong></span>   }</pre>&#13;
<pre class="pre1">items[0] points to 500,000,000 doubles&#13;
items[1] points to 500,000,000 doubles&#13;
items[2] points to 500,000,000 doubles&#13;
items[3] points to 500,000,000 doubles&#13;
items[4] points to 500,000,000 doubles&#13;
items[5] points to 500,000,000 doubles&#13;
items[6] points to 500,000,000 doubles&#13;
items[7] points to 500,000,000 doubles&#13;
items[8] points to 500,000,000 doubles&#13;
customNewHandler was called</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 12.7</strong></span> | <code>set_new_handler</code> specifying the function to call when <code>new</code> fails. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h3 class="h3" id="sec12_9"><span class="violet">12.9</span> Standard Library Exception Hierarchy</h3>&#13;
<p>Exceptions fall nicely into several categories. The C++ standard library includes a hierarchy of exception classes, some of which are shown in the following diagram:</p>&#13;
<div class="image"><img src="Images/669fig01.jpg" alt="Images" width="716" height="230"/></div>&#13;
<p>For a list of the 28 exception types in the C++ standard library, see:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p669pro01" id="p669pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/error/exception</pre>&#13;
<p>You can build programs that can <code>throw</code></p>&#13;
<p class="bull">• standard exceptions,</p>&#13;
<p class="bull">• exceptions derived from the standard exceptions,</p>&#13;
<p class="bull">• your own exceptions not derived from the standard exceptions or</p>&#13;
<p class="bull">• instances of non-class types, like fundamental-type values and pointers.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The <span class="violet"><strong><code>exception</code></strong></span> class hierarchy is a good starting point for creating custom exception types. In fact, rather than throwing exceptions of the types shown in the preceding diagram, <strong>the C++ Core Guidelines recommend creating derived-class exception types that are specific to your application</strong>. Such custom types can convey more meaning than the generically named exception types, like <code>runtime_error</code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec20">Base Class <code>exception</code></h5>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The standard library exception hierarchy is headed by base-class <code>exception</code> (defined in header <span class="violet"><strong><code>&lt;exception&gt;</code></strong></span>). This class contains <code>virtual</code> function <code>what</code> that derived classes can override to issue an appropriate error message. If a <code>catch</code> handler specifies a reference to a base-class exception type, it can <code>catch</code> objects of all exception classes derived publicly from that base class.<sup><a id="ch12fn41a" href="ch12.xhtml#ch12fn41">41</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn41" href="ch12.xhtml#ch12fn41a">41</a>. “<strong>E.15: Catch exceptions from a hierarchy by reference.</strong>” Accessed March 13, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-exception-ref">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-exception-ref</a></code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec21">Derived Classes of <code>exception</code></h5>&#13;
<p>Immediate derived classes of <code>exception</code> include <code>runtime_error</code> and <span class="violet"><strong><code>logic_error</code></strong></span> (both defined in header <code>&lt;stdexcept&gt;</code>), each of which has several derived classes. Also derived from <code>exception</code> are the exceptions thrown by C++ operators:</p>&#13;
<p class="bull">• <code>bad_alloc</code> is thrown by <code>new</code> (<a href="ch12.xhtml#sec12_8">Section 12.8</a>),</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>bad_cast</code></strong></span> is thrown by <code>dynamic_cast</code> (Section 19.7) and</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>bad_typeid</code></strong></span> is thrown by <code>typeid</code> (Section 19.7).</p>&#13;
<h5 class="h5" id="ch12lev3sec22">Derived Classes of <code>runtime_error</code></h5>&#13;
<p>Class <code>runtime_error</code>, which we used briefly in <a href="ch12.xhtml#sec12_5">Section 12.5</a>, is the base class of several other standard exception classes that indicate execution-time errors:</p>&#13;
<p class="bull">• Class <span class="violet"><strong><code>overflow_error</code></strong></span> describes an <strong><span class="violet">arithmetic overflow error</span></strong> (i.e., the result is larger than the largest number that can be stored in a given numeric type).</p>&#13;
<p class="bull">• Class <span class="violet"><strong><code>underflow_error</code></strong></span> describes an <strong><span class="violet">arithmetic underflow error</span></strong> (i.e., the result is smaller than the smallest number that can be stored in a given numeric type).</p>&#13;
<h5 class="h5" id="ch12lev3sec23">Derived Classes of <code>logic_error</code></h5>&#13;
<p>Class <code>logic_error</code> is the base class of several standard exception classes that indicate errors in program logic:</p>&#13;
<p class="bull">• We used class <span class="violet"><strong><code>invalid_argument</code></strong></span> in <em>set</em> functions (starting in <a href="ch09.xhtml#ch09">Chapter 9</a>) to indicate when an attempt was made to set an invalid value. Proper coding can, of course, prevent invalid arguments from reaching a function.</p>&#13;
<p class="bull">• Class <span class="violet"><strong><code>length_error</code></strong></span> indicates that a length larger than the maximum size allowed for the object being manipulated was used for that object.</p>&#13;
<p class="bull">• Class <span class="violet"><strong><code>out_of_range</code></strong></span> indicates that a value, such as a subscript into an array, exceeded its allowed range of values.</p>&#13;
<h5 class="h5" id="ch12lev3sec24">Catching Exception Types Related By Inheritance</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Using inheritance with exceptions enables an exception handler to <code>catch</code> related errors with concise notation:</p>&#13;
<p class="bull">• <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/>  One approach is to <code>catch</code> each type of reference to a derived-class exception object individually. This is error-prone—you could forget to test explicitly for one or more of the derived-class types.</p>&#13;
<p class="bull">• A more concise approach is to <code>catch</code> references to base-class exception objects.</p>&#13;
<p>It’s a logic error if you place a base-class <code>catch</code> handler before one that catches one of that base class’s derived types. The base-class <code>catch</code> matches all objects of classes derived from that base class, so the derived-class <code>catch</code> will never execute.<sup><a id="ch12fn42a" href="ch12.xhtml#ch12fn42">42</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn42" href="ch12.xhtml#ch12fn42a">42</a>. “<strong>E.31: Properly order your catch-clauses.</strong>” Accessed March 13, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re_catch/">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re_catch/</a></code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec25">Catching All Exceptions</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>C++ exceptions need not derive from class <code>exception</code>, so catching type <code>exception</code> is not guaranteed to <code>catch</code> all exceptions a program could encounter. You can use <code>catch(...)</code> to catch all exception types thrown in a <code>try</code> block.</strong> There are weaknesses to this approach:</p>&#13;
<p class="bull">• The type of the caught exception is unknown.</p>&#13;
<p class="bull">• Also, without a named parameter, you cannot refer to the exception object inside the exception handler.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The <code>catch(...)</code> handler is primarily used to perform recovery that does not depend on the exception type, such as releasing common resources. <strong>The exception can be rethrown to alert enclosing <code>catch</code> handlers.</strong></p>&#13;
<h3 class="h3" id="sec12_10"><span class="violet">12.10</span> C++’s Alternative to the <code>finally</code> Block</h3>&#13;
<p>In several programming languages that were created after C++—such as Java, C# and Python—the <code>try</code> statement has an optional <code>finally</code> block that is guaranteed to execute, regardless of whether the corresponding <code>try</code> block completes successfully or terminates due to an exception. The <code>finally</code> block is placed after a <code>try</code> block’s last exception handler or immediately after the <code>try</code> block if there are no exception handlers (which is allowed in those languages but not in C++). This makes <code>finally</code> blocks in those other languages a good mechanism for guaranteeing resource deallocation to prevent resource leaks.</p>&#13;
<p>As a programmer in another language, you might wonder why C++’s <code>try</code> statement has not added a <code>finally</code> block. In C++, we do not need <code>finally</code> due to <strong>RAII (Resource Acquisition Is Initialization)</strong>, smart pointers and destructors. If you design a class to use RAII, objects of your class will acquire their resources during object construction and deallocate them during object destruction.</p>&#13;
<p>Over the years, similar capabilities have been added to Java, C# and Python as well:</p>&#13;
<p class="bull">• Java has <code>try</code>-with-resources statements.</p>&#13;
<p class="bull">• C# has <code>using</code> statements.</p>&#13;
<p class="bull">• Python has <code>with</code> statements.</p>&#13;
<p>As program control enters these statements, each creates objects that acquire resources, which you can then use in the statements’ bodies. When these statements terminate—successfully or due to an exception—they deallocate the resources automatically.</p>&#13;
<h3 class="h3" id="sec12_11"><span class="violet">12.11</span> Libraries Often Support Both Exceptions and Error Codes</h3>&#13;
<p>Exceptions are not universally used. A 2018 ISO worldwide C++ developer survey showed that exceptions were partially or fully banned in 52% of projects.<sup><a id="ch12fn43a" href="ch12.xhtml#ch12fn43">43</a></sup> For example,</p>&#13;
<p class="footnote"><a id="ch12fn43" href="ch12.xhtml#ch12fn43a">43</a>. “C++ Developer Survey 'Lite': 2018-02.” Accessed March 25, 2021. <code><a href="https://isocpp.org/files/papers/CppDevSurvey-2018-02-summary.pdf">https://isocpp.org/files/papers/CppDevSurvey-2018-02-summary.pdf</a></code>.</p>&#13;
<p class="bull">• the <strong>Google C++ Style Guide</strong><sup><a id="ch12fn44a" href="ch12.xhtml#ch12fn44">44</a></sup> indicates that they do not use exceptions, and</p>&#13;
<p class="footnote"><a id="ch12fn44" href="ch12.xhtml#ch12fn44a">44</a>. “Google C++ Style Guide.” Accessed March 22, 2021. <code><a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a></code>.</p>&#13;
<p class="bull">• the <strong>Joint Strike Fighter Air Vehicle (JSF AV) C++ Coding Standards</strong><sup><a id="ch12fn45a" href="ch12.xhtml#ch12fn45">45</a></sup> explicitly forbids using <code>try</code>, <code>catch</code> and <code>throw</code>.</p>&#13;
<p class="footnote"><a id="ch12fn45" href="ch12.xhtml#ch12fn45a">45</a>. “Joint Strike Fighter Air Vehicle C++ Coding Standards.” December 2005. Accessed March 22, 2021. <code><a href="https://www.stroustrup.com/JSF-AV-rules.pdf">https://www.stroustrup.com/JSF-AV-rules.pdf</a></code>.</p>&#13;
<p>When organizations prohibit exceptions, they’re also prohibiting use of libraries that contain functions with the potential to throw exceptions—such as the C++ standard library.</p>&#13;
<p>There are various disadvantages to not allowing exceptions in projects. Some problems one developer encountered in a project that banned exceptions included:<sup><a id="ch12fn46a" href="ch12.xhtml#ch12fn46">46</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn46" href="ch12.xhtml#ch12fn46a">46</a>. Lucian Radu Teodorescu’s answer to “Why do some people recommend not using exception handling in C++? Is this just a "culture" in C++ community, or do some real reasons exist behind this?” August 2, 2015. Accessed March 25, 2021. <code><a href="https://www.quora.com/Why-do-some-people-recommend-not-using-exception-handling-in-C++-Is-this-just-a-culture-in-C++-community-or-do-some-real-reasons-exist-behind-this/answer/Lucian-Radu-Teodorescu">https://www.quora.com/Why-do-some-people-recommend-not-using-exception-handling-in-C++-Is-this-just-a-culture-in-C++-community-or-do-some-real-reasons-exist-behind-this/answer/Lucian-Radu-Teodorescu</a></code>.</p>&#13;
<p class="bull">• interoperability issues with class libraries that use exceptions,</p>&#13;
<p class="bull">• the amount of code required to deal with error conditions,</p>&#13;
<p class="bull">• problems with errors during object construction,</p>&#13;
<p class="bull">• problems with overloaded assignment operators,</p>&#13;
<p class="bull">• difficulties with error-handling flows of control,</p>&#13;
<p class="bull">• cluttering of the code by intermixing of logic and error handling,</p>&#13;
<p class="bull">• issues with resource allocation and deallocation, and</p>&#13;
<p class="bull">• efficiency of the code.</p>&#13;
<p>To give programmers the flexibility of choosing whether to use exceptions, some libraries support dual interfaces with two versions of each function:</p>&#13;
<p class="bull">• one that throws an exception when it encounters a problem, and</p>&#13;
<p class="bull">• one that sets or returns an error indicator when it encounters a problem.</p>&#13;
<p>As an example of this, consider the functions in C++17’s <code>&lt;filesystem&gt;</code> library<sup><a id="ch12fn47a" href="ch12.xhtml#ch12fn47">47</a></sup>. These functions enable you to manipulate files and folders from C++ applications. In this library, each function has two versions—one that throws a <code>filesystem_error</code> exception and one that sets a value in its <code>error_code</code> argument that you pass to the function by reference.</p>&#13;
<p class="footnote"><a id="ch12fn47" href="ch12.xhtml#ch12fn47a">47</a>. <code><a href="https://en.cppreference.com/w/cpp/filesystem">https://en.cppreference.com/w/cpp/filesystem</a></code>.</p>&#13;
<h3 class="h3" id="sec12_12"><span class="violet">12.12</span> Logging</h3>&#13;
<p>One common task when handling exceptions is to log where they occurred into a human-readable text file that developers can analyze later for debugging purposes. Logging can be used during development time to help locate and fix problems. It also can be used once an application ships—if an application crashes, it might write a log file that the user can then send to the developer.</p>&#13;
<p>Logging is not built into the C++ standard library, though you could create your own logging mechanisms using C++’s file-processing capabilities. However, there are many open source C++ logging libraries:</p>&#13;
<p class="bull">• Boost.Log—<code><a href="https://www.boost.org/doc/libs/1_75_0/libs/log/doc/html/">https://www.boost.org/doc/libs/1_75_0/libs/log/doc/html/</a></code>.</p>&#13;
<p class="bull">• Easlylogging++—<code><a href="https://github.com/amrayn/easyloggingpp">https://github.com/amrayn/easyloggingpp</a></code>.</p>&#13;
<p class="bull">• Google Logging Library (glog)—<code><a href="https://github.com/google/glog">https://github.com/google/glog</a></code>.</p>&#13;
<p class="bull">• Loguru—<code><a href="https://github.com/emilk/loguru">https://github.com/emilk/loguru</a></code>.</p>&#13;
<p class="bull">• Plog—<code><a href="https://github.com/SergiusTheBest/plog">https://github.com/SergiusTheBest/plog</a></code>.</p>&#13;
<p class="bull">• spdlog—<code><a href="https://github.com/gabime/spdlog">https://github.com/gabime/spdlog</a></code>.</p>&#13;
<p>Some of these are header-only libraries that you can simply include in your projects. Others require installation procedures.</p>&#13;
<h3 class="h3" id="sec12_13"><span class="violet">12.13</span> Looking Ahead to Contracts<sup><a id="ch12fn48a" href="ch12.xhtml#ch12fn48">48</a></sup></h3>&#13;
<p class="footnote"><a id="ch12fn48" href="ch12.xhtml#ch12fn48a">48</a>. <strong>Contracts are not yet a standard C++ feature</strong>. The syntax we show here could change before contracts eventually become part of the language.</p>&#13;
<p>To strengthen your program’s error-handling architecture, you can specify the expected states before and after a function’s execution with preconditions and postconditions, respectively. We’ll define and show code examples of each, and explain what happens when they are violated.</p>&#13;
<p class="bull">• A <strong><span class="violet">precondition</span></strong><sup><a id="ch12fn49a" href="ch12.xhtml#ch12fn49">49</a></sup> must be true when a function is invoked. Preconditions describe constraints on function parameters and any other expectations the function has just before it begins executing. <strong>If the preconditions are not met, then the function’s behavior is undefined</strong>—it may throw an exception, proceed with an illegal value or attempt to recover from the error. If code with undefined behavior is allowed to proceed, the results could be unpredictable and not portable across platforms. Each function can have multiple preconditions.</p>&#13;
<p class="footnote"><a id="ch12fn49" href="ch12.xhtml#ch12fn49a">49</a>. “Precondition.” Accessed March 27, 2021. <code><a href="https://en.wikipedia.org/wiki/Precondition">https://en.wikipedia.org/wiki/Precondition</a></code>.</p>&#13;
<p class="bull">• A <strong><span class="violet">postcondition</span></strong><sup><a id="ch12fn50a" href="ch12.xhtml#ch12fn50">50</a></sup> is true after the function successfully returns. Postconditions describe constraints on the return value or side effects the function may have. When defining a function, you should document all postconditions so that others know what to expect when they call your function. You also should ensure that your function honors its postconditions if its preconditions are met. Each function can have multiple postconditions.</p>&#13;
<p class="footnote"><a id="ch12fn50" href="ch12.xhtml#ch12fn50a">50</a>. “Postcondition.” Accessed March 27, 2021. <code><a href="https://en.wikipedia.org/wiki/Postcondition">https://en.wikipedia.org/wiki/Postcondition</a></code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec26">Precondition and Postcondition Violations</h5>&#13;
<p>Today, precondition and postcondition violations often are dealt with by throwing exceptions. Consider <code>array</code> and <code>vector</code> function <code>at</code>, which receives an index into the container. For a precondition, function <code>at</code> requires that its index argument be greater than or equal to <code>0</code> and less than the container’s size. If the precondition is met, <code>at</code>’s postcondition states that the function will return the item at that index; otherwise, <code>at</code> throws an <code>out_of_range</code> exception. As a client of an <code>array</code> or <code>vector</code>, we trust that function <code>at</code> satisfies its postcondition, provided that we meet the precondition.</p>&#13;
<p>Preconditions and postconditions are assertions, so you can implement them with the <code>assert</code> preprocessor macro (<a href="ch12.xhtml#sec12_6_1">Section 12.6.1</a>) as program control enters or exits a function. Preprocessor macros are generally deprecated in C++. Until contracts become part of C++, you’ll continue using the <code>assert</code> macro or custom C++ code to express preconditions, assertions and postconditions.</p>&#13;
<h5 class="h5" id="ch12lev3sec27">Invariants</h5>&#13;
<p>An <strong><span class="violet">invariant</span></strong> is a condition that should always be true in your code—that is, a condition that never changes. <strong><span class="violet">Class invariants</span></strong> must be true for each object of a class. They generally are tied to an object’s lifecycle. Class invariants remain true from the time an object is constructed until it’s destructed. For example:</p>&#13;
<p class="bull">• <a href="ch09.xhtml#ch09lev1sec6">Section 9.6</a>’s <code>Account</code> class requires that its <code>m_balance</code> data member always be nonnegative.</p>&#13;
<p class="bull">• <a href="ch09.xhtml#ch09lev1sec7">Section 9.7</a>’s <code>Time</code> class requires that its <code>m_hour</code> data member always have a value in the range 0 through 23, and its <code>m_minute</code> and <code>m_second</code> members always have values in the range 0 through 59.</p>&#13;
<p>These invariants ensure that objects of these classes always maintain valid state information throughout their lifetimes. Functions also may contain invariants. For example, in a function that searches for a specified value in a <code>vector&lt;int&gt;</code>, the invariant is that if the value is in the <code>vector</code>, the value’s index must be greater than or equal to 0 and less than the <code>vector</code>’s size.</p>&#13;
<h5 class="h5" id="ch12lev3sec28">Design By Contract</h5>&#13;
<p><strong><span class="violet">Design by contract (DbC)</span></strong><sup><a id="ch12fn51a" href="ch12.xhtml#ch12fn51">51</a>,<a id="ch12fn52a" href="ch12.xhtml#ch12fn52">52</a>,<a id="ch12fn53a" href="ch12.xhtml#ch12fn53">53</a></sup> is a <strong>software-design approach</strong> created by <strong>Bertrand Meyer in the 1980s and used in the design of his Eiffel programming language</strong>. Using this approach:</p>&#13;
<p class="footnote"><a id="ch12fn51" href="ch12.xhtml#ch12fn51a">51</a>. Bertrand Meyer. <em>Object-Oriented Software Construction</em>. Prentice Hall, 1988.</p>&#13;
<p class="footnote"><a id="ch12fn52" href="ch12.xhtml#ch12fn52a">52</a>. Bertrand Meyer. In <em>Touch of Class: Learning to Program Well with Objects and Contracts</em>, xvii. Springer Berlin AN, 2016.</p>&#13;
<p class="footnote"><a id="ch12fn53" href="ch12.xhtml#ch12fn53a">53</a>. “Design by contract.” Accessed March 28, 2010. <code><a href="https://en.wikipedia.org/wiki/Design_by_contract">https://en.wikipedia.org/wiki/Design_by_contract</a></code>.</p>&#13;
<p class="bull">• a function expects client code to meet the function’s precondition(s),</p>&#13;
<p class="bull">• if the preconditions are true, the function guarantees that its postcondition(s) will be true, and</p>&#13;
<p class="bull">• any invariants are maintained.</p>&#13;
<p><span class="size">23</span> A proposal to add support for contract-based programming (commonly referred to as “contracts”) to the C++ standard was first proposed in 2012 and later rejected.<sup><a id="ch12fn54a" href="ch12.xhtml#ch12fn54">54</a></sup> Another proposal was eventually accepted for inclusion in C++20, but removed<sup><a id="ch12fn55a" href="ch12.xhtml#ch12fn55">55</a></sup> late in C++20’s development cycle due to “lingering design disagreements and concerns.”<sup><a id="ch12fn56a" href="ch12.xhtml#ch12fn56">56</a></sup> So, contracts have been pushed to at least C++23.</p>&#13;
<p class="footnote"><a id="ch12fn54" href="ch12.xhtml#ch12fn54a">54</a>. Nathan Meyers, “What Happened to C++20 Contracts?” August 5, 2019. Accessed March 28, 2021. <code><a href="https://www.reddit.com/r/cpp/comments/cmk7ek/what_happened_to_c20_contracts/">https://www.reddit.com/r/cpp/comments/cmk7ek/what_happened_to_c20_contracts/</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn55" href="ch12.xhtml#ch12fn55a">55</a>. Nathan Meyers, “What Happened to C++20 Contracts?” August 5, 2019. Accessed March 28, 2021. <code><a href="https://www.reddit.com/r/cpp/comments/cmk7ek/what_happened_to_c20_contracts/">https://www.reddit.com/r/cpp/comments/cmk7ek/what_happened_to_c20_contracts/</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn56" href="ch12.xhtml#ch12fn56a">56</a>. Herb Sutter, “Trip report: Summer ISO C++ standards meeting (Cologne),” July 2019. Accessed March 28, 2021. <code><a href="https://herbsutter.com/2019/07/20/trip-report-summer-iso-c-standards-meeting-cologne/">https://herbsutter.com/2019/07/20/trip-report-summer-iso-c-standards-meeting-cologne/</a></code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec29">Gradually Moving to Contracts in the C++ Standard Library</h5>&#13;
<p>Herb Sutter says, “in Java and .NET some 90% of all exceptions are thrown for precondition violations.” He also says, “The programming world now broadly recognizes that programming bugs (e.g., out-of-bounds access, null dereference, and in general all pre/ post/assert-condition violations) cause a corrupted state that cannot be recovered from programmatically, and so they should never be reported to the calling code as exceptions or error codes that code could somehow handle.”<sup><a id="ch12fn57a" href="ch12.xhtml#ch12fn57">57</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn57" href="ch12.xhtml#ch12fn57a">57</a>. Herb Sutter, “Trip report: Summer ISO C++ standards meeting (Rapperswil),” July 2018. Accessed March 22, 2021. <code><a href="https://herbsutter.com/2018/07/">https://herbsutter.com/2018/07/</a></code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>A key idea behind incorporating contracts is that many errors we currently deal with via exceptions can be located via preconditions and postconditions then eliminated by fixing the code.</strong><sup><a id="ch12fn58a" href="ch12.xhtml#ch12fn58">58</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn58" href="ch12.xhtml#ch12fn58a">58</a>. Glennen Carnie, “Contract killing (in Modern C++),” September 18, 2019. Accessed March 28, 2021. <code><a href="https://blog.feabhas.com/2019/09/contract-killing-in-modern-c/">https://blog.feabhas.com/2019/09/contract-killing-in-modern-c/</a></code>.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <strong>A goal of contracts is to make most functions <code>noexcept</code>,</strong><sup><a id="ch12fn59a" href="ch12.xhtml#ch12fn59">59</a></sup> <strong>which will enable the compiler to perform additional optimizations.</strong> Sutter says, that <strong>“Gradually switching precondition violations from exceptions to contracts promises to eventually remove a majority of all exceptions thrown by the standard library.”</strong><sup><a id="ch12fn60a" href="ch12.xhtml#ch12fn60">60</a>,<a id="ch12fn61a" href="ch12.xhtml#ch12fn61">61</a></sup></p>&#13;
<p class="footnote"><a id="ch12fn59" href="ch12.xhtml#ch12fn59a">59</a>. Herb Sutter, “Trip report: Summer ISO C++ standards meeting (Rapperswil),” July 2018. Accessed March 22, 2021. <code><a href="https://herbsutter.com/2018/07/">https://herbsutter.com/2018/07/</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn60" href="ch12.xhtml#ch12fn60a">60</a>. Herb Sutter, “Trip report: Summer ISO C++ standards meeting (Rapperswil),” July 2018. Accessed March 22, 2021. <code><a href="https://herbsutter.com/2018/07/">https://herbsutter.com/2018/07/</a></code>.</p>&#13;
<p class="footnote"><a id="ch12fn61" href="ch12.xhtml#ch12fn61a">61</a>. To get a sense of the number of exceptions thrown by C++ and its libraries, we searched for the word “throws” in the final draft of the C++ standard document located at <code><a href="https://isocpp.org/files/papers/N4860.pdf">https://isocpp.org/files/papers/N4860.pdf</a></code>. The document is over 1800 pages—450+ pages cover the language, 1000+ cover the standard library and the rest are appendices, bibliography, cross references and indexes. “Throws” appears 422 times—there were 80 occurrences of “throws nothing,” 13 occurrences of “throws nothing unless…” (indicating an exception that is thrown as a result of stack unwinding) and 329 occur-rences of functions that throw exceptions. Many of these 329 cases are examples of where contracts will help eliminate the need to throw exceptions.</p>&#13;
<h5 class="h5" id="ch12lev3sec30">Contracts Attributes</h5>&#13;
<p>The contracts proposal<sup><a id="ch12fn62a" href="ch12.xhtml#ch12fn62">62</a></sup> introduces three attributes of the form</p>&#13;
<p class="footnote"><a id="ch12fn62" href="ch12.xhtml#ch12fn62a">62</a>. G. Dos Reis, J.D. Garcia, J. Lakos, A. Meredith, N. Meyers, B. Stroustrup, “Support for contract based programming in C++,” June, 8, 2018. Accessed March 28, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html</a></code>.</p>&#13;
<p class="pren"><code>[[</code><em>contractAttribute optionalLevel optionalIdentifier: condition</em><code>]]</code></p>&#13;
<p>that you can use to specify preconditions, postconditions and assertions for your functions. The <em>optionalIdentifier</em> is one of the function’s local variables for use in postconditions, as you’ll see in <a href="ch12.xhtml#fig12_9">Fig. 12.9</a>. The contract attributes are:</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>expects</code></strong></span>—for specifying a function’s preconditions that are checked before the function’s body begins executing,</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>ensures</code></strong></span>—for specifying a function’s postconditions that are checked just before the function returns, and</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>assert</code></strong></span>—for specifying assertions that are checked as they’re encountered throughout a function’s execution.</p>&#13;
<p>If you specify multiple preconditions and postconditions, they’re checked in their order of declaration.</p>&#13;
<h5 class="h5" id="ch12lev3sec31">Contracts Levels</h5>&#13;
<p>There are three contract levels:</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>default</code></strong></span> specifies a contract that has little runtime overhead compared to the function’s typical execution time. If a level is not specified, the compiler assumes <code>default</code>.</p>&#13;
<p class="bull">• <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="violet"> <strong><code>audit</code></strong></span> specifies a contract that has <strong>significant runtime overhead</strong> compared to the function’s typical execution time. Such contracts are intended primarily for use during program development.</p>&#13;
<p class="bull">• <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="violet"> <strong><code>axiom</code></strong></span> specifies a contract that is meant to be enforced by static code checkers, rather than at runtime.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Using these levels will enable you to select which contracts are enforced at runtime, thus controlling the performance overhead. You can choose—presumably via compiler flags— whether to turn contracts off entirely, perform the low-overhead <code>default</code> contracts or perform the high-overhead <code>audit</code> contracts.</p>&#13;
<h5 class="h5" id="ch12lev3sec32">Specifying Preconditions, Postconditions and Assertions</h5>&#13;
<p>Precondition contracts (<code>expects</code>) and postcondition contracts (<code>ensures</code>) are specified in a function’s prototype—they are listed after the function’s signature and before the semicolon. For example, a function that calculates the real (not imaginary) square root of a <code>double</code> value expects its argument to be greater than or equal to zero. You can specify this with an <code>expects</code> precondition contract:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p676pro01" id="p676pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">double</span> squareRoot(<span class="blue">double</span> value)&#13;
   [[e<span class="blue">xpects:</span> value &gt;= <span class="green">0.0</span>]];</pre>&#13;
<p>If the function definition also serves as the function prototype, the precondition and postcondition contracts are listed between the function’s signature and its opening left brace.</p>&#13;
<p>Assertions are specified as statements in the function body. For instance, to check whether an integer exam <code>grade</code> is in the range <code>0</code> through <code>100</code>, you’d write:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p677pro01" id="p677pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">[[<span class="blue">assert</span>: grade &gt;= <span class="green">0</span> &amp;&amp; grade &lt;= <span class="green">100</span>]];</pre>&#13;
<p>Note that the <code>assert</code> in the preceding statement is not an <code>assert</code> macro.</p>&#13;
<h5 class="h5" id="ch12lev3sec33">Early-Access Implementation</h5>&#13;
<p>There is an early-access contracts implementation in GNU C++<sup><a id="ch12fn63a" href="ch12.xhtml#ch12fn63">63</a></sup> that you can test through the <strong><span class="violet">Compiler Explorer website</span></strong><sup><a id="ch12fn64a" href="ch12.xhtml#ch12fn64">64</a></sup> (<code><a href="https://godbolt.org">https://godbolt.org</a></code>), which supports many compiler versions across various programming languages. You can choose “<strong>x86-64 gcc (contracts)</strong>” as your compiler and compile contracts-based code using the compiler options described at:</p>&#13;
<p class="footnote"><a id="ch12fn63" href="ch12.xhtml#ch12fn63a">63</a>. There is also an early-access Clang contracts implementation at <code><a href="https://github.com/arcosuc3m/clang-contracts">https://github.com/arcosuc3m/clang-contracts</a></code>, but you need to build and install it yourself.</p>&#13;
<p class="footnote"><a id="ch12fn64" href="ch12.xhtml#ch12fn64a">64</a>. Copyright © 2012–2019, Compiler Explorer Authors. All rights reserved. Compiler Explorer is by Matt Godbolt. <code><a href="https://xania.org/MattGodbolt">https://xania.org/MattGodbolt</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p677pro02" id="p677pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">https://gitlab.com/lock3/gcc-new/-/wikis/contract-assertions</pre>&#13;
<p>We provide a <code>godbolt.org</code> URL where you can try each of our examples using the early-access implementation. The GNU C++ early-access contracts implementation uses different keywords for preconditions and postconditions:</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>pre</code></strong></span> rather than <code>excepts</code>, and</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>post</code></strong></span> rather than <code>ensures</code>.</p>&#13;
<h5 class="h5" id="ch12lev3sec34">Example: Division By Zero</h5>&#13;
<p><a href="ch12.xhtml#fig12_8">Figure 12.8</a> reimplements our <code>quotient</code> function from <a href="ch12.xhtml#fig12_3">Fig. 12.3</a>. Here, we specify in the <code>quotient</code> function’s prototype (lines 6–7) a <code>default</code> level precondition contract indicating that the <code>denominator</code> must not be <code>0.0</code>. The <code>default</code> keyword also can be specified explicitly, as in:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p677pro03" id="p677pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">[[<span class="blue">pre</span> <span class="blue">default</span>: denominator != <span class="green">0.0</span>]]</pre>&#13;
<p>This example can be found at:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p677pro04" id="p677pro04a">Click here to view code image</a></p>&#13;
<pre class="pre">https://godbolt.org/z/fWxTE5ov9</pre>&#13;
<p>As you type code into the Compiler Explorer editor, or when you load an existing example, Compiler Explorer automatically compiles and runs it or displays any compilation errors.</p>&#13;
<div class="group" id="fig12_8">&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p12pro08" id="p12pro08a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig12_08.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// quotient function with a contract precondition.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">double</span> quotient(<span class="blue">double</span> numerator, <span class="blue">double</span> denominator)&#13;
<span class="cviolet"> <strong>7</strong></span>      [[<span class="blue">pre</span>: denominator != <span class="green">0.0</span>]];&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      cout &lt;&lt; <span class="green">"quotient(100, 7): "</span> &lt;&lt; quotient(<span class="green">100</span>, <span class="green">7</span>)&#13;
<span class="cviolet"><strong>11</strong></span>         &lt;&lt; <span class="green">"\nquotient(100, 0): "</span> &lt;&lt; quotient(<span class="green">100</span>, <span class="green">0</span>) &lt;&lt; <span class="green">'\n'</span>;&#13;
<span class="cviolet"><strong>12</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="lgreen">// perform division</span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">double</span> quotient(<span class="blue">double</span> numerator, <span class="blue">double</span> denominator) {&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">return</span> numerator / denominator;&#13;
<span class="cviolet"><strong>17</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 12.8</strong></span> | quotient function with a contract precondition.</p>&#13;
</div>&#13;
<p>We preset the compiler options for this example to</p>&#13;
<pre class="pre">-std=c++2a -fcontracts</pre>&#13;
<p><span class="size">20</span> which compiles the code with C++20 and experimental contracts support—<code>c++2a</code> was the early-access GNU C++ compiler notation for C++20. Compiler Explorer generally shows at least two tabs—a code editor and a compiler. Our examples also show the output tab so you can see the executed program’s results—this is also where compilation errors would be displayed. The compiler tab has two drop-down lists at the top. One lets you select the compiler. The other lets you view and edit the compiler options, or you can click the down arrow to select common compiler options.</p>&#13;
<p>The <code>quotient</code> call at line 10 satisfies the precondition and executes successfully, producing:</p>&#13;
<pre class="pre1">quotient(100, 7): 14.2857</pre>&#13;
<p>The <code>quotient</code> call at line 11, however, causes a <strong><span class="violet">contract violation</span></strong>. So, the <strong><span class="violet">default violation handler</span></strong> (<span class="violet"><strong><code>handle_contract_violation</code></strong></span>) is implicitly called, displays the following error message then terminates the program:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p678pro01" id="p678pro01a">Click here to view code image</a></p>&#13;
<pre class="pre1">default std::handle_contract_violation called:&#13;
 ./example.cpp 7 quotient denominator != 0.0 default default 0</pre>&#13;
<p>Changing the compilation options to</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p678pro02" id="p678pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">-std=c++2a -fcontracts -fcontract-build-level=off</pre>&#13;
<p><strong>disables contract checking</strong> and allows line 11 to execute, producing the output:</p>&#13;
<pre class="pre1">quotient(100, 0): inf</pre>&#13;
<p>Recall that division by zero is undefined behavior in C++. However, many compilers, including the three key compilers we use throughout this book, return positive or negative infinity (<code>inf</code> or <code>-inf</code>) in this case. This is the behavior specified by the <strong>IEEE 754 standard for floating-point arithmetic</strong>, which is widely supported by modern programming languages.</p>&#13;
<h5 class="h5" id="ch12lev3sec35">Contract Continuation Mode</h5>&#13;
<p>The default <strong><span class="violet">continuation mode</span></strong> for contract violations is to terminate the program immediately. To allow a program to continue executing, you can add the compiler option</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p678pro03" id="p678pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">-fcontract-continuation-mode=on</pre>&#13;
<h5 class="h5" id="ch12lev3sec36">Example: Binary Search</h5>&#13;
<p>Consider <a href="ch12.xhtml#fig12_9">Fig. 12.9</a>, which defines a <code>binarySearch</code> function template with a precondition and a postcondition. To save space, we show only the prototype here. The complete example, which you can find at:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p679pro01" id="p679pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://godbolt.org/z/K1qxf8MYY</pre>&#13;
<p>contains the <code>binarySearch</code> function template’s definition.</p>&#13;
<div class="group" id="fig12_9">&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p12pro09" id="p12pro09a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig12_09.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// binarySearch function with a precondition and a postcondition.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> binarySearch(<span class="blue">const</span> vector&lt;T&gt;&amp; items, <span class="blue">const</span> T&amp; key)&#13;
<span class="cviolet"><strong>10</strong></span>      [[<span class="blue">pre</span> <span class="blue">audit</span>: is_sorted(begin(items), end(items))]]&#13;
<span class="cviolet"><strong>11</strong></span>      [[<span class="blue">post</span> loc: loc == <span class="green">-1</span> || (loc &gt;= <span class="green">0</span> &amp;&amp; loc &lt; items.size())]];&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="lgreen">// sorted vector v1 satisfies binarySearch's precondition</span>&#13;
<span class="cviolet"><strong>15</strong></span>      vector v1{<span class="green">10</span>, <span class="green">20</span>, <span class="green">30</span>, <span class="green">40</span>, <span class="green">50</span>, <span class="green">60</span>, <span class="green">70</span>, <span class="green">80</span>, <span class="green">90</span>};&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">int</span> result1 = binarySearch(v1, <span class="green">70</span>);&#13;
<span class="cviolet"><strong>17</strong></span>      cout &lt;&lt; <span class="green">"70 was "</span> &lt;&lt; (result1 != <span class="green">-1</span> ? <span class="green">""</span> : <span class="green">"not "</span>) &lt;&lt; <span class="green">"found in v1\n"</span>;&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="lgreen">// unsorted vector v2 violates binarySearch's precondition</span>&#13;
<span class="cviolet"><strong>20</strong></span>      vector v2{<span class="green">60</span>, <span class="green">70</span>, <span class="green">80</span>, <span class="green">90</span>, <span class="green">10</span>, <span class="green">20</span>, <span class="green">30</span>, <span class="green">40</span>, <span class="green">50</span>};&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">int</span> result2 = binarySearch(v2, <span class="green">60</span>);&#13;
<span class="cviolet"><strong>22</strong></span>      cout &lt;&lt; <span class="green">"60 was "</span> &lt;&lt; (result2 != <span class="green">-1</span> ? <span class="green">""</span> : <span class="green">"not "</span>) &lt;&lt; <span class="green">"found in v2\n"</span>;&#13;
<span class="cviolet"><strong>23</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 12.9</strong></span> | <code>binarySearch</code> function with a precondition and a postcondition.</p>&#13;
</div>&#13;
<p>The <code>binarySearch</code> function template performs a binary search on a <code>vector</code>. This algorithm requires the <code>vector</code> to be in sorted order; otherwise, the result could be incorrect. So we declared the precondition</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p679pro02" id="p679pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">[[<span class="blue">pre audit</span>: is_sorted(begin(items), end(items))]]</pre>&#13;
<p>which calls the C++ standard library function <span class="violet"><strong><code>is_sorted</code></strong></span> (from header <code>&lt;algorithm&gt;</code><sup><a id="ch12fn65a" href="ch12.xhtml#ch12fn65">65</a></sup>) to check whether the <code>vector</code> is sorted. This is potentially an expensive operation. A binary search of a billion element sorted <code>vector</code> requires only 30 comparisons. However, determining whether the <code>vector</code> is sorted requires 999,999,999 comparisons. And sorting one billion elements efficiently with an <em>O</em>(<em>n</em> log<sub>2</sub><em>n</em>) sort algorithm could require about 30 billion operations. A developer might want to enable this test during development and disable it in production code. For this reason, we specified the precondition contract level <code>audit</code>.</p>&#13;
<p class="footnote"><a id="ch12fn65" href="ch12.xhtml#ch12fn65a">65</a>. There are over 200 functions in the C++ standard library’s <code>&lt;algorithm&gt;</code> header. We survey many of these in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>&#13;
<p>The <code>binarySearch</code> function template’s prototype also specifies the postcondition:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p680pro01" id="p680pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">[[<span class="blue">post</span> loc: loc == -1 || (loc &gt;= <span class="green">0</span> &amp;&amp; loc &lt; items.size())]]</pre>&#13;
<p>This demonstrates an optional identifier (<code>loc</code>) from the function body that can be used in the postcondition contract. If our <code>binarySearch</code> function template does not find the search key, it will return the <code>loc</code> value <code>-1</code>. Otherwise, <code>loc</code> will be an index that’s greater than or equal to <code>0</code> and less than the <code>vector</code>’s size.</p>&#13;
<p>We preset the compiler options for this example to</p>&#13;
<pre class="pre">-std=c++2a -fcontracts</pre>&#13;
<p><span class="size">20</span> which, again, compiles the code with C++20 and <code>default</code> level contracts support, so <strong>the line 10 <code>audit</code> level precondition contract is ignored</strong>. In <code>main</code>, we created two <code>vector</code>s of integers containing the same values—<code>v1</code> is sorted (line 15), and <code>v2</code> is unsorted (line 20). With the initial compiler settings, the precondition is not tested, sothe <code>binarySearch</code> calls in lines 16 and 21 complete, and the program displays the output:</p>&#13;
<pre class="pre1">70 was found in v1&#13;
60 was not found in v2</pre>&#13;
<p>Because the <strong><code>audit</code> level</strong> precondition was ignored, our program has a logic error. The second line of output shows that <code>60</code> was not found in <code>v2</code>. Again, the algorithm expects <code>v2</code> to be sorted, so it failed to find <code>60</code>, even though it’s in <code>v2</code>. Changing the <strong><span class="violet">contract build level</span></strong> to <code>audit</code> in the compilation options, as in:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p680pro02" id="p680pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">-std=c++2a -fcontracts -fcontract-build-level=audit</pre>&#13;
<p>enables <code>audit</code> level contract checking. When the program runs with <code>audit</code> contracts enabled, the <code>vector v1</code> in line 16’s <code>binarySearch</code> call satisfies the precondition in line 10 and, as before, line 17 outputs:</p>&#13;
<pre class="pre1">70 was found in v1</pre>&#13;
<p>However, <code>vector v2</code> in line 21’s <code>binarySearch</code> call causes a <strong>contract violation</strong>, resulting in the error message:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p680pro03" id="p680pro03a">Click here to view code image</a></p>&#13;
<pre class="pre1">default std::handle_contract_violation called:&#13;
 ./example.cpp 10 binarySearch&lt;int&gt; is_sorted(begin(items), end(items)) audit&#13;
default 0</pre>&#13;
<p>The postcondition in our example is always true, because we coded the <code>binarySearch</code> function correctly. To show a postcondition contract violation, we</p>&#13;
<p class="bull">• modified <code>binarySearch</code> to incorrectly return <code>-2</code> when the key is not found, and</p>&#13;
<p class="bull">• changed the <code>binarySearch</code> call in line 16 to search for a key that’s not in <code>v1</code>.</p>&#13;
<p>This forces <code>binarySearch</code> to return <code>-2</code>, violating the postcondition. You can view the modified code at:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p680pro04" id="p680pro04a">Click here to view code image</a></p>&#13;
<pre class="pre">https://godbolt.org/z/EbbYGET7n</pre>&#13;
<p>In this case, the postcondition causes a contract violation and produces the output:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p681pro01" id="p681pro01a">Click here to view code image</a></p>&#13;
<pre class="pre1">default std::handle_contract_violation called:&#13;
 ./example.cpp 11 binarySearch&lt;int&gt; loc == -1 || (loc &gt;= 0 &amp;&amp;&#13;
loc &lt; items.size()) default default 0</pre>&#13;
<h5 class="h5" id="ch12lev3sec37">Custom Contract Violation Handler</h5>&#13;
<p>The examples so far used the default contract violation handler. When a contract violation occurs, a <span class="violet"><strong><code>contract_violation</code></strong></span> object is created containing the following information:</p>&#13;
<p class="bull">• the line number of the violation—returned by member function <code>line_number</code>,</p>&#13;
<p class="bull">• the source-code file name—returned by member function <code>file_name</code>,</p>&#13;
<p class="bull">• the function name in which the violation occurred—returned by member function <code>function_name</code>,</p>&#13;
<p class="bull">• a description of the condition that was violated—returned by member function <code>comment</code>, and</p>&#13;
<p class="bull">• the contract level—returned by member function <code>assertion_level</code>.</p>&#13;
<p>The <code>contract_violation</code> is passed to the <strong><span class="violet">violation handler</span></strong> function of the form:</p>&#13;
<p class="codelink"><a href="Images/ch12_images.xhtml#p681pro02" id="p681pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">void</span> handle_contract_violation(<span class="blue">const</span> contract_violation&amp; violation)&#13;
{&#13;
   <span class="lgreen">// handler code</span>&#13;
}</pre>&#13;
<h3 class="h3" id="sec12_14"><span class="violet">12.14</span> Wrap-Up</h3>&#13;
<p>In this chapter, we discussed that C++ is used to build real-world, mission-critical and business-critical software. The systems it’s used for are often massive. You learned that it’s essential to eliminate bugs during development and decide how to handle problems once the software is in production.</p>&#13;
<p>We overviewed the ways that exceptions may surface in your code. We discussed how exception handling helps you write robust, fault-tolerant programs that catch infrequent problems and continue executing, perform appropriate cleanup and terminate gracefully, or terminate abruptly in the case of unanticipated exceptions.</p>&#13;
<p>We reviewed exception-handling concepts in an example that demonstrated the flows of control when a program executes successfully, and when an exception occurs. We discussed use-cases for catching then rethrowing exceptions. We showed how stack unwinding enables other functions to handle an exception that is not caught in a particular scope.</p>&#13;
<p>You learned when to use exceptions. We also introduced the exception guarantees you can provide in your code—no guarantee, a basic exception guarantee, a strong exception guarantee and no-throw exception guarantee. We discussed why exceptions are used to indicate errors during construction and why destructors should not throw exceptions. We also showed how to use function <code>try</code> blocks to catch exceptions from a constructor’s member-initializer list or from base-class destructors when a derived-class object is destroyed.</p>&#13;
<p>You saw that operator <code>new</code> throws <code>bad_alloc</code> exceptions when dynamic memory allocation fails. We also showed how dynamic memory allocation failures were handled in legacy C++ code with <code>set_new_handler</code>.</p>&#13;
<p>We introduced the C++ standard library exception class hierarchy and created a custom exception class that inherited from a C++ standard library exception class. You learned why it’s important to catch exceptions by reference to enable exception handlers to catch exception types related by inheritance and to avoid slicing. We also introduced logging exceptions into a file that developers can analyze later for debugging purposes.</p>&#13;
<p>We discussed why some organizations disallow exception handling. You also saw that some libraries provide dual interfaces, so developers can choose whether to use versions of functions that throw exceptions or versions that set error codes.</p>&#13;
<p>The chapter concluded with an introduction to the contracts feature, originally adopted for C++20 but delayed to a future C++ version. We showed how to use contracts to test preconditions, postconditions and assertions at runtime. You learned that these test conditions which should always be true in correct code. You saw that if such conditions are false, contract violations occur and, by default, the code terminates immediately. This enables you to find errors faster, eliminate them during development and, hopefully, create more robust code.</p>&#13;
<p><a href="ch07.xhtml#ch07">Chapter 7</a> introduced the <code>array</code> and <code>vector</code> standard library classes. In <a href="ch13.xhtml#ch13">Chapter 13</a>, you’ll learn about many additional C++ standard library containers as well as iterators, which are used by standard library algorithms to walk through containers and manipulate their elements.</p>&#13;
</div></body>
</html>