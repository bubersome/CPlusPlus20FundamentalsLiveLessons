<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch08">Chapter 8. <code>string</code>s, <code>string_view</code>s, Text Files, CSV Files and Regex</h2>&#13;
<div class="image"><img src="Images/p0323-01.jpg" alt="Images" width="370" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Determine <code>string</code> characteristics.</p>&#13;
<p class="squ"><span class="red">■</span> Find, replace and insert characters in <code>string</code>s.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++11 numeric conversion functions.</p>&#13;
<p class="squ"><span class="red">■</span> See the C++20 update to how <code>string</code> member function <code>reserve</code> modifies <code>string</code> capacity.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++17 <code>string_view</code>s for lightweight views of contiguous characters.</p>&#13;
<p class="squ"><span class="red">■</span> Write and read sequential files.</p>&#13;
<p class="squ"><span class="red">■</span> Perform input from and output to <code>string</code>s in memory.</p>&#13;
<p class="squ"><span class="red">■</span> Do an objects-natural case study using an object of an open-source-library class to read and process data about the Titanic disaster from a CSV (comma-separated values) file.</p>&#13;
<p class="squ"><span class="red">■</span> Do an objects-natural case study using C++11 regular expressions (regex) to search strings for patterns, validate data and replace substrings.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec1"><span class="violet"><strong>8.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec2"><span class="violet"><strong>8.2</strong></span> <code>string</code> Assignment and Concatenation</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec3"><span class="violet"><strong>8.3</strong></span> Comparing <code>string</code>s</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec4"><span class="violet"><strong>8.4</strong></span> Substrings</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec5"><span class="violet"><strong>8.5</strong></span> Swapping <code>string</code>s</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec6"><span class="violet"><strong>8.6</strong></span> <code>string</code> Characteristics</a></p>&#13;
<p class="chap-lev2"><a href="#ch08lev2sec1">8.6.1 C++20 Update to <code>string</code> Member-Function <code>reserve</code></a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec7"><span class="violet"><strong>8.7</strong></span> Finding Substrings and Characters in a <code>string</code></a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec8"><span class="violet"><strong>8.8</strong></span> Replacing Characters in a <code>string</code></a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec9"><span class="violet"><strong>8.9</strong></span> Inserting Characters into a <code>string</code></a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec10"><span class="violet"><strong>8.10</strong></span> C++11 Numeric Conversions</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec11"><span class="violet"><strong>8.11</strong></span> C++17 <code>string_view</code></a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec12"><span class="violet"><strong>8.12</strong></span> Files and Streams</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec13"><span class="violet"><strong>8.13</strong></span> Creating a Sequential File</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec14"><span class="violet"><strong>8.14</strong></span> Reading Data from a Sequential File</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec15"><span class="violet"><strong>8.15</strong></span> C++14 Reading and Writing Quoted Text</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec16"><span class="violet"><strong>8.16</strong></span> Updating Sequential Files</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec17"><span class="violet"><strong>8.17</strong></span> String Stream Processing</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec18"><span class="violet"><strong>8.18</strong></span> Raw String Literals</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec19"><span class="violet"><strong>8.19</strong></span> Objects Natural Case Study: Reading and Analyzing a CSV File Containing Titanic Disaster Data</a></p>&#13;
<p class="chap-lev2"><a href="#ch08lev2sec2">8.19.1 Using <code>rapidcsv</code> to Read the Contents of a CSV File</a></p>&#13;
<p class="chap-lev2"><a href="#ch08lev2sec3">8.19.2 Reading and Analyzing the Titanic Disaster Dataset</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec20"><span class="violet"><strong>8.20</strong></span> Objects Natural Case Study: Introduction to Regular Expressions</a></p>&#13;
<p class="chap-lev2"><a href="#ch08lev2sec4">8.20.1 Matching Complete Strings to Patterns</a></p>&#13;
<p class="chap-lev2"><a href="#ch08lev2sec5">8.20.2 Replacing Substrings</a></p>&#13;
<p class="chap-lev2"><a href="#ch08lev2sec6">8.20.3 Searching for Matches</a></p>&#13;
<p class="chap-lev1"><a href="#ch08lev1sec21"><span class="violet"><strong>8.21</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec1"><span class="violet">8.1</span> Introduction</h3>&#13;
<p><span class="size">17</span> This chapter discusses additional <code>std::string</code> features and introduces C++17 <code>string_view</code>s, text file-processing, CSV file processing and regular expressions.</p>&#13;
<h5 class="h5" id="ch08lev3sec1"><code>std::string</code>s</h5>&#13;
<p><span class="size">20</span> We’ve been using <code>std::string</code> object since <a href="ch02.xhtml#ch02">Chapter 2</a>. Here, we introduce many more <code>std::string</code> manipulations, including assignment, comparisons, extracting substrings, searching for substrings, modifying <code>std::string</code> objects and converting <code>std::string</code> objects to numeric values. We also introduce a C++20 change to the mechanics of the <code>std::string</code> member function <code>reserve</code>.</p>&#13;
<h5 class="h5" id="ch08lev3sec2">C++17 <code>string_view</code>s</h5>&#13;
<p><span class="size">17</span> We introduce C++17’s <code>string_view</code>s, which are read-only views of C-strings or <code>std::string</code> objects. Like <code>std::span</code>, a <code>string_view</code> does not own the data it views. You’ll see that <code>string_view</code>s have many similar capabilities to <code>std::string</code>s, making them appropriate for many cases in which you do not need modifiable strings.</p>&#13;
<h5 class="h5" id="ch08lev3sec3">Text Files</h5>&#13;
<p>Data storage in memory is temporary. <span class="violet"><strong>Files</strong></span> are used for <span class="violet"><strong>data persistence</strong></span>—permanent retention of data. Computers store files on <span class="violet"><strong>secondary storage devices,</strong></span> such as flash drives, and frequently today, in the cloud. In this chapter, we explain how to build C++ programs that create, update and process sequential text files. We also show how to output data to and read data from a <code>std::string</code> in memory using <code>ostringstream</code>s and <code>istringstream</code>s.</p>&#13;
<h5 class="h5" id="ch08lev3sec4">Objects Natural Case Study: CSV Files and the Titanic Disaster Dataset</h5>&#13;
<p>In this chapter’s first objects-natural case study, we introduce the CSV (comma-separated values) file format. CSV is popular for datasets used in big data, data analytics and data science, and artificial intelligence applications like natural language processing, machine learning and deep learning.</p>&#13;
<p><span class="size">DS</span> One of the most commonly used datasets for data analytics and data science beginners is the Titanic disaster dataset. It lists all the passengers and whether they survived when the ship <em>Titanic</em> struck an iceberg and sank on its maiden voyage April 14–15, 1912. We use a class from the open-source <code>rapidcsv</code> library to create an object that reads the Titanic dataset from a CSV file. Then, we view some of the data and perform some basic data analytics.</p>&#13;
<h5 class="h5" id="ch08lev3sec5">Objects Natural Case Study: Using Regular Expressions to Search Strings for Patterns, Validate Data and Replace Substrings</h5>&#13;
<p><span class="size">11</span> In this chapter’s second objects-natural case study, we introduce regular expressions, which are particularly crucial in today’s data-rich applications. We’ll use C++11 <code>regex</code> objects to create regular expressions then use them with various functions in the <code>&lt;regex&gt;</code> header to match patterns in text. In earlier chapters, we mentioned the importance of validating user input in industrial-strength code. The <code>std::string</code>, string stream and regular expression capabilities presented in this chapter are frequently used to validate data.</p>&#13;
<h3 class="h3" id="ch08lev1sec2"><span class="violet">8.2</span> <code>string</code> Assignment and Concatenation</h3>&#13;
<p><a href="#fig8_1">Figure 8.1</a> demonstrates <code>std::string</code> assignment and concatenation.</p>&#13;
<div class="group" id="fig8_1">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig01" id="aa08fig01">Click here to view code image</a></p>&#13;
<pre class="pre3"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_01.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Demonstrating string assignment and concatenation.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace std;</span></code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int main() {</span></code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.1</strong></span> Demonstrating <code>string</code> assignment and concatenation.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec6">String Assignment</h5>&#13;
<p>Lines 9–11 create the <code>string</code>s <code>s1</code>, <code>s2</code> and <code>s3</code>. Line 13 uses the assignment operator to copy the contents of <code>s1</code> into <code>s2</code>. You also can specify two arguments, as in</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0227-01a" id="f0227-01aa">Click here to view code image</a></p>&#13;
<pre class="pre">string bar{<span class="green">8</span>, <span class="green">'*'</span>}; <span class="pd_green">// string of 8 '*' characters</span></pre>&#13;
<p>which creates a <code>string</code> containing eight <code>'*'</code> characters.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0227-01" id="f0227-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>9</strong></span>    string s1{<span class="green">"cat"</span>};&#13;
<span class="cviolet"><strong>10</strong></span>    string s2; <span class="pd_green">// initialized to the empty string</span>&#13;
<span class="cviolet"><strong>11</strong></span>    string s3; <span class="pd_green">// initialized to the empty string</span>&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>    <span class="yell">s2 = s1;</span> <span class="pd_green">// assign s1 to s2</span>&#13;
<span class="cviolet"><strong>14</strong></span>    <span class="yell">s3.assign(s1);</span> <span class="pd_green">// assign s1 to s3</span>&#13;
<span class="cviolet"><strong>15</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"s1: {}\ns2: {}\ns3: {}\n\n"</span>, s1, s2, s3);&#13;
<span class="cviolet"><strong>16</strong></span></pre>&#13;
<pre class="pre1">s1: cat&#13;
s2: cat&#13;
s3: cat</pre>&#13;
<p>Line 14 uses member function <code><span class="violet"><strong>assign</strong></span></code> to copy <code>s1</code>’s contents into <code>s3</code>. This particular version of assign is equivalent to using the operator, but <code>assign</code> also has many overloads that enable you to assign characters to an existing <code>string</code> object. For details of each, see</p>&#13;
<pre class="pre"><a href="https://en.cppreference.com/w/cpp/string/basic_string/assign">https://en.cppreference.com/w/cpp/string/basic_string/assign</a></pre>&#13;
<p><code>std::string</code> also provides an overloaded version of member function <code>assign</code> that copies a specified number of characters, as in</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0228-02" id="f0228-02a">Click here to view code image</a></p>&#13;
<pre class="pre">target.assign(source, start, numberOfChars);</pre>&#13;
<p>where <code>source</code> is the <code>string</code> to copy, <code>start</code> is the starting index, and <code>numberOfChars</code> is the number of characters to copy.</p>&#13;
<h5 class="h5" id="ch08lev3sec7">Accessing String Elements By Index</h5>&#13;
<p>Lines 17 and 18 use the string member function <code><span class="violet"><strong>at</strong></span></code> to assign <code>'r'</code> to <code>s2</code> at index <code>0</code> (forming <code>"rat"</code>) and to assign <code>'r'</code> to <code>s3</code> at index <code>2</code> (forming <code>"car"</code>).</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0228-03" id="f0228-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>17</strong></span>    <span class="yell">s2.at(<span class="green">0</span>) = <span class="green">'r'</span>;</span> <span class="pd_green">// modify s2</span>&#13;
<span class="cviolet"><strong>18</strong></span>    <span class="yell">s3.at(<span class="green">2</span>) = <span class="green">'r'</span>;</span> <span class="pd_green">// modify s3</span>&#13;
<span class="cviolet"><strong>19</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"After modifications:\ns2: {}\ns3: {}"</span>, s2, s3);&#13;
<span class="cviolet"><strong>20</strong></span></pre>&#13;
<pre class="pre1">After modifications:&#13;
s2: rat&#13;
s3: car</pre>&#13;
<p>You also can use the member function <code>at</code> to get the character at a specific index in a <code>string</code>. As with <code>std::array</code> and <code>std::vector</code>, a <code>std::string</code>’s <code>at</code> member function performs range checking and throws an <code>out_of_range</code> exception if the index is not within the <code>string</code>’s bounds. The subscript operator, <code>[]</code>, also is available for <code>string</code>s, but does not provide checked access. This is consistent with its use with <code>std::array</code> and <code>std::vector</code>. You also can iterate through the characters in a string using range-based <code>for</code> as in</p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">char</span> c : s3) {&#13;
   cout &lt;&lt; c;&#13;
}</pre>&#13;
<p>which ensures that you do not access any elements outside the <code>string</code>’s bounds.</p>&#13;
<h5 class="h5" id="ch08lev3sec8">Accessing String Elements By Index</h5>&#13;
<p>Line 22 initializes <code>s4</code> to the contents of <code>s1</code> followed by <code>"apult"</code>. For <code>std::string</code>, the <code>+</code> operator denotes string concatenation. Line 23 uses member function <code><span class="violet"><strong>append</strong></span></code> to concatenate <code>s1</code> and <code>"acomb"</code>. Next, line 24 uses the overloaded addition assignment operator, <code>+=</code>, to concatenate <code>s3</code> and <code>"pet"</code>. Then line 30 appends the string <code>"comb"</code> to empty <code>string s5</code>. The arguments are the <code>std::string</code> to retrieve characters from (<code>s1</code>), the starting index (<code>4</code>) and the number of characters to append (<code>s1.size() - 4</code>).</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0229-01" id="f0229-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>21</strong></span>    cout &lt;&lt; <span class="green">"\n\nAfter concatenations:\n"</span>;&#13;
<span class="cviolet"><strong>22</strong></span>    <span class="yell">string s4{s1 + <span class="green">"apult"</span>};</span> <span class="pd_green">// concatenation</span>&#13;
<span class="cviolet"><strong>23</strong></span>    <span class="yell">s1.append(<span class="green">"acomb"</span>);</span> <span class="pd_green">// create "catacomb"</span>&#13;
<span class="cviolet"><strong>24</strong></span>    <span class="yell">s3 += <span class="green">"pet"</span>;</span> <span class="pd_green">// create "carpet" with overloaded +=</span>&#13;
<span class="cviolet"><strong>25</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"s1: {}\ns3: {}\ns4: {}\n"</span>, s1, s3, s4);&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>    <span class="pd_green">// append locations 4 through end of s1 to</span>&#13;
<span class="cviolet"><strong>28</strong></span>    <span class="pd_green">// create string "comb" (s5 was initially empty)</span>&#13;
<span class="cviolet"><strong>29</strong></span>    string s5; <span class="pd_green">// initialized to the empty string</span>&#13;
<span class="cviolet"><strong>30</strong></span>    <span class="yell">s5.append(s1, <span class="green">4</span>, s1.size() - <span class="green">4</span>);</span>&#13;
<span class="cviolet"><strong>31</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"s5: {}"</span>, s5);&#13;
<span class="cviolet"><strong>32</strong></span>  }</pre>&#13;
<pre class="pre1">After concatenations:&#13;
s1: catacomb&#13;
s3: carpet&#13;
s4: catapult&#13;
s5: comb</pre>&#13;
<h3 class="h3" id="ch08lev1sec3"><span class="violet">8.3</span> Comparing <code>string</code>s</h3>&#13;
<p><code>std::string</code> provides member functions for comparing <code>string</code>s (<a href="#fig8_2">Fig. 8.2</a>). Throughout this example, we call function <code>displayResult</code> (lines 8–18) to display each comparison’s result. The program declares four <code>string</code>s (lines 21–24) and outputs each (line 26).</p>&#13;
<div class="group" id="fig8_2">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig02" id="aa08fig02">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_02.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Comparing strings.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">void</span> displayResult(<span class="blue">const</span> string&amp; s, <span class="blue">int</span> result) {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>      <code><span class="blue">if</span> (result == <span class="green">0</span>) {</code>&#13;
<span class="cviolet"><strong>10</strong></span>         <code>cout &lt;&lt; s + <span class="green">" == 0\n";</span></code>&#13;
<span class="cviolet"><strong>11</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>12</strong></span>      <code><span class="blue">else if</span> (result &gt; <span class="green">0</span>) {</code>&#13;
<span class="cviolet"><strong>13</strong></span>         <code>cout &lt;&lt; s + <span class="green">" &gt; 0\n";</span></code>&#13;
<span class="cviolet"><strong>14</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>15</strong></span>      <code><span class="blue">else</span> { <span class="pd_green">// result &lt; 0</span></code>&#13;
<span class="cviolet"><strong>16</strong></span>         <code>cout &lt;&lt; s + <span class="green">" &lt; 0\n"</span>;</code>&#13;
<span class="cviolet"><strong>17</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>18</strong></span>    <code>}</code>&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>21</strong></span>      <code><span class="blue">const</span> string s1{<span class="green">"Testing the comparison functions."</span>};</code>&#13;
<span class="cviolet"><strong>22</strong></span>      <code><span class="blue">const</span> string s2{<span class="green">"Hello"</span>};</code>&#13;
<span class="cviolet"><strong>23</strong></span>      <code><span class="blue">const</span> string s3{<span class="green">"stinger"</span>};</code>&#13;
<span class="cviolet"><strong>24</strong></span>      <code><span class="blue">const</span> string s4{s2}; <span class="pd_green">// "Hello"</span></code>&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>      <code>cout &lt;&lt; fmt::format(<span class="green">"s1: {}\ns2: {}\ns3: {}\ns4: {}"</span>, s1, s2, s3, s4);</code>&#13;
<span class="cviolet"><strong>27</strong></span></pre>&#13;
<pre class="pre1"><code>s1: Testing the comparison functions.</code>&#13;
<code>s2: Hello</code>&#13;
<code>s3: stinger</code>&#13;
<code>s4: Hello</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.2</strong></span> Comparing <code>string</code>s.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec9">Comparing Strings with the Relational and Equality Operators</h5>&#13;
<p>Strings may be compared with the relational and equality operators—each returns a <code>bool</code>. Comparisons are performed <span class="violet"><strong>lexicographically</strong></span>—that is, based on the integer values of each character (see <a href="app02.xhtml#app02">Appendix B</a>, <a href="app02.xhtml#app02">ASCII Character Set</a>). Line 29 tests whether <code>s1</code> is greater than <code>s4</code> using the overloaded &gt; operator. In this case, <code>s1</code> starts with a capital <code>T</code>, and <code>s4</code> starts with a capital <code>H</code>. So, <code>s1</code> is greater than <code>s4</code> because <code>T</code> has a higher numeric value than <code>H</code>.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0230-01" id="f0230-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>28</strong></span>     <span class="pd_green">// comparing s1 and s4</span>&#13;
<span class="cviolet"><strong>29</strong></span>    <span class="blue">if</span> (<span class="yell">s1 &gt; s4</span>) {&#13;
<span class="cviolet"><strong>30</strong></span>       cout &lt;&lt; <span class="green">"\n\ns1 &gt; s4\n"</span>;&#13;
<span class="cviolet"><strong>31</strong></span>    }&#13;
<span class="cviolet"><strong>32</strong></span></pre>&#13;
<pre class="pre1">s1 &gt; s4</pre>&#13;
<h5 class="h5" id="ch08lev3sec10">Comparing Strings with Member Function <code>compare</code></h5>&#13;
<p>Line 34 compares <code>s1</code> to <code>s2</code> using <code>std::string</code> member function <code><span class="violet"><strong>compare</strong></span></code>. This member function returns <code>0</code> if the <code>string</code>s are equal, a positive number if <code>s1</code> is <span class="violet"><strong>lexicographically</strong></span> greater than <code>s2</code> or a negative number if <code>s1</code> is lexicographically less than <code>s2</code>. Because a <code>string</code> starting with <code>'T'</code> is considered lexicographically greater than a string starting with <code>'H'</code>, <code>result</code> is assigned a value greater than <code>0</code>, as confirmed by the output.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0230-02" id="f0230-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>33</strong></span>    <span class="pd_green">// comparing s1 and s2</span>&#13;
<span class="cviolet"><strong>34</strong></span>    displayResult(<span class="green">"s1.compare(s2)"</span>, <span class="yell">s1.compare(s2)</span>);&#13;
<span class="cviolet"><strong>35</strong></span>&#13;
<span class="cviolet"><strong>36</strong></span>    <span class="pd_green">// comparing s1 (elements 2-5) and s3 (elements 0-5)</span>&#13;
<span class="cviolet"><strong>37</strong></span>    displayResult(<span class="green">"s1.compare(2, 5, s3, 0, 5)"</span>,&#13;
<span class="cviolet"><strong>38</strong></span>       <span class="yell">s1.compare(<span class="green">2</span>, <span class="green">5</span>, s3, <span class="green">0</span>, <span class="green">5</span>)</span>);&#13;
<span class="cviolet"><strong>39</strong></span>&#13;
<span class="cviolet"><strong>40</strong></span>    <span class="pd_green">// comparing s2 and s4</span>&#13;
<span class="cviolet"><strong>41</strong></span>    displayResult(<span class="green">"s4.compare(0, s2.size(), s2)"</span>,&#13;
<span class="cviolet"><strong>42</strong></span>       <span class="yell">s4.compare(<span class="green">0</span>, s2.size(), s2)</span>);&#13;
<span class="cviolet"><strong>43</strong></span>&#13;
<span class="cviolet"><strong>44</strong></span>    <span class="pd_green">// comparing s2 and s4</span>&#13;
<span class="cviolet"><strong>45</strong></span>    displayResult(<span class="green">"s2.compare(0, 3, s4)"</span>, <span class="yell">s2.compare(<span class="green">0</span>, <span class="green">3</span>, s4)</span>);&#13;
<span class="cviolet"><strong>46</strong></span>  }</pre>&#13;
<pre class="pre1">s1.compare(s2) &gt; 0&#13;
s1.compare(2, 5, s3, 0, 5) == 0&#13;
s4.compare(0, s2.size(), s2) == 0&#13;
s2.compare(0, 3, s4) &lt; 0</pre>&#13;
<p>The call to <code>compare</code> in line 38 compares portions of <code>s1</code> and <code>s3</code> using an overloaded version of member function <code>compare</code>. The first two arguments (<code>2</code> and <code>5</code>) specify the starting index and length of the portion of <code>s1</code> (<code>"sting"</code>) to compare with <code>s3</code>. The third argument is the comparison <code>string</code>. The last two arguments (<code>0</code> and <code>5</code>) are the starting index and length of the portion of the comparison <code>string</code> being compared (also <code>"sting"</code>). The two pieces being compared here are identical, so <code>compare</code> returns <code>0</code> as confirmed in the output.</p>&#13;
<p>Line 42 uses another overloaded version of function <code>compare</code> to compare <code>s4</code> and <code>s2</code>. The first two arguments are the starting index and length. The last argument is the comparison <code>string</code>. The pieces of <code>s4</code> and <code>s2</code> being compared are identical, so <code>compare</code> returns <code>0</code>.</p>&#13;
<p>Line 45 compares the first <code>3</code> characters in <code>s2</code> to <code>s4</code>. Because <code>"Hel"</code> begins with the same first three letters as <code>"Hello"</code> but has fewer letters overall, <code>"Hel"</code> is considered less than <code>"Hello"</code> and <code>compare</code> returns a value less than zero.</p>&#13;
<h3 class="h3" id="ch08lev1sec4"><span class="violet">8.4</span> Substrings</h3>&#13;
<p><code>std::string</code>’s member function <code><span class="violet"><strong>substr</strong></span></code> (<a href="#fig8_3">Fig. 8.3</a>) returns a substring from a <code>string</code>. The result is a new <code>string</code> object that’s copied from the source <code>string</code>. Line 9 uses member function <code>substr</code> to get a substring from <code>s</code> starting at index <code>3</code> and consisting of <code>4</code> characters.</p>&#13;
<div class="group" id="fig8_3">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig03" id="aa08fig03">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_03.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Demonstrating string member function substr.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>8</strong></span>       <code><span class="blue">const</span> string s{<span class="green">"airplane"</span>};</code>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code>cout &lt;&lt; <span class="yell">s.substr(<span class="green">3</span>, <span class="green">4</span>)</span> &lt;&lt; endl; <span class="pd_green">// retrieve substring "plan"</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>plan</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.3</strong></span> Demonstrating <code>string</code> member function <code>substr</code>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec5"><span class="violet">8.5</span> Swapping <code>string</code>s</h3>&#13;
<p><code>std::string</code> provides member function <code><span class="violet"><strong>swap</strong></span></code> for swapping <code>string</code>s. <a href="#fig8_4">Figure 8.4</a> <code><span class="violet"><strong>swap</strong></span></code> (line 14) to exchange the values of <code>first</code> and <code>second</code>.</p>&#13;
<div class="group" id="fig8_4">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig04" id="aa08fig04">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_04.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Using the swap function to swap two strings.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>      <code>string first{<span class="green">"one"</span>};</code>&#13;
<span class="cviolet"><strong>10</strong></span>      <code>string second{<span class="green">"two"</span>};</code>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <code>cout &lt;&lt; fmt::format(</code>&#13;
<span class="cviolet"><strong>13</strong></span>                 <code><span class="green">"Before swap:\nfirst: {}; second: {}"</span>, first, second);</code>&#13;
<span class="cviolet"><strong>14</strong></span>      <code><span class="yell">first.swap(second);</span> <span class="pd_green">// swap strings</span></code>&#13;
<span class="cviolet"><strong>15</strong></span>      <code>cout &lt;&lt; fmt::format(</code>&#13;
<span class="cviolet"><strong>16</strong></span>                 <code><span class="green">"\n\nAfter swap:\nfirst: {}; second: {}"</span>, first, second);</code>&#13;
<span class="cviolet"><strong>17</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Before swap:</code>&#13;
<code>first: one; second: two</code>&#13;
&#13;
<code>After swap:</code>&#13;
<code>first: two; second: one</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.4</strong></span> Using the <code>swap</code> function to swap two <code>string</code>s.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec6"><span class="violet">8.6</span> <code>string</code> Characteristics</h3>&#13;
<p><code>std::string</code> provides member functions for gathering information about a <code>string</code>’s size, capacity, maximum length and other characteristics:</p>&#13;
<p class="bull">• A <code>string</code>’s size is the number of characters currently stored in the <code>string</code>.</p>&#13;
<p class="bull">• A <code>string</code>’s <span class="violet"><strong>capacity</strong></span> is the number of characters that can be stored in the <code>string</code> before it must allocate more memory to store additional characters. A string performs memory allocation for you behind the scenes. The capacity of a <code>string</code> must be at least equal to the current size of the <code>string</code>, though it can be greater. The exact capacity of a <code>string</code> depends on the implementation.</p>&#13;
<p class="bull">• The <span class="violet"><strong>maximum size</strong></span> is the largest possible size a <code>string</code> can have. If this value is exceeded, a <code>length_error</code> exception is thrown.</p>&#13;
<p><a href="#fig8_5">Figure 8.5</a> demonstrates <code>string</code> member functions for determining these characteristics. Function <code>printStatistics</code> (lines 9–12) receives a <code>string</code> and displays its capacity (using member function <code><span class="violet"><strong>capacity</strong></span></code>), maximum size (using member function <code><span class="violet"><strong>max_size</strong></span></code>), size (using member function <code>size</code>), and whether the <code>string</code> is empty (using member function <code>empty</code>).</p>&#13;
<div class="group" id="fig8_5">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig05" id="aa08fig05">Click here to view code image</a></p>&#13;
<pre class="pre3"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_05.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Printing string characteristics.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="pd_green">// display string statistics</span></code>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">void</span> printStatistics(<span class="blue">const</span> string&amp; s) {</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code>cout &lt;&lt; fmt::format(<span class="green">"capacity: {}\nmax size: {}\nsize: {}\nempty: {}"</span>,</code>&#13;
<span class="cviolet"><strong>11</strong></span>                  <code><span class="yell">s.capacity()</span>, <span class="yell">s.max_size()</span>, <span class="yell">s.size()</span>, <span class="yell">s.empty()</span>);</code>&#13;
<span class="cviolet"><strong>12</strong></span>    <code>}</code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>    <code><span class="blue">int</span> main() {</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.5</strong></span> Printing <code>string</code> characteristics.</p>&#13;
</div>&#13;
<p>The program declares empty <code>string string1</code> (line 15) and passes it to function <code>printStatistics</code> (line 18). The initial call to <code>printStatistics</code> indicates that <code>string1</code>’s initial size is <code>0</code>—it contains no characters. Recall that the size and length are always identical. On Visual C++, the maximum size (shown in the output) is 2,147,483,647. On GNU C++, the maximum is 9,223,372,036,854,775,807 and on Apple Clang it’s 18,446,744,073,709,551,599. Object <code>string1</code> is an empty <code>string</code>, so function <code>empty</code> returns <code>true</code>.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0233-01" id="f0233-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>15</strong></span>    string string1; <span class="pd_green">// empty string</span>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>    cout &lt;&lt; <span class="green">"Statistics before input:\n"</span>;&#13;
<span class="cviolet"><strong>18</strong></span>    printStatistics(string1);&#13;
<span class="cviolet"><strong>19</strong></span></pre>&#13;
<pre class="pre1">Statistics before input:&#13;
capacity: 15&#13;
max size: 2147483647&#13;
size: 0&#13;
empty: true</pre>&#13;
<p>Line 21 inputs a string (in this case, <code>"tomato"</code>). Line 24 calls <code>printStatistics</code> to output updated <code>string1</code> statistics. The size is now <code>6</code>, and <code>string1</code> is no longer empty.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0233-02" id="f0233-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>20</strong></span>    cout &lt;&lt; <span class="green">"\n\nEnter a string: "</span>;&#13;
<span class="cviolet"><strong>21</strong></span>    cin &gt;&gt; string1; <span class="pd_green">// delimited by whitespace</span>&#13;
<span class="cviolet"><strong>22</strong></span>    cout &lt;&lt; <span class="green">"The string entered was: "</span> &lt;&lt; string1;&#13;
<span class="cviolet"><strong>23</strong></span>    cout &lt;&lt; <span class="green">"\nStatistics after input:\n"</span>;&#13;
<span class="cviolet"><strong>24</strong></span>    printStatistics(string1);&#13;
<span class="cviolet"><strong>25</strong></span></pre>&#13;
<pre class="pre1">Enter a string: <strong>tomato</strong>&#13;
The string entered was: tomato&#13;
Statistics after input:&#13;
capacity: 15&#13;
max size: 2147483647&#13;
size: 6&#13;
empty: false</pre>&#13;
<p>Line 27 inputs another string (in this case, <code>"soup"</code>) and stores it in <code>string1</code>, thereby replacing <code>"tomato"</code>. Line 30 calls <code>printStatistics</code> to output updated <code>string1</code> statistics. Note that the length is now <code>4</code>.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0233-03" id="f0233-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>26</strong></span>    cout &lt;&lt; <span class="green">"\n\nEnter a string: "</span>;&#13;
<span class="cviolet"><strong>27</strong></span>    cin &gt;&gt; string1; <span class="pd_green">// delimited by whitespace</span>&#13;
<span class="cviolet"><strong>28</strong></span>    cout &lt;&lt; <span class="green">"The string entered was: "</span> &lt;&lt; string1;&#13;
<span class="cviolet"><strong>29</strong></span>    cout &lt;&lt; <span class="green">"\nStatistics after input:\n"</span>;&#13;
<span class="cviolet"><strong>30</strong></span>    printStatistics(string1);&#13;
<span class="cviolet"><strong>31</strong></span></pre>&#13;
<pre class="pre1">Enter a string: soup&#13;
The string entered was: soup&#13;
Statistics after input:&#13;
capacity: 15&#13;
max size: 2147483647&#13;
size: 4&#13;
empty: false</pre>&#13;
<p>Line 33 uses <code>+=</code> to concatenate a 46-character string to <code>string1</code>. Line 36 calls <code>print-Statistics</code> to output updated <code>string1</code> statistics. Because <code>string1</code>’s capacity was not large enough to accommodate the new string size, the capacity was automatically increased to <code>63</code> elements, and <code>string1</code>’s size is now <code>50</code>.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0234-02" id="f0234-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>32</strong></span>    <span class="pd_green">// append 46 characters to string1</span>&#13;
<span class="cviolet"><strong>33</strong></span>    string1 += <span class="green">"1234567890abcdefghijklmnopqrstuvwxyz1234567890"</span>;&#13;
<span class="cviolet"><strong>34</strong></span>    cout &lt;&lt; <span class="green">"\n\nstring1 is now: "</span> &lt;&lt; string1;&#13;
<span class="cviolet"><strong>35</strong></span>    cout &lt;&lt; <span class="green">"\nStatistics after concatenation:\n"</span>;&#13;
<span class="cviolet"><strong>36</strong></span>    printStatistics(string1);&#13;
<span class="cviolet"><strong>37</strong></span></pre>&#13;
<pre class="pre1">Statistics after resizing to add 10 characters:&#13;
capacity: 63&#13;
max size: 2147483647&#13;
size: 60&#13;
empty: false</pre>&#13;
<p>Line 38 uses member function <code><span class="violet"><strong>resize</strong></span></code> to increase <code>string1</code>’s size by <code>10</code> characters. The additional elements are set to null characters. The <code>printStatistics</code> output shows that the capacity did not change, but the size is now <code>60</code>.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0234-03" id="f0234-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>38</strong></span>    <span class="yell">string1.resize(string1.size() + <span class="green">10</span>);</span> <span class="pd_green">// add 10 elements to string1</span>&#13;
<span class="cviolet"><strong>39</strong></span>    cout &lt;&lt; <span class="green">"\n\nStatistics after resizing to add 10 characters:\n"</span>;&#13;
<span class="cviolet"><strong>40</strong></span>    printStatistics(string1);&#13;
<span class="cviolet"><strong>41</strong></span>    cout &lt;&lt; endl;&#13;
<span class="cviolet"><strong>42</strong></span>  }</pre>&#13;
<pre class="pre1">Statistics after resizing to add 10 characters:&#13;
capacity: 63&#13;
max size: 2147483647&#13;
size: 60&#13;
empty: false</pre>&#13;
<h4 class="h4" id="ch08lev2sec1">8.6.1 C++20 Update to <code>string</code> Member-Function <code>reserve</code></h4>&#13;
<p><span class="size">20</span> You can change the capacity of a <code>string</code> without changing its size by calling <code>string</code> member function <code><span class="violet"><strong>reserve</strong></span></code>. If its integer argument is greater than the current capacity, the capacity is increased to greater than or equal to the argument value. As of C++20, if <code>reserve</code>’s argument is less than the current capacity, the capacity does not change. Before C++20, <code>reserve</code> optionally would reduce the capacity and, if the argument were smaller than the <code>string</code>’s size, optionally would reduce the capacity to match the size.</p>&#13;
<h3 class="h3" id="ch08lev1sec7"><span class="violet">8.7</span> Finding Substrings and Characters in a <code>string</code></h3>&#13;
<p><code>std::string</code> provides member functions for finding substrings and characters in a <code>string</code>. <a href="#fig8_6">Figure 8.6</a> demonstrates the <code>find</code> functions. String <code>s</code> is declared and initialized in line 9.</p>&#13;
<div class="group" id="fig8_6">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig06" id="aa08fig06">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_06.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Demonstrating the string find member functions.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code><span class="blue">const</span> string s{<span class="green">"noon is 12pm; midnight is not"</span>};</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code>cout &lt;&lt; <span class="green">"Original string: "</span> &lt;&lt; s;</code>&#13;
<span class="cviolet"><strong>11</strong></span></pre>&#13;
<pre class="pre1"><code>Original string: noon is 12pm; midnight is not</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.6</strong></span> Demonstrating the <code>string find</code> member functions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec11">Member Functions <code>find</code> and <code>rfind</code></h5>&#13;
<p>Lines 13–14 attempt to find <code>"is"</code> in <code>s</code> using member functions <code><span class="violet"><strong>find</strong></span></code> and <code><span class="violet"><strong>rfind</strong></span></code>, which search from the beginning and end of <code>s</code>, respectively. If <code>"is"</code> is found, the index of the starting location of that string is returned. If the <code>string</code> is not found, the <code>string find-</code>related functions return the constant <code><span class="violet"><strong>string::npos</strong></span></code> to indicate that a substring or character was not found in the <code>string</code>. The rest of the find functions presented in this section return the same type unless otherwise noted.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0235-01" id="f0235-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>12</strong></span>    <span class="pd_green">// find "is" from the beginning and end of s</span>&#13;
<span class="cviolet"><strong>13</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"\ns.find(\"is\"): {}\ns.rfind(\"is\"): {}"</span>,&#13;
<span class="cviolet"><strong>14</strong></span>               <span class="yell">s.find("is"), s.rf<span class="green">ind(</span>"is")</span>);&#13;
<span class="cviolet"><strong>15</strong></span></pre>&#13;
<pre class="pre1">s.find("is"): 5&#13;
s.rfind("is"): 23</pre>&#13;
<h5 class="h5" id="ch08lev3sec12">Member Function <code>find_first_of</code></h5>&#13;
<p>Line 17 uses member function <code><span class="violet"><strong>find_first_of</strong></span></code> to locate the first occurrence in <code>s</code> of any character in <code>"misop"</code>. The searching is done from the beginning of <code>s</code>. The character <code>'o'</code> is found in element 1.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0235-02" id="f0235-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>16</strong></span>    <span class="pd_green">// find 'o' from beginning</span>&#13;
<span class="cviolet"><strong>17</strong></span>    <span class="blue">int</span> location = <span class="yell">s.find_first_of(<span class="green">"misop"</span>)</span>;&#13;
<span class="cviolet"><strong>18</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"\ns.find_first_of(\"misop\") found {} at {}"</span>,&#13;
<span class="cviolet"><strong>19</strong></span>               s.at(location), location);&#13;
<span class="cviolet"><strong>20</strong></span></pre>&#13;
<pre class="pre1">s.find_first_of("misop") found o at 1</pre>&#13;
<h5 class="h5" id="ch08lev3sec13">Member Function <code>find_last_of</code></h5>&#13;
<p>Line 22 uses member function <code><span class="violet"><strong>find_last_of</strong></span></code> to find the last occurrence in <code>s</code> of any character in <code>"misop"</code>. The searching is done from the end of <code>s</code>. The character <code>'o'</code> is found in element 28.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0236-02" id="f0236-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>21</strong></span>    <span class="pd_green">// find 'o' from end</span>&#13;
<span class="cviolet"><strong>22</strong></span>    location = <span class="yell">s.find_last_of(<span class="green">"misop"</span>)</span>;&#13;
<span class="cviolet"><strong>23</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"\ns.find_last_of(\"misop\") found {} at {}"</span>,&#13;
<span class="cviolet"><strong>24</strong></span>               s.at(location), location);&#13;
<span class="cviolet"><strong>25</strong></span></pre>&#13;
<pre class="pre1">s.find_last_of("misop") found o at 27</pre>&#13;
<h5 class="h5" id="ch08lev3sec14">Member Function <code>find_first_not_of</code></h5>&#13;
<p>Line 27 uses member function <code><span class="violet"><strong>find_first_not_of</strong></span></code> to find the first character from the beginning of <code>s</code> that is not contained in <code>"noi spm"</code>, finding <code>'1'</code> in element 8. Line 33 uses member function <code>find_first_not_of</code> to find the first character not contained in <code>"12noi spm"</code>. It searches from the beginning of <code>s</code> and finds <code>';'</code> in element 12. Line 39 uses member function <code>find_first_not_of</code> to find the first character not contained in <code>"noon is 12pm; midnight is not"</code>. In this case, the <code>string</code> being searched contains every character specified in the string argument. Because a character was not found, <code>string::npos</code> (which has the value <code>–1</code> in this case) is returned.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0236-03" id="f0236-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>26</strong></span>    <span class="pd_green">// find '1' from beginning</span>&#13;
<span class="cviolet"><strong>27</strong></span>    location = <span class="yell">s.find_first_not_of(<span class="green">"noi spm"</span>)</span>;&#13;
<span class="cviolet"><strong>28</strong></span>    cout &lt;&lt; fmt::format(&#13;
<span class="cviolet"><strong>29</strong></span>               <span class="green">"\ns.find_first_not_of(\"noi spm\") found {} at {}"</span>,&#13;
<span class="cviolet"><strong>30</strong></span>               s.at(location), location);&#13;
<span class="cviolet"><strong>31</strong></span>&#13;
<span class="cviolet"><strong>32</strong></span>    <span class="pd_green">// find '.' at location 13</span>&#13;
<span class="cviolet"><strong>33</strong></span>    location = <span class="yell">s.find_first_not_of(<span class="green">"12noi spm"</span>)</span>;&#13;
<span class="cviolet"><strong>34</strong></span>    cout &lt;&lt; fmt::format(&#13;
<span class="cviolet"><strong>35</strong></span>               <span class="green">"\ns.find_first_not_of(\"12noi spm\") found {} at {}",</span>&#13;
<span class="cviolet"><strong>36</strong></span>               s.at(location), location);&#13;
<span class="cviolet"><strong>37</strong></span>&#13;
<span class="cviolet"><strong>38</strong></span>    <span class="pd_green">// search for characters not in "noon is 12pm; midnight is not"</span>&#13;
<span class="cviolet"><strong>39</strong></span>    location = <span class="yell">s.find_first_not_of(<span class="green">"noon is 12pm; midnight is not"</span>)</span>;&#13;
<span class="cviolet"><strong>40</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"\ns.find_first_not_of("</span> +&#13;
<span class="cviolet"><strong>41</strong></span>               <span class="green">"\"noon is 12pm; midnight is not\"): {}", location)</span>;&#13;
<span class="cviolet"><strong>42</strong></span>  }</pre>&#13;
<pre class="pre1">s.find_first_not_of("noi spm") found 1 at 8&#13;
s.find_first_not_of("12noi spm") found ; at 12&#13;
s.find_first_not_of("noon is 12pm; midnight is not"): -1</pre>&#13;
<h3 class="h3" id="ch08lev1sec8"><span class="violet">8.8</span> Replacing Characters in a <code>string</code></h3>&#13;
<p><a href="#fig8_7">Figure 8.7</a> demonstrates <code>string</code> member functions for replacing and erasing characters. Lines 10–14 declare and initialize <code>string string1</code>.</p>&#13;
<div class="group" id="fig8_7">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig07" id="aa08fig07">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_07.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Demonstrating string member functions erase and replace.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="pd_green">// compiler concatenates all parts into one string</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>      <code>string string1{<span class="green">"The values in any left subtree"</span></code>&#13;
<span class="cviolet"><strong>11</strong></span>      <code><span class="green">"\nare less than the value in the"</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>      <code><span class="green">"\nparent node and the values in"</span></code>&#13;
<span class="cviolet"><strong>13</strong></span>      <code><span class="green">"\nany right subtree are greater"</span></code>&#13;
<span class="cviolet"><strong>14</strong></span>      <code><span class="green">"\nthan the value in the parent node"</span>};</code>&#13;
<span class="cviolet"><strong>15</strong></span>      &#13;
<span class="cviolet"><strong>16</strong></span>      <code>cout &lt;&lt; fmt::format(<span class="green">"Original string:\n{}\n\n"</span>, string1);</code>&#13;
<span class="cviolet"><strong>17</strong></span></pre>&#13;
<pre class="pre1"><code>Original string:</code>&#13;
<code>The values in any left subtree</code>&#13;
<code>are less than the value in the</code>&#13;
<code>parent node and the values in</code>&#13;
<code>any right subtree are greater</code>&#13;
<code>than the value in the parent node</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.7</strong></span> Demonstrating <code>string</code> member functions <code>erase</code> and <code>replace</code>.</p>&#13;
</div>&#13;
<p>Line 18 uses <code>string</code> member function <code><span class="violet"><strong>erase</strong></span></code> to erase everything from (and including) the character in position 62 to the end of <code>string1</code>. Each newline character occupies one character in the <code>string</code>.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0237-01a" id="f0237-01aa">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>18</strong></span>    <span class="yell">string1.erase(<span class="green">62</span>);</span> <span class="pd_green">// remove from index 62 through end of string1</span>&#13;
<span class="cviolet"><strong>19</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"string1 after erase:\n{}\n\n"</span>, string1);&#13;
<span class="cviolet"><strong>20</strong></span></pre>&#13;
<pre class="pre1">string1 after erase:&#13;
The values in any left subtree&#13;
are less than the value in the</pre>&#13;
<p>Lines 21–27 use <code>find</code> to locate each occurrence of the space character. Each space is then replaced with a period by a call to <code>string</code> member function <code><span class="violet"><strong>replace</strong></span></code>. Function <code>replace</code> takes three arguments—the index of the character in the <code>string</code> at which replacement should begin, the number of characters to replace and the replacement string. Member function <code>find</code> returns <code>string::npos</code> when the search character is not found. In line 26, we add <code>1</code> to <code>position</code> to continue searching from the next character’s location.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0238-01" id="f0238-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>21</strong></span>    size_t position = string1.find(<span class="green">" "</span>); <span class="pd_green">// find first space</span>&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>    <span class="pd_green">// replace all spaces with period</span>&#13;
<span class="cviolet"><strong>24</strong></span>    <span class="blue">while</span> (position != <span class="green">string::npos</span>) {&#13;
<span class="cviolet"><strong>25</strong></span>       <span class="yell">string1.replace(position, <span class="green">1</span>, <span class="green">"."</span>)</span>;&#13;
<span class="cviolet"><strong>26</strong></span>       position = string1.find(<span class="green">" "</span>, position + <span class="green">1</span>);&#13;
<span class="cviolet"><strong>27</strong></span>    }&#13;
<span class="cviolet"><strong>28</strong></span>&#13;
<span class="cviolet"><strong>29</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"After first replacement:\n{}\n\n"</span>, string1);&#13;
<span class="cviolet"><strong>30</strong></span></pre>&#13;
<pre class="pre1">After first replacement:&#13;
The.values.in.any.left.subtree&#13;
are.less.than.the.value.in.the</pre>&#13;
<p>Lines 31–38 use functions <code>find</code> and <code>replace</code> to find every period and replace every period and its following character with two semicolons. The arguments passed to this version of <code>replace</code> are:</p>&#13;
<p class="bull">• the index of the element where the replace operation begins,</p>&#13;
<p class="bull">• the number of characters to replace,</p>&#13;
<p class="bull">• a replacement character string from which a substring is selected to use as replacement characters,</p>&#13;
<p class="bull">• the element in the character string where the replacement substring begins and</p>&#13;
<p class="bull">• the number of characters in the replacement character string to use.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0238-02" id="f0238-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>31</strong></span>    position = string1.find(<span class="green">"."</span>); <span class="pd_green">// find first period</span>&#13;
<span class="cviolet"><strong>32</strong></span>&#13;
<span class="cviolet"><strong>33</strong></span>    <span class="pd_green">// replace all periods with two semicolons</span>&#13;
<span class="cviolet"><strong>34</strong></span>    <span class="pd_green">// NOTE: this will overwrite characters</span>&#13;
<span class="cviolet"><strong>35</strong></span>    <span class="blue">while</span> (position != <span class="green">string::npos</span>) {&#13;
<span class="cviolet"><strong>36</strong></span>       <span class="yell">string1.replace(position, <span class="green">2</span>, <span class="green">"xxxxx;;yyy"</span>, <span class="green">5</span>, <span class="green">2</span>);</span>&#13;
<span class="cviolet"><strong>37</strong></span>       position = string1.find(<span class="green">"."</span>, position + <span class="green">1</span>);&#13;
<span class="cviolet"><strong>38</strong></span>    }&#13;
<span class="cviolet"><strong>39</strong></span>&#13;
<span class="cviolet"><strong>40</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"After second replacement:\n{}\n"</span>, string1);&#13;
<span class="cviolet"><strong>41</strong></span>  }</pre>&#13;
<pre class="pre1">After first replacement:&#13;
The.values.in.any.left.subtree&#13;
are.less.than.the.value.in.the&#13;
&#13;
After second replacement:&#13;
The;;alues;;n;;ny;;eft;;ubtree&#13;
are;;ess;;han;;he;;alue;;n;;he</pre>&#13;
<h3 class="h3" id="ch08lev1sec9"><span class="violet">8.9</span> Inserting Characters into a <code>string</code></h3>&#13;
<p><code>std::string</code> provides overloaded member functions for inserting characters into a <code>string</code> (<a href="#fig8_8">Fig. 8.8</a>). Line 14 uses <code>string</code> member function <code><span class="violet"><strong>insert</strong></span></code> to insert <code>"middle "</code> before element 10 of <code>s1</code>. Line 15 uses <code>insert</code> to insert <code>"xx"</code> before <code>s2</code>’s element 3. The last two arguments specify the starting and last element of <code>"xx"</code> to insert. Using <code>string::npos</code> causes the entire <code>string</code> to be inserted.</p>&#13;
<div class="group" id="fig8_8">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig08" id="aa08fig08">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_08.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Demonstrating std::string insert member functions.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>       <code>string s1{<span class="green">"beginning end"</span>};</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code>string s2{<span class="green">"12345678"</span>};</code>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>       <code>cout &lt;&lt; fmt::format(<span class="green">"Initial strings:\ns1: {}\ns2: {}\n\n"</span>, s1, s2);</code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>       <code><span class="yell">s1.insert(<span class="green">10</span>, <span class="green">"middle "</span>);</span> <span class="pd_green">// insert "middle " at location 10 in s1</span></code>&#13;
<span class="cviolet"><strong>15</strong></span>       <code><span class="yell">s2.insert(<span class="green">3</span>, <span class="green">"xx"</span>, <span class="green">0</span>, <span class="green">string::npos</span>);</span> <span class="pd_green">// insert "xx" at location 3 in s2</span></code>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>       <code>cout &lt;&lt; fmt::format(<span class="green">"Strings after insert:\ns1: {}\ns2: {}\n"</span>, s1, s2);</code>&#13;
<span class="cviolet"><strong>18</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Initial strings:</code>&#13;
<code>s1: beginning end</code>&#13;
<code>s2: 12345678</code>&#13;
&#13;
<code>Strings after insert:</code>&#13;
<code>s1: beginning middle end</code>&#13;
<code>s2: 123xx45678</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.8</strong></span> Demonstrating <code>std::string insert</code> member functions.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec10"><span class="violet">8.10</span> C++11 Numeric Conversions</h3>&#13;
<p><span class="size">11</span> C++11 added functions for converting from numeric values to <code>string</code>s and from <code>string</code>s to numeric values.</p>&#13;
<h5 class="h5" id="ch08lev3sec15">Converting Numeric Values to <code>string</code> Objects</h5>&#13;
<p>C++11’s <code><span class="violet"><strong>to_string</strong></span></code> function (from header <code>&lt;string&gt;</code>) returns the <code>string</code> representation of its numeric argument. The function is overloaded for all the fundamental numeric types <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code>, <code>unsigned long long</code>, <code>float</code>, <code>double</code> and <code>long double</code>.</p>&#13;
<h5 class="h5" id="ch08lev3sec16">Converting <code>string</code> Objects to Numeric Values</h5>&#13;
<p><span class="size">11</span> C++11 provides eight functions (from the <code>&lt;string&gt;</code> header) for converting <code>string</code> objects to numeric values:</p>&#13;
<div class="group">&#13;
<div class="images"><img src="Images/p0338-01.jpg" alt="Images" width="672" height="247"/></div>&#13;
</div>&#13;
<p>Each function attempts to convert the beginning of its <code>string</code> argument to a numeric value. If no conversion can be performed, each function throws an <code>invalid_argument</code> exception. If the result of the conversion is out of range for the function’s return type, each function throws an <code>out_of_range</code> exception.</p>&#13;
<h5 class="h5" id="ch08lev3sec17">Functions That Convert <code>string</code>s to Integral Types</h5>&#13;
<p>Consider an example of converting a <code>string</code> to an integral value. Assuming the <code>string</code>:</p>&#13;
<pre class="pre">string s(<span class="green">"100hello"</span>);</pre>&#13;
<p>the following statement converts the beginning of the string to the <code>int</code> value <code>100</code> and stores that value in <code>convertedInt</code>:</p>&#13;
<pre class="pre"><span class="blue">int</span> convertedInt = stoi(s);</pre>&#13;
<p>Each function that converts a <code>string</code> to an integral type receives three parameters—the last two have default arguments. The parameters are:</p>&#13;
<p class="bull">• A <code>string</code> containing the characters to convert.</p>&#13;
<p class="bull">• A pointer to a <code>size_t</code> variable. The function uses this pointer to store the index of the first character that was not converted. The default argument is <code>nullptr</code>, in which case the function does not store the index.</p>&#13;
<p class="bull">• An <code>int</code> from 2 to 36 representing the number’s base—the default is base 10.</p>&#13;
<p>So, the preceding statement is equivalent to</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0240-01a" id="f0240-01aa">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> convertedInt = stoi(s, <span class="blue">nullptr</span>, <span class="green">10</span>);</pre>&#13;
<p>Given a <code>size_t</code> variable named <code>index</code>, the statement:</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0240-02" id="f0240-02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> convertedInt = stoi(s, &amp;index, <span class="green">2</span>);</pre>&#13;
<p>converts the binary number <code>"100"</code> (base 2) to an <code>int</code> (100 in binary is the <code>int</code> value 4) and stores in <code>index</code> the location of the string’s letter <code>"h"</code> (the first character that was not converted).</p>&#13;
<h5 class="h5" id="ch08lev3sec18">Functions That Convert <code>string</code>s to Floating-Point Types</h5>&#13;
<p>The functions that convert <code>string</code>s to floating-point types each receive two parameters:</p>&#13;
<p class="bull">• A <code>string</code> containing the characters to convert.</p>&#13;
<p class="bull">• A pointer to a <code>size_t</code> variable where the function stores the index of the first character that was not converted. The default argument is <code>nullptr</code>, in which case the function does not store the index.</p>&#13;
<p>Consider an example of converting a <code>string</code> to a floating-point value. Assuming the <code>string</code>:</p>&#13;
<pre class="pre">string s(<span class="green">"123.45hello"</span>);</pre>&#13;
<p>the following statement converts the beginning of the <code>string</code> to the <code>double</code> value <code>123.45</code> and stores that value in <code>convertedDouble</code>:</p>&#13;
<pre class="pre"><span class="blue">double</span> convertedDouble = stod(s);</pre>&#13;
<p>Again, the second argument is <code>nullptr</code> by default.</p>&#13;
<h3 class="h3" id="ch08lev1sec11"><span class="violet">8.11</span> C++17 <code>string_view</code></h3>&#13;
<p><span class="size">17</span> C++17 introduced <code><span class="violet"><strong>string_view</strong></span></code><span class="violet"><strong>s</strong></span> (header <code><span class="violet"><strong>&lt;string_view&gt;</strong></span></code>), which are read-only views of C-strings or <code>std::string</code> objects. Like <code>std::span</code>, a <code>string_view</code> does not own the data it views. It contains:</p>&#13;
<p class="bull">• a pointer to the first character in a contiguous sequence of characters and</p>&#13;
<p class="bull">• a count of the number of characters.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> <span class="size">CG</span> <code>string_view</code>s enable many <code>std::string</code>-style operations on C-strings without the overhead of creating and initializing <code>std::string</code> objects, which copies the C-string contents. The C++ Core Guidelines state that you should prefer <code>std::string</code> if you need to “own character sequences”—for example, to be able to modify <code>std::string</code> contents.<sup><a id="rch08fn1" href="ch08.xhtml#ch08fn1">1</a></sup> If you simply need a read-only view of a contiguous sequence of characters, use a <code>string_view</code>.<sup><a id="rch08fn2" href="ch08.xhtml#ch08fn2">2</a></sup></p>&#13;
<p class="footnote"><a id="ch08fn1" href="ch08.xhtml#rch08fn1">1</a>. <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-string">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-string</a>.</p>&#13;
<p class="footnote"><a id="ch08fn2" href="ch08.xhtml#rch08fn2">2</a>. <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-view">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-view</a>.</p>&#13;
<h5 class="h5" id="ch08lev3sec19">Creating a <code>string_view</code></h5>&#13;
<p><a href="#fig8_9">Figure 8.9</a> demonstrates several <code>string_view</code> features. Line 5 includes the header <code>&lt;string_view&gt;</code>. Line 11 creates the <code>std::string s1</code> and line 12 copies <code>s1</code> into <code>s2</code>. Line 12 initializes a <code>string_view</code> with the <code>std::string s1</code> (line 12), but you can also initialize a <code>string_view</code> with a C-string.</p>&#13;
<div class="group" id="fig8_9">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig09" id="aa08fig09">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_09.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// C++17 string_view.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="yell"><span class="blue">#include</span> &lt;string_view&gt;</span></code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>8</strong></span>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>10</strong></span>       <code>string s1{<span class="green">"red"</span>};</code>&#13;
<span class="cviolet"><strong>11</strong></span>       <code>string s2{s1};</code>&#13;
<span class="cviolet"><strong>12</strong></span>       <code><span class="yell">string_view v1{s1};</span> <span class="pd_green">// v2 "sees" the contents of s1</span></code>&#13;
<span class="cviolet"><strong>13</strong></span>       <code>cout &lt;&lt; fmt::format(<span class="green">"s1: {}\ns2: {}\nv1: {}\n\n"</span>, s1, s2, v1);</code>&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<pre class="pre1"><code>s1: red</code>&#13;
<code>s2: red</code>&#13;
<code>v1: red</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.9</strong></span> C++17 <code>string_view</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec20"><code>string_view</code>s <code>“</code>See<code>”</code> Changes to the Characters They View</h5>&#13;
<p>Because a <code>string_view</code> does not own the sequence of characters it views, it “sees” any changes to the original characters. Line 16 modifies the <code>std::string s1</code>. Then line 17 shows <code>s1</code>’s, <code>s2</code>’s and the <code>string_view v1</code>’s contents.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0242-01" id="f0242-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>15</strong></span>    <span class="pd_green">// string_views see changes to the characters they view</span>&#13;
<span class="cviolet"><strong>16</strong></span>    s1.at(<span class="green">0</span>) = <span class="green">'R'</span>; <span class="pd_green">// capitalize s1</span>&#13;
<span class="cviolet"><strong>17</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"s1: {}\ns2: {}\nv1: {}\n\n"</span>, s1, s2, v1);&#13;
<span class="cviolet"><strong>18</strong></span></pre>&#13;
<pre class="pre1">s1: Red&#13;
s2: red&#13;
v1: Red</pre>&#13;
<h5 class="h5" id="ch08lev3sec21"><code>string_view</code>s Are Comparable with <code>std::string</code>s or <code>string_view</code>s</h5>&#13;
<p>Like <code>std::string</code>, <code>string_view</code>s are comparable with the relational and equality operators. You also can intermix <code>std::string</code>s and <code>string_view</code>s as in the equality comparisons in line 21.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0242-02" id="f0242-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>19</strong></span>    <span class="pd_green">// string_views are comparable with strings or string_views</span>&#13;
<span class="cviolet"><strong>20</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"s1 == v1: {}\ns2 == v1: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>21</strong></span>               <span class="yell">s1 == v1</span>, <span class="yell">s2 == v1</span>);&#13;
<span class="cviolet"><strong>22</strong></span></pre>&#13;
<pre class="pre1">s1 == v1: true&#13;
s2 == v1: false</pre>&#13;
<h5 class="h5" id="ch08lev3sec22"><code>string_view</code>s Can Remove a Prefix or Suffix</h5>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> You can easily remove a specified number of characters from the beginning or end of a <code>string_view</code>. These are fast operations for a <code>string_view</code>—they simply adjust the character count and, in the case of removing from the beginning, move the pointer to the first character in the <code>string_view</code>. Lines 24–25 call <code>string_view</code> member functions <code><span class="violet"><strong>remove_prefix</strong></span></code> and <code><span class="violet"><strong>remove_suffix</strong></span></code> to remove one character from the beginning and one from the end of <code>v1</code>, respectively. Note that <code>s1</code> remains unmodified.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0242-03" id="f0242-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>23</strong></span>    <span class="pd_green">// string_view can remove a prefix or suffix</span>&#13;
<span class="cviolet"><strong>24</strong></span>    <span class="yell">v1.remove_prefix(<span class="green">1</span>);</span> <span class="pd_green">// remove one character from the front</span>&#13;
<span class="cviolet"><strong>25</strong></span>    <span class="yell">v1.remove_suffix(<span class="green">1</span>);</span> <span class="pd_green">// remove one character from the back</span>&#13;
<span class="cviolet"><strong>26</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"s1: {}\nv1: {}\n\n"</span>, s1, v1);&#13;
<span class="cviolet"><strong>27</strong></span></pre>&#13;
<pre class="pre1">s1: Red&#13;
v1: e</pre>&#13;
<h5 class="h5" id="ch08lev3sec23"><code>string_view</code>s Are Iterable</h5>&#13;
<p>Line 29 initializes a <code>string_view</code> from a C-string. Like <code>std::string</code>s, <code>string_view</code>s are iterable, so you can use them with the range-based <code>for</code> statement (as in lines 31–33).</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0243-02" id="f0243-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>28</strong></span>    <span class="pd_green">// string_views are iterable</span>&#13;
<span class="cviolet"><strong>29</strong></span>    <span class="yell">string_view v2{<span class="green">"C-string"</span>};</span>&#13;
<span class="cviolet"><strong>30</strong></span>    cout &lt;&lt; <span class="green">"The characters in v2 are: "</span>;&#13;
<span class="cviolet"><strong>31</strong></span>    <span class="yell"><span class="blue">for</span> (<span class="blue">const char</span> c : v2)</span> {&#13;
<span class="cviolet"><strong>32</strong></span>       cout &lt;&lt; c &lt;&lt; <span class="green">" "</span>;&#13;
<span class="cviolet"><strong>33</strong></span>    }&#13;
<span class="cviolet"><strong>34</strong></span></pre>&#13;
<pre class="pre1">The characters in v2 are: C - s t r i n g</pre>&#13;
<h5 class="h5" id="ch08lev3sec24"><code>string_view</code>s Enable Various String Operations on C-Strings</h5>&#13;
<p>Many <code>std::string</code> member functions that do not modify a string also are defined for <code>string_view</code>s. For example, line 36 calls <code><span class="violet"><strong>size</strong></span></code> to determine the number of characters in the <code>string_view</code>, line 37 calls <code><span class="violet"><strong>find</strong></span></code> to get the index of <code>'-'</code> in the <code>string_view</code>. Line 38 uses the new C++20 <code><span class="violet"><strong>starts_with</strong></span></code> function to determine whether the <code>string_view</code> starts with <code>'C'</code>. For a complete list of <code>string_view</code> member functions, see</p>&#13;
<pre class="pre"><a href="https://en.cppreference.com/w/cpp/string/basic_string_view">https://en.cppreference.com/w/cpp/string/basic_string_view</a></pre>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0243-03" id="f0243-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>35</strong></span>    <span class="pd_green">// string_views enable various string operations on C-Strings</span>&#13;
<span class="cviolet"><strong>36</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"\n\nv2.size(): {}\n"</span>, <span class="yell">v2.size()</span>);&#13;
<span class="cviolet"><strong>37</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"v2.find('-'): {}\n"</span>, <span class="yell">v2.find(<span class="green">'-'</span>)</span>);&#13;
<span class="cviolet"><strong>38</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"v2.starts_with('C'): {}\n"</span>, <span class="yell">v2.starts_with(<span class="green">'C'</span>)</span>);&#13;
<span class="cviolet"><strong>39</strong></span>  }</pre>&#13;
<pre class="pre1">v2.size(): 8&#13;
v2.find('-'): 1&#13;
v2.starts_with('C'): true</pre>&#13;
<h3 class="h3" id="ch08lev1sec12"><span class="violet">8.12</span> Files and Streams</h3>&#13;
<p>C++ views each file simply as <em>a</em> sequence of bytes:</p>&#13;
<div class="group">&#13;
<div class="images"><img src="Images/p0341-01.jpg" alt="Images" width="716" height="65"/></div>&#13;
</div>&#13;
<p>Each file ends either with an <span class="violet"><strong>end-of-file marker</strong></span> or at a specific byte number recorded in an operating-system-maintained administrative data structure. When a file is opened, an object is created, and a stream is associated with the object. The objects <code>cin</code>, <code>cout</code>, <code>cerr</code> and <code>clog</code> are created for you in the header <code>&lt;iostream&gt;</code>. The streams associated with these objects provide communication channels between a program and a particular file or device. The <code>cin</code> object (standard input stream object) enables a program to input data from the keyboard or other devices. The <code>cout</code> object (standard output stream object) enables a program to output data to the screen or other devices. The objects <code>cerr</code> and <code>clog</code> objects (standard error stream objects) enable a program to output error messages to the screen or other devices. Messages written to <code>cerr</code> are output immediately. In contrast, messages written to <code>clog</code> are stored in a memory object called a buffer. When the buffer is full, its contents are written to the standard error stream.</p>&#13;
<h5 class="h5" id="ch08lev3sec25">File-Processing Streams</h5>&#13;
<p>To perform file processing in C++, headers <code>&lt;iostream&gt;</code> and <code>&lt;fstream&gt;</code> must be included. Header <code>&lt;fstream&gt;</code> includes the following definitions:</p>&#13;
<p class="bull">• <code>ifstream</code> is for file input that reads <code>char</code>s.</p>&#13;
<p class="bull">• <code>ofstream</code> is for file output that writes <code>char</code>s.</p>&#13;
<p class="bull">• <code>fstream</code> combines the capabilities of <code>ifstream</code> and <code>ofstream</code>.</p>&#13;
<p>The <code>cout</code> and <code>cin</code> capabilities we’ve discussed so far and the additional I/O features we describe in <a href="ch18.xhtml#ch18">Chapter 18</a> also can be applied to file streams.</p>&#13;
<h3 class="h3" id="ch08lev1sec13"><span class="violet">8.13</span> Creating a Sequential File</h3>&#13;
<p>C++ imposes no structure on files. Thus, a concept like that of a record (Section 1.4) does not exist in C++. You must structure files to meet the application’s requirements. The following example shows how you can impose a simple record structure on a file.</p>&#13;
<p><a href="#fig8_10">Figure 8.10</a> creates a sequential file that might be used in an accounts-receivable system to help keep track of the money owed to a company by its credit clients. For each client, the program obtains the client’s account number, name and balance (i.e., the amount the client owes the company for goods and services received in the past). The data obtained for each client constitutes a record for that client.</p>&#13;
<div class="group" id="fig8_10">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig10" id="aa08fig10">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_10.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Creating a sequential file.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="yell"><span class="blue">#include</span> &lt;cstdlib&gt;</span> <span class="pd_green">// exit function prototype</span></code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="yell"><span class="blue">#include</span> &lt;fstream&gt;</span> <span class="pd_green">// contains file stream processing types</span></code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>11</strong></span>      <code><span class="pd_green">// ofstream opens the file</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>      <code><span class="blue">if</span> (<span class="yell">ofstream output{<span class="green">"clients.txt"</span>, ios::out}</span>; <span class="yell">output</span>) {</code>&#13;
<span class="cviolet"><strong>13</strong></span>         <code>cout &lt;&lt; <span class="green">"Enter the account, name, and balance.\n"</span></code>&#13;
<span class="cviolet"><strong>14</strong></span>            <code>&lt;&lt; <span class="green">"Enter end-of-file to end input.\n? "</span>;</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>         <code><span class="blue">int</span> account;</code>&#13;
<span class="cviolet"><strong>17</strong></span>         <code>string name;</code>&#13;
<span class="cviolet"><strong>18</strong></span>         <code><span class="blue">double</span> balance;</code>&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>         <code><span class="pd_green">// read account, name and balance from cin, then place in file</span></code>&#13;
<span class="cviolet"><strong>21</strong></span>         <code><span class="blue">while</span> (<span class="yell">cin &gt;&gt; account &gt;&gt; name &gt;&gt; balance</span>) {</code>&#13;
<span class="cviolet"><strong>22</strong></span>            <code>output &lt;&lt; fmt::format(<span class="green">"{} {} {}\n? "</span>, account, name, balance);</code>&#13;
<span class="cviolet"><strong>23</strong></span>         <code>}</code>&#13;
<span class="cviolet"><strong>24</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>25</strong></span>      <code><span class="blue">else</span> {</code>&#13;
<span class="cviolet"><strong>26</strong></span>         <code>cerr &lt;&lt; <span class="green">"File could not be opened\n"</span></code>;&#13;
<span class="cviolet"><strong>27</strong></span>         <code>exit(<span class="green">EXIT_FAILURE</span>);</code>&#13;
<span class="cviolet"><strong>28</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>29</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Enter the account, name, and balance.</code>&#13;
<code>Enter end-of-file to end input.</code>&#13;
<code>? <strong>100 Jones 24.98</strong></code>&#13;
<code>? <strong>200 Doe 345.67</strong></code>&#13;
<code>? <strong>300 White 0.00</strong></code>&#13;
<code>? <strong>400 Stone -42.16</strong></code>&#13;
<code>? <strong>500 Rich 224.62</strong></code>&#13;
<code>? <strong>^Z</strong></code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.10</strong></span> Creating a sequential file.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec26">Opening a File</h5>&#13;
<p><a href="#fig8_10">Figure 8.10</a> writes data to a file, so we open the file for output by creating an <code>ofstream</code> object (line 12). Two arguments are used to initialize the <code>ofstream</code>—the <span class="violet"><strong>filename</strong></span> and the <span class="violet"><strong>file-open mode</strong></span>. For an <code>ofstream</code> object, the file-open mode can be</p>&#13;
<p class="bull">• <code><span class="violet"><strong>ios::out</strong></span></code> (the default) to output data to a file or</p>&#13;
<p class="bull">• <code><span class="violet"><strong>ios::app</strong></span></code> to append data to the end of a file (without modifying any data already in the file).</p>&#13;
<p><span class="size">11</span> <span class="size">17</span> Line 12 creates the <code>ofstream</code> object <code>output</code> associated with the file <code>clients.txt</code> and opens it for output. We did not specify a path to the file (that is, its location), so it’splaced in the same directory as the program. Before C++11, the filename was specified as a pointer-based string. C++11 added specifying the filename as a <code>string</code> object. C++17 introduced the <code><span class="violet"><strong>&lt;filesystem&gt;</strong></span></code> <span class="violet"><strong>header</strong></span> with features for manipulating files and folders in C++. As of C++17, you also may specify the file to open as a <code><span class="violet"><strong>filesystem::path</strong></span></code> object.</p>&#13;
<p>Since <code>ios::out</code> is the default, the second argument in line 12 is not required, so we could have used:</p>&#13;
<pre class="pre">ofstream output{<span class="green">"clients.txt"</span>}</pre>&#13;
<p>Existing files opened with mode <code>ios::out</code> are <span class="violet"><strong>truncated</strong></span>—all data in the file is discarded. If the file does not yet exist, the <code>ofstream</code> object creates the file. The following table lists the file-open modes—these modes can also be combined:</p>&#13;
<div class="group">&#13;
<div class="images"><img src="Images/p0344-01.jpg" alt="Images" width="751" height="270"/></div>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec27">Opening a File via the <code>open</code> Member Function</h5>&#13;
<p>You can create an <code>ofstream</code> object without opening a specific file. In this case, a file can be attached to the object later. For example, the statement</p>&#13;
<pre class="pre">ofstream output;</pre>&#13;
<p>creates an <code>ofstream</code> object that’s not yet associated with a file. The <code>ofstream</code> member function <code><span class="violet"><strong>open</strong></span></code> opens a file and attaches it to an existing <code>ofstream</code> object as follows:</p>&#13;
<pre class="pre">output.open(<span class="green">"clients.txt"</span>, <span class="green">ios::out</span>);</pre>&#13;
<p>Again, <code>ios::out</code> is the default value for the second argument. Use caution when opening an existing file for output (<code>ios::out</code>), especially when you want to preserve the file’s contents, which will be discarded without warning.</p>&#13;
<h5 class="h5" id="ch08lev3sec28">Testing Whether a File Was Opened Successfully</h5>&#13;
<p><span class="size">11</span> After creating an <code>ofstream</code> object and attempting to open it, the <code>if</code> statement uses the file object <code>output</code> as a condition (line 12) to determine whether the <code>open</code> operation succeeded. For a file object, there is an overloaded <code>operator bool</code> (added in C++11) that implicitly evaluates the file object to <code>true</code> if the file opened successfully. Some possible reasons opening a file might fail are:</p>&#13;
<p class="bull">• attempting to open a nonexistent file for reading</p>&#13;
<p class="bull">• attempting to open a file for reading or writing in a directory that you don’t have permission to access, and</p>&#13;
<p class="bull">• <img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> opening a file for writing when no secondary storage space is available.</p>&#13;
<p>If the condition indicates an unsuccessful attempt to open the file, line 26 outputs an error message, and line 27 invokes function <code>exit</code> to terminate the program. The argument to <code>exit</code> is returned to the environment from which the program was invoked. Passing <code>EXIT_SUCCESS</code> (defined in <code>&lt;cstdlib&gt;</code>) to <code>exit</code> indicates that the program terminated normally; passing any other value (in this case, <code>EXIT_FAILURE</code>) indicates that the program terminated due to an error.</p>&#13;
<h5 class="h5" id="ch08lev3sec29">Processing Data</h5>&#13;
<p>If line 12 opens the file successfully, the program begins processing data. Lines 13–14 prompt the user to enter either the various fields for each record or the end-of-file indicator when data entry is complete. To enter end-of-file key on Linux or macOS type <em>&lt;Ctrl-d&gt;</em> (on a line by itself). On Microsoft Windows, type <em>&lt;Ctrl-z&gt;</em> then press <em>Enter</em>.</p>&#13;
<p>The <code>while</code> statement’s condition (line 21) implicitly invokes the <code>operator bool</code> member function on <code>cin</code>. The condition remains <code>true</code> as long as each input operation with <code>cin</code> is successful. Entering the end-of-file indicator causes the <code>operator bool</code> member function to return <code>false</code>. You also can call member function <code>eof</code> on the input object to determine whether the end-of-file indicator has been entered.</p>&#13;
<p>Line 21 extracts each set of data into the variables <code>account</code>, <code>name</code> and <code>balance</code>, and determines whether end-of-file has been entered. When end-of-file is encountered (that is, when the user enters the end-of-file key combination) or an input operation fails, the <code>operator bool</code> returns <code>false</code>, and the <code>while</code> statement terminates.</p>&#13;
<p>Line 28 writes a set of data to the file <code>clients.txt</code>, using the stream insertion operator <code>&lt;&lt;</code> and the <code>output</code> object associated with the file at the beginning of the program. The data may be retrieved by a program designed to read the file (see <a href="#ch08lev1sec14">Section 8.14</a>). The file created in <a href="#fig8_10">Fig. 8.10</a> is simply a text file—it can be viewed by any text editor.</p>&#13;
<h5 class="h5" id="ch08lev3sec30">Closing a File</h5>&#13;
<p>Once the user enters the end-of-file indicator, the <code>while</code> loop terminates. At this point, the <code>output</code> object goes out of scope, which automatically closes the file. You should always close a file as soon as it’s no longer needed in a program. You also can close a file object explicitly, using member function <code><span class="violet"><strong>close</strong></span></code>, as in:</p>&#13;
<pre class="pre">output.close();</pre>&#13;
<h5 class="h5" id="ch08lev3sec31">Sample Execution</h5>&#13;
<p>In the sample execution of <a href="#fig8_10">Fig. 8.10</a>, the user enters information for five accounts, then signals that data entry is complete by entering end-of-file (<code>^Z</code> is displayed for Microsoft Windows). This dialog window does not show how the data records appear in the file. The next section shows how to create a program that reads this file and prints its contents.</p>&#13;
<h3 class="h3" id="ch08lev1sec14"><span class="violet">8.14</span> Reading Data from a Sequential File</h3>&#13;
<p>The previous section demonstrated how to create a sequential-access file. <a href="#fig8_11">Figure 8.11</a> reads data sequentially from a file and displays the records from the <code>clients.txt</code> file that we wrote in <a href="#fig8_10">Fig. 8.10</a>. Creating an <code>ifstream</code> object opens a file for input. An <code>ifstream</code> is initialized with a filename and file-open mode<em>.</em> Line 12 creates an <code>ifstream</code> object called <code>input</code> that opens the <code>clients.txt</code> file for reading. If a file’s contents should not be modified, use <code><span class="violet"><strong>ios::in</strong></span></code> to open it only for input to prevent unintentional modification of the file’s contents.</p>&#13;
<div class="group" id="fig8_11">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig11" id="aa08fig11">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_11.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Reading and printing a sequential file.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;cstdlib&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;fstream&gt; <span class="pd_green">// file stream</span></code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>11</strong></span>      <code><span class="pd_green">// ifstream opens the file</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>      <code><span class="blue">if</span> (<span class="yell">ifstream input{<span class="green">"clients.txt"</span>, <span class="green">ios::in</span>}</span>; <span class="yell">input</span>) {</code>&#13;
<span class="cviolet"><strong>13</strong></span>         <code>cout &lt;&lt; fmt::format("{:<span class="green">&lt;10}{:&lt;13}{}\n",</span></code>&#13;
<span class="cviolet"><strong>14</strong></span>                    <code><span class="green">"Account"</span>, <span class="green">"Name"</span>, <span class="green">"Balance"</span>);</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>         <code><span class="blue">int</span> account;</code>&#13;
<span class="cviolet"><strong>17</strong></span>         <code>string name;</code>&#13;
<span class="cviolet"><strong>18</strong></span>         <code><span class="blue">double</span> balance;</code>&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>         <code><span class="pd_green">// display each record in file</span></code>&#13;
<span class="cviolet"><strong>21</strong></span>         <code><span class="blue">while</span> (<span class="yell">input &gt;&gt; account &gt;&gt; name &gt;&gt; balance</span>) {</code>&#13;
<span class="cviolet"><strong>22</strong></span>            <code>cout &lt;&lt; fmt::format("{:&lt;1<span class="green">0}{:&lt;13}{:&gt;7.2f}\n",</span></code>&#13;
<span class="cviolet"><strong>23</strong></span>               <code>account, name, balance);</code>&#13;
<span class="cviolet"><strong>24</strong></span>         <code>}</code>&#13;
<span class="cviolet"><strong>25</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>26</strong></span>      <code><span class="blue">else</span> {</code>&#13;
<span class="cviolet"><strong>27</strong></span>         <code>cerr &lt;&lt; <span class="green">"File could not be opened\n"</span>;</code>&#13;
<span class="cviolet"><strong>28</strong></span>         <code>exit(<span class="green">EXIT_FAILURE);</span></code>&#13;
<span class="cviolet"><strong>29</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>30</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Account	Name	Balance</code>&#13;
<code>100 	Jones 	  24.98</code>&#13;
<code>200 	Doe 	 345.67</code>&#13;
<code>300 	White 	   0.00</code>&#13;
<code>400 	Stone 	 -42.16</code>&#13;
<code>500 	Rich 	 224.62</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.11</strong></span> Reading and printing a sequential file.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec32">Opening a File for Input</h5>&#13;
<p>Objects of class <code>ifstream</code> are opened for input by default, so</p>&#13;
<pre class="pre">ifstream input(<span class="green">"clients.txt"</span>);</pre>&#13;
<p>opens <code>clients.txt</code> for input. An <code>ifstream</code> object can be created without opening a file—you can attach one to it later. Before attempting to retrieve data from the file, line 12 uses the <code>input</code> object as a condition to determine whether the file was opened successfully. The overloaded operator <code>bool</code> converts the <code>ifstream</code> object to a <code>true</code> or <code>false</code> value.</p>&#13;
<h5 class="h5" id="ch08lev3sec33">Reading from the File</h5>&#13;
<p>Line 21 reads a set of data (i.e., a record) from the file. After line 21 executes the first time, <code>account</code> has the value <code>100</code>, <code>name</code> has the value <code>"Jones"</code> and <code>balance</code> has the value <code>24.98</code>. Each time line 21 executes, it reads another record into the variables <code>account</code>, <code>name</code> and <code>balance</code>. Lines 22–23 display the records. When the end of the file is reached, the implicit call to <code>operator bool</code> in the <code>while</code> condition returns <code>false</code>, the <code>ifstream</code> object goes out of scope (which automatically closes the file), and the program terminates.</p>&#13;
<h5 class="h5" id="ch08lev3sec34">File-Position Pointers</h5>&#13;
<p>Programs often read sequentially from the beginning of a file and read all the data consecutively until the desired data is found. It might be necessary to process the file sequentially several times (from the beginning) during the execution of a program. <code>istream</code> and <code>ost-ream</code> provide member functions <code><span class="violet"><strong>seekg</strong></span></code> (“seek get”) and <code><span class="violet"><strong>seekp</strong></span></code> (“seek put”) to reposition the <span class="violet"><strong>file-position pointer</strong></span>. This represents the byte number of the next byte in the file to be read or written. Each <code>istream</code> object has a <span class="violet"><strong>get pointer</strong></span>, which indicates the byte number in the file from which the next input is to occur. Each <code>ostream</code> object has a <span class="violet"><strong>put pointer</strong></span>, which indicates the byte number in the file at which the next output should be placed. The statement</p>&#13;
<pre class="pre">input.seekg(<span class="green">0</span>);</pre>&#13;
<p>repositions the file-position pointer to the beginning of the file (location <code>0</code>) attached to <code>input</code>. The argument to <code>seekg</code> is an integer. If the end-of-file indicator has been set, you’d also need to execute</p>&#13;
<pre class="pre">input.clear();</pre>&#13;
<p>to re-enable reading from the stream.</p>&#13;
<p>An optional second argument indicates the <span class="violet"><strong>seek direction</strong></span>;</p>&#13;
<p class="bull">• <code><span class="violet"><strong>ios::beg</strong></span></code> (the default) for positioning relative to the beginning of a stream,</p>&#13;
<p class="bull">• <code><span class="violet"><strong>ios::cur</strong></span></code> for positioning relative to the current position in a stream or</p>&#13;
<p class="bull">• <code><span class="violet"><strong>ios::end</strong></span></code> for positioning backward relative to the end of a stream.</p>&#13;
<p>The file-position pointer is an integer value that specifies the location in the file as the number of bytes from the file’s starting location. This is also referred to as the <span class="violet"><strong>offset</strong></span> from the beginning of the file. Some examples of positioning the <em>get</em> file-position pointer are</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0249-01" id="f0249-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="pd_green">// position to the nth byte of fileObject (assumes ios::beg)</span>&#13;
fileObject.seekg(n);</pre>&#13;
<pre class="pre"><span class="pd_green">// position n bytes in fileObject</span>&#13;
fileObject.seekg(n, <span class="green">ios::cur</span>);</pre>&#13;
<pre class="pre"><span class="pd_green">// position n bytes back from end of fileObject</span>&#13;
fileObject.seekg(n, <span class="green">ios::end</span>);</pre>&#13;
<pre class="pre"><span class="pd_green">// position at end of fileObject</span>&#13;
fileObject.seekg(<span class="green">0</span>, <span class="green">ios::end</span>);</pre>&#13;
<p>The same operations can be performed using <code>ostream</code> member function <code>seekp</code>. Member functions <code><span class="violet"><strong>tellg</strong></span></code> and <code><span class="violet"><strong>tellp</strong></span></code> are provided to return the current locations of the <em>get</em> and <em>put</em> pointers, respectively. The following statement assigns the <em>get</em> file-position pointer value to variable <code>location</code> of type <code>long</code>:</p>&#13;
<pre class="pre">location = fileObject.tellg();</pre>&#13;
<h3 class="h3" id="ch08lev1sec15"><span class="violet">8.15</span> C++14 Reading and Writing Quoted Text</h3>&#13;
<p><span class="size">14</span> Many text files contain quoted text, such as <code>"C++20 for Programmers"</code>. For example, in files representing HTML5 web pages, attribute values are enclosed in quotes. If you’re building a web browser to display the contents of such a web page, you must be able to read those quoted strings and remove the quotes.</p>&#13;
<p>Suppose you need to read from a text file, as you did in <a href="#fig8_11">Fig. 8.11</a>, but with each account’s data formatted as follows:</p>&#13;
<pre class="pre">100 "Janie Jones" 24.98</pre>&#13;
<p>Recall that the stream extraction operator <code>&gt;&gt;</code> treats white space as a delimiter. So, if we read the preceding data using the expression in line 30 of <a href="#fig8_11">Fig. 8.11</a>:</p>&#13;
<pre class="pre">input &gt;&gt; account &gt;&gt; name &gt;&gt; balance</pre>&#13;
<p>the first stream extraction reads <code>100</code> into the <code>int</code> variable <code>account</code>, and the second reads only <code>"Janie</code> into the <code>string</code> variable <code>name</code>. The opening double quote would be part of the <code>string</code> in <code>name</code>. The third stream extraction fails while attempting to read a value for the <code>double</code> variable <code>balance</code> because the next token (i.e., piece of data) in the input stream—<code>Jones"</code>—is not a <code>double</code>.</p>&#13;
<h5 class="h5" id="ch08lev3sec35">Reading Quoted Text</h5>&#13;
<p><span class="size">14</span> C++14 added the stream manipulator <code><span class="violet"><strong>quoted</strong></span></code> (header <code>&lt;iomanip&gt;</code>) for reading quoted text from a stream. It includes any white space characters in the quoted text and discards the double-quote delimiters. For example, if we read the preceding data, the expression:</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0250-01" id="f0250-01a">Click here to view code image</a></p>&#13;
<pre class="pre">input &gt;&gt; account &gt;&gt; quoted(name) &gt;&gt; balance</pre>&#13;
<p>reads <code>100</code> into <code>account</code>, reads <code>Janie Jones</code> as one <code>string</code> into <code>name</code>, and reads <code>24.98</code> into <code>balance</code>. If the quoted data contains <code>\"</code> escape sequences, each is read and stored in the <code>string</code> as the escape sequence <code>\"</code>—not as <code>"</code>.</p>&#13;
<h5 class="h5" id="ch08lev3sec36">Writing Quoted Text</h5>&#13;
<p>Similarly, you can write quoted text to a stream. For example, if <code>name</code> contains <code>Janie Jones</code>, the statement:</p>&#13;
<pre class="pre">outputStream &lt;&lt; quoted(name);</pre>&#13;
<p>writes to the text-based <code>outputStream</code>:</p>&#13;
<pre class="pre">"Janie Jones"</pre>&#13;
<h3 class="h3" id="ch08lev1sec16"><span class="violet">8.16</span> Updating Sequential Files</h3>&#13;
<p>Data that is formatted and written to a sequential file, as shown in <a href="#ch08lev1sec13">Section 8.13</a>, cannot be modified in place without the risk of destroying other data in the file. For example, if the name “<code>White</code>” needs to be changed to “<code>Worthington</code>,” the old name cannot be overwritten without corrupting the file. The record for <code>White</code> was written to the file as</p>&#13;
<pre class="pre">300 White 0.00</pre>&#13;
<p>If this record were rewritten beginning at the same location in the file using the longer name, the record would be</p>&#13;
<pre class="pre">300 Worthington 0.00</pre>&#13;
<p>The new record contains six more characters than the original. Any characters after “<code>h</code>” in “<code>Worthington</code>” would overwrite <code>0.00</code> and the beginning of the next sequential record in the file. The problem with the formatted input/output model using the stream insertion operator <code>&lt;&lt;</code> and the stream extraction operator <code>&gt;&gt;</code> is that fields—and hence records—can vary in size. For example, values 7, 14, –117, 2074, and 27383 are all <code>int</code>s, which store the same number of “raw data” bytes internally (typically four bytes on 32-bit machines and eight bytes on 64-bit machines). However, these integers become different-sized fields, depending on their actual values, when output as formatted text (character sequences). Therefore, the formatted input/output model usually is not used to update records in place.</p>&#13;
<p>Such updating can be done with sequential files, but awkwardly. For example, to make the preceding name change in a sequential file, we could:</p>&#13;
<p class="bull">• copy the records before <code>300 White 0.00</code> to a new file,</p>&#13;
<p class="bull">• write the updated record to the new file, then</p>&#13;
<p class="bull">• write the records after <code>300 White 0.00</code> to the new file.</p>&#13;
<p>Then we could delete the old file and rename the new one. This requires processing every record in the file to update one record. If many records are being updated in one pass of the file, though, this technique can be acceptable.</p>&#13;
<h3 class="h3" id="ch08lev1sec17"><span class="violet">8.17</span> String Stream Processing</h3>&#13;
<p>In addition to standard stream I/O and file stream I/O, C++ stream I/O includes capabilities for inputting from, and outputting to, <code>string</code>s in memory. These capabilities often are referred to as <span class="violet"><strong>in-memory I/O</strong></span> or <span class="violet"><strong>string stream processing</strong></span>. You can read from a <code>string</code> with <code><span class="violet"><strong>istringstream</strong></span></code> and write to a <code>string</code> with <code><span class="violet"><strong>ostringstream</strong></span></code>.</p>&#13;
<p>Class templates <code>istringstream</code> and <code>ostringstream</code> provide the same functionality as classes <code>istream</code> and <code>ostream</code> plus other member functions specific to in-memory formatting. Programs that use in-memory formatting must include the <code><span class="violet"><strong>&lt;sstream&gt;</strong></span></code> and <code>&lt;iost-ream&gt;</code> headers. An <code>ostringstream</code> object uses a <code>string</code> object to store the output data. Its <code><span class="violet"><strong>str</strong></span></code> member function returns a copy of that <code>string</code>.</p>&#13;
<p>One application of string stream processing is data validation. A program can read an entire line at a time from the input stream into a <code>string</code>. Next, a validation routine can scrutinize the <code>string</code>’s contents and correct (or repair) the data, if necessary. Then the program can input from the <code>string</code>, knowing that the input data is in the proper format.</p>&#13;
<p><span class="size">11</span> To assist with data validation, C++11 added powerful pattern-matching regular-expression capabilities. For instance, in a program requiring a U.S. format telephone number (e.g., <code>(800) 555-1212</code>), you can use a regular expression to confirm that a string matches that format. Many websites provide regular expressions for validating e-mail addresses, URLs, phone numbers, addresses and other popular kinds of data. We introduce regular expressions and provide several examples in <a href="#ch08lev1sec20">Section 8.20</a>.</p>&#13;
<h5 class="h5" id="ch08lev3sec37">Demonstrating <code>ostringstream</code></h5>&#13;
<p><a href="#fig8_12">Figure 8.12</a> creates an <code>ostringstream</code> object, then uses the stream insertion operator to output a series of <code>string</code>s and numerical values to the object.</p>&#13;
<div class="group" id="fig8_12">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig12" id="aa08fig12">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_12.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Using an ostringstream object.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="yell"><span class="blue">#include</span> &lt;sstream&gt;</span> <span class="pd_green">// header for string stream processing</span></code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
 <span class="cviolet"><strong>9</strong></span>      <code><span class="yell">ostringstream output;</span> <span class="pd_green">// create ostringstream object</span></code>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>      <code><span class="blue">const</span> string string1{<span class="green">"Output of several data types "</span>};</code>&#13;
<span class="cviolet"><strong>12</strong></span>      <code><span class="blue">const</span> string string2{<span class="green">"to an ostringstream object:"</span>};</code>&#13;
<span class="cviolet"><strong>13</strong></span>      <code><span class="blue">const</span> string string3{<span class="green">"\n        double: "</span>};</code>&#13;
<span class="cviolet"><strong>14</strong></span>      <code><span class="blue">const</span> string string4{<span class="green">"\n           int: "</span>};</code>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <code><span class="blue">constexpr double</span> s{<span class="green">123.4567</span>};</code>&#13;
<span class="cviolet"><strong>17</strong></span>      <code><span class="blue">constexpr int</span> i{<span class="green">22</span>};</code>&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <code><span class="pd_green">// output strings, double and int to ostringstream</span></code>&#13;
<span class="cviolet"><strong>20</strong></span>      <code><span class="yell">output &lt;&lt; string1 &lt;&lt; string2 &lt;&lt; string3 &lt;&lt; d &lt;&lt; string4 &lt;&lt; i;</span></code>&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>      <code><span class="pd_green">// call str to obtain string contents of the ostringstream</span></code>&#13;
<span class="cviolet"><strong>23</strong></span>      <code>cout &lt;&lt; <span class="green">"output contains:\n"</span> &lt;&lt; <span class="yell">output.str();</span></code>&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>      <code><span class="pd_green">// add additional characters and call str to output string</span></code>&#13;
<span class="cviolet"><strong>26</strong></span>      <code><span class="yell">output &lt;&lt; <span class="green">"\nmore characters added"</span>;</span></code>&#13;
<span class="cviolet"><strong>27</strong></span>      <code>cout &lt;&lt; <span class="green">"\n\nafter additional stream insertions, output contains:\n"</span></code>&#13;
<span class="cviolet"><strong>28</strong></span>      <code>&lt;&lt; <span class="green">""</span> &lt;&lt; <span class="yell">output.str()</span> &lt;&lt; endl;</code>&#13;
<span class="cviolet"><strong>29</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1"><code>outputString contains:</code>&#13;
<code>Output of several data types to an ostringstream object:</code>&#13;
<code>double: 123.457</code>&#13;
   <code>int: 22</code>&#13;
&#13;
<code>after additional stream insertions, outputString contains:</code>&#13;
<code>Output of several data types to an ostringstream object:</code>&#13;
<code>double: 123.457</code>&#13;
   <code>int: 22</code>&#13;
<code>more characters added</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.12</strong></span> Using an <code>ostringstream</code> object.</p>&#13;
</div>&#13;
<p>Line 20 outputs <code>string string1</code>, <code>string string2</code>, <code>string string3</code>, <code>double d</code>, <code>string string4</code> and <code>int i</code>—all to <code>output</code> in memory. Line 23 displays <code>output.str()</code>, which returns the <code>string</code> created by <code>output</code> in line 20. Line 25 appends more data to the <code>string</code> in memory by simply issuing another stream insertion operation to <code>output</code>, then lines 27–28 display the updated contents.</p>&#13;
<h5 class="h5" id="ch08lev3sec38">Demonstrating <code>istringstream</code></h5>&#13;
<p>An <code>istringstream</code> object inputs data from a <code>string</code> in memory. Data is stored in an <code>istringstream</code> object as characters. Input from the <code>istringstream</code> object works identically to input from any file. The end of the <code>string</code> is interpreted by the <code>istringstream</code> object as end-of-file.</p>&#13;
<p><a href="#fig8_13">Figure 8.13</a> demonstrates input from an <code>istringstream</code> object. Lines 9–10 create <code>string inputString</code> containing the data and <code>istringstream</code> object <code>input</code> constructed to read from <code>inputString</code>, which consists of two strings (<code>"Amanda"</code> and <code>"test"</code>), an <code>int</code> (<code>123</code>), a <code>double</code> (<code>4.7</code>) and a <code>char</code> (<code>'A'</code>). These are read into variables <code>s1</code>, <code>s2</code>, <code>i</code>, <code>d</code> and <code>c</code> in line 18, then displayed in lines 20–21. Next, the program attempts to read from <code>input</code> again in line 24, but the operation fails because there is no more data in <code>inputString</code>. So the <code>input</code> evaluates to <code>false</code>, and the <code>else</code> part of the <code>if</code>…<code>else</code> statement executes.</p>&#13;
<div class="group" id="fig8_13">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig13" id="aa08fig13">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_13.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Demonstrating input from an istringstream object.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="yell"><span class="blue">#include</span> &lt;sstream&gt;</span></code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>8</strong></span>&#13;
 <span class="cviolet"><strong>9</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>10</strong></span>      <code><span class="blue">const</span> string inputString{<span class="green">"Amanda test 123 4.7 A"</span>};</code>&#13;
<span class="cviolet"><strong>11</strong></span>      <code><span class="yell">istringstream input{inputString};</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>      <code>string s1;</code>&#13;
<span class="cviolet"><strong>13</strong></span>      <code>string s2;</code>&#13;
<span class="cviolet"><strong>14</strong></span>      <code><span class="blue">int</span> i;</code>&#13;
<span class="cviolet"><strong>15</strong></span>      <code><span class="blue">double</span> d;</code>&#13;
<span class="cviolet"><strong>16</strong></span>      <code><span class="blue">char</span> c;</code>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>      <code><span class="yell">input &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; i &gt;&gt; d &gt;&gt; c;</span></code>&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>      <code>cout &lt;&lt; <span class="green">"Items extracted from the istringstream object:\n"</span></code>&#13;
<span class="cviolet"><strong>21</strong></span>         <code>&lt;&lt; fmt::format(<span class="green">"{}\n{}\n{}\n{}\n{}\n"</span>, s1, s2, i, d, c);</code>&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>      <code><span class="pd_green">// attempt to read from empty stream</span></code>&#13;
<span class="cviolet"><strong>24</strong></span>      <code><span class="blue">if</span> (<span class="blue">long</span> value; <span class="yell">input &gt;&gt; value</span>) {</code>&#13;
<span class="cviolet"><strong>25</strong></span>         <code>cout &lt;&lt; fmt::format("<span class="green">\n\nlong value is: {}\n"</span>, value);</code>&#13;
<span class="cviolet"><strong>26</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>27</strong></span>      <code><span class="blue">else</span> {</code>&#13;
<span class="cviolet"><strong>28</strong></span>         <code>cout &lt;&lt; fmt::format("<span class="green">\n\ninput is empty\n"</span>);</code>&#13;
<span class="cviolet"><strong>29</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>30</strong></span>    <code>}</code></pre>&#13;
<pre class="pre1"><code>Items extracted from the istringstream object:</code>&#13;
<code>Amanda</code>&#13;
<code>test</code>&#13;
<code>123</code>&#13;
<code>4.7</code>&#13;
<code>A</code>&#13;
&#13;
<code>input is empty</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.13</strong></span> Demonstrating input from an <code>istringstream</code> object.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec18"><span class="violet">8.18</span> Raw String Literals</h3>&#13;
<p>Recall that backslash characters in strings introduce escape sequences—like <code>\n</code> for newline and <code>\t</code> for tab. If you wish to include a backslash in a string, you must use two backslash characters <code>\\</code>, making some strings difficult to read. For example, Microsoft Windows uses backslashes to separate folder names when specifying a file’s location. To represent a file’s location on Windows, you might write:</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0253-01" id="f0253-01a">Click here to view code image</a></p>&#13;
<pre class="pre">string windowsPath{<span class="green">"C:\\MyFolder\\MySubFolder\\MyFile.txt"</span>}</pre>&#13;
<p><span class="size">11</span> For such cases, <span class="violet"><strong>raw string literals</strong></span> (introduced in C++11) that have the format</p>&#13;
<pre class="pre">R"(<span class="non_code"><em>rawCharacters</em></span>)"</pre>&#13;
<p>are more convenient. The parentheses are required around the <em>rawCharacters</em> that compose the raw string literal. The compiler automatically inserts backslashes as necessary in a raw string literal to properly escape special characters like double quotes (<code>"</code>), backslashes (<code>\</code>), etc. Using a raw string literal, we can write the preceding <code>string</code> as:</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0254-01" id="f0254-01a">Click here to view code image</a></p>&#13;
<pre class="pre">string windowsPath{<span class="green">R"(C:\MyFolder\MySubFolder\MyFile.txt)"</span>}</pre>&#13;
<p>Raw strings can make your code more readable, particularly when using the regular expressions that we discuss in <a href="#ch08lev1sec20">Section 8.20</a>. Regular expressions often contain many backslash characters. We’ll also use raw strings in <a href="#ch08lev2sec3">Section 8.19.2</a>.</p>&#13;
<p>The preceding raw string literal can include optional delimiters up to 16 characters long before the left parenthesis, <code>(</code>, and after the right parenthesis,), as in</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0254-02" id="f0254-02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="green">R"MYDELIMITER(J.*\d[0-35-9]-\d\d-\d\d)MYDELIMITER"</span></pre>&#13;
<p>The optional delimiters must be identical if provided.</p>&#13;
<p>Raw string literals may be used in any context that requires a string literal. They may also include line breaks, in which case the compiler inserts <code>\n</code> escape sequences. For example, the raw string literal</p>&#13;
<pre class="pre"><span class="green">R"(multiple lines</span>&#13;
<span class="green">of text)"</span></pre>&#13;
<p>is treated as the string literal</p>&#13;
<pre class="pre"><span class="green">"multiple lines\nof text"</span></pre>&#13;
<h3 class="h3" id="ch08lev1sec19"><span class="violet">8.19</span> Objects Natural Case Study: Reading and Analyzing a CSV File Containing Titanic Disaster Data</h3>&#13;
<p>The <span class="violet"><strong>CSV (comma-separated values)</strong></span> file format, which uses the <code><span class="violet"><strong>.csv</strong></span></code> <span class="violet"><strong>file extension</strong></span>, is particularly popular, especially for datasets used in big data, data analytics and data science and in artificial intelligence applications like machine learning and deep learning. Here, we’ll demonstrate reading from a CSV file.</p>&#13;
<h5 class="h5" id="ch08lev3sec39">Datasets</h5>&#13;
<p>There’s an enormous variety of free datasets available online. The OpenML machine learning resource site</p>&#13;
<pre class="pre"><a href="https://openml.org">https://openml.org</a></pre>&#13;
<p>contains over 21,000 free datasets in comma-separated values (CSV) format. Another great source of datasets is:</p>&#13;
<pre class="pre"><a href="https://github.com/awesomedata/awesome-public-datasets">https://github.com/awesomedata/awesome-public-datasets</a></pre>&#13;
<h5 class="h5" id="ch08lev3sec40"><code>account.csv</code></h5>&#13;
<p>For our first example, we’ve included a simple dataset in <code>accounts.csv</code> in the <code>ch08</code> folder. This file contains the account information shown in <a href="#fig8_11">Fig. 8.11</a>’s output, but in the format:</p>&#13;
<pre class="pre">account,name,balance&#13;
100,Jones,24.98&#13;
200,Doe,345.67&#13;
300,White,0.0&#13;
400,Stone,-42.16&#13;
500,Rich,224.62</pre>&#13;
<p>The first row of a CSV file typically contains column names. Each subsequent row contains one data record representing the values for those columns. In this dataset, we have three columns representing an <code>account</code>, <code>name</code> and <code>balance</code>.</p>&#13;
<h4 class="h4" id="ch08lev2sec2">8.19.1 Using <code>rapidcsv</code> to Read the Contents of a CSV File</h4>&#13;
<p>The <code>rapidcsv</code><sup><a id="rch08fn3" href="ch08.xhtml#ch08fn3">3</a></sup> header-only library</p>&#13;
<p class="footnote"><a id="ch08fn3" href="ch08.xhtml#rch08fn3">3</a>. Copyright ©2017, Kristofer Berggren. All rights reserved.</p>&#13;
<pre class="pre"><a href="https://github.com/d99kris/rapidcsv">https://github.com/d99kris/rapidcsv</a></pre>&#13;
<p>provides class <code>rapidcsv::Document</code> that you can use to read and manipulate CSV files. Many other libraries have built-in CSV support. For your convenience, we provided <code>rapidcsv</code> in the example’s folder’s <code>libraries/rapidcsv</code> subfolder. As in earlier examples that use open-source libraries, you’ll need to point the compiler at the <code>rapidcsv</code> subfolder’s <code>src</code> folder so you can include <code>"rapidcsv.h"</code> (<a href="#fig8_14">Fig. 8.14</a>, line 7).</p>&#13;
<div class="group" id="fig8_14">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig14" id="aa08fig14">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_14.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <code><span class="pd_green">// Reading from a CSV file.</span></code>&#13;
 <span class="cviolet"><strong>3</strong></span>    <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <span class="cviolet"><strong>4</strong></span>    <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <span class="cviolet"><strong>5</strong></span>    <code><span class="blue">#include</span> &lt;vector&gt;</code>&#13;
 <span class="cviolet"><strong>6</strong></span>    <code><span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <span class="cviolet"><strong>7</strong></span>    <code><span class="yell"><span class="blue">#include</span> <span class="green">"rapidcsv.h"</span></span></code>&#13;
 <span class="cviolet"><strong>8</strong></span>    <code><span class="blue">using namespace</span> std;</code>&#13;
 <span class="cviolet"><strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>    <code><span class="blue">int</span> main() {</code>&#13;
<span class="cviolet"><strong>11</strong></span>      <code><span class="yell">rapidcsv::Document document{<span class="green">"accounts.csv"</span>};</span> <span class="pd_green">// loads accounts.csv</span></code>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="yell"><code>vector&lt;<span class="blue">int</span>&gt; accounts{document.GetColumn&lt;<span class="blue">int</span>&gt;(<span class="green">"account"</span>)};</code>      </span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="yell"><code>vector&lt;string&gt; names{document.GetColumn&lt;string&gt;(<span class="green">"name"</span>)};</code>      </span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="yell"><code>vector&lt;<span class="blue">double</span>&gt; balances{document.GetColumn&lt;<span class="blue">double</span>&gt;(<span class="green">"balance"</span>)};</code></span>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <code>cout &lt;&lt; fmt::format(<span class="green">"{:&lt;10}{:&lt;13}{}\n"</span>, <span class="green">"Account"</span>, <span class="green">"Name"</span>, <span class="green">"Balance"</span>);</code>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>      <code><span class="blue">for</span> (size_t i{<span class="green">0</span>}; i &lt; accounts.size(); ++i) {</code>&#13;
<span class="cviolet"><strong>19</strong></span>         <code>cout &lt;&lt; fmt::format(<span class="green">"{:&lt;10}{:&lt;13}{:&gt;7.2f}\n"</span>,</code>&#13;
<span class="cviolet"><strong>20</strong></span>                    <code>accounts.at(i), names.at(i), balances.at(i));</code>&#13;
<span class="cviolet"><strong>21</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>22</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Account	Name	Balance</code>&#13;
<code>100	Jones	  24.98</code>&#13;
<code>200	Doe 	 345.67</code>&#13;
<code>300	White 	   0.00</code>&#13;
<code>400 	Stone 	 -42.16</code>&#13;
<code>500 	Rich 	 224.62</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.14</strong></span> Reading from a CSV file.</p>&#13;
</div>&#13;
<p>Line 11 creates and initializes a <code>rapidcsv::Document</code> object named <code>document</code>. This statement loads the specified file (<code>"accounts.csv"</code>). Class <code>Document</code>’s member functions enable you to work with the CSV data by row, by column or by individual value in a specific row and column. In this example, lines 12–14 get the data using the class’s <code>GetColumn</code> template member function. This function returns the specified column’s data as a <code>std::vector</code> containing elements of the type you specify in angle brackets. Line 12’s call</p>&#13;
<pre class="pre">document.GetColumn&lt;<span class="blue">int</span>&gt;(<span class="green">"account"</span>)</pre>&#13;
<p>returns a <code>vector&lt;int&gt;</code> containing the account numbers for every record. Similarly, the calls in line 13–14 return a <code>vector&lt;string&gt;</code> and a <code>vector&lt;double&gt;</code> containing all the records’ names and balances, respectively. Lines 16–21 format and display the file’s contents to confirm that they were read properly.</p>&#13;
<h5 class="h5" id="ch08lev3sec41">Caution: Commas in CSV Data Fields</h5>&#13;
<p>Be careful when working with strings containing embedded commas, such as the name <code>"Jones, Sue"</code>. If this name were accidentally stored as the two strings <code>"Jones"</code> and <code>"Sue"</code>, that CSV record would have <em>four</em> fields, not <em>three</em>. Programs that read CSV files typically expect every record to have the same number of fields; otherwise, problems occur.</p>&#13;
<h5 class="h5" id="ch08lev3sec42">Caution: Missing Commas and Extra Commas in CSV Files</h5>&#13;
<p>Be careful when preparing and processing CSV files. For example, suppose your file is composed of records, each with <em>four</em> comma-separated <code>int</code> values, such as:</p>&#13;
<pre class="pre"><span class="green">100</span>,<span class="green">85</span>,<span class="green">77</span>,<span class="green">9</span></pre>&#13;
<p>If you accidentally omit one of these commas, as in:</p>&#13;
<pre class="pre"><span class="green">100</span>,<span class="green">8577</span>,<span class="green">9</span></pre>&#13;
<p>then the record has only <em>three</em> fields, one with the invalid value <code>8577</code>.</p>&#13;
<p>If you put two adjacent commas where only one is expected, as in:</p>&#13;
<pre class="pre"><span class="green">100</span>,<span class="green">85</span>,,<span class="green">77</span>,<span class="green">9</span></pre>&#13;
<p>then you have <em>five</em> fields rather than <em>four</em>, and one of the fields erroneously would be <em>empty</em>. Each of these comma-related errors could confuse programs trying to process the record.</p>&#13;
<h4 class="h4" id="ch08lev2sec3">8.19.2 Reading and Analyzing the Titanic Disaster Dataset</h4>&#13;
<p><span class="size">DS</span> One of the most commonly used datasets for data analytics and data science beginners is the <span class="violet"><strong>Titanic disaster dataset</strong></span><sup><a id="rch08fn4" href="ch08.xhtml#ch08fn4">4</a></sup>. It lists all the passengers and whether they survived when the ship <em>Titanic</em> struck an iceberg and sank on its maiden voyage April 14–15, 1912. We’ll load the dataset in <a href="#fig8_15">Fig. 8.15</a>, view some of its data and perform some basic data analytics.</p>&#13;
<p class="footnote"><a id="ch08fn4" href="ch08.xhtml#rch08fn4">4</a>. “Titanic” dataset on OpenML.org (<code><a href="https://www.openml.org/d/40945">https://www.openml.org/d/40945</a></code>). Author: Frank E. Harrell, Jr. and Thomas Cason. Source: Vanderbilt Biostatistics (<code><a href="http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic.html">http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic.html</a></code>). The OpenML license terms (<code><a href="https://www.openml.org/cite">https://www.openml.org/cite</a></code>) say, “You are free to use OpenML and all empirical data and metadata under the CC-BY license (<code><a href="http://creativecommons.org/licenses/by/4.0">http://creativecommons.org/licenses/by/4.0</a></code>/), requesting appropriate credit if you do.”</p>&#13;
<div class="group" id="fig8_15">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig15" id="aa08fig15">Click here to view code image</a></p>&#13;
<pre class="pre3"> <span class="cviolet"><strong>1</strong></span>    <code><span class="pd_green">// fig08_14.cpp</span></code>&#13;
 <span class="cviolet"><strong>2</strong></span>    <span class="pd_green">// Reading the Titanic dataset from a CSV file, then analyzing it.</span>&#13;
 <span class="cviolet"><strong>3</strong></span>    <span class="blue">#include</span> &lt;algorithm&gt;&#13;
 <span class="cviolet"><strong>4</strong></span>    <span class="blue">#include</span> &lt;cmath&gt;&#13;
 <span class="cviolet"><strong>5</strong></span>    <span class="blue">#include</span> &lt;iostream&gt;&#13;
 <span class="cviolet"><strong>6</strong></span>    <span class="blue">#include</span> &lt;numeric&gt;&#13;
 <span class="cviolet"><strong>7</strong></span>    <span class="blue">#include</span> &lt;ranges&gt;&#13;
 <span class="cviolet"><strong>8</strong></span>    <span class="blue">#include</span> &lt;string&gt;&#13;
 <span class="cviolet"><strong>9</strong></span>    <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"><strong>10</strong></span>    <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"><strong>11</strong></span>    <span class="yell"><span class="blue">#include</span> <span class="green">"rapidcsv.h"</span></span>&#13;
<span class="cviolet"><strong>12</strong></span>    <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>    <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>15</strong></span>       <code><span class="pd_green">// load Titanic dataset; treat missing age values as NaN</span></code>&#13;
<span class="cviolet"><strong>16</strong></span>       <span class="yell"><code>rapidcsv::Document titanic(<span class="green">"titanic.csv"</span>,</code>               </span>&#13;
<span class="cviolet"><strong>17</strong></span>       <span class="yell">   <code>rapidcsv::LabelParams{}, rapidcsv::SeparatorParams{},</code></span>&#13;
<span class="cviolet"><strong>18</strong></span>       <span class="yell">   rapidcsv::ConverterParams{<span class="blue">true</span>});                    </span>&#13;
<span class="cviolet"><strong>19</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.15</strong></span> Reading the Titanic dataset from a CSV file, then analyzing it.</p>&#13;
</div>&#13;
<p>‘To download the dataset in CSV format go to</p>&#13;
<pre class="pre"><a href="https://www.openml.org/d/40945">https://www.openml.org/d/40945</a></pre>&#13;
<p>and click the CSV download button in the page’s upper-right corner. This downloads the file <code>phpMYEkMl.csv</code>, which we renamed as <code>titanic.csv</code>. We assume that you’ll download the file, rename it as <code>titanic.csv</code> and place it in the chapter’s <code>ch08</code> examples folder.</p>&#13;
<p><span class="size">20</span> <a href="#fig8_14">Figure 8.14</a> uses some C++20 <code>ranges</code> library features we introduced in <a href="ch06.xhtml#ch06lev1sec14">Section 6.14</a>. At the time of this writing, only GNU C++ 10.1 supports the <code>ranges</code> library.</p>&#13;
<h5 class="h5" id="ch08lev3sec43">Getting to Know the Data</h5>&#13;
<p>Much of data analytics and data science is devoted to getting to know your data. One way is simply to look at the raw data. If you open the <code>titanic.csv</code> file in a text editor or spreadsheet application, you’ll see that the dataset contains 1309 rows, each containing 14 columns—often called <span class="violet"><strong>features</strong></span> in data analytics. We’ll use only four columns here:</p>&#13;
<p class="bull">• <code>survived</code>: <code>1</code> or <code>0</code> for yes or no, respectively.</p>&#13;
<p class="bull">• <code>sex</code>: <code>"female"</code> or <code>"male"</code>.</p>&#13;
<p class="bull">• <code>age</code>: The passenger’s age. Most values in this column are integers, but some children under 1 year of age have floating-point <code>age</code> values, so we’ll process this column as <code>double</code> values.</p>&#13;
<p class="bull">• <code>pclass</code>: 1, 2 or 3 for first class, second class or third class, respectively.</p>&#13;
<p>To learn more about the dataset’s origins and its other columns, visit:</p>&#13;
<pre class="pre"><a href="http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic3info.txt">http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic3info.txt</a></pre>&#13;
<h5 class="h5" id="ch08lev3sec44">Missing Data</h5>&#13;
<p>Bad data values and missing values can significantly impact data analysis. The Titanic dataset is missing <code>age</code>s for 263 passengers. These are represented as <code>?</code> in the CSV file. In this example, when we produce descriptive statistics for the passengers’ ages, we’ll filter out and ignore the missing values. Some data scientists advise against any attempts to insert “reasonable values.” Instead, they advocate clearly marking missing data and leaving it up to a data analytics package to handle the issue. Others offer strong cautions.<sup><a id="rch08fn5" href="ch08.xhtml#ch08fn5">5</a></sup></p>&#13;
<p class="footnote"><a id="ch08fn5" href="ch08.xhtml#rch08fn5">5</a>. This footnote was abstracted from a comment sent to us July 20, 2018 by one of our Python text-book’s academic reviewers, Dr. Alison Sanchez of the University of San Diego School of Business. She commented: “Be cautious when mentioning 'substituting reasonable values' for missing or bad values.' A stern warning: 'Substituting' values that increase statistical significance or give more 'reasonable' or 'better' results is not permitted. 'Substituting' data should not turn into 'fudging' data. The first rule students should learn is not to eliminate or change values that contradict their hypotheses. 'Substituting reasonable values' does not mean students should feel free to change values to get the results they want.”</p>&#13;
<h5 class="h5" id="ch08lev3sec45">Loading the Dataset</h5>&#13;
<p>Lines 16–18 create and initialize a <code>rapidcsv::Document</code> object named <code>titanic</code> that loads <code>"titanic.csv"</code>. The second and third arguments in line 17 are two of the default arguments used to initialize a <code>Document</code> object when you create it only by specifying the CSV file name. Recall from our discussion of default function arguments that when an argument is specified explicitly for a parameter with a default argument, all prior arguments in the argument list also must be specified explicitly. We provided the second and third arguments, so we can specify the fourth argument.</p>&#13;
<p>The <code>rapidcsv::LabelParams{}</code> argument specifies by default that the CSV file’s first row contains the column names. The <code>rapidcsv::SeparatorParams{}</code> argument specifies by default that each record’s fields are separated by commas. The fourth argument:</p>&#13;
<pre class="pre">rapidcsv::ConverterParams{<span class="blue">true</span>}</pre>&#13;
<p>enables RapidCSV to convert missing and bad data values in integer columns to 0 and floating-point columns to NaN (not a number). This enables us to load all the data in the <code>age</code> column into a <code>vector&lt;double</code>&gt;, including the missing values represented by <code>?</code>.</p>&#13;
<h5 class="h5" id="ch08lev3sec46">Removing the Quotes from the Columns Containing Strings</h5>&#13;
<p>Lines 21–24 use the <code>rapidcsv::Document</code>’s <code>GetColumn</code> member function to get each column by name. In the dataset, the column names are enclosed in double-quote characters, so they are required to load the columns. For example, in the raw string <code>R"("survived")"</code> represents the column name <code>"survived"</code> with the enclosing quotes.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0258-01" id="f0258-01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>20</strong></span>    <span class="pd_green">// get data by column; ignoring column 0 in this example</span>&#13;
<span class="cviolet"><strong>21</strong></span>    <span class="blue">auto</span> survived{<span class="yell">titanic.GetColumn&lt;<span class="blue">int</span>&gt;(<span class="green">R"("survived")"</span>)</span>};&#13;
<span class="cviolet"><strong>22</strong></span>    <span class="blue">auto</span> sex{<span class="yell">titanic.GetColumn&lt;string&gt;(<span class="green">R"("sex")"</span>)</span>};&#13;
<span class="cviolet"><strong>23</strong></span>    <span class="blue">auto</span> age{<span class="yell">titanic.GetColumn&lt;<span class="blue">double</span>&gt;(<span class="green">R"("age")"</span>)</span>};&#13;
<span class="cviolet"><strong>24</strong></span>    <span class="blue">auto</span> pclass{<span class="yell">titanic.GetColumn&lt;<span class="blue">int</span>&gt;(<span class="green">R"("pclass")"</span>)</span>};&#13;
<span class="cviolet"><strong>25</strong></span></pre>&#13;
<h5 class="h5" id="ch08lev3sec47">Removing the Quotes from the Column Containing Strings</h5>&#13;
<p>String values in the Titanic dataset are enclosed in double-quotes—e.g., <code>"female"</code> and <code>"male"</code>. The <code>rapidcsv::Document</code> object includes the quotes in each such <code>std::string</code> it returns. Lines 27–29 remove these quotes from each value in the <code>vector</code> named <code>sex</code>. For the current <code>item</code>, line 28 calls <code>std::string</code> member function <code>erase</code> to remove the character at index <code>0</code> (a quote) in the string. The first argument is the index (<code>0</code>) at which to begin erasing characters. The second is the number of characters to erase (<code>1</code>). <code>erase</code> returns a reference to the modified <code>std::string</code>, which we use to the <code>std::string</code>’s <code>pop_back</code> member function. This removes the string’s last character (also a quote).</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0259-01" id="f0259-01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>26</strong></span>    <span class="pd_green">// lambda to remove the quotes from the strings</span>&#13;
<span class="cviolet"><strong>27</strong></span>    <span class="blue">for</span> (string&amp; item : sex) {&#13;
<span class="cviolet"><strong>28</strong></span>       item.erase(<span class="green">0, 1</span>).pop_back();&#13;
<span class="cviolet"><strong>29</strong></span>    }&#13;
<span class="cviolet"><strong>30</strong></span></pre>&#13;
<h5 class="h5" id="ch08lev3sec48">Viewing Some Rows in the Titanic Dataset</h5>&#13;
<p>The 1309 rows each represent one passenger. According to Wikipedia, there were approximately 1317 passengers and 815 of them died.<sup><a id="rch08fn6" href="ch08.xhtml#ch08fn6">6</a></sup> For large datasets, it’s not possible to display all the data at once. A common practice when getting to know your data is to display a few rows from the beginning and end of the dataset, so you can get a sense of the data. The code in lines 32–37 displays the first five elements of each column’s data:</p>&#13;
<p class="footnote"><a id="ch08fn6" href="ch08.xhtml#rch08fn6">6</a>. <code><a href="https://en.wikipedia.org/wiki/Passengers_of_the_RMS_Titanic">https://en.wikipedia.org/wiki/Passengers_of_the_RMS_Titanic</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0259-02" id="f0259-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>31</strong></span>    <span class="pd_green">// display first 5 rows</span>&#13;
<span class="cviolet"><strong>32</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"First five rows:\n{:&lt;10}{:&lt;8}{:&lt;6}{}\n"</span>,&#13;
<span class="cviolet"><strong>33</strong></span>               <span class="green">"survived"</span>, <span class="green">"sex"</span>, <span class="green">"age"</span>, <span class="green">"class"</span>);&#13;
<span class="cviolet"><strong>34</strong></span>    <span class="blue">for</span> (size_t i{<span class="green">0</span>}; i &lt; <span class="green">5</span>; ++i) {&#13;
<span class="cviolet"><strong>35</strong></span>       cout &lt;&lt; fmt::format(<span class="green">"{:&lt;10}{:&lt;8}{:&lt;6.1f}{}\n"</span>,&#13;
<span class="cviolet"><strong>36</strong></span>          survived.at(i), sex.at(i), age.at(i), passengerClass.at(i));&#13;
<span class="cviolet"><strong>37</strong></span>    }&#13;
<span class="cviolet"><strong>38</strong></span></pre>&#13;
<pre class="pre1">First five rows:&#13;
survived  sex     age   class&#13;
1         female  29.0  1&#13;
1         male    0.9   1&#13;
0         female  2.0   1&#13;
0         male    30.0  1&#13;
0         female  25.0  1</pre>&#13;
<p>The code in lines 40–46 displays the last five elements of each column’s data. To determine the control variable’s starting value, line 42 calls the <code>rapidcsv::Document</code>’s <code>GetRowCount</code> member function. Then line 43 initializes the control variable to five less than the row count. Note the value in the <code>age</code> column for one of row is <code>nan</code>, indicating a missing value in the dataset.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0259-03" id="f0259-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>39</strong></span>    <span class="pd_green">// display last 5 rows</span>&#13;
<span class="cviolet"><strong>40</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"\nLast five rows:\n{:&lt;10}{:&lt;8}{:&lt;6}{}\n"</span>,&#13;
<span class="cviolet"><strong>41</strong></span>       <span class="green">"survived"</span>, <span class="green">"sex"</span>, <span class="green">"age"</span>, <span class="green">"class"</span>);&#13;
<span class="cviolet"><strong>42</strong></span>    <span class="blue">auto</span> count{<span class="yell">titanic.GetRowCount()</span>};&#13;
<span class="cviolet"><strong>43</strong></span>    <span class="blue">for</span> (size_t i{count - <span class="green">5</span>}; i &lt; count; ++i) {&#13;
<span class="cviolet"><strong>44</strong></span>       cout &lt;&lt; fmt::format(<span class="green">"{:&lt;10}{:&lt;8}{:&lt;6.1f}{}\n"</span>,&#13;
<span class="cviolet"><strong>45</strong></span>          survived.at(i), sex.at(i), age.at(i), pclass.at(i));&#13;
<span class="cviolet"><strong>46</strong></span>    }&#13;
<span class="cviolet"><strong>47</strong></span></pre>&#13;
<pre class="pre1">Last five rows:&#13;
survived  sex     age   class&#13;
0         female  14.5  3&#13;
0         female  nan   3&#13;
0         male    26.5  3&#13;
0         male    27.0  3&#13;
0         male    29.0  3</pre>&#13;
<h5 class="h5" id="ch08lev3sec49">Basic Descriptive Statistics</h5>&#13;
<p><span class="size">DS</span> <span class="size">20</span> As part of getting to know a dataset, data scientists often use statistics to describe and summarize data. Let’s calculate several <span class="violet"><strong>descriptive statistics</strong></span> for the age column, including the number of passengers for which we have age values, and the average, minimum, maximum and median age values. Before performing these calculations, we must remove <code>nan</code> values—calculations performed with <code>nan</code> result in <code>nan</code>. Lines 49–50 use the C++20 ranges filtering techniques from <a href="ch06.xhtml#ch06lev1sec14">Section 6.14</a> to keep only the values in the <code>age vector</code> that are <em>not</em> <code>nan</code>. Function <code>isnan</code> (header <code>&lt;cmath&gt;</code>) returns <code>true</code> if the value is <code>nan</code>. Next, line 51 creates a <code>vector&lt;double&gt;</code> named <code>cleanAge</code>. The <code>vector</code> initializes its elements by iterating through the filtered results from <code>begin(removeNaN)</code> to <code>end(removeNan)</code>.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0260-02" id="f0260-02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>48</strong></span>    <span class="pd_green">// use C++20 ranges to eliminate missing values from age column</span>&#13;
<span class="cviolet"><strong>49</strong></span>    <span class="blue">auto</span> removeNaN =&#13;
<span class="cviolet"><strong>50</strong></span>       age | views::filter([](con<span class="blue">st auto&amp; x</span>) {ret<span class="blue">urn</span> <span class="yell">!isnan(x)</span>;});&#13;
<span class="cviolet"><strong>51</strong></span>    vector&lt;<span class="blue">double</span>&gt; cleanAge{begin(removeNaN), end(removeNaN)};&#13;
<span class="cviolet"><strong>52</strong></span></pre>&#13;
<h5 class="h5" id="ch08lev3sec50">Basic Descriptive Statistics for the Cleaned Age Column</h5>&#13;
<p>Now, we can calculate the descriptive statistics. Line 54 sorts <code>cleanAge</code>, which will help us determine the minimum, maximum and median values. To count the number of people for which we have valid <code>age</code>s, we simply get <code>cleanAge</code>’s <code>size</code> (line 55).</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0260-03" id="f0260-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>53</strong></span>    <span class="pd_green">// descriptive statistics for cleaned ages column</span>&#13;
<span class="cviolet"><strong>54</strong></span>    sort(begin(cleanAge), end(cleanAge));&#13;
<span class="cviolet"><strong>55</strong></span>    size_t size{cleanAge.size()};&#13;
<span class="cviolet"><strong>56</strong></span>    <span class="blue">double</span> median{};&#13;
<span class="cviolet"><strong>57</strong></span>&#13;
<span class="cviolet"><strong>58</strong></span>    <span class="blue">if</span> (size % <span class="green">2</span> == <span class="green">0</span>) { <span class="pd_green">// find median value for even number of items</span>&#13;
<span class="cviolet"><strong>59</strong></span>       median = (cleanAge.at(size / <span class="green">2</span> - <span class="green">1</span>) + cleanAge.at(size / <span class="green">2</span>)) / <span class="green">2</span>;&#13;
<span class="cviolet"><strong>60</strong></span>    }&#13;
<span class="cviolet"><strong>61</strong></span>    <span class="blue">else</span> { <span class="pd_green">// find median value for odd number of items</span>&#13;
<span class="cviolet"><strong>62</strong></span>       median = cleanAge.at(size / <span class="green">2</span>);&#13;
<span class="cviolet"><strong>63</strong></span>    }&#13;
<span class="cviolet"><strong>64</strong></span>&#13;
<span class="cviolet"><strong>65</strong></span>    cout &lt;&lt; <span class="green">"\nDescriptive statistics for the age column:\n"</span>&#13;
<span class="cviolet"><strong>66</strong></span>       &lt;&lt; fmt::format(<span class="green">"Passengers with age data: {}\n"</span>, size)&#13;
<span class="cviolet"><strong>67</strong></span>       &lt;&lt; fmt::format(<span class="green">"Average age: {:.2f}\n"</span>,&#13;
<span class="cviolet"><strong>68</strong></span>             accumulate(begin(cleanAge), end(cleanAge), <span class="green">0.0</span>) / size)&#13;
<span class="cviolet"><strong>69</strong></span>       &lt;&lt; fmt::format(<span class="green">"Minimum age: {:.2f}\n"</span>, cleanAge.front())&#13;
<span class="cviolet"><strong>70</strong></span>       &lt;&lt; fmt::format(<span class="green">"Maximum age: {:.2f}\n"</span>, cleanAge.back())&#13;
<span class="cviolet"><strong>71</strong></span>       &lt;&lt; fmt::format(<span class="green">"Median age: {:.2f}\n",</span> median);&#13;
<span class="cviolet"><strong>72</strong></span></pre>&#13;
<pre class="pre1">Descriptive statistics for the age column:&#13;
Passengers with age data: 1046&#13;
Average age: 29.88&#13;
Minimum age: 0.17&#13;
Maximum age: 80.00&#13;
Median age: 28.00</pre>&#13;
<p>Lines 56–63 determine the <code>median</code>. If <code>cleanAge</code>’s <code>size</code> is even, the <code>median</code> is the average of the two middle elements (line 59); otherwise, it’s the middle element (line 62). Lines 65–71 display the descriptive statistics. Line 68 calculates the average age by using the <code>accumulate</code> algorithm to total the ages, then dividing the result by <code>size</code>. The <code>vector</code> is sorted, so lines 69–70 determine the minimum and maximum values by calling the <code>vector</code>’s <code><span class="violet"><strong>front</strong></span></code> and <code><span class="violet"><strong>back</strong></span></code> member functions, respectively. The average and median are <span class="violet"><strong>measures of central tendency</strong></span>. Each is a way to produce a single value that represents a “central” value in a set of values, i.e., a value which is, in some sense, typical of the others.</p>&#13;
<p>For the <code>1046</code> people with valid <code>age</code>s, the average <code>age</code> was <code>29.88</code> years old. The youngest passenger (i.e., the minimum) was just over two months old (<code>0.17 * 12</code> is <code>2.04</code>), and the oldest (i.e., the maximum) was 80. The <code>median age</code> was <code>28</code>.</p>&#13;
<h5 class="h5" id="ch08lev3sec51">Determining Passenger Counts By Class</h5>&#13;
<p>Let’s calculate each class’s number of passengers. Lines 74–79 define a lambda that</p>&#13;
<p class="bull">• filters the <code>pclass</code> column, keeping only the elements for the specified <code>classNumber</code> (line 76),</p>&#13;
<p class="bull">• maps each to the value <code>1</code> (line 77), then</p>&#13;
<p class="bull">• uses <code>accumulate</code> to total the mapped results, which gives us the count for the specified <code>classNumber</code>.</p>&#13;
<p>The lambda introducer <code>[classNumber]</code> in line 76 indicates that the lambda will use the variable <code>classNumber</code> (line 74 in the parameter list) in line 76’s lambda body. Known as <span class="violet"><strong>capturing</strong></span> the variable, this is required to use a variable that’s not defined in the lambda. Lines 81–83 define constants for the three passenger classes. Lines 84–86 call <code>countClass</code> for each passenger class, and lines 88–90 display the counts.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0261-02" id="f0261-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>73</strong></span>    <span class="pd_green">// passenger counts by class</span>&#13;
<span class="cviolet"><strong>74</strong></span>    <span class="blue">auto</span> countClass = [](<span class="blue">const auto</span>&amp; column, <span class="blue">const int</span> classNumber) {&#13;
<span class="cviolet"><strong>75</strong></span>       <span class="blue">auto</span> filterByClass{column&#13;
<span class="cviolet"><strong>76</strong></span>          | views::filter(<span class="yell">[classNumber](auto x) {<span class="blue">return</span> classNumber == x;}</span>)&#13;
<span class="cviolet"><strong>77</strong></span>          | views::transform([](auto x) {<span class="blue">return</span> 1;})};&#13;
<span class="cviolet"><strong>78</strong></span>       <span class="blue">return</span> accumulate(begin(filterByClass), end(filterByClass), 0);&#13;
<span class="cviolet"><strong>79</strong></span>    };&#13;
<span class="cviolet"><strong>80</strong></span>&#13;
<span class="cviolet"><strong>81</strong></span>    <span class="blue">constexpr int</span> firstClass{<span class="green">1</span>};&#13;
<span class="cviolet"><strong>82</strong></span>    <span class="blue">constexpr int</span> secondClass{<span class="green">2</span>};&#13;
<span class="cviolet"><strong>83</strong></span>    <span class="blue">constexpr int</span> thirdClass{<span class="green">3</span>};&#13;
<span class="cviolet"><strong>84</strong></span>    <span class="blue">const int</span> firstCount{countClass(pclass, firstClass)};&#13;
<span class="cviolet"><strong>85</strong></span>    <span class="blue">const int</span> secondCount{countClass(pclass, secondClass)};&#13;
<span class="cviolet"><strong>86</strong></span>    <span class="blue">const int</span> thirdCount{countClass(pclass, thirdClass)};&#13;
<span class="cviolet"><strong>87</strong></span>&#13;
<span class="cviolet"><strong>88</strong></span>    cout &lt;&lt; <span class="green">"\nPassenger counts by class:\n"</span>&#13;
<span class="cviolet"><strong>89</strong></span>       &lt;&lt; fmt::format(<span class="green">"1st: {}\n2nd: {}\n3rd: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>90</strong></span>             firstCount, secondCount, thirdCount);&#13;
<span class="cviolet"><strong>91</strong></span></pre>&#13;
<pre class="pre1">Passenger counts by class:&#13;
1st: 323&#13;
2nd: 554&#13;
3rd: 2127</pre>&#13;
<h5 class="h5" id="ch08lev3sec52">Basic Descriptive Statistics for the Cleaned Age Column</h5>&#13;
<p>Let’s say you want to determine some statistics about people who survived. Line 93 filters the <code>survived</code> column, keeping only the survivors. Recall that this column contains <code>1</code> or <code>0</code> to represent survived or died, respectively. These also are values that C++ can treat as <code>true</code> (<code>1</code>) or <code>false</code> (<code>0</code>), so the lambda in line 93 simply returns the column value. If that value is <code>1</code>, the filter operation keeps that value in the results. Line 94 uses the <code>accumulate</code> function to calculate the <code>survivorCount</code> by iterating over the results and totaling the <code>1</code>s. To find out how many people died, we simply subtract <code>survivorCount</code> from the <code>survived vector</code>’s size. Line 99 calculates the percentage of people who survived.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0262-02" id="f0262-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>92</strong></span>    <span class="pd_green">// percentage of people who survived</span>&#13;
<span class="cviolet"><strong>93</strong></span>    <span class="blue">auto</span> survivors = survived | views::filter([](<span class="blue">auto</span> x) {<span class="blue">return</span> x;});&#13;
<span class="cviolet"><strong>94</strong></span>    <span class="blue">int</span> survivorCount{accumulate(begin(survivors), end(survivors), <span class="green">0</span>)};&#13;
<span class="cviolet"><strong>95</strong></span>&#13;
<span class="cviolet"><strong>96</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"\nSurvived count: {}\nDied count: {}\n"</span>,&#13;
<span class="cviolet"><strong>97</strong></span>               survivorCount, survived.size() - survivorCount);&#13;
<span class="cviolet"><strong>98</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"Percent who survived: {:.2f}%\n\n"</span>,&#13;
<span class="cviolet"><strong>99</strong></span>               <span class="green">100.0</span> * survivorCount / survived.size());&#13;
<span class="cviolet"><strong>100</strong></span></pre>&#13;
<pre class="pre1">Survived count: 500&#13;
Died count: 809&#13;
Percent who survived: 38.20%</pre>&#13;
<h5 class="h5" id="ch08lev3sec53">Counting By Sex and By Passenger Class the Numbers of People Who Survived</h5>&#13;
<p><span class="size">14</span> Lines 102–122 iterate through the <code>survived</code> column, using its <code>1</code> or <code>0</code> value as a condition (line 109). For each survivor, we increment counters for the survivor’s <code>sex</code> (<code>surviving-Women</code> and <code>survivingMen</code> in line 110) and <code>pclass</code> (<code>surviving1st</code>, <code>surviving2nd</code> and <code>surviving3rd</code> in lines 112–120). We’ll use these counts to calculate percentages. In line 110, the literal value <code>"female"s</code> with the trailing <code>s</code> after the closing quote is a C++14 <span class="violet"><strong>string object literal</strong></span> that treats <code>"female"</code> as a <code>std::string</code> rather than a C-string. So the <code>==</code> comparison is between two <code>std::string</code> objects.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0262-03" id="f0262-03a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>101</strong></span>    <span class="pd_green">// count who survived by male/female, 1st/2nd/3rd class</span>&#13;
<span class="cviolet"><strong>102</strong></span>    <span class="blue">int</span> survivingMen{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>103</strong></span>    <span class="blue">int</span> survivingWomen{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>104</strong></span>    <span class="blue">int</span> surviving1st{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>105</strong></span>    <span class="blue">int</span> surviving2nd{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>106</strong></span>    <span class="blue">int</span> surviving3rd{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>107</strong></span>&#13;
<span class="cviolet"><strong>108</strong></span>    <span class="blue">for</span> (size_t i{<span class="green">0</span>}; i &lt; survived.size(); ++i) {&#13;
<span class="cviolet"><strong>109</strong></span>       <span class="blue">if</span> (survived.at(i)) {&#13;
<span class="cviolet"><strong>110</strong></span>          sex.at(i) == <span class="green">"female"s</span> ? ++survivingWomen : ++survivingMen;&#13;
<span class="cviolet"><strong>111</strong></span>&#13;
<span class="cviolet"><strong>112</strong></span>          <span class="blue">if</span> (firstClass == pclass.at(i)) {&#13;
<span class="cviolet"><strong>113</strong></span>             ++surviving1st;&#13;
<span class="cviolet"><strong>114</strong></span>          }&#13;
<span class="cviolet"><strong>115</strong></span>          <span class="blue">else if</span> (secondClass == pclass.at(i)) {&#13;
<span class="cviolet"><strong>116</strong></span>             ++surviving2nd;&#13;
<span class="cviolet"><strong>117</strong></span>          }&#13;
<span class="cviolet"><strong>118</strong></span>          <span class="blue">else</span> { <span class="pd_green">// third class</span>&#13;
<span class="cviolet"><strong>119</strong></span>             ++surviving3rd;&#13;
<span class="cviolet"><strong>120</strong></span>          }&#13;
<span class="cviolet"><strong>121</strong></span>       }&#13;
<span class="cviolet"><strong>122</strong></span>    }&#13;
<span class="cviolet"><strong>123</strong></span></pre>&#13;
<h5 class="h5" id="ch08lev3sec54">Calculating Percentages of People Who Survived</h5>&#13;
<p>Lines 125–135 calculate and display the percentages of:</p>&#13;
<p class="bull">• women who survived,</p>&#13;
<p class="bull">• men who survived,</p>&#13;
<p class="bull">• first-class passengers who survived,</p>&#13;
<p class="bull">• second-class passengers who survived, and</p>&#13;
<p class="bull">• third-class passengers who survived.</p>&#13;
<p>Of the survivors, about two-thirds were women, and first-class passengers survived at a higher rate than the other passenger classes.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0263-02" id="f0263-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>124</strong></span>    <span class="pd_green">// percentages who survived by male/female, 1st/2nd/3rd class</span>&#13;
<span class="cviolet"><strong>125</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"Female survivor percentage: {:.2f}%\n"</span>,&#13;
<span class="cviolet"><strong>126</strong></span>               <span class="green">100.0</span> * survivingWomen / survivorCount)&#13;
<span class="cviolet"><strong>127</strong></span>         &lt;&lt; fmt::format(<span class="green">"Male survivor percentage: {:.2f}%\n\n"</span>,&#13;
<span class="cviolet"><strong>128</strong></span>               <span class="green">100.0</span> * survivingMen / survivorCount)&#13;
<span class="cviolet"><strong>129</strong></span>         &lt;&lt; fmt::format(<span class="green">"1st class survivor percentage: {:.2f}%\n"</span>,&#13;
<span class="cviolet"><strong>130</strong></span>               <span class="green">100.0</span> * surviving1st / survivorCount)&#13;
<span class="cviolet"><strong>131</strong></span>         &lt;&lt; fmt::format(<span class="green">"2nd class survivor percentage: {:.2f}%\n"</span>,&#13;
<span class="cviolet"><strong>132</strong></span>               <span class="green">100.0</span> * surviving2nd / survivorCount)&#13;
<span class="cviolet"><strong>133</strong></span>         &lt;&lt; fmt::format(<span class="green">"3rd class survivor percentage: {:.2f}%\n"</span>,&#13;
<span class="cviolet"><strong>134</strong></span>               <span class="green">100.0</span> * surviving3rd / survivorCount);&#13;
<span class="cviolet"><strong>135</strong></span>  }</pre>&#13;
<pre class="pre1">Female survivor percentage: 67.80%&#13;
Male survivor percentage: 32.20%&#13;
&#13;
1st class survivor percentage: 40.00%&#13;
2nd class survivor percentage: 23.80%&#13;
3rd class survivor percentage: 36.20%</pre>&#13;
<h3 class="h3" id="ch08lev1sec20"><span class="violet">8.20</span> Objects Natural Case Study: Introduction to Regular Expressions</h3>&#13;
<p>Sometimes you’ll need to recognize patterns in text, like phone numbers, e-mail addresses, ZIP Codes, web page addresses, Social Security numbers and more. A <span class="violet"><strong>regular expression</strong></span> string describes a search pattern for matching characters in other strings.</p>&#13;
<p>Regular expressions can help you extract data from unstructured text, such as social media posts. They’re also important for ensuring that data is in the proper format before you attempt to process it.</p>&#13;
<h5 class="h5" id="ch08lev3sec55">Validating Data</h5>&#13;
<p>Before working with text data, you’ll often use regular expressions to validate it. For example, you might check that:</p>&#13;
<p class="bull">• A U.S. ZIP Code consists of five digits (such as 02215) or five digits followed by a hyphen and four more digits (such as 02215-4775).</p>&#13;
<p class="bull">• A string last name contains only letters, spaces, apostrophes and hyphens.</p>&#13;
<p class="bull">• An e-mail address contains only the allowed characters in the allowed order.</p>&#13;
<p class="bull">• A U.S. Social Security number contains three digits, a hyphen, two digits, a hyphen and four digits, and adheres to other rules about the specific numbers that can be used in each group of digits.</p>&#13;
<p>You’ll rarely need to create your own regular expressions for common items like these. The following free websites</p>&#13;
<p class="bull">• <code><a href="https://regex101.com">https://regex101.com</a></code></p>&#13;
<p class="bull">• <code><a href="https://regexr.com/">https://regexr.com/</a></code></p>&#13;
<p class="bull">• <code><a href="http://www.regexlib.com">http://www.regexlib.com</a></code></p>&#13;
<p class="bull">• <code><a href="https://www.regular-expressions.info">https://www.regular-expressions.info</a></code></p>&#13;
<p>and others offer repositories of existing regular expressions that you can copy and use. Many sites like these also allow you to test regular expressions to determine whether they’ll meet your needs.</p>&#13;
<h5 class="h5" id="ch08lev3sec56">Other Uses of Regular Expressions</h5>&#13;
<p>Regular expressions also are used to:</p>&#13;
<p class="bull">• Extract data from text (known as <em>scraping</em>)—e.g., locating all URLs in a web page.</p>&#13;
<p class="bull">• Clean data—e.g., removing data that’s not required, removing duplicate data, handling incomplete data, fixing typos, ensuring consistent data formats, removing formatting, changing text case, dealing with outliers and more.</p>&#13;
<p class="bull">• Transform data into other formats—e.g., reformatting tab-separated or space-separated values into comma-separated values (CSV) for an application that requires data to be in CSV format. We discussed CSV in <a href="#ch08lev1sec19">Section 8.19</a>.</p>&#13;
<h4 class="h4" id="ch08lev2sec4">8.20.1 Matching Complete Strings to Patterns</h4>&#13;
<p>To use regular expressions, include the header <code><span class="violet"><strong>&lt;regex&gt;</strong></span></code>, which provides several classes and functions for recognizing and manipulating regular expressions.</p>&#13;
<h5 class="h5" id="ch08lev3sec57">Matching Literal Characters</h5>&#13;
<p>The <code>&lt;regex&gt;</code> function <code><span class="violet"><strong>regex_match</strong></span></code> (<a href="#fig8_16">Fig. 8.16</a>) returns <code>true</code> if the entire string in its first argument <em>matches the pattern in its second argument</em>. By default, pattern matching is case sensitive—later, you’ll see how to perform case-insensitive matches. Let’s begin by matching literal characters—that is, characters that match themselves. Line 10 creates a <code>regex</code> object <code>r1</code> for the pattern <code>"02215"</code> containing only literal digits that match themselves in the specified order. Line 13 calls <code>regex_match</code> for the strings <code>"02215"</code> and <code>"51220"</code>. Each has the same digits, but only <code>"02215"</code> has them <em>in the correct order for a match</em>.</p>&#13;
<div class="group" id="fig8_16">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig16" id="aa08fig16">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <span class="pd_green">// fig08_16.cpp</span>&#13;
 <span class="cviolet"><strong>2</strong></span>    <span class="pd_green">// Matching entire strings to regular expressions.</span>&#13;
 <span class="cviolet"><strong>3</strong></span>    <span class="blue">#include</span> &lt;iostream&gt;&#13;
 <span class="cviolet"><strong>4</strong></span>    <span class="blue">#include</span> &lt;regex&gt;&#13;
 <span class="cviolet"><strong>5</strong></span>    <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span>&#13;
 <span class="cviolet"><strong>6</strong></span>    <span class="blue">using namespace</span> std;&#13;
 <span class="cviolet"><strong>7</strong></span>&#13;
 <span class="cviolet"><strong>8</strong></span>    <span class="blue">int</span> main() {&#13;
 <span class="cviolet"><strong>9</strong></span>       <span class="pd_green">// fully match a pattern of literal characters</span>&#13;
<span class="cviolet"><strong>10</strong></span>       <span class="yell">regex r1(<span class="green">"02215"</span>);</span>&#13;
<span class="cviolet"><strong>11</strong></span>       cout &lt;&lt; <span class="green">"Matching against: 02215\n"</span>&#13;
<span class="cviolet"><strong>12</strong></span>            &lt;&lt; fmt::format("0221<span class="green">5: {}; 51220: {}\n\n",</span>&#13;
<span class="cviolet"><strong>13</strong></span>                  <span class="yell">regex_match(<span class="green">"02215"</span>, r1)</span>, <span class="yell">regex_match(<span class="green">"51220"</span>, r1)</span>);&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<pre class="pre1">Matching against: 02215&#13;
02215: true; 51220: false</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.16</strong></span> Matching entire strings to regular expressions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec58">Metacharacters, Character Classes and Quantifiers</h5>&#13;
<p>Regular expressions typically contain various special symbols called <span class="violet"><strong>metacharacters</strong></span>:</p>&#13;
<pre class="pre">[]  {}  ()  \  *  +  ^  $  ?  .  |</pre>&#13;
<p>The <code><span class="violet"><strong>\</strong></span></code> <span class="violet"><strong>metacharacter</strong></span> begins each of the predefined <span class="violet"><strong>character classes</strong></span>, several of which are shown in the following table with the groups of characters they match.</p>&#13;
<div class="group">&#13;
<div class="images"><img src="Images/p0363-01.jpg" alt="Images" width="754" height="270"/></div>&#13;
</div>&#13;
<p><em>To match any metacharacter as its literal value, precede it by a backslash</em>. For example, <code>\$</code> matches a dollar sign (<code>$</code>) and <code>\\</code> matches a backslash (<code>\</code>).</p>&#13;
<h5 class="h5" id="ch08lev3sec59">Matching Digits</h5>&#13;
<p>Let’s validate a five-digit ZIP Code. In the regular expression <code>\d{5}</code> (created by the raw string literal in line 16), <code><span class="violet"><strong>\d</strong></span></code> is a character class representing a digit (0–9). A character class is a <span class="violet"><strong>regular expression escape sequence</strong></span> that <em>matches one character</em>. To match more than one, follow the character class with a <span class="violet"><strong>quantifier</strong></span>. The quantifier <code>{5}</code> repeats <code>\d</code> five times, as if we had written <code>\d\d\d\d\d</code>, to match five consecutive digits. Line 19’s second call to <code>regex_match</code> returns <code>false</code> because <code>"9876"</code> contains only four consecutive digit characters.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0266-01" id="f0266-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>15</strong></span>    <span class="pd_green">// fully match five digits</span>&#13;
<span class="cviolet"><strong>16</strong></span>    <span class="yell">regex r2(<span class="green">R"(\d{5})"</span>);</span>&#13;
<span class="cviolet"><strong>17</strong></span>    cout &lt;&lt; <span class="green">R"(Matching against: \d{5})"</span> &lt;&lt; <span class="green">"\n"</span>&#13;
<span class="cviolet"><strong>18</strong></span>         &lt;&lt; fmt::format("0221<span class="green">5: {}; 9876: {}\n\n",</span>&#13;
<span class="cviolet"><strong>19</strong></span>               <span class="yell">regex_match(<span class="green">"02215"</span>, r2)</span>, <span class="yell">regex_match(<span class="green">"9876"</span>, r2)</span>);&#13;
<span class="cviolet"><strong>20</strong></span></pre>&#13;
<pre class="pre1">Matching against: \d{5}&#13;
02215: true; 9876: false</pre>&#13;
<h5 class="h5" id="ch08lev3sec60">Custom Character Classes</h5>&#13;
<p>Characters in square brackets, <code>[]</code>, define a <span class="violet"><strong>custom character class</strong></span> that <em>matches a single character</em>. For example, <code>[aeiou]</code> matches a lowercase vowel, <code>[A-Z]</code> matches an uppercase letter, <code>[a-z]</code> matches a lowercase letter and <code>[a-zA-Z]</code> matches any lowercase or uppercase letter. Let’s use a custom character class to validate a simple first name with no spaces or punctuation.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0266-02" id="f0266-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>21</strong></span>    <span class="pd_green">// match a word that starts with a capital letter</span>&#13;
<span class="cviolet"><strong>22</strong></span>    <span class="yell">regex r3(<span class="green">"[A-Z][a-z]*"</span>);</span>&#13;
<span class="cviolet"><strong>23</strong></span>    cout &lt;&lt; <span class="green">"Matching against: [A-Z][a-z]*\n"</span>&#13;
<span class="cviolet"><strong>24</strong></span>         &lt;&lt; fmt::format(<span class="green">"Wally: {}; eva: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>25</strong></span>               <span class="yell">regex_match(<span class="green">"Wally"</span>, r3)</span>, <span class="yell">regex_match(<span class="green">"eva"</span>, r3)</span>);&#13;
<span class="cviolet"><strong>26</strong></span></pre>&#13;
<pre class="pre1">Matching against: [A-Z][a-z]*&#13;
Wally: true; eva: false</pre>&#13;
<p>A first name might contain many letters. In the regular expression <code>r3</code> (line 22), <code>[A-Z]</code> matches one uppercase letter, and <code>[a-z]*</code> matches any number of lowercase letters. The <code><span class="violet"><strong>*</strong></span></code> <span class="violet"><strong>quantifier</strong></span> <em>matches zero or more occurrences of the subexpression to its left</em> (in this case, <code>[a-z]</code>). So <code>[A-Z][a-z]*</code> matches <code>"Amanda"</code>, <code>"Bo"</code> or even <code>"E"</code>.</p>&#13;
<p>When a custom character class starts with a <span class="violet"><strong>caret (</strong></span><code><span class="violet"><strong>^</strong></span></code><span class="violet"><strong>)</strong></span>, the class <em>matches any character that’s not specified</em>. So <code>[^a-z]</code> (line 28) matches any character that’s not a lowercase letter:</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0266-03" id="f0266-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>27</strong></span>    <span class="pd_green">// match any character that's not a lowercase letter</span>&#13;
<span class="cviolet"><strong>28</strong></span>    <span class="yell">regex r4(<span class="green">"[^a-z]"</span>);</span>&#13;
<span class="cviolet"><strong>29</strong></span>    cout &lt;&lt; <span class="green">"Matching against: [^a-z]\n"</span>&#13;
<span class="cviolet"><strong>30</strong></span>         &lt;&lt; fmt::format(<span class="green">"A: {}; a: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>31</strong></span>               <span class="yell">regex_match(<span class="green">"A"</span>, r4)</span>, <span class="yell">regex_match(<span class="green">"a"</span>, r4)</span>);&#13;
<span class="cviolet"><strong>32</strong></span></pre>&#13;
<pre class="pre1">Matching against: [^a-z]&#13;
A: true; a: false</pre>&#13;
<p><em>Metacharacters in a custom character class are treated as literal characters</em>—that is, the characters themselves. So <code>[*+$]</code> (line 34) matches a single <code>*</code>, <code>+</code> or <code>$</code> character:</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0267-02" id="f0267-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>33</strong></span>    <span class="pd_green">// match metacharacters as literals in a custom character class</span>&#13;
<span class="cviolet"><strong>34</strong></span>    <span class="yell">regex r5(<span class="green">"[*+$]"</span>);</span>&#13;
<span class="cviolet"><strong>35</strong></span>    cout &lt;&lt; <span class="green">"Matching against: [*+$]\n"</span>&#13;
<span class="cviolet"><strong>36</strong></span>         &lt;&lt; fmt::format(<span class="green">"*: {}; !: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>37</strong></span>               <span class="yell">regex_match(<span class="green">"*"</span>, r5)</span>, <span class="yell">regex_match(<span class="green">"!"</span>, r5)</span>);&#13;
<span class="cviolet"><strong>38</strong></span></pre>&#13;
<pre class="pre1">Matching against: [*+$]&#13;
*: true; !: false</pre>&#13;
<h5 class="h5" id="ch08lev3sec61">* vs. + Quantifier</h5>&#13;
<p>If you want to require at least one lowercase letter in a first name, replace the <code>*</code> quantifier in line 22 with <code><span class="violet"><strong>+</strong></span></code>. This <em>matches at least one occurrence of a subexpression to its left:</em></p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0267-03" id="f0267-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>39</strong></span>    <span class="pd_green">// matching a capital letter followed by at least one lowercase letter</span>&#13;
<span class="cviolet"><strong>40</strong></span>    <span class="yell">regex r6(<span class="green">"[A-Z][a-z]+"</span>)</span>;&#13;
<span class="cviolet"><strong>41</strong></span>    cout &lt;&lt; <span class="green">"Matching against: [A-Z][a-z]*\n"</span>&#13;
<span class="cviolet"><strong>42</strong></span>         &lt;&lt; fmt::format(<span class="green">"Wally: {}; E: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>43</strong></span>               <span class="yell">regex_match(<span class="green">"Wally"</span>, r6)</span>, <span class="yell">regex_match(<span class="green">"E"</span>, r6)</span>);&#13;
<span class="cviolet"><strong>44</strong></span></pre>&#13;
<pre class="pre1">Matching against: [A-Z][a-z]*&#13;
Wally: true; E: false</pre>&#13;
<p>Both * and + are <span class="violet"><strong>greedy</strong></span>—they <em>match as many characters as possible</em>. So the regular expression <code>[A-Z][a-z]+</code> matches <code>"Al"</code>, <code>"Eva"</code>, <code>"Samantha"</code>, <code>"Benjamin"</code> and any other words that begin with a capital letter followed at least one lowercase letter.</p>&#13;
<h5 class="h5" id="ch08lev3sec62">Other Quantifiers</h5>&#13;
<p>The <code><span class="violet"><strong>?</strong></span></code> <span class="violet"><strong>quantifier</strong></span> <em>matches zero or one occurrence of the subexpression to its left</em>. In the regular expression <code>labell?ed</code> (line 46), the subexpression is the literal character <code>"l"</code>. So in line 49’s <code>regex_match</code> calls, the regular expression matches <code>labelled</code> (the U.K. English spelling and <code>labeled</code> (the U.S. English spelling), but in line 50’s <code>regex_match</code> calls, the regular expression does not match the misspelled word <code>labellled</code>.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0267-04" id="f0267-04a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>45</strong></span>    <span class="pd_green">// matching zero or one occurrenctes of a subexpression</span>&#13;
<span class="cviolet"><strong>46</strong></span>    <span class="yell">regex r7(<span class="green">"labell?ed"</span>);</span>&#13;
<span class="cviolet"><strong>47</strong></span>    cout &lt;&lt; <span class="green">"Matching against: labell?ed\n"</span>&#13;
<span class="cviolet"><strong>48</strong></span>         &lt;&lt; fmt::format(<span class="green">"labelled: {}; labeled: {}; labellled: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>49</strong></span>               <span class="yell">regex_match(<span class="green">"labelled"</span>, r7)</span>, <span class="yell">regex_match(<span class="green">"labeled"</span>, r7)</span>,&#13;
<span class="cviolet"><strong>50</strong></span>               <span class="yell">regex_match(<span class="green">"labellled"</span>, r7)</span>);&#13;
<span class="cviolet"><strong>51</strong></span></pre>&#13;
<pre class="pre1">Matching against: labell?ed&#13;
labelled: true; labeled: true; labellled: false</pre>&#13;
<p>You can <em>match at least n occurrences of a subexpression to its left</em> with the <code><span class="violet"><strong>{</strong></span></code><span class="violet"><em><strong>n</strong></em></span><code><span class="violet"><strong>,}</strong></span></code> <span class="violet"><strong>quantifier</strong></span>. The regular expression in line 53 matches strings containing at least three digits:</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0268-02" id="f0268-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>52</strong></span>    <span class="pd_green">// matching n (3) or more occurrences of a subexpression</span>&#13;
<span class="cviolet"><strong>53</strong></span>    <span class="yell">regex r8(<span class="green">R"(\d{3,})"</span>);</span>&#13;
<span class="cviolet"><strong>54</strong></span>    cout &lt;&lt; <span class="green">R"(Matching against: \d{3,})"</span> &lt;&lt; <span class="green">"\n"</span>&#13;
<span class="cviolet"><strong>55</strong></span>         &lt;&lt; fmt::format(<span class="green">"123: {}; 1234567890: {}; 12: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>56</strong></span>               <span class="yell">regex_match(<span class="green">"123"</span>, r8)</span>, <span class="yell">regex_match(<span class="green">"1234567890"</span>, r8),</span>&#13;
<span class="cviolet"><strong>57</strong></span>               <span class="yell">regex_match(<span class="green">"12"</span>, r8)</span>);&#13;
<span class="cviolet"><strong>58</strong></span></pre>&#13;
<pre class="pre1">Matching against: \d{3,}&#13;
123: true; 1234567890: true; 12: false</pre>&#13;
<p>You can <em>match between n and m (inclusive) occurrences</em> of a subexpression with the <code><span class="violet"><strong>{</strong></span></code><span class="violet"><em><strong>n</strong></em></span><code><span class="violet"><strong>,</strong></span></code><span class="violet"><em><strong>m</strong></em></span><code><span class="violet"><strong>}</strong></span></code> <span class="violet"><strong>quantifier</strong></span>. The regular expression in line 60 matches strings containing 3 to 6 digits:</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0268-03" id="f0268-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>59</strong></span>    <span class="pd_green">// matching n to m inclusive (3-6), occurrences of a subexpression</span>&#13;
<span class="cviolet"><strong>60</strong></span>    <span class="yell">regex r9(<span class="green">R"(\d{3,6})"</span>);</span>&#13;
<span class="cviolet"><strong>61</strong></span>    cout &lt;&lt; <span class="green">R"(Matching against: \d{3,6})"</span> &lt;&lt; <span class="green">"\n"</span>&#13;
<span class="cviolet"><strong>62</strong></span>         &lt;&lt; fmt::format(<span class="green">"123: {}; 123456: {}; 1234567: {}; 12: {}\n"</span>,&#13;
<span class="cviolet"><strong>63</strong></span>               <span class="yell">regex_match(<span class="green">"123"</span>, r9)</span>, <span class="yell">regex_match(<span class="green">"123456"</span>, r9)</span>,&#13;
<span class="cviolet"><strong>64</strong></span>               <span class="yell">regex_match(<span class="green">"1234567"</span>, r9)</span>, <span class="yell">regex_smatch(<span class="green">"12"</span>, r9)</span>);&#13;
<span class="cviolet"><strong>65</strong></span>  }</pre>&#13;
<pre class="pre1">Matching against: \d{3,6}\&#13;
123: true; 123456: true; 1234567: false; 12: false</pre>&#13;
<h4 class="h4" id="ch08lev2sec5">8.20.2 Replacing Substrings</h4>&#13;
<p>The header <code>&lt;regex&gt;</code> provides function <code><span class="violet"><strong>regex_replace</strong></span></code> to replace patterns in a string. Let’s convert a tab-delimited string to comma-delimited (<a href="#fig8_17">Fig. 8.17</a>). The <code>regex_replace</code> (line 15) function receives three arguments:</p>&#13;
<p class="bull">• the <code>string</code> to be searched (<code>"1\t2\t3\t4"</code>)</p>&#13;
<p class="bull">• the <code>regex</code> pattern to match (the tab character <code>"\t"</code>) and</p>&#13;
<p class="bull">• the replacement text (<code>","</code>)</p>&#13;
<p>and returns a new <code>string</code> containing the modifications. The expression <code>regex{R"(\t)"}</code> in line 15 creates a temporary <code>regex</code> object, initializes it and immediately passes it to <code>regex_replace</code>. This is useful if you do not need to reuse a <code>regex</code> multiple times.</p>&#13;
<div class="group" id="fig8_17">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig17" id="aa08fig17">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>  <span class="pd_green">// fig08_17.cpp</span>&#13;
 <span class="cviolet"><strong>2</strong></span>  <span class="pd_green">// Regular expression replacements and splitting.</span>&#13;
 <span class="cviolet"><strong>3</strong></span>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
 <span class="cviolet"><strong>4</strong></span>  <span class="blue">#include</span> &lt;regex&gt;&#13;
 <span class="cviolet"><strong>5</strong></span>  <span class="blue">#include</span> &lt;string&gt;&#13;
 <span class="cviolet"><strong>6</strong></span>  <span class="blue">#include</span> &lt;vector&gt;&#13;
 <span class="cviolet"><strong>7</strong></span>  <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span>&#13;
 <span class="cviolet"><strong>8</strong></span>  <span class="blue">using namespace</span> std;&#13;
 <span class="cviolet"><strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>    <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>11</strong></span>       <span class="pd_green">// replace tabs with commas</span>&#13;
<span class="cviolet"><strong>12</strong></span>       string s1(<span class="green">"1\t2\t3\t4"</span>);&#13;
<span class="cviolet"><strong>13</strong></span>       cout &lt;&lt; <span class="green">"Original string: 1\\t2\\t3\\t4\n"</span>;&#13;
<span class="cviolet"><strong>14</strong></span>       cout &lt;&lt; fmt::format(<span class="green">"After replacing tabs with commas: {}\n"</span>,&#13;
<span class="cviolet"><strong>15</strong></span>                   <span class="yell">regex_replace(s1, regex{<span class="green">R"(\t)"</span>}, <span class="green">","</span>)</span>);&#13;
<span class="cviolet"><strong>16</strong></span>    }</pre>&#13;
<pre class="pre1">Original string: 1\t2\t3\t4&#13;
After replacing tabs with commas: 1,2,3,4</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.17</strong></span> Regular expression replacements and splitting.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec6">8.20.3 Searching for Matches</h4>&#13;
<p>You can match a substring within a string using function <code><span class="violet"><strong>regex_search</strong></span></code> (<a href="#fig8_18">Fig. 8.18</a>), which returns <code>true</code> if any part of an arbitrary <code>string</code> matches the regular expression. Optionally, the function also gives you access to the matching substring via an object of the class template <code><span class="violet"><strong>match_results</strong></span></code> that you pass as an argument. There are <code>match_results</code> aliases for different string types:</p>&#13;
<p class="bull">• For searches in <code>std::string</code>s and string object literals, use an <code><span class="violet"><strong>smatch</strong></span></code> (pronounced “ess match”).</p>&#13;
<p class="bull">• For searches on C-strings and string literals, you use a <code><span class="violet"><strong>cmatch</strong></span></code> (pronounced “see match”).</p>&#13;
<div class="group" id="fig8_18">&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#a08fig18" id="aa08fig18">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>1</strong></span>    <span class="pd_green">// fig08_18.cpp</span>&#13;
 <span class="cviolet"><strong>2</strong></span>    <span class="pd_green">// Matching patterns throughout a string.</span>&#13;
 <span class="cviolet"><strong>3</strong></span>    <span class="blue">#include</span> &lt;iostream&gt;&#13;
 <span class="cviolet"><strong>4</strong></span>    <span class="blue">#include</span> &lt;regex&gt;&#13;
 <span class="cviolet"><strong>5</strong></span>    <span class="blue">#include</span> &lt;string&gt;&#13;
 <span class="cviolet"><strong>6</strong></span>    <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="pd_green">// In C++20, this will be #include &lt;format&gt;</span>&#13;
 <span class="cviolet"><strong>7</strong></span>    <span class="blue">using namespace</span> std;&#13;
 <span class="cviolet"><strong>8</strong></span>&#13;
 <span class="cviolet"><strong>9</strong></span>    <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>       <span class="pd_green">// performing a simple match</span>&#13;
<span class="cviolet"><strong>11</strong></span>       string s1{<span class="green">"Programming is fun"</span>};&#13;
<span class="cviolet"><strong>12</strong></span>       cout &lt;&lt; fmt::format(<span class="green">"s1: {}\n\n"</span>, s1);&#13;
<span class="cviolet"><strong>13</strong></span>       cout &lt;&lt; <span class="green">"Search anywhere in s1:\n"</span>&#13;
<span class="cviolet"><strong>14</strong></span>          &lt;&lt; fmt::format(<span class="green">"Programming: {}; fun: {}; fn: {}\n\n",</span>&#13;
<span class="cviolet"><strong>15</strong></span>                <span class="yell">regex_search(s1, regex{<span class="green">"Programming"}),</span></span>&#13;
<span class="cviolet"><strong>16</strong></span>                <span class="yell">regex_search(s1, regex{<span class="green">"fun"</span>}),</span>&#13;
<span class="cviolet"><strong>17</strong></span>                <span class="yell">regex_search(s1, regex{<span class="green">"fn"</span>}));</span>&#13;
<span class="cviolet"><strong>18</strong></span></pre>&#13;
<pre class="pre1">s1: Programming is fun&#13;
&#13;
Search anywhere in s1:&#13;
Programming: true; fun: true; fn: false</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 8.18</strong></span> Matching patterns throughout a string.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec63">Finding a Match Anywhere in a String</h5>&#13;
<p>The calls to function <code>regex_search</code> in lines 15–17, search in <code>s1</code> (<code>"Programming is fun"</code>) for the first occurrence of a substring that matches a regular expression—in this case, the literal strings <code>"Programming"</code>, <code>"fun"</code> and <code>"fn"</code>. Function <code>regex_search</code>’s two-argument version simply returns <code>true</code> or <code>false</code> to indicate a match.</p>&#13;
<h5 class="h5" id="ch08lev3sec64">Ignoring Case in a Regular Expression and Viewing the Matching Text</h5>&#13;
<p>The <code><span class="violet"><strong>regex_constants</strong></span></code> in the header <code>&lt;regex&gt;</code> can customize how regular expressions perform matches. For example, matches are case sensitive by default, but by using the constant <code><span class="violet"><strong>regex_constants::icase</strong></span></code>, you can perform a case-insensitive search.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0270-01" id="f0270-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>19</strong></span>    <span class="pd_green">// ignoring case</span>&#13;
<span class="cviolet"><strong>20</strong></span>    string s2{<span class="green">"SAM WHITE"</span>};&#13;
<span class="cviolet"><strong>21</strong></span>    <span class="yell">smatch match;</span> <span class="pd_green">// store the text that matches the pattern</span>&#13;
<span class="cviolet"><strong>22</strong></span>    cout &lt;&lt; fmt::format(<span class="green">"s2: {}\n\n"</span>, s2);&#13;
<span class="cviolet"><strong>23</strong></span>    cout &lt;&lt; <span class="green">"Case insensitive search for Sam in s2:\n"</span>&#13;
<span class="cviolet"><strong>24</strong></span>         &lt;&lt; fmt::format(<span class="green">"Sam: {}\n"</span>,&#13;
<span class="cviolet"><strong>25</strong></span>               <span class="yell">regex_search(s2, match, regex{<span class="green">"Sam"</span>, <span class="green">regex_constants::icase</span>})</span>)&#13;
<span class="cviolet"><strong>26</strong></span>         &lt;&lt; fmt::format(<span class="green">"Matched text: {}\n\n"</span>, <span class="yell">match.str()</span>);&#13;
<span class="cviolet"><strong>27</strong></span></pre>&#13;
<pre class="pre1">s2: SAM WHITE&#13;
&#13;
Case insensitive search for Sam in s2:&#13;
Sam: true&#13;
Matched text: SAM</pre>&#13;
<p>Line 25 calls <code>regex_search</code>’s three-argument version in which the arguments are:</p>&#13;
<p class="bull">• the string to search (<code>s2</code>; line 20), which in this case contains all capital letters,</p>&#13;
<p class="bull">• the <code>smatch</code> object (line 21) that stores the match if there is one, and</p>&#13;
<p class="bull">• the <code>regex</code> pattern to match.</p>&#13;
<p>Here, we created the <code>regex</code> with a second argument</p>&#13;
<pre class="pre">regex{<span class="green">"Sam"</span>, <span class="green">regex_constants::icase</span>}</pre>&#13;
<p>This <code>regex</code> matches the literal characters <code>"Sam"</code> regardless of their case. So, in <code>s2</code>, <code>"SAM"</code> matches the <code>regex "Sam"</code> because both have the same letters, even though <code>"SAM"</code> contains only uppercase letters. To confirm the matching text, line 26 gets the <code>match</code>’s <code>string</code> representation by calling its member function <code><span class="violet"><strong>str</strong></span></code>.</p>&#13;
<h5 class="h5" id="ch08lev3sec65">Finding All Matches in a String</h5>&#13;
<p>Let’s extract all the U.S. phone numbers of the form <code>###-###-####</code> from a string. The following code finds each substring in <code>contact</code> (line 29) that matches the <code>regex phone</code> (line 30) and displays the matching text.</p>&#13;
<p class="codelink"><a href="Images/ch08_images.xhtml#f0271-01" id="f0271-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>28</strong></span>    <span class="pd_green">// finding all matches</span>&#13;
<span class="cviolet"><strong>29</strong></span>    string contact{<span class="green">"Wally White, Home: 555-555-1234, Work: 555-555-4321"</span>};&#13;
<span class="cviolet"><strong>30</strong></span>    <span class="yell">regex phone{<span class="green">R"(\d{3}-\d{3}-\d{4})"</span>};</span>&#13;
<span class="cviolet"><strong>31</strong></span>&#13;
<span class="cviolet"><strong>32</strong></span>    cout &lt;&lt; <span class="green">"\nFinding all phone numbers in:\n"</span> &lt;&lt; contact &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>33</strong></span>    <span class="blue">while</span> (<span class="yell">regex_search(contact, match, phone)</span>) {&#13;
<span class="cviolet"><strong>34</strong></span>       cout &lt;&lt; fmt::format(<span class="green">"   {}\n"</span>, <span class="yell">match.str()</span>);&#13;
<span class="cviolet"><strong>35</strong></span>       <span class="yell">contact = match.suffix();</span>&#13;
<span class="cviolet"><strong>36</strong></span>    }&#13;
<span class="cviolet"><strong>37</strong></span>  }</pre>&#13;
<pre class="pre1">Finding all phone numbers in:&#13;
Wally White, Home: 555-555-1234, Work: 555-555-4321&#13;
   555-555-1234&#13;
   555-555-4321</pre>&#13;
<p>The <code>while</code> statement iterates as long as <code>regex_search</code> returns <code>true</code>—that is, as long as it finds a match. Each iteration of the loop</p>&#13;
<p class="bull">• displays the substring that matched the regular expression (line 34), then</p>&#13;
<p class="bull">• replaces <code>contact</code> with the result of calling the <code>match</code> object’s member function <code><span class="violet"><strong>suffix</strong></span></code> (line 35), which returns the portion of the string that has not yet been searched. This new <code>contact</code> string is used in the next call to <code>regex_search</code>.</p>&#13;
<h3 class="h3" id="ch08lev1sec21"><span class="violet">8.21</span> Wrap-Up</h3>&#13;
<p>This chapter discussed more details of <code>std::string</code>, such as assigning, concatenating, comparing, searching and swapping strings. We also introduced several member functions to determine string characteristics, to find, replace and insert characters in a string, and to convert <code>string</code>s to pointer-based strings and vice versa. We performed input from and output to strings in memory, and introduced functions for converting numeric values to <code>string</code>s and for converting <code>string</code>s to numeric values.</p>&#13;
<p>We presented sequential text-file processing using features from the header <code>&lt;fstream&gt;</code> to manipulate persistent data, then demonstrated string stream processing. In our first objects-natural case study, we used an open source library to read the contents of the Titanic dataset from a CSV file, then performed some basic data analytics. In our second objects-natural case study, we introduced regular expressions for pattern matching.</p>&#13;
<p>We’ve now introduced the basic concepts of control statements, functions, <code>array</code>s, <code>vector</code>s, <code>string</code>s and files. You’ve already seen in many of our objects natural case studies, that C++ applications typically create and manipulate objects that perform the work of the application.</p>&#13;
<p>In <a href="ch09.xhtml#ch09">Chapter 9</a>, you’ll learn how to implement your own custom classes and use objects of those classes in applications. We’ll begin discussing class-design and related software-engineering concepts.</p>&#13;
</div></body>
</html>