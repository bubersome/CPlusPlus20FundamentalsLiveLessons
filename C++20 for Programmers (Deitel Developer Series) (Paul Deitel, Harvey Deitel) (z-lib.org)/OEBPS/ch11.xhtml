<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch11">Chapter 11. Operator Overloading, Copy/Move Semantics and Smart Pointers</h2>&#13;
<div class="image"><img src="Images/common.jpg" alt="Images" width="370" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Use built-in <code>string</code> class overloaded operators.</p>&#13;
<p class="squ"><span class="red">■</span> Use operator overloading to help you craft valuable classes.</p>&#13;
<p class="squ"><span class="red">■</span> Understand the special member functions and when to implement them for custom types.</p>&#13;
<p class="squ"><span class="red">■</span> Understand when objects should be moved vs. copied.</p>&#13;
<p class="squ"><span class="red">■</span> Use <em>rvalue</em> references and move semantics to eliminate unnecessary copies of temporary objects that are going out of scope, improving program performance.</p>&#13;
<p class="squ"><span class="red">■</span> Understand why you should avoid dynamic memory management with operators <code>new</code> and <code>delete</code>.</p>&#13;
<p class="squ"><span class="red">■</span> Manage dynamic memory automatically with smart pointers.</p>&#13;
<p class="squ"><span class="red">■</span> Craft a polished <code>MyArray</code> class that defines the five special member functions to support copy and move semantics, and overloads many unary and binary operators.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++20’s three-way comparison operator (<code>&lt;=&gt;</code>).</p>&#13;
<p class="squ"><span class="red">■</span> Convert objects to other types.</p>&#13;
<p class="squ"><span class="red">■</span> Use keyword <code>explicit</code> to prevent constructors and conversion operators from being used for implicit conversions.</p>&#13;
<p class="squ"><span class="red">■</span> Experience a “light-bulb moment” when you’ll truly appreciate the elegance and beauty of the class concept.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_1"><span class="violet"><strong>11.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_2"><span class="violet"><strong>11.2</strong></span> Using the Overloaded Operators of Standard Library Class <code>string</code></a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_3"><span class="violet"><strong>11.3</strong></span> Operator Overloading Fundamentals</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_3_1">11.3.1 Operator Overloading Is Not Automatic</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_3_2">11.3.2 Operators That Cannot Be Overloaded</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_3_3">11.3.3 Operators That You Do Not Have to Overload</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_3_4">11.3.4 Rules and Restrictions on Operator Overloading</a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_4"><span class="violet"><strong>11.4</strong></span> (Downplaying) Dynamic Memory Management with <code>new</code> and <code>delete</code></a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_5"><span class="violet"><strong>11.5</strong></span> Modern C++ Dynamic Memory Management—RAII and Smart Pointers</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_5_1">11.5.1 Smart Pointers</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_5_2">11.5.2 Demonstrating <code>unique_ptr</code></a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_5_3">11.5.3  <code>unique_ptr</code> Ownership</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_5_4">11.5.4  <code>unique_ptr</code> to a Built-In Array</a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_6"><span class="violet"><strong>11.6</strong></span> <code>MyArray</code> Case Study: Crafting a Valuable Class with Operator Overloading</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_1">11.6.1 Special Member Functions</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_2">11.6.2 Using Class <code>MyArray</code></a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_3">11.6.3  <code>MyArray</code> Class Definition</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_4">11.6.4 Constructor That Specifies a <code>MyArray</code>’s Size</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_5">11.6.5 C++11 Passing a Braced Initializer to a Constructor</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_6">11.6.6 Copy Constructor and Copy Assignment Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_7">11.6.7 Move Constructor and Move Assignment Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_8">11.6.8 Destructor</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_9">11.6.9  <code>toString</code> and <code>size</code> Functions</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_10">11.6.10 Overloading the Equality (<code>==</code>) and Inequality (<code>!=</code>) Operators</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_11">11.6.11 Overloading the Subscript (<code>[]</code>) Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_12">11.6.12 Overloading the Unary <code>bool</code> Conversion Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_13">11.6.13 Overloading the Preincrement Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_14">11.6.14 Overloading the Postincrement Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_15">11.6.15 Overloading the Addition Assignment Operator (<code>+=</code>)</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_16">11.6.16 Overloading the Binary Stream Extraction (<code>&gt;&gt;</code>) and Stream Insertion (<code>&lt;&lt;</code>) Operators</a></p>&#13;
<p class="chap-lev2"><a href="ch11.xhtml#sec11_6_17">11.6.17  <code>friend</code> Function <code>swap</code></a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_7"><span class="violet"><strong>11.7</strong></span> C++20 Three-Way Comparison Operator (<code>&lt;=&gt;</code>)</a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_8"><span class="violet"><strong>11.8</strong></span> Converting Between Types</a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_9"><span class="violet"><strong>11.9</strong></span> <code>explicit</code> Constructors and Conversion Operators</a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_10"><span class="violet"><strong>11.10</strong></span> Overloading the Function Call Operator <code>()</code></a></p>&#13;
<p class="chap-lev1"><a href="ch11.xhtml#sec11_11"><span class="violet"><strong>11.11</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="sec11_1"><span class="violet">11.1</span> Introduction</h3>&#13;
<p>This chapter shows how to enable C++’s existing operators to work with class objects—a process called <strong><span class="violet">operator overloading</span></strong>. One example of an overloaded operator in standard C++ is <code>&lt;&lt;</code>, which is used <em>both</em> as</p>&#13;
<p class="bull">• the stream insertion operator <em>and</em></p>&#13;
<p class="bull">• the bitwise left-shift operator (which is discussed in Appendix E).</p>&#13;
<p>Similarly, <code>&gt;&gt;</code> also is overloaded; it’s used both as</p>&#13;
<p class="bull">• the stream extraction operator <em>and</em></p>&#13;
<p class="bull">• the bitwise right-shift operator (which is discussed in Appendix E).</p>&#13;
<p>You’ve actually been using overloaded operators since early in the book. Various overloads are built into the core C++ language itself. For example, C++ overloads the addition operator (<code>+</code>) to perform differently, based on its context in integer, floating-point and pointer arithmetic with data of fundamental types.</p>&#13;
<p>You can overload most operators to be used with class objects. The compiler generates the appropriate code based on the operand types. The jobs performed by overloaded operators also can be performed by explicit function calls, but operator notation is often more natural.</p>&#13;
<h5 class="h5" id="ch11lev3sec1"><code>string</code> Class Overloaded Operators Demonstration</h5>&#13;
<p>In <a href="ch02.xhtml#ch02lev1sec7">Section 2.7</a>’s objects-natural case study, we introduced the standard library’s <code>string</code> class and demonstrated a few of its features, such as string concatenation with the <code>+</code> operator. Here, we demonstrate many additional <code>string</code>-class overloaded operators, so you can appreciate how valuable operator overloading is in a key standard library class before implementing it in your own custom classes. Next, we’ll present operator-overloading fundamentals.</p>&#13;
<h5 class="h5" id="ch11lev3sec2">Dynamic Memory Management and Smart Pointers</h5>&#13;
<p>We introduce dynamic memory management, which enables a program to acquire additional memory it needs for objects at runtime rather than at compile-time and release that memory when it’s no longer needed so it can be used for other purposes. We discuss the potential problems with dynamically allocated memory, such as forgetting to release memory that’s no longer needed—known as a <strong><span class="violet">memory leak</span></strong>. Then, we introduce smart pointers, which can automatically release dynamically allocated memory for you. As you’ll see, <strong>smart pointers</strong>, when coupled with the <strong>RAII (Resource Acquisition Is Initialization) strategy</strong>, enable you to eliminate subtle memory leak issues.</p>&#13;
<h5 class="h5" id="ch11lev3sec3"><code>MyArray</code> Case Study</h5>&#13;
<p>Next, we present one of the book’s capstone case studies. We build a custom <code>MyArray</code> class that uses overloaded operators and other capabilities to solve various problems with C++’s native pointer-based arrays. We introduce and implement the five <strong>special member functions</strong> you can define in each class—the copy constructor, copy assignment operator, move constructor, move assignment operator and destructor. Sometimes the default constructor also is included as a special member function. We introduce copy semantics and move semantics, which help tell a compiler when it can move resources from one object to another to avoid costly unnecessary copies.</p>&#13;
<p><code>MyArray</code> uses smart pointers and RAII, and overloads many unary and binary operators, including</p>&#13;
<p class="bull">• <code>=</code> (assignment),</p>&#13;
<p class="bull">• <code>==</code> (equality),</p>&#13;
<p class="bull">• <code>!=</code> (inequality),</p>&#13;
<p class="bull">• <code>[]</code> (subscript),</p>&#13;
<p class="bull">• <code>++</code> (increment),</p>&#13;
<p class="bull">• <code>+=</code> (addition assignment),</p>&#13;
<p class="bull">• <code>&gt;&gt;</code> (stream extraction) and</p>&#13;
<p class="bull">• <code>&lt;&lt;</code> (stream insertion).</p>&#13;
<p>We also show how to define a conversion operator that converts a <code>MyArray</code> to a <code>true</code> or <code>false bool</code> value, indicating whether a <code>MyArray</code> contains elements or is empty.</p>&#13;
<p><strong>Many of our readers have said that working through the <code>MyArray</code> case study is a “light bulb moment,” helping them truly appreciate what classes and object technology are all about.</strong> Once you master this <code>MyArray</code> class, you’ll indeed understand the essence of object technology—<strong>crafting, using and reusing valuable classes—and sharing them with colleagues and perhaps the entire C++ open-source community</strong>.</p>&#13;
<h5 class="h5" id="ch11lev3sec4">C++20’s Three-Way Comparison Operator (<strong><code>&lt;=&gt;</code></strong>)</h5>&#13;
<p><span class="size">20</span> We introduce C++20’s new three-way comparison operator (&lt;=&gt;), which is also referred to as the “spaceship operator.”<sup><a id="ch11fn1a" href="ch11.xhtml#ch11fn1">1</a></sup></p>&#13;
<p class="footnote"><a id="ch11fn1" href="ch11.xhtml#ch11fn1a">1</a>. “Spaceship operator” was coined by Randal L. Schwartz when he was teaching the same operator in a Perl programming course—the operator reminded him of a spaceship in an early video game. <code><a href="https://groups.google.com/a/dartlang.org/g/misc/c/WS5xftItpl4/m/jcIttrMq8agJ?pli=1">https://groups.google.com/a/dartlang.org/g/misc/c/WS5xftItpl4/m/jcIttrMq8agJ?pli=1</a></code>.</p>&#13;
<h5 class="h5" id="ch11lev3sec5">Conversion Operators</h5>&#13;
<p>We discuss overloaded conversion operators and conversion constructors in more depth. In particular, we demonstrate how implicit conversions can cause subtle problems. Then, we use <code>explicit</code> to prevent those problems.</p>&#13;
<h3 class="h3" id="sec11_2"><span class="violet">11.2</span> Using the Overloaded Operators of Standard Library Class <code>string</code></h3>&#13;
<p><a href="ch08.xhtml#ch08">Chapter 8</a> presented class <code>string</code> in detail. <a href="ch11.xhtml#fig11_1">Figure 11.1</a> demonstrates many of class <code>string</code>’s overloaded operators and several other useful member functions, including <code>empty</code>, <code>substr</code> and <code>at</code>:</p>&#13;
<p class="bull">• <code>empty</code> determines whether a <code>string</code> is empty,</p>&#13;
<p class="bull">• <code>substr</code> (for “substring”) returns a <code>string</code> that’s a portion of an existing <code>string</code>, and</p>&#13;
<p class="bull">• <code>at</code> returns the character at a specific index in a <code>string</code> (after checking that the index is in range).</p>&#13;
<p>For discussion purposes, we split this example into small chunks of code, each followed by its output.</p>&#13;
<div class="group" id="fig11_1">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p11pro01" id="p11pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig11_01.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library string class test program.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// in C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 11.1</strong></span> | Standard library <code>string</code> class test program.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec6">Creating <code>string</code> and <strong><code>string_view</code></strong> Objects and Displaying Them with <strong><code>cout</code></strong> and Operator <strong><code>&lt;&lt;</code></strong></h5>&#13;
<p>Lines 10–13 create three <code>string</code>s and a <code>string_view</code>:</p>&#13;
<p class="bull">• the <code>string s1</code> is initialized with the literal <code>"happy"</code>,</p>&#13;
<p class="bull">• the <code>string s2</code> is initialized with the literal <code>" birthday"</code>,</p>&#13;
<p class="bull">• the <code>string s3</code> uses <code>string</code>’s default constructor to create an empty <code>string</code>, and</p>&#13;
<p class="bull">• the <code>string_view v</code> is initialized to reference the characters in the literal <code>"hello"</code>.</p>&#13;
<p>Lines 16–17 output these three objects, using <code>cout</code> and operator <code>&lt;&lt;</code>, which the <code>string</code> and <code>string_view</code> class designers overloaded to handle <code>string</code> objects.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p579pro01" id="p579pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>10</strong></span>   string s1{<span class="green">"happy"</span>}; <span class="lgreen">// initialize string from char*</span>&#13;
<span class="cviolet"><strong>11</strong></span>   string s2{<span class="green">" birthday"</span>}; <span class="lgreen">// initialize string from char*</span>&#13;
<span class="cviolet"><strong>12</strong></span>   string s3; <span class="lgreen">// creates an empty string</span>&#13;
<span class="cviolet"><strong>13</strong></span>   string_view v{<span class="green">"hello"</span>}; <span class="lgreen">// initialize string_view from char*</span>&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// output strings and string_view</span>&#13;
<span class="cviolet"><strong>16</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"s1: \"{}\"; s2: \"{}\"; s3: \"{}\"; v: \"{}\"\n\n"</span>,&#13;
<span class="cviolet"><strong>17</strong></span>              s1, s2, s3, v);&#13;
<span class="cviolet"><strong>18</strong></span></pre>&#13;
<pre class="pre1">s1: "happy"; s2: " birthday"; s3: ""; v: "hello"</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec7">Comparing <code>string</code> Objects with the Equality and Relational Operators</h5>&#13;
<p><span class="size">20</span> Lines 20–26 show the results of comparing <code>s2</code> to <code>s1</code> by using class <code>string</code>’s overloaded equality and relational operators. These perform lexicographical comparisons (that is, like a dictionary ordering) using the numerical values of the characters in each <code>string</code> (see Appendix B, ASCII Character Set). When you use C++20’s <code>format</code> function to convert a <code>bool</code> to a <code>string</code>, <code>format</code> produces the <code>string "true"</code> or the <code>string "false"</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p579pro02" id="p579pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>19</strong></span>   <span class="lgreen">// test overloaded equality and relational operators</span>&#13;
<span class="cviolet"><strong>20</strong></span>   cout &lt;&lt; <span class="green">"The results of comparing s2 and s1:\n"</span>&#13;
<span class="cviolet"><strong>21</strong></span>      &lt;&lt; fmt::format(<span class="green">"s2 == s1: {}\n"</span>, s2 == s1)&#13;
<span class="cviolet"><strong>22</strong></span>      &lt;&lt; fmt::format(<span class="green">"s2 != s1: {}\n"</span>, s2 != s1)&#13;
<span class="cviolet"><strong>23</strong></span>      &lt;&lt; fmt::format(<span class="green">"s2 &gt; s1: {}\n"</span>, s2 &gt; s1)&#13;
<span class="cviolet"><strong>24</strong></span>      &lt;&lt; fmt::format(<span class="green">"s2 &lt; s1: {}\n"</span>, s2 &lt; s1)&#13;
<span class="cviolet"><strong>25</strong></span>      &lt;&lt; fmt::format(<span class="green">"s2 &gt;= s1: {}\n"</span>, s2 &gt;= s1)&#13;
<span class="cviolet"><strong>26</strong></span>      &lt;&lt; fmt::format(<span class="green">"s2 &lt;= s1: {}\n\n"</span>, s2 &lt;= s1);&#13;
<span class="cviolet"><strong>27</strong></span></pre>&#13;
<pre class="pre1">The results of comparing s2 and s1:&#13;
s2 == s1: false&#13;
s2 != s1: true&#13;
s2 &gt; s1: false&#13;
s2 &lt; s1: true&#13;
s2 &gt;= s1: false&#13;
s2 &lt;= s1: true</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec8"><code>string</code> Member Function <strong><code>empty</code></strong></h5>&#13;
<p>Line 31 uses <code>string</code> member function <span class="violet"><strong><code>empty</code></strong></span>, which returns <code>true</code> if the <code>string</code> is empty; otherwise, it returns <code>false</code>. The object <code>s3</code> was initialized with the default constructor, so it is indeed empty.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p580pro01" id="p580pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>28</strong></span>   <span class="lgreen">// test string member function empty</span>&#13;
<span class="cviolet"><strong>29</strong></span>   cout &lt;&lt; <span class="green">"Testing s3.empty():\n"</span>;&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>   <span class="blue">if</span> (s3.empty()) {&#13;
<span class="cviolet"><strong>32</strong></span>      cout &lt;&lt; <span class="green">"s3 is empty; assigning s1 to s3;\n"</span>;&#13;
<span class="cviolet"><strong>33</strong></span>      s3 = s1; <span class="lgreen">// assign s1 to s3</span>&#13;
<span class="cviolet"><strong>34</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"s3 is \"{}\"\n\n"</span>, s3);&#13;
<span class="cviolet"><strong>35</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>36</strong></span></pre>&#13;
<pre class="pre1">Testing s3.empty():&#13;
s3 is empty; assigning s1 to s3;&#13;
s3 is "happy"</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec9"><code>string</code> Copy Assignment Operator</h5>&#13;
<p>Line 33 demonstrates class <code>string</code>’s <strong><span class="violet">overloaded copy assignment operator</span></strong> by assigning <code>s1</code> to <code>s3</code>. Line 34 outputs <code>s3</code> to demonstrate that the assignment worked correctly.</p>&#13;
<h5 class="h5" id="ch11lev3sec10"><code>string</code> Concatenation and C++14 <strong><code>string</code></strong>-object Literals</h5>&#13;
<p>Line 38 demonstrates class <code>string</code>’s overloaded <code>+=</code> operator for <strong><span class="violet">string concatenation assignment</span></strong>. In this case, the contents of <code>s2</code> are appended to <code>s1</code>, thus modifying its value. Then line 39 outputs the resulting <code>string</code> that’s stored in <code>s1</code>. Line 42 demonstrates that you also may append a C-string literal to a <code>string</code> object by using operator <code>+=</code>. Line 43 displays the result.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p580pro02" id="p580pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>37</strong></span>   <span class="lgreen">// test overloaded string concatenation assignment operator</span>&#13;
<span class="cviolet"><strong>38</strong></span>   s1 += s2; <span class="lgreen">// test overloaded concatenation</span>&#13;
<span class="cviolet"><strong>39</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"s1 += s2 yields s1 = {}\n\n"</span>, s1);&#13;
<span class="cviolet"><strong>40</strong></span>&#13;
<span class="cviolet"><strong>41</strong></span>   <span class="lgreen">// test string concatenation with a C string</span>&#13;
<span class="cviolet"><strong>42</strong></span>   s1 += <span class="green">" to you"</span>;&#13;
<span class="cviolet"><strong>43</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"s1 += \" to you\" yields s1 = {}\n\n"</span>, s1);&#13;
<span class="cviolet"><strong>44</strong></span>&#13;
<span class="cviolet"><strong>45</strong></span>   <span class="lgreen">// test string concatenation with a C++14 string-object literal</span>&#13;
<span class="cviolet"><strong>46</strong></span>   s1 += <span class="green">", have a great day!"s</span>; <span class="lgreen">// s after " for string-object literal</span>&#13;
<span class="cviolet"><strong>47</strong></span>   <code>cout &lt;&lt; fmt::format(</code>&#13;
<span class="cviolet"><strong>48</strong></span>              <span class="green">"s1 += \", have a great day!\"s yields\ns1 = {}\n\n"</span>, s1);&#13;
<span class="cviolet"><strong>49</strong></span></pre>&#13;
<pre class="pre1">s1 += s2 yields s1 = happy birthday&#13;
&#13;
s1 += " to you" yields s1 = happy birthday to you&#13;
&#13;
s1 += ", have a great day!"s yields&#13;
s1 = happy birthday to you, have a great day!</pre>&#13;
</div>&#13;
<p><span class="size">14</span> Similarly, line 46 concatenates <code>s1</code> with a C++14 <span class="violet"><strong><code>string</code></strong></span><strong><span class="violet">-object literal</span></strong>, which is indicated by placing the letter <code>s</code> immediately following the closing <code>"</code> of a <code>string</code> literal, as in</p>&#13;
<pre class="pre">", have a great day!"s</pre>&#13;
<p>The preceding literal actually results in a call to a C++ standard library function that returns a <code>string</code> object containing the literal’s characters. Lines 47–48 display the new value of <code>s1</code>.</p>&#13;
<h5 class="h5" id="ch11lev3sec11"><code>string</code> Member Function <strong><code>substr</code></strong></h5>&#13;
<p>Class <code>string</code> provides member function <span class="violet"><strong><code>substr</code></strong></span> (lines 53 and 58) to return a <code>string</code> containing a portion of the <code>string</code> object on which the function is called. The call to <code>substr</code> in line 53 obtains a 14-character substring of <code>s1</code> starting at position 0. The call in line 58 obtains a substring starting from position 15 of <code>s1</code>. When the second argument is not specified, <code>substr</code> returns the remainder of the <code>string</code> on which it’s called.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p581pro01" id="p581pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>50</strong></span>   <span class="lgreen">// test string member function substr</span>&#13;
<span class="cviolet"><strong>51</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"{} {}\n{}\n\n"</span>,&#13;
<span class="cviolet"><strong>52</strong></span>              <span class="green">"The substring of s1 starting at location 0 for",</span>&#13;
<span class="cviolet"><strong>53</strong></span>              <span class="green">"14 characters, s1.substr(0, 14), is:"</span>, s1.substr(<span class="green">0</span>, <span class="green">14</span>));&#13;
<span class="cviolet"><strong>54</strong></span>&#13;
<span class="cviolet"><strong>55</strong></span>   <span class="lgreen">// test substr "to-end-of-string" option</span>&#13;
<span class="cviolet"><strong>56</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"{} {}\n{}\n\n"</span>,&#13;
<span class="cviolet"><strong>57</strong></span>              <span class="green">"The substring of s1 starting at"</span>,&#13;
<span class="cviolet"><strong>58</strong></span>              <span class="green">"location 15, s1.substr(15), is:"</span>, s1.substr(<span class="green">15</span>));&#13;
<span class="cviolet"><strong>59</strong></span></pre>&#13;
<pre class="pre1">The substring of s1 starting at location 0 for 14 characters, s1.substr(0,&#13;
14), is:&#13;
happy birthday&#13;
&#13;
The substring of s1 starting at location 15, s1.substr(15), is:&#13;
to you, have a great day!</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec12"><code>string</code> Copy Constructor</h5>&#13;
<p>Line 61 creates <code>string</code> object <code>s4</code>, initializing it with a copy of <code>s1</code>. This calls class <code>string</code>’s <strong><span class="violet">copy constructor</span></strong>, which copies the contents of <code>s1</code> into the new object <code>s4</code>. You’ll see how to define a custom copy constructor for your own class in <a href="ch11.xhtml#sec11_6">Section 11.6</a>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p581pro02" id="p581pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>60</strong></span>   <span class="lgreen">// test copy constructor</span>&#13;
<span class="cviolet"><strong>61</strong></span>   <code>string s4{s1};</code>&#13;
<span class="cviolet"><strong>62</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"s4 = {}\n\n"</span>, s4);&#13;
<span class="cviolet"><strong>63</strong></span></pre>&#13;
<pre class="pre1">s4 = happy birthday to you, have a great day!</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec13">Testing Self-Assignment with the <code>string</code> Copy Assignment Operator</h5>&#13;
<p>Line 66 uses class <code>string</code>’s overloaded copy assignment (<code>=</code>) operator to demonstrate that it handles <strong><span class="violet">self-assignment</span></strong> properly, so <code>s4</code> still has the same value after the self-assignment. We’ll see when we build class <code>MyArray</code> later in the chapter that <strong>self-assignment must be handled carefully for objects that manage their own memory</strong>, and we’ll show how to deal with the issues.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p582pro01" id="p582pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>64</strong></span>   <span class="lgreen">// test overloaded copy assignment (=) operator with self-assignment</span>&#13;
<span class="cviolet"><strong>65</strong></span>   cout &lt;&lt; <span class="green">"assigning s4 to s4\n"</span>;&#13;
<span class="cviolet"><strong>66</strong></span>   <code>s4 = s4;</code>&#13;
<span class="cviolet"><strong>67</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"s4 = {}\n\n"</span>, s4);&#13;
<span class="cviolet"><strong>68</strong></span></pre>&#13;
<pre class="pre1">assigning s4 to s4&#13;
s4 = happy birthday to you, have a great day!</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec14">Initializing a <code>string</code> with a <strong><code>string_view</code></strong></h5>&#13;
<p>Line 71 demonstrates class <code>string</code>’s constructor that receives a <code>string_view</code>, in this case, copying the character data represented by the <code>string_view v</code> (line 13) into the new <code>string s5</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p582pro02" id="p582pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>69</strong></span>   <span class="lgreen">// test string's string_view constructor</span>&#13;
<span class="cviolet"><strong>70</strong></span>   cout &lt;&lt; <span class="green">"initializing s5 with string_view v\n"</span>;&#13;
<span class="cviolet"><strong>71</strong></span>   <code>string s5{v};</code>&#13;
<span class="cviolet"><strong>72</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"s5 is {}\n\n"</span>, s5);&#13;
<span class="cviolet"><strong>73</strong></span></pre>&#13;
<pre class="pre1">initializing s5 with string_view v&#13;
s5 is hello</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec15"><code>string</code>’s <strong><code>[]</code></strong> Operator</h5>&#13;
<p>Lines 75–76 use <code>string</code>’s overloaded <code>[]</code> operator in assignments to create <em>lvalues</em> for replacing characters in <code>s1</code>. Lines 77–78 output <code>s1</code>’s new value. The <code>[]</code> operator returns the character at the specified location as a modifiable <em>lvalue</em> or a nonmodifiable <em>lvalue</em> (e.g., a</p>&#13;
<p><code>const</code> reference), depending on the context in which the expression appears. For example:</p>&#13;
<p class="bull">• If <code>[]</code> is used on a non-<code>const string</code>, the function returns a modifiable <em>lvalue</em>, which can be used on the left of an assignment (<code>=</code>) operator to assign a new value to that location in the <code>string</code>, as line lines 76–76.</p>&#13;
<p class="bull">• If <code>[]</code> is used on a <code>const string</code>, the function returns a nonmodifiable <em>lvalue</em> that can be used to obtain, but not modify, the value at that location in the <code>string</code>.</p>&#13;
<p><strong>The overloaded <code>[]</code> operator does not perform bounds checking. So, you must ensure that operations using this operator do not accidentally manipulate elements outside the <code>string</code>’s bounds.</strong></p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p582pro03" id="p582pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>74</strong></span>   <span class="lgreen">// test using overloaded subscript operator to create lvalue</span>&#13;
<span class="cviolet"><strong>75</strong></span>   s1[<span class="green">0</span>] = <span class="green">'H'</span>;&#13;
<span class="cviolet"><strong>76</strong></span>   s1[<span class="green">6</span>] = <span class="green">'B'</span>;&#13;
<span class="cviolet"><strong>77</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"{}:\n{}\n\n"</span>,&#13;
<span class="cviolet"><strong>78</strong></span>              <span class="green">"after s1[0] = 'H' and s1[6] = 'B', s1 is",</span> <span class="green"/>s1);&#13;
<span class="cviolet"><strong>79</strong></span></pre>&#13;
<pre class="pre1">after s1[0] = 'H' and s1[6] = 'B', s1 is:&#13;
Happy Birthday to you, have a great day!</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec16"><code>string</code>’s <strong><code>at</code></strong> Member Function</h5>&#13;
<p>Class <code>string</code> provides bounds checking in its member function <span class="violet"><strong><code>at</code></strong></span>, which throws an exception if its argument is an invalid index. If the index is valid, function <code>at</code> returns the character at the specified location as a modifiable <em>lvalue</em> or a nonmodifiable <em>lvalue</em> (e.g., a <code>const</code> reference), depending on the context in which the call appears. Line 83 demonstrates a call to function <code>at</code> with an invalid index causing an <code>out_of_range</code> exception. The error message in this case was produced by GNU C++.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p583pro01" id="p583pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>80</strong></span>      <span class="lgreen">// test index out of range with string member function "at"</span>&#13;
<span class="cviolet"><strong>81</strong></span>      <span class="blue">try</span> {&#13;
<span class="cviolet"><strong>82</strong></span>         cout &lt;&lt; <span class="green">"Attempt to assign 'd' to s1.at(100) yields:\n"</span>;&#13;
<span class="cviolet"><strong>83</strong></span>         s1.at(100<span class="green">) =</span> <span class="green">'d'</span>; <span class="lgreen">// ERROR: subscript out of range</span>&#13;
<span class="cviolet"><strong>84</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>85</strong></span>      <span class="blue">catch</span> (<span class="blue">const</span> out_of_range&amp; ex) {&#13;
<span class="cviolet"><strong>86</strong></span>         cout &lt;&lt; fmt::format("An <span class="green">exception occurred: {}\n"</span>, ex.what());&#13;
<span class="cviolet"><strong>87</strong></span>      }&#13;
<span class="cviolet"><strong>88</strong></span>   }</pre>&#13;
<pre class="pre1">Attempt to assign 'd' to s1.at(100) yields:&#13;
An exception occurred: basic_string::at: __n (which is 100) &gt;= this-&gt;size()&#13;
(which is 40)</pre>&#13;
</div>&#13;
<h3 class="h3" id="sec11_3"><span class="violet">11.3</span> Operator Overloading Fundamentals</h3>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> As you saw in <a href="ch11.xhtml#fig11_1">Fig. 11.1</a>, standard library class <code>string</code>’s overloaded operators provide a concise notation for manipulating <code>string</code> objects. You can use operators with your own user-defined types as well. C++ allows most existing operators to be overloaded by defining <span class="violet"><strong><code>operator</code> functions.</strong></span> Once you define an <code>operator</code> function for a given operator and your custom class, that operator has meaning appropriate for objects of your class.</p>&#13;
<h4 class="h4" id="sec11_3_1">11.3.1 Operator Overloading Is Not Automatic</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> You must write <code>operator</code> functions that perform the desired operations. An operator is overloaded by writing a non-<code>static</code> member function definition or a non-member function definition. An operator function’s name is the keyword <span class="violet"><strong><code>operator</code></strong></span>, followed by the symbol of the operator being overloaded. For example, the function name <code>operator+</code> would overload the addition operator (<code>+</code>). <strong>When operators are overloaded as member functions, they must be non-<code>static</code>. They are called on an object of the class and operate on that object.</strong></p>&#13;
<h4 class="h4" id="sec11_3_2">11.3.2 Operators That Cannot Be Overloaded</h4>&#13;
<p>Most of C++’s operators can be overloaded—the following operators cannot:<sup><a id="ch11fn2a" href="ch11.xhtml#ch11fn2">2</a></sup></p>&#13;
<p class="footnote"><a id="ch11fn2" href="ch11.xhtml#ch11fn2a">2</a>. Although it’s possible to overload the address (<code>&amp;</code>), comma (<code>,</code>), <code>&amp;&amp;</code> and <code>||</code> operators, you should avoid doing so to avoid subtle errors. See <code><a href="https://isocpp.org/wiki/faq/operator-overloading">https://isocpp.org/wiki/faq/operator-overloading</a></code>. Accessed February 25, 2021.</p>&#13;
<p class="bull">• <code>.</code> (dot) member-selection operator</p>&#13;
<p class="bull">• <code>.*</code> pointer-to-member operator (discussed in Section 19.6)</p>&#13;
<p class="bull">• <code>::</code> scope-resolution operator</p>&#13;
<p class="bull">• <code>?:</code> conditional operator</p>&#13;
<h4 class="h4" id="sec11_3_3">11.3.3 Operators That You Do Not Have to Overload</h4>&#13;
<p>Three operators work with objects of each new class by default:</p>&#13;
<p class="bull">• <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size">11</span> The <strong>assignment operator (<code>=</code>)</strong> may be used with <em>most</em> classes to perform <strong><span class="violet">member-wise assignment</span></strong> of the data members. The default assignment operator assigns each data member from the “source” object (on the right) to the “target” object (on the left). As you’ll see <a href="ch11.xhtml#sec11_6_6">Section 11.6.6</a>, <strong>this can be dangerous for classes that have pointer members</strong>. So, you’ll either explicitly overload the assignment operator or explicitly disallow the compiler from defining the default assignment operator. This is also true for the <strong>C++11 move assignment operator</strong>, which we discuss in <a href="ch11.xhtml#sec11_6">Section 11.6</a>.</p>&#13;
<p class="bull">• The <strong>address (<code>&amp;</code>) operator</strong> returns a pointer to the object.</p>&#13;
<p class="bull">• The <strong>comma operator</strong> evaluates the expression to its left then the expression to its right, and returns the latter expression’s value. Though this operator can be overloaded, generally, it is not.<sup><a id="ch11fn3a" href="ch11.xhtml#ch11fn3">3</a></sup></p>&#13;
<p class="footnote"><a id="ch11fn3" href="ch11.xhtml#ch11fn3a">3</a>. “Operator Overloading.” Accessed February 24, 2021. <code><a href="https://isocpp.org/wiki/faq/operator-overloading">https://isocpp.org/wiki/faq/operator-overloading</a></code>.</p>&#13;
<h4 class="h4" id="sec11_3_4">11.3.4 Rules and Restrictions on Operator Overloading</h4>&#13;
<p>As you prepare to overload operators for your own classes, there are several rules and restrictions you should keep in mind:</p>&#13;
<p class="bull">• <strong>An operator’s precedence cannot be changed by overloading.</strong> Parentheses can be used to <em>force</em> the order of evaluation of overloaded operators in an expression.</p>&#13;
<p class="bull">• <strong>An operator’s grouping cannot be changed by overloading</strong><em>.</em> If an operator normally groups left-to-right, then so do its overloaded versions.</p>&#13;
<p class="bull">• <strong>An operator’s “arity” (the number of operands an operator takes) cannot be changed by overloading</strong>. Overloaded unary operators remain unary operators and overloaded binary operators remain binary operators. The only ternary operator (<code>?:</code>) cannot be overloaded. Operators <code>&amp;</code>, <code>*</code>, <code>+</code> and <code>-</code> each have unary and binary versions that can be overloaded separately.</p>&#13;
<p class="bull">• <strong>Only existing operators can be overloaded</strong><em>.</em> You cannot create new ones.</p>&#13;
<p class="bull">• <strong>You cannot overload operators to change how an operator works on only fundamental-type values</strong><em>.</em> For example, you cannot make the <code>+</code> operator subtract two <code>int</code>s.</p>&#13;
<p class="bull">• <strong>Operator overloading works only with objects of user-defined types or with a mixture of an object of a user-defined type and an object of a fundamental type.</strong></p>&#13;
<p class="bull">• <span class="size">20</span> <strong>Related operators, like <code>+</code> and <code>+=</code>, generally must be overloaded separately</strong>. In C++20, if you define <code>==</code> for your class, C++ provides <code>!=</code> for you—it simply returns the opposite of <code>==</code>.</p>&#13;
<p class="bull">• <strong>When overloading <code>()</code>, <code>[]</code>, <code>-&gt;</code> or <code>=</code>, the operator overloading function must be declared as a class member</strong>. You’ll see later that this is required when the left operand must be an object of your custom class type. Operator functions for all other overloadable operators may be member functions or non-member functions.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> You should overload operators for class types to work as closely as possible to how they work with fundamental types. Avoid excessive or inconsistent use of operator overloading, as this can make a program cryptic and difficult to read.</p>&#13;
<h3 class="h3" id="sec11_4"><span class="violet">11.4</span> (Downplaying) Dynamic Memory Management with <code>new</code> and <code>delete</code></h3>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> You can <strong><span class="violet">allocate</span></strong> and <strong><span class="violet">deallocate</span></strong> memory in a program for objects and for arrays of any built-in or user-defined type. This is known as <strong><span class="violet">dynamic memory management</span></strong>. In <a href="ch07.xhtml#ch07">Chapter 7</a>, we introduced pointers and showed various old-style techniques you’re likely to see in legacy code, then we showed improved Modern C++ techniques. We do the same here. For decades, C++ dynamic memory management was performed with operators <span class="violet"><strong><code>new</code></strong></span> and <span class="violet"><strong><code>delete</code></strong></span>. <strong>The C++ Core Guidelines recommend against using these operatorsdirectly.</strong><sup><a id="ch11fn4a" href="ch11.xhtml#ch11fn4">4</a>,<a id="ch11fn5a" href="ch11.xhtml#ch11fn5">5</a></sup> You’ll likely see them in legacy C++ code, so we discuss them here. <a href="ch11.xhtml#sec11_5">Section 11.5</a> discusses Modern C++ dynamic memory management techniques, which we’ll use in <a href="ch11.xhtml#sec11_6">Section 11.6</a>’s <code>MyArray</code> case study.</p>&#13;
<p class="footnote"><a id="ch11fn4" href="ch11.xhtml#ch11fn4a">4</a>. “R.11: Avoid calling <code>new</code> and <code>delete</code> explicitly.” Accessed February 26, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete</a></code>.</p>&#13;
<p class="footnote"><a id="ch11fn5" href="ch11.xhtml#ch11fn5a">5</a>. Operators <code>new</code> and <code>delete</code> can be overloaded, but this is beyond the scope of the book. If you do overload <code>new</code>, then you should overload <code>delete</code> in the same scope to avoid subtle dynamic memory management errors. Overloading <code>new</code> and <code>delete</code> is typically done for precise control over how memory is allocated and deallocated, often for performance. This might be used, for example, to preallocate a pool of memory, then create new objects within that pool to reduce runtime memory-allocation overhead. For an overview of the so-called placement <code>new</code> and <code>delete</code> operators, see <code><a href="https://en.wikipedia.org/wiki/Placement_syntax">https://en.wikipedia.org/wiki/Placement_syntax</a></code>.</p>&#13;
<h5 class="h5" id="ch11lev3sec17">The Old Way—Operators <code>new</code> and <strong><code>delete</code></strong></h5>&#13;
<p>You can use the <code>new</code> operator to dynamically reserve (that is, allocate) the exact amount of memory required to hold an object or built-in array. The object or built-in array is created on the <strong><span class="violet">free store</span></strong>—a region of memory assigned to each program for storing dynamically allocated objects. Once memory is allocated, you can access it via the pointer returned by operator <code>new</code>. When you no longer need the memory, you can return it to the free store by using the <code>delete</code> operator to deallocate (i.e., release) the memory, which can then be reused by future <code>new</code> operations.</p>&#13;
<h5 class="h5" id="ch11lev3sec18">Obtaining Dynamic Memory with <code>new</code></h5>&#13;
<p>Consider the following statement:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p585pro01" id="p585pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">Time* timePtr{<span class="blue">new</span> Time{}};</pre>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> The <code>new</code> operator allocates storage of the proper size for a <code>Time</code> object, calls a default constructor to initialize the object (in this case, <code>Time</code>’s default constructor) and returns a pointer of the type specified to the right of the <code>new</code> operator (in this case, a <code>Time*</code>). In the preceding statement, class <code>Time</code>’s default constructor is called, because we did not supply arguments to initialize the <code>Time</code> object. If <code>new</code> is unable to find sufficient space in memory for the object, it throws a <span class="violet"><strong><code>bad_alloc</code></strong></span><strong><span class="violet"> exception</span></strong>. <a href="ch12.xhtml#ch12">Chapter 12</a> shows how to deal with <code>new</code> failures.</p>&#13;
<h5 class="h5" id="ch11lev3sec19">Releasing Dynamic Memory with <code>delete</code></h5>&#13;
<p>To destroy a dynamically allocated object and free the space for the object, use the <code>delete</code> operator as follows:</p>&#13;
<pre class="pre"><span class="blue">delete</span> timePtr;</pre>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> This statement calls the destructor for the object to which <code>timePtr</code> points, then deallocates the object’s memory, returning it to the free store. Not releasing dynamically allocated memory when it’s no longer needed can cause memory leaks that eventually lead to a system running out of memory prematurely. The problem might be even worse. If the leaked memory contains objects that manage other resources, those objects’ destructors will not be called to release the resources, causing additional leaks.</p>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Do not <code>delete</code> memory that was not allocated by <code>new</code>. Doing so results in undefined behavior. After you <code>delete</code> a block of dynamically allocated memory, be sure not to <code>delete</code> the same block again, which typically causes a program to crash. One way to guard against this is to immediately set the pointer to <code>nullptr</code>—deleting such a pointer has no effect.</p>&#13;
<h5 class="h5" id="ch11lev3sec20">Initializing Dynamically Allocated Objects</h5>&#13;
<p>You can initialize a newly allocated object with constructor arguments to the right of the type, as in:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p586pro01" id="p586pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">Time* timePtr{<span class="blue">new</span> Time{<span class="green">12</span>, <span class="green">45</span>, <span class="green">0</span>}};</pre>&#13;
<p>which initializes a new <code>Time</code> object to 12:45:00 PM and assigns its pointer to <code>timePtr</code>.</p>&#13;
<h5 class="h5" id="ch11lev3sec21">Dynamically Allocating Built-In Arrays with <code>new[]</code></h5>&#13;
<p>You also can use the <code>new</code> operator to dynamically allocate built-in arrays. The following statement dynamically allocates a 10-element integer array:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p586pro02" id="p586pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span>* gradesArray{<span class="blue">new</span> <span class="blue">int</span>[<span class="green">10</span>]{}};</pre>&#13;
<p>This statement aims the <code>int</code> pointer <code>gradesArray</code> at the first element of the dynamically allocated array. The empty braced initializer following <code>new int[10]</code> <strong><span class="violet">value initialize</span></strong> the array’s elements, which sets fundamental-type elements to <code>0</code>, <code>bool</code>s to <code>false</code> and pointers to <code>nullptr</code>. The braced initializer may also contain a comma-separated list of initializers for the array’s elements. Value initializing an object calls its default constructor, if available. The rules become more complicated for objects that do not have default constructors. For more details, see the value-initialization rules at:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p586pro03" id="p586pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/language/value_initialization</pre>&#13;
<p>The size of a built-in array created at compile time must be specified using an integral constant expression. However, a dynamically allocated array’s size can be specified using <em>any</em> nonnegative integral expression that can be evaluated at execution time.</p>&#13;
<h5 class="h5" id="ch11lev3sec22">Releasing Dynamically Allocated Built-In Arrays with <code>delete[]</code></h5>&#13;
<p>To deallocate the memory to which <code>gradesArray</code> points, use the statement</p>&#13;
<pre class="pre"><span class="blue">delete</span>[] gradesArray;</pre>&#13;
<p>If the pointer points to a built-in array of objects, this statement first calls the destructor for each object in the array, then deallocates the memory for the entire array. As with <code>delete</code>, <code>delete[]</code> on a <code>nullptr</code> has no effect.</p>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> If the preceding statement did <em>not</em> include the square brackets (<code>[]</code>) and <code>gradesArray</code> pointed to a built-in array of objects, the result is undefined. Some compilers call the destructor only for the first object in the array. <strong>Using <code>delete</code> instead of <code>delete[]</code> for built-in arrays of objects results in undefined behavior. To ensure that every object in the array receives a destructor call, always use operator <code>delete[]</code> to delete memory allocated by <code>new[]</code>.</strong> We’ll show better techniques for managing dynamically allocated memory that enable you to avoid using <code>new</code> and <code>delete</code>.</p>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <strong>If there is only one pointer to a block of dynamically allocated memory and the pointer goes out of scope or you assign it <code>nullptr</code> or a different memory address, a memory leak occurs</strong>. <strong>After deleting dynamically allocated memory, set the pointer’s value to <code>nullptr</code></strong> to indicate that it no longer points to memory in the free store. This ensures that your code cannot inadvertently access the previously allocated memory—doing so could cause subtle logic errors.</p>&#13;
<h5 class="h5" id="ch11lev3sec23">Range-Based <code>for</code> Does Not Work with Dynamically Allocated Built-In Arrays</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> You might be tempted to use C++11’s range-based <code>for</code> statement to iterate over dynamically allocated arrays. Unfortunately, this will not compile. The compiler must know the number of elements at compile-time to iterate over an array with range-based <code>for</code>. As a workaround, you can create a C++20 <code>span</code> object that represents the dynamically allocated array and its number of elements, then iterate over the <code>span</code> object with range-based <code>for</code>.</p>&#13;
<h3 class="h3" id="sec11_5"><span class="violet">11.5</span> Modern C++ Dynamic Memory Management—RAII and Smart Pointers</h3>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/>A common design pattern is to allocate dynamic memory, assign the address of that memory to a pointer, use the pointer to manipulate the memory and deallocate the memory when it’s no longer needed. If an exception occurs after successful memory allocation but before the <code>delete</code> or <code>delete[]</code> statement executes, a <strong>memory leak</strong> could occur.</p>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> For this reason, the C++ Core Guidelines recommend that you manage resources like dynamic memory using <strong><span class="violet">RAII—Resource Acquisition Is Initialization</span></strong>.<sup><a id="ch11fn6a" href="ch11.xhtml#ch11fn6">6</a>,<a id="ch11fn7a" href="ch11.xhtml#ch11fn7">7</a></sup> The concept is straightforward. For any resource that must be returned to the system when the program is done using it, the program should:</p>&#13;
<p class="footnote"><a id="ch11fn6" href="ch11.xhtml#ch11fn6a">6</a>. “R: Resource Management.” Accessed February 26, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource</a></code>.</p>&#13;
<p class="footnote"><a id="ch11fn7" href="ch11.xhtml#ch11fn7a">7</a>. “R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization).” Accessed February 26, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii</a></code>.</p>&#13;
<p class="bull">• create the object as a local variable in a function—the object’s constructor should allocate the resource,</p>&#13;
<p class="bull">• use that object as necessary in your program, then</p>&#13;
<p class="bull">• when the function call terminates, the object goes out of scope, which automatically calls the object’s destructor to release the resource.</p>&#13;
<h4 class="h4" id="sec11_5_1">11.5.1 Smart Pointers</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> C++11 <strong><span class="violet">smart pointers</span></strong> use RAII to manage dynamically allocated memory for you. The standard library header <span class="violet"><strong><code>&lt;memory&gt;</code></strong></span> defines three smart pointer types:</p>&#13;
<p class="bull">• <code>unique_ptr</code></p>&#13;
<p class="bull">• <code>shared_ptr</code></p>&#13;
<p class="bull">• <code>weak_ptr</code></p>&#13;
<p>A <span class="violet"><strong><code>unique_ptr</code></strong></span> maintains a pointer to dynamically allocated memory. The class name contains “unique” because <strong>a dynamically allocated object can belong to only one <code>unique_ptr</code> at a time</strong>. When a <code>unique_ptr</code> object goes out of scope, its destructor uses <code>delete</code> (or <code>delete[]</code> for an array) to deallocate the memory that the <code>unique_ptr</code> manages. The rest of <a href="ch11.xhtml#sec11_5">Section 11.5</a> demonstrates <code>unique_ptr</code>, which we’ll also use in our <code>MyArray</code> case study. We introduce <code>shared_ptr</code> and <code>weak_ptr</code> in <a href="ch19.xhtml#ch19">Chapter 19</a>, Other Topics and a Look Toward the Future of C++.</p>&#13;
<h4 class="h4" id="sec11_5_2">11.5.2 Demonstrating <code>unique_ptr</code></h4>&#13;
<p><a href="ch11.xhtml#fig11_2">Figure 11.2</a> demonstrates a <code>unique_ptr</code> object that points to a dynamically allocated object of a custom class <code>Integer</code> (lines 7–22). For pedagogic purposes, the class’s constructor and destructor both display when they are called. Line 29 creates <code>unique_ptr</code> object <code>ptr</code> and initializes it with a pointer to a dynamically allocated <code>Integer</code> object that contains the value <span class="size">14</span> 7. To initialize the <code>unique_ptr</code>, line 29 calls C++14’s <span class="violet"><strong><code>make_unique</code></strong></span><strong><span class="violet"> function template</span></strong>, which allocates dynamic memory with operator <code>new</code>, then returns a <code>unique_ptr</code> to that memory.<sup><a id="ch11fn8a" href="ch11.xhtml#ch11fn8">8</a></sup> In this example, <code>make_unique&lt;Integer&gt;</code> returns a <code>unique_ptr&lt;Integer&gt;</code>—line 29 uses the <code>auto</code> keyword to infer <code>ptr</code>’s type from its initializer.</p>&#13;
<p class="footnote"><a id="ch11fn8" href="ch11.xhtml#ch11fn8a">8</a>. Prior to C++14, you’d pass the result of a <code>new</code> expression directly to <code>unique_ptr</code>’s constructor.</p>&#13;
<div class="group" id="fig11_2">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p11pro02" id="p11pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig11_02.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating unique_ptr.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;memory&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">class</span> Integer {&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"><strong>10</strong></span>      Integer(<span class="blue">int</span> i) : value{i} { <span class="lgreen"/>&#13;
<span class="cviolet"><strong>11</strong></span>         cout &lt;&lt; <span class="green">"Constructor for Integer "</span> &lt;&lt; value &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>12</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="lgreen">// destructor</span>&#13;
<span class="cviolet"><strong>15</strong></span>      <code>~Integer() {</code>&#13;
<span class="cviolet"><strong>16</strong></span>         cout &lt;&lt; <span class="green">"Destructor for Integer "</span> &lt;&lt; value &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>17</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">int</span> getValue() <span class="blue">const</span> {<span class="blue">return</span> value;} <span class="lgreen">// return Integer value</span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">int</span> value{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>22</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>   <span class="lgreen">// use unique_ptr to manipulate Integer object</span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>26</strong></span>      cout &lt;&lt; <span class="green">"Creating a unique_ptr object that points to an Integer\n"</span>;&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="lgreen">// create a unique_ptr object and "aim" it at a new Integer object</span>&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="blue">auto</span> ptr{make_unique&lt;Integer&gt;(<span class="green">7</span>)};&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>      <span class="lgreen">// use unique_ptr to call an Integer member function</span>&#13;
<span class="cviolet"><strong>32</strong></span>      cout &lt;&lt; <span class="green">"Integer value: "</span> &lt;&lt; ptr-&gt;getValue()&#13;
<span class="cviolet"><strong>33</strong></span>         &lt;&lt; <span class="green">"\n\nMain ends\n"</span>;&#13;
<span class="cviolet"><strong>34</strong></span>   }</pre>&#13;
<pre class="pre1">Creating a unique_ptr object that points to an Integer&#13;
Constructor for Integer 7&#13;
Integer value: 7&#13;
&#13;
Main ends&#13;
Destructor for Integer 7</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 11.2</strong></span> | Demonstrating <code>unique_ptr</code>.</p>&#13;
</div>&#13;
<p>Line 32 uses <code>unique_ptr</code>’s overloaded <code>-&gt;</code> operator to invoke function <code>getValue</code> on the <code>Integer</code> object that <code>ptr</code> manages. The expression <code>ptr-&gt;getValue()</code> also could have been written as:</p>&#13;
<pre class="pre">(*ptr).getValue()</pre>&#13;
<p>which uses <code>unique_ptr</code>’s overloaded <code>*</code> operator to dereference <code>ptr</code>, then uses the dot (<code>.</code>) operator to invoke function <code>getValue</code> on the <code>Integer</code> object.</p>&#13;
<p>Because <code>ptr</code> is a local variable in <code>main</code>, it’s destroyed when <code>main</code> terminates. The <code>unique_ptr</code> destructor <code>delete</code>s the dynamically allocated <code>Integer</code> object, which calls the object’s destructor. <strong>The program releases the <code>Integer</code> object’s memory, whether program control leaves the block normally via a <code>return</code> statement or reaching the end of the block—or as the result of an exception.</strong></p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Most importantly, using <code>unique_ptr</code> as shown here <strong>prevents resource leaks</strong>. For example, suppose a function returns a pointer aimed at some dynamically allocated object. Unfortunately, the function caller that receives this pointer might not <code>delete</code> the object, thus resulting in a <strong>memory leak</strong>. However, if the function returns a <code>unique_ptr</code> to the object, the object will be deleted automatically when the <code>unique_ptr</code> object’s destructor gets called.</p>&#13;
<h4 class="h4" id="sec11_5_3">11.5.3 <code>unique_ptr</code> Ownership</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Only one <code>unique_ptr</code> at a time can own a dynamically allocated object, so assigning one <code>unique_ptr</code> to another <strong>transfers ownership</strong> to the target <code>unique_ptr</code> on the assignment’s left. The same is true when one <code>unique_ptr</code> is passed as an argument to another <code>unique_ptr</code>’s constructor. These operations use <code>unique_ptr</code>’s move assignment operator and move constructor, which we discuss in <a href="ch11.xhtml#sec11_6">Section 11.6</a>. <strong>The last <code>unique_ptr</code> object that owns the dynamic memory will delete the memory.</strong> This makes <code>unique_ptr</code> an ideal mechanism for returning ownership of dynamically allocated objects to client code. When the <code>unique_ptr</code> goes out of scope in the client code, the <code>unique_ptr</code>’s destructor deletes the dynamically allocated object. If that object has a destructor, it is called before the memory is returned to the system.</p>&#13;
<h4 class="h4" id="sec11_5_4">11.5.4 <code>unique_ptr</code> to a Built-In Array</h4>&#13;
<p>You can also use a <code>unique_ptr</code> to manage a dynamically allocated built-in array, as we’ll do in <a href="ch11.xhtml#sec11_6">Section 11.6</a>’s <code>MyArray</code> case study. For example, in the statement</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p590pro01" id="p590pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">auto</span> ptr{make_unique&lt;<span class="blue">int</span>[]&gt;(<span class="green">10</span>)};</pre>&#13;
<p><span class="size">14</span> <code>make_unique</code>’s type argument is specified as <code>int[]</code>. So <code>make_unique</code> dynamically allocates a built-in array with the number of elements specified by its argument (<code>10</code>). By default, the <code>int</code> elements are value initialized to 0. The preceding statement uses <code>auto</code> to infer <code>ptr</code>’s type (<code>unique_ptr&lt;<span class="blue">int</span>[]&gt;</code>), based on its initializer.</p>&#13;
<p>A <code>unique_ptr</code> that manages an array provides an <strong>overloaded subscript operator (<code>[]</code>)</strong> to access its elements. For example, the statement</p>&#13;
<pre class="pre">ptr[<span class="green">2</span>] = <span class="green">7</span>;</pre>&#13;
<p>assigns <code>7</code> to the <code>int</code> at <code>ptr[2]</code>, and the following statement displays that <code>int</code>:</p>&#13;
<pre class="pre">cout &lt;&lt; ptr[<span class="green">2</span>] &lt;&lt; <span class="green">"\n"</span>;</pre>&#13;
<h3 class="h3" id="sec11_6"><span class="violet">11.6</span> <code>MyArray</code> Case Study: Crafting a Valuable Class with Operator Overloading</h3>&#13;
<p><strong>Class development is an interesting, creative and intellectually challenging activity— always with the goal of crafting valuable classes.</strong> When we refer to “arrays” in this case study, we mean the built-in arrays we discussed in <a href="ch07.xhtml#ch07">Chapter 7</a>. These pointer-based arrays have many problems, including:</p>&#13;
<p class="bull">• C++ does not check whether an array index is out-of-bounds. A program can easily “walk off” either end of an array, likely causing a fatal runtime error if you forget to test for this possibility in your code.</p>&#13;
<p class="bull">• Arrays of size <em>n</em> must use index values in the range 0 to <em>n</em> – 1. Alternate index ranges are not allowed.</p>&#13;
<p class="bull">• You cannot input an entire array with the stream extraction operator (<code>&gt;&gt;</code>) or output one with the stream insertion operator (<code>&lt;&lt;</code>). You must read or write every element.<sup><a id="ch11fn9a" href="ch11.xhtml#ch11fn9">9</a></sup></p>&#13;
<p class="footnote"><a id="ch11fn9" href="ch11.xhtml#ch11fn9a">9</a>. In <a href="ch13.xhtml#ch13">Chapter 13</a>, Standard Library Containers and Iterators, you’ll use C++ standard library functions to input and output entire containers of elements, such as <code>vector</code>s and <code>array</code>s.</p>&#13;
<p class="bull">• Two arrays cannot be meaningfully compared with equality or relational operators. Array names are simply pointers to where the arrays begin in memory. Two arrays will always be at different memory locations.</p>&#13;
<p class="bull">• When you pass an array to a general-purpose function that handles arrays of any size, you must pass the array’s size as an additional argument. As you saw in <a href="ch07.xhtml#ch07lev1sec10">Section 7.10</a>, C++20’s <code>span</code>s help solve this problem.</p>&#13;
<p class="bull">• <span class="size">20</span> You cannot assign one array to another with the assignment operator(s).</p>&#13;
<p>With C++, you can implement more robust array capabilities via classes and operator overloading, as has been done with C++ standard library class templates <code>array</code> and <code>vector</code>. In this section, we’ll develop our own custom <code>MyArray</code> class that’s preferable to arrays. Internally, class <code>MyArray</code> will use a <code>unique_ptr</code> smart pointer to manage a dynamically allocated built-in array of <code>int</code> values.<sup><a id="ch11fn10a" href="ch11.xhtml#ch11fn10">10</a></sup></p>&#13;
<p class="footnote"><span class="size">20</span>  <a id="ch11fn10" href="ch11.xhtml#ch11fn10a">10.</a> In this section, we’ll use operator overloading to craft a valuable class. In <a href="ch15.xhtml#ch15">Chapter 15</a>, we’ll make it more valuable by converting it to a class template, and we’ll use C++20’s new concepts feature to add even more value.</p>&#13;
<p>We’ll create a powerful <code>MyArray</code> class with the following capabilities:</p>&#13;
<p class="bull">• <code>MyArray</code>s perform range checking when you access them via the subscript (<code>[]</code>) operator to ensure indices remain within their bounds. Otherwise, the <code>MyArray</code> object will throw a standard library <code>out_of_bounds</code> exception.</p>&#13;
<p class="bull">• Entire <code>MyArray</code>s can be input or output with the overloaded stream extraction (<code>&gt;&gt;</code>) and stream insertion (<code>&lt;&lt;</code>) operators, without the client-code programmer having to write iteration statements.</p>&#13;
<p class="bull">• <code>MyArray</code>s may be compared to one another with the equality operators <code>==</code> and <code>!=</code>. The class could easily be enhanced to include the relational operators.</p>&#13;
<p class="bull">• <code>MyArray</code>s know their own size, making it easier to pass them to functions.</p>&#13;
<p class="bull">• <code>MyArray</code> objects may be assigned to one another with the assignment operator.</p>&#13;
<p class="bull">• <code>MyArray</code>s may be converted to <code>bool false</code> or <code>true</code> values to determine whether they are empty or contain elements.</p>&#13;
<p class="bull">• <code>MyArray</code> provides prefix and postfix increment (<code>++</code>) operators that add <code>1</code> to every element. We can easily add prefix and postfix decrement (<code>--</code>) operators.</p>&#13;
<p class="bull">• <code>MyArray</code> provides an addition assignment operator (<code>+=</code>) that adds a specified value to every element. The class could easily be enhanced to support the <code>-=</code>, <code>*=</code>, <code>/=</code> and <code>%=</code> assignment operators.</p>&#13;
<p>Class <code>MyArray</code> will demonstrate the <strong>five special member functions</strong> and the <strong><code>unique_ptr</code> smart pointer for managing dynamically allocated memory</strong>. We’ll use <strong>RAII (Resource Acquisition Is Initialization)</strong> throughout this example to manage the dynamically allocated memory resources. All dynamically allocated memory will be allocated by the class’s constructors as <code>MyArray</code> objects are initialized and deallocated automatically by the class’s destructor when <code>MyArray</code> objects go out of scope<strong>, preventing memory leaks.</strong> Our <code>MyArray</code> class is not meant to replace standard library class templates <code>array</code> and <code>vector</code>, nor is it meant to mimic their capabilities. It demonstrates key C++ language and library features that you’ll find useful when you build your own classes.</p>&#13;
<h4 class="h4" id="sec11_6_1">11.6.1 Special Member Functions</h4>&#13;
<p>Every class you define can have five <strong><span class="violet">special member functions</span></strong>, each of which we define in class <code>MyArray</code>:</p>&#13;
<p class="bull">• a <strong><span class="violet">copy constructor</span></strong>,</p>&#13;
<p class="bull">• a <strong><span class="violet">copy assignment operator</span></strong>,</p>&#13;
<p class="bull">• a <strong><span class="violet">move constructor</span></strong>,</p>&#13;
<p class="bull">• a <strong><span class="violet">move assignment operator</span></strong>, and</p>&#13;
<p class="bull">• a <strong><span class="violet">destructor</span></strong>.</p>&#13;
<p>The copy constructor and copy assignment operator implement the class’s <strong><span class="violet">copy semantics</span></strong>—that is, how to copy a <code>MyArray</code> when it is passed by value to a function, returned by value from a function or assigned to another <code>MyArray</code>. The move constructor and move assignment operator implement the class’s <strong><span class="violet">move semantics</span></strong>, which eliminate costly unnecessary copies of objects that are about to be destroyed. We discuss the details of these special member functions as we encounter the need for them throughout this case study.</p>&#13;
<h4 class="h4" id="sec11_6_2">11.6.2 Using Class <code>MyArray</code></h4>&#13;
<p>The program of Figs. 11.3–11.5 demonstrates class <code>MyArray</code> and its rich selection of overloaded operators. The code in <a href="ch11.xhtml#fig11_3">Fig. 11.3</a> tests the various <code>MyArray</code> capabilities. We present the class definition in <a href="ch11.xhtml#fig11_4">Fig. 11.4</a> and each of its member-function definitions in <a href="ch11.xhtml#fig11_5">Fig. 11.5</a>. We’ve broken the code and outputs into small segments for discussion purposes. For pedagogic purposes, many of class <code>MyArray</code>’s member functions, including all of special member functions, display output to show when they’re called.</p>&#13;
<h5 class="h5" id="ch11lev3sec24">Function <code>getArrayByValue</code></h5>&#13;
<p>Later in this program, we’ll call the <code>getArrayByValue</code> function (<a href="ch11.xhtml#fig11_3">Fig. 11.3</a>, lines 10–13) to create a local <code>MyArray</code> object by calling <code>MyArray</code>’s constructor that receives an <strong>initializer list</strong>. Function <code>getArrayByValue</code> returns that local object <em>by value</em>.</p>&#13;
<div class="group" id="fig11_3">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p11pro03" id="p11pro03a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig11_03.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// MyArray class test program.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;utility&gt; <span class="lgreen">// for std::move</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"MyArray.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="lgreen">// function to return a MyArray by value</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <code>MyArray getArrayByValue() {</code>&#13;
<span class="cviolet"><strong>11</strong></span>      MyArray localInts{<span class="green">10</span>, <span class="green">20</span>, <span class="green">30</span>}; <span class="lgreen">// create three-element MyArray</span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">return</span> localInts; <span class="lgreen">// return by value creates an rvalue</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 11.3</strong></span> | <code>MyArray</code> class test program.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec25">Creating <code>MyArray</code> Objects and Displaying Their Size and Contents</h5>&#13;
<p>Lines 16–17 create objects <code>ints1</code> with seven elements and <code>ints2</code> with 10 elements. Each calls the <code>MyArray</code> constructor that receives the number of elements and initializes the elements to zeros. Lines 20–21 display <code>ints1</code>’s <code>size</code> then output its contents using <code>MyArray</code>’s <strong>overloaded stream insertion operator (<code>&lt;&lt;</code>)</strong>. Lines 24–25 do the same for <code>ints2</code>. Each statement uses <code>&lt;&lt;</code> to output two string literals, a <code>size_t</code> and a <code>MyArray</code> object.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p593pro01" id="p593pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>15</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>16</strong></span>      MyArray ints1(<span class="green">7</span>); <span class="lgreen">// 7-element MyArray</span><span class="lgreen"><strong>; note () rather than {}</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      MyArray ints2(<span class="green">10</span>); <span class="lgreen">// 10-element MyArray</span><span class="lgreen"><strong>; note () rather than {}</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="lgreen">// print ints1 size and contents</span>&#13;
<span class="cviolet"><strong>20</strong></span>      cout &lt;&lt; <span class="green">"\nints1 size: "</span> &lt;&lt; ints1.size()&#13;
<span class="cviolet"><strong>21</strong></span>         &lt;&lt; <span class="green">"\ncontents: "</span> &lt;&lt; ints1; <span class="lgreen">// uses overloaded &lt;&lt;</span>&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="lgreen">// print ints2 size and contents</span>&#13;
<span class="cviolet"><strong>24</strong></span>      cout &lt;&lt; <span class="green">"\n\nints2 size: "</span> &lt;&lt; ints2.size()&#13;
<span class="cviolet"><strong>25</strong></span>         &lt;&lt; <span class="green">"\ncontents: "</span> &lt;&lt; ints2; <span class="lgreen">// uses overloaded &lt;&lt;</span>&#13;
<span class="cviolet"><strong>26</strong></span></pre>&#13;
<pre class="pre1">MyArray(size_t) constructor&#13;
MyArray(size_t) constructor&#13;
&#13;
ints1 size: 7&#13;
contents: {0, 0, 0, 0, 0, 0, 0}&#13;
&#13;
ints2 size: 10&#13;
contents: {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec26">Using Parentheses Rather Than Braces to Call the Constructor</h5>&#13;
<p>So far, we’ve used braced initializers, <code>{}</code>, to pass arguments to constructors. Lines 16–17 use parentheses, <code>()</code>, to call the <code>MyArray</code> constructor that receives a size. We do this because our class—like the standard library’s <code>array</code> and <code>vector</code> classes—also supports constructing a <code>MyArray</code> from a braced initializer list containing the <code>MyArray</code>’s element values. When the compiler sees a statement like:</p>&#13;
<pre class="pre">MyArray ints1{<span class="green">7</span>};</pre>&#13;
<p>it invokes the constructor that accepts the braced-initializer list of integers, not the single-argument constructor that receives the size.</p>&#13;
<h5 class="h5" id="ch11lev3sec27">Using the Overloaded Stream Extraction Operator to Fill a <code>MyArray</code></h5>&#13;
<p>Next, line 28 prompts the user to enter 17 integers. Line 29 uses the <code>MyArray</code> <strong>overloaded stream extraction operator (<code>&gt;&gt;</code>)</strong> to read the first seven values into <code>ints1</code> and the remaining 10 values into <code>ints2</code> (recall that each <code>MyArray</code> knows its own size). Line 31 displays each <code>MyArray</code>’s updated contents using the <strong>overloaded stream insertion operator (<code>&lt;&lt;</code>)</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p593pro02" id="p593pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// input and print ints1 and ints2</span>&#13;
<span class="cviolet"><strong>28</strong></span>   cout &lt;&lt; <span class="green">"\n\nEnter 17 integers: "</span>;&#13;
<span class="cviolet"><strong>29</strong></span>   cin &gt;&gt; ints1 &gt;&gt; ints2; <span class="lgreen">// uses overloaded &gt;&gt;</span>&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>   cout &lt;&lt; <span class="green">"\nints1: "</span> &lt;&lt; ints1 &lt;&lt; <span class="green">"\nints2: "</span> &lt;&lt; ints2;&#13;
<span class="cviolet"><strong>32</strong></span></pre>&#13;
<pre class="pre1">Enter 17 integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17&#13;
&#13;
ints1: {1, 2, 3, 4, 5, 6, 7}&#13;
ints2: {8, 9, 10, 11, 12, 13, 14, 15, 16, 17}</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec28">Using the Overloaded Inequality Operator (<strong><code>!=</code></strong>)</h5>&#13;
<p>Line 36 tests <code>MyArray</code>’s <strong>overloaded inequality operator (<code>!=</code>)</strong> by evaluating the condition</p>&#13;
<pre class="pre">ints1 != ints2</pre>&#13;
<p><span class="size">20</span> The program output shows that the <code>MyArray</code> objects are not equal. Two <code>MyArray</code> objects will be equal if they have the same number of elements and their corresponding element values are identical. As you’ll see, we define only <code>MyArray</code>’s overloaded <code>==</code> operator. In C++20, the compiler autogenerates <code>!=</code> if you provide an <code>==</code> operator for your type—<code>!=</code> simply returns the opposite of <code>==</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p594pro01" id="p594pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>33</strong></span>   <span class="lgreen">// use overloaded inequality (!=) operator</span>&#13;
<span class="cviolet"><strong>34</strong></span>   cout &lt;&lt; <span class="green">"\n\nEvaluating: ints1 != ints2\n"</span>;&#13;
<span class="cviolet"><strong>35</strong></span>&#13;
<span class="cviolet"><strong>36</strong></span>   <span class="blue">if</span> (ints1 != ints2) {&#13;
<span class="cviolet"><strong>37</strong></span>      cout &lt;&lt; <span class="green">"ints1 and ints2 are not equal\n\n"</span>;&#13;
<span class="cviolet"><strong>38</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>39</strong></span></pre>&#13;
<pre class="pre1">Evaluating: ints1 != ints2&#13;
ints1 and ints2 are not equal</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec29">Initializing a New <code>MyArray</code> with a Copy of an Existing <strong><code>MyArray</code></strong></h5>&#13;
<p>Line 41 instantiates the <code>MyArray</code> object <code>ints3</code> and initializes it with a copy of <code>ints1</code>’s data. This invokes the <code>MyArray</code> <strong>copy constructor</strong> to copy <code>ints1</code>’s elements into <code>ints3</code>. A <strong>copy constructor</strong> is invoked whenever a copy of an object is needed, such as:</p>&#13;
<p class="bull">• passing an object by value to a function,</p>&#13;
<p class="bull">• returning an object by value from a function, or</p>&#13;
<p class="bull">• initializing an object with a copy of another object of the same class.</p>&#13;
<p>Line 44 displays <code>ints3</code>’s <code>size</code> and contents to confirm that <code>ints3</code>’s elements were set correctly by the <strong>copy constructor</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p594pro02" id="p594pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>40</strong></span>   <span class="lgreen">// create MyArray ints3 by copying ints1</span>&#13;
<span class="cviolet"><strong>41</strong></span>   MyArray ints3{ints1}; <span class="lgreen">// invokes copy constructor</span>&#13;
<span class="cviolet"><strong>42</strong></span>&#13;
<span class="cviolet"><strong>43</strong></span>   <span class="lgreen">// print ints3 size and contents</span>&#13;
<span class="cviolet"><strong>44</strong></span>   cout &lt;&lt; <span class="green">"\nints3 size: "</span> &lt;&lt; ints3.size() &lt;&lt; <span class="green">"\ncontents: "</span> &lt;&lt; ints3;&#13;
<span class="cviolet"><strong>45</strong></span></pre>&#13;
<pre class="pre1">MyArray copy constructor&#13;
&#13;
ints3 size: 7&#13;
contents: {1, 2, 3, 4, 5, 6, 7}</pre>&#13;
</div>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">11</span> When a class such as <code>MyArray</code> contains both a <strong>copy constructor</strong> and a <strong>move constructor</strong>, the compiler chooses the correct one to use based on the context. In line 41, the compiler chose <code>MyArray</code>’s <strong>copy constructor</strong> because variable names, like <code>ints1</code>, are <em>lvalues</em>. As you’ll soon see, a <strong>move constructor</strong> receives an <strong><em>rvalue</em> reference</strong>, which is part of C++11’s <strong>move semantics</strong>. <strong>An <em>rvalue</em> reference may not refer to an <em>lvalue</em>.</strong></p>&#13;
<p>The <strong>copy constructor</strong> can also be invoked by writing line 41 as:</p>&#13;
<pre class="pre">MyArray ints3 = ints1;</pre>&#13;
<p>In an object’s definition, the equal sign does <em>not</em> indicate assignment. It invokes the single-argument copy constructor, passing as the argument the value to the <code>=</code> symbol’s right.</p>&#13;
<h5 class="h5" id="ch11lev3sec30">Using the Overloaded Copy Assignment Operator (<strong><code>=</code></strong>)</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Line 48 assigns <code>ints2</code> to <code>ints1</code> to test the <strong>overloaded copy assignment operator (<code>=</code>)</strong>. Builtin arrays cannot handle this assignment. An array’s name is not a modifiable <em>lvalue</em>, so you cannot assign one array’s name to another—such an assignment causes a compilation error. Line 50 displays both objects’ contents to confirm that they’re now identical. <code>MyArray ints1</code> initially held seven integers, but the overloaded operator <strong>resizes</strong> the dynamically allocated built-in array to hold a copy of <code>ints2</code>’s 10 elements. <strong>As with copy constructors and move constructors, if a class contains both a copy assignment operator and a move assignment operator, the compiler chooses which one to call based on the arguments</strong>. In this case, <code>ints2</code> is a variable and thus an <em>lvalue</em>, so the copy assignment operator is called. Note in the output that line 48 also resulted in calls to the <code>MyArray</code> copy constructor and destructor—you’ll see why when we present the assignment operator’s implementation in <a href="ch11.xhtml#sec11_6_6">Section 11.6.6</a>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p595pro01" id="p595pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>46</strong></span>   <span class="lgreen">// use overloaded copy assignment (=) operator</span>&#13;
<span class="cviolet"><strong>47</strong></span>   cout &lt;&lt; <span class="green">"\n\nAssigning ints2 to ints1:\n"</span>;&#13;
<span class="cviolet"><strong>48</strong></span>   ints1 = ints2; <span class="lgreen">// note target MyArray is smaller</span>&#13;
<span class="cviolet"><strong>49</strong></span>&#13;
<span class="cviolet"><strong>50</strong></span>   cout &lt;&lt; <span class="green">"\nints1: "</span> &lt;&lt; ints1 &lt;&lt; <span class="green">"\nints2: "</span> &lt;&lt; ints2;&#13;
<span class="cviolet"><strong>51</strong></span></pre>&#13;
<pre class="pre1">Assigning ints2 to ints1:&#13;
MyArray copy assignment operator&#13;
MyArray copy constructor&#13;
MyArray destructor&#13;
&#13;
ints1: {8, 9, 10, 11, 12, 13, 14, 15, 16, 17}&#13;
ints2: {8, 9, 10, 11, 12, 13, 14, 15, 16, 17}</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec31">Using the Overloaded Equality Operator (<strong><code>==</code></strong>)</h5>&#13;
<p>Line 55 compares <code>ints1</code> and <code>ints2</code> with the <strong>overloaded equality operator (<code>==</code>)</strong> to confirm they are indeed identical after the assignment in line 48.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p595pro02" id="p595pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>52</strong></span>   <span class="lgreen">// use overloaded equality (==) operator</span>&#13;
<span class="cviolet"><strong>53</strong></span>   cout &lt;&lt; <span class="green">"\n\nEvaluating: ints1 == ints2\n"</span>;&#13;
<span class="cviolet"><strong>54</strong></span>&#13;
<span class="cviolet"><strong>55</strong></span>   <span class="blue">if</span> (ints1 == ints2) {&#13;
<span class="cviolet"><strong>56</strong></span>      cout &lt;&lt; <span class="green">"ints1 and ints2 are equal\n\n"</span>;&#13;
<span class="cviolet"><strong>57</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>58</strong></span></pre>&#13;
<pre class="pre1">Evaluating: ints1 == ints2&#13;
ints1 and ints2 are equal</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec32">Using the Overloaded Subscript Operator (<strong><code>[]</code></strong>)</h5>&#13;
<p>Line 60 uses the <strong>overloaded subscript operator (<code>[]</code>)</strong> to refer to <code>ints1[5]</code>—an <em>in-range</em> element of <code>ints1</code>. This indexed (subscripted) name is used to get the value stored in <code>ints1[5]</code>. Line 64 uses <code>ints1[5]</code> on an assignment’s left side as a modifiable <em>lvalue</em><sup><a id="ch11fn11a" href="ch11.xhtml#ch11fn11">11</a></sup> to assign a new value, <code>1000</code>, to element <code>5</code> of <code>ints1</code>. We’ll see that <strong><code>operator[]</code></strong> returns a reference to use as the modifiable <em>lvalue</em> after confirming <code>5</code> is a valid index. Line 70 attempts to assign <code>1000</code> to <code>ints1[15]</code>. <strong>This index is outside <code>int1</code>’s bounds, so the overloaded <code>operator[]</code> throws an <code>out_of_range</code> exception</strong>. Lines 72–74 catch the exception and display its error message by calling the exception’s <code>what</code> member function.</p>&#13;
<p class="footnote"><a id="ch11fn11" href="ch11.xhtml#ch11fn11a">11</a>. Recall that an <em>lvalue</em> can be declared <code>const</code>, in which case it would not be modifiable.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p596pro01" id="p596pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>59</strong></span>   <span class="lgreen">// use overloaded subscript operator to create an rvalue</span>&#13;
<span class="cviolet"><strong>60</strong></span>   cout &lt;&lt; <span class="green">"ints1[5] is "</span> &lt;&lt; ints1[5];&#13;
<span class="cviolet"><strong>61</strong></span>&#13;
<span class="cviolet"><strong>62</strong></span>   <span class="lgreen">// use overloaded subscript operator to create an lvalue</span>&#13;
<span class="cviolet"><strong>63</strong></span>   cout &lt;&lt; <span class="green">"\n\nAssigning 1000 to ints1[5]\n"</span>;&#13;
<span class="cviolet"><strong>64</strong></span>   ints1[<span class="green">5</span>] = <span class="green">1000</span>;&#13;
<span class="cviolet"><strong>65</strong></span>   cout &lt;&lt; <span class="green">"ints1: "</span> &lt;&lt; ints1;&#13;
<span class="cviolet"><strong>66</strong></span>&#13;
<span class="cviolet"><strong>67</strong></span>   <span class="lgreen">// attempt to use out-of-range subscript</span>&#13;
<span class="cviolet"><strong>68</strong></span>   <span class="blue">try</span> {&#13;
<span class="cviolet"><strong>69</strong></span>      cout &lt;&lt; <span class="green">"\n\nAttempt to assign 1000 to ints1[15]\n"</span>;&#13;
<span class="cviolet"><strong>70</strong></span>      ints1[15] <span class="green">=</span> <span class="green">1000</span>; <span class="lgreen">// ERROR: subscript out of range</span>&#13;
<span class="cviolet"><strong>71</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>72</strong></span>   <span class="blue">catch</span> (<span class="blue">const</span> out_of_range&amp; ex) {&#13;
<span class="cviolet"><strong>73</strong></span>      cout &lt;&lt; <span class="green">"An exception occurred: "</span> &lt;&lt; ex.what() &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>74</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>75</strong></span></pre>&#13;
<pre class="pre1">ints1[5] is 13&#13;
&#13;
Assigning 1000 to ints1[5]&#13;
ints1: {8, 9, 10, 11, 12, 1000, 14, 15, 16, 17}&#13;
&#13;
Attempt to assign 1000 to ints1[15]&#13;
An exception occurred: Index out of range</pre>&#13;
</div>&#13;
<p>The <strong>array subscript operator <code>[]</code></strong> is not restricted for use only with arrays. It also can be used, for example, to select elements from other kinds of <em>container classes</em> that maintain collections of items, such as <code>string</code>s (collections of characters) and <code>map</code>s (collections of key-value pairs, which we’ll discuss in <a href="ch13.xhtml#ch13">Chapter 13</a>, Standard Library Containers and Iterators). Also, when <strong>overloaded <code>operator[]</code></strong> functions are defined, <em>indices are not required to be integers</em>. In <a href="ch13.xhtml#ch13">Chapter 13</a>, we discuss the standard library <code>map</code> class that allows indices of other types, such as <code>string</code>s.</p>&#13;
<h5 class="h5" id="ch11lev3sec33">Creating <code>MyArray</code> <strong><code>ints4</code></strong> and Initializing It With the <strong><code>MyArray</code></strong> Returned By Function <strong><code>getArrayByValue</code></strong></h5>&#13;
<p>Line 79 initializes <code>MyArray ints4</code> with the result of calling function <code>getArrayByValue</code> (lines 10–13), which creates a local <code>MyArray</code> containing <code>10</code>, <code>20</code> and <code>30</code>, then returns it <em>by value.</em> Then, line 81 displays the new <code>MyArray</code>’s size and contents.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p597pro01" id="p597pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>76</strong></span>   <span class="lgreen">// initialize ints4 with contents of the MyArray returned by</span>&#13;
<span class="cviolet"><strong>77</strong></span>   <span class="lgreen">// getArrayByValue; print size and contents</span>&#13;
<span class="cviolet"><strong>78</strong></span>   cout &lt;&lt; <span class="green">"\nInitialize ints4 with temporary MyArray object\n"</span>;&#13;
<span class="cviolet"><strong>79</strong></span>   <code>MyArray ints4{getArrayByValue()};</code>&#13;
<span class="cviolet"><strong>80</strong></span>&#13;
<span class="cviolet"><strong>81</strong></span>   cout &lt;&lt; <span class="green">"\nints4 size: "</span> &lt;&lt; ints4.size() &lt;&lt; <span class="green">"\ncontents: "</span> &lt;&lt; ints4;&#13;
<span class="cviolet"><strong>82</strong></span></pre>&#13;
<pre class="pre1">Initialize ints4 with temporary MyArray object&#13;
MyArray(initializer_list) constructor&#13;
&#13;
ints4 size: 3&#13;
contents: {10, 20, 30}</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec34">Named Return Value Optimization (NRVO)</h5>&#13;
<p>Recall from function <code>getArrayByValue</code>’s definition (lines 10–13) that it creates and initializes a local <code>MyArray</code> using the constructor that receives an <code>initializer_list</code> of <code>int</code> values (line 11). This constructor displays</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p597pro02" id="p597pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">MyArray(initializer_list) constructor</pre>&#13;
<p>each time it’s called. Next, <code>getArrayByValue</code> returns that local array <em>by value</em> (line 12). You might expect that returning an object by value would make a temporary copy of the object for use in the caller. If it did this would call <code>MyArray</code>’s copy constructor to copy the local <code>MyArray</code>. You also might expect the local <code>MyArray</code> object to go out of scope and have its destructor called as <code>getArrayByValue</code> returns to its caller. However, neither the copy constructor nor the destructor displayed lines of output here.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size">17</span> This is due to a compiler performance optimization called <strong><span class="violet">named return value optimization (NRVO)</span></strong>. When the compiler sees that a local object is constructed, returned from a function by value then used to initialize an object in the caller, the compiler instead constructs the object directly in the caller where it will be used, eliminating the temporary object and extra constructor and destructor calls mentioned above. Prior to C++17 this was an optional optimization, but this optimization is required as of C++17.<sup><a id="ch11fn12a" href="ch11.xhtml#ch11fn12">12</a>,<a id="ch11fn13a" href="ch11.xhtml#ch11fn13">13</a></sup></p>&#13;
<p class="footnote"><a id="ch11fn12" href="ch11.xhtml#ch11fn12a">12</a>. Sy Brand. “Guaranteed Copy Elision Does Not Elide Copies.” C++ Team Blog, February 18, 2019. Accessed February, 24, 2021. <code><a href="https://devblogs.microsoft.com/cppblog/guaranteed-copy-elision-does-not-elide-copies/">https://devblogs.microsoft.com/cppblog/guaranteed-copy-elision-does-not-elide-copies/</a></code>.</p>&#13;
<p class="footnote"><a id="ch11fn13" href="ch11.xhtml#ch11fn13a">13</a>. Richard Smith, “Guaranteed copy elision through simplified value categories,” September 27, 2015. Accessed February 24, 2021. <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html</a></code>.</p>&#13;
<h5 class="h5" id="ch11lev3sec35">Creating <code>MyArray</code> <strong><code>ints5</code></strong> and Initializing It With the <em>rvalue</em> Returned By Function <strong><code>std::move</code></strong></h5>&#13;
<p>A <strong>copy constructor</strong> is called when you initialize one <code>MyArray</code> with another that’s represented by an <em>lvalue</em>. A copy constructor copies its arguments contents. This is similar to a copy-and-paste operation in a text editor—after the operation, you have two copies of the data.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> C++ also supports <strong>move semantics</strong>,<sup><a id="ch11fn14a" href="ch11.xhtml#ch11fn14">14</a></sup> which help the compiler eliminate the overhead of unnecessarily copying objects. A move is similar to a cut-and-paste operation in a text editor—the data gets <em>moved</em> from the cut location to the paste location. A <strong>move constructor</strong> moves into a new object the resources of an object that’s no longer needed. Such a constructor receives a C++11 <span class="violet"><strong><em>rvalue</em> reference</strong></span>, which you’ll see is declared with <em>TypeName</em><code>&amp;&amp;</code>. <em>Rvalue</em> references may refer only to <em>rvalues</em>. Typically, these are temporary objects or objects that are about to be destroyed—called <strong><span class="violet">expiring values</span></strong> or <span class="violet"><em><strong>xvalues</strong></em></span>.</p>&#13;
<p class="footnote"><a id="ch11fn14" href="ch11.xhtml#ch11fn14a">14</a>. Klaus Iglberger, “Back to Basics: Move Semantics,” YouTube Video, June 16, 2019, <code><a href="https://www.youtube.com/watch?v=St0MNEU5b0o">https://www.youtube.com/watch?v=St0MNEU5b0o</a></code>.</p>&#13;
<p><span class="size">11</span> Line 86 uses class <code>MyArray</code>’s <strong>move constructor</strong> to initialize <code>MyArray ints5</code>, then line 88 displays the size and contents of the new <code>MyArray</code>. The object <code>ints4</code> is an <em>lvalue</em>—so it cannot be passed directly to <code>MyArray</code>’s move constructor. If you no longer need an object’s resources, you can <strong>convert it from an <em>lvalue</em> to an <em>rvalue</em> reference</strong> by passing the object to the C++11 standard library function <span class="violet"><strong><code>std::move</code></strong></span> (from header <code>&lt;utility&gt;</code>). <strong>This function casts its argument to an <em>rvalue</em> reference</strong>,<sup><a id="ch11fn15a" href="ch11.xhtml#ch11fn15">15</a></sup> telling the compiler that <code>ints4</code>’s contents are no longer needed. So, line 86 forces <code>MyArray</code>’s <strong>move constructor</strong> to be called and <code>ints4</code>’s contents are <em>moved</em> into <code>ints5</code>.</p>&#13;
<p class="footnote"><a id="ch11fn15" href="ch11.xhtml#ch11fn15a">15</a>. More specifically, this is called <em>xvalue</em> (for expiring value).</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p598pro01" id="p598pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>83</strong></span>   <span class="lgreen">// convert ints4 to an rvalue reference with std::move and</span>&#13;
<span class="cviolet"><strong>84</strong></span>   <span class="lgreen">// use the result to initialize MyArray ints5</span>&#13;
<span class="cviolet"><strong>85</strong></span>   cout &lt;&lt; <span class="green">"\n\nInitialize ints5 with the result of std::move(ints4)\n"</span>;&#13;
<span class="cviolet"><strong>86</strong></span>   MyArray ints5{std::move(ints4)}; <span class="lgreen">// invokes move constructor</span>&#13;
<span class="cviolet"><strong>87</strong></span>&#13;
<span class="cviolet"><strong>88</strong></span>   cout &lt;&lt; <span class="green">"\nints5 size: "</span> &lt;&lt; ints5.size() &lt;&lt; <span class="green">"\ncontents: "</span> &lt;&lt; ints5;&#13;
<span class="cviolet"><strong>89</strong></span>   cout &lt;&lt; <span class="green">"\n\nSize of ints4 is now: "</span> &lt;&lt; ints4.size();&#13;
<span class="cviolet"><strong>90</strong></span></pre>&#13;
<pre class="pre1">Initialize ints5 with the result of std::move(ints4)&#13;
MyArray move constructor&#13;
&#13;
ints5 size: 3&#13;
contents: {10, 20, 30}&#13;
&#13;
Size of ints4 is now: 0</pre>&#13;
</div>&#13;
<p>It’s recommended that you use <code>std::move</code> as shown here <strong><em>only</em> if you know the source object passed to <code>std::move</code> will never be used again</strong>. Once an object has been moved, two valid operations can be performed with it:</p>&#13;
<p class="bull">• destroying it, and</p>&#13;
<p class="bull">• using it on the left side of an assignment to give it a new value.</p>&#13;
<p><strong>In general, you should not call member functions on a moved-from object</strong>. <em>We do so in line 89 only to prove that the</em> <strong><em>move constructor</em></strong> <em>indeed moved ints4’s resources</em>—the output shows that <code>ints4</code>’s size is now <code>0</code>.</p>&#13;
<h5 class="h5" id="ch11lev3sec36">Assigning <code>MyArray</code> <strong><code>ints5</code></strong> to <strong><code>ints4</code></strong> with the Move Assignment Operator</h5>&#13;
<p>Lines 93 and 95 use class <code>MyArray</code>’s <strong>move assignment operator</strong> to move <code>ints5</code>’s contents (<code>10</code>, <code>20</code> and <code>30</code>) back into <code>ints4</code> then display the size and contents of <code>ints4</code>. Line 93 <em>explicitly converts</em> the <em>lvalue</em> <code>ints5</code> to an <strong><em>rvalue</em> reference</strong> using <code>std::move</code>. This indicates that <code>ints5</code> no longer needs its resources, so the compiler can <em>move</em> them into <code>ints4</code>. In this case, the compiler calls <code>MyArray</code>’s <strong>move assignment operator</strong>. <em>For demo purposes only, we output ints5’s size to show that the</em> <strong><em>move assignment operator</em></strong> <em>indeed moved its resources.</em> Again, <strong>you should not call member functions on a moved-from object</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p600pro01" id="p600pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>91</strong></span>   <span class="lgreen">// move contents of ints5 into ints4</span>&#13;
<span class="cviolet"><strong>92</strong></span>   cout &lt;&lt; <span class="green">"\n\nMove ints5 into ints4 via move assignment\n"</span>;&#13;
<span class="cviolet"><strong>93</strong></span>   ints4 = std::move(ints5); <span class="lgreen">// invokes move assignment</span>&#13;
<span class="cviolet"><strong>94</strong></span>&#13;
<span class="cviolet"><strong>95</strong></span>   cout &lt;&lt; <span class="green">"\nints4 size: "</span> &lt;&lt; ints4.size() &lt;&lt; <span class="green">"\ncontents: "</span> &lt;&lt; ints4;&#13;
<span class="cviolet"><strong>96</strong></span>   cout &lt;&lt; <span class="green">"\n\nSize of ints5 is now: "</span> &lt;&lt; ints5.size();&#13;
<span class="cviolet"><strong>97</strong></span></pre>&#13;
<pre class="pre1">Move ints5 into ints4 via move assignment&#13;
MyArray move assignment operator&#13;
&#13;
ints4 size: 3&#13;
contents: {10, 20, 30}&#13;
&#13;
Size of ints5 is now: 0</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec37">Converting <code>MyArray</code> <strong><code>ints5</code></strong> to a <strong><code>bool</code></strong> to Test Whether It’s Empty</h5>&#13;
<p>Many programming languages allow you to use a container-class object like a <code>MyArray</code> as a condition to determine whether the container has elements. For class <code>MyArray</code>, we defined a <code>bool</code> conversion operator that returns <code>true</code> if the <code>MyArray</code> object contains elements (i.e., its <code>size</code> is greater than 0) and <code>false</code> otherwise. In contexts that require <code>bool</code> values, such as control statement conditions, C++ can invoke an object’s <code>bool</code> conversion operator implicitly. This is known as a <strong><span class="violet">contextual conversion</span></strong>. Line 99 uses the <code>MyArray ints5</code> as a condition, which calls <code>MyArray</code>’s <code>bool</code> conversion operator. Since we just moved <code>ints5</code>’s resources into <code>ints4</code>, <code>ints5</code> is now empty, and the operator returns <code>false</code>. <em>Once again, you should not call member functions on moved-from objects</em>—we do so here only to prove that <code>ints5</code>’s resources have been moved.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p600pro02" id="p600pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>98</strong></span>   <span class="lgreen">// check if ints5 is empty by contextually converting it to a bool</span>&#13;
<span class="cviolet"><strong>99</strong></span>   <span class="blue">if</span> (ints5) {&#13;
<span class="cviolet"><strong>100</strong></span>      cout &lt;&lt; <span class="green">"\n\nints5 contains elements\n"</span>;&#13;
<span class="cviolet"><strong>101</strong></span>  <code>}</code>&#13;
<span class="cviolet"><strong>102</strong></span>  <span class="blue">else</span> {&#13;
<span class="cviolet"><strong>103</strong></span>     cout &lt;&lt; <span class="green">"\n\nints5 is empty\n"</span>;&#13;
<span class="cviolet"><strong>104</strong></span>  <code>}</code>&#13;
<span class="cviolet"><strong>105</strong></span></pre>&#13;
<pre class="pre1">ints5 is empty</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec38">Preincrementing Every <code>ints4</code> Element with the Overloaded <strong><code>++</code></strong> Operator</h5>&#13;
<p>Some libraries support <strong>“broadcast” operations</strong> that apply the same operation to every element of a data structure. For example, consider the popular high-performance Python programming language library <strong>NumPy</strong>. This library’s <strong><code>ndarray</code> (<em>n</em>-dimensional array) data structure</strong> overloads many arithmetic operators. They conveniently perform mathematical operations on <em>every</em> element of an <code>ndarray</code>. In NumPy, the following Python code adds one to every element of the <code>ndarray</code> named <code>numbers</code> (no iteration statement is required):</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p600pro03" id="p600pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">numbers += <span class="green">1</span> <span class="lgreen"># Python does not have a ++ operator</span></pre>&#13;
<p>To demonstrate preincrement and postincrement, we’ve added a similar capability to class <code>MyArray</code>. Line 107 displays <code>ints4</code>’s current contents, then line 108 uses the expression <code>++ints4</code> to preincrement the entire <code>MyArray</code>, by adding one to every element. This expression’s result is the updated <code>MyArray</code>. We then use <code>MyArray</code>’s <strong>overloaded stream insertion operator (<code>&lt;&lt;</code>)</strong> to display the contents.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p601pro01" id="p601pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>106</strong></span>   <span class="lgreen">// add one to every element of ints4 using preincrement</span>&#13;
<span class="cviolet"><strong>107</strong></span>   cout &lt;&lt; <span class="green">"\nints4: "</span> &lt;&lt; ints4;&#13;
<span class="cviolet"><strong>108</strong></span>   cout &lt;&lt; <span class="green">"\npreincrementing ints4: "</span> &lt;&lt; ++ints4;&#13;
<span class="cviolet"><strong>109</strong></span></pre>&#13;
<pre class="pre1">ints4: {10, 20, 30}&#13;
preincrementing ints4: {11, 21, 31}</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec39">Postincrementing Every <code>ints4</code> Element with the Overloaded <strong><code>++</code></strong> Operator</h5>&#13;
<p>Line 111 postincrements the entire <code>MyArray</code> with the expression <code>ints4++</code>. Recall that a postincrement returns its operand’s <strong>previous value</strong>, as confirmed by the program’s output. The outputs showing that <code>MyArray</code>’s <strong>copy constructor</strong> and <strong>destructor</strong> were called are from the postincrement operator’s implementation, which we’ll discuss in <a href="ch11.xhtml#sec11_6_14">Section 11.6.14</a>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p601pro02" id="p601pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>110</strong></span>   <span class="lgreen">// add one to every element of ints4 using postincrement</span>&#13;
<span class="cviolet"><strong>111</strong></span>   cout &lt;&lt; <span class="green">"\n\npostincrementing ints4: "</span> &lt;&lt; ints4++ &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>112</strong></span>   cout &lt;&lt; <span class="green">"\nints4 now contains: "</span> &lt;&lt; ints4;&#13;
<span class="cviolet"><strong>113</strong></span></pre>&#13;
<pre class="pre1">postincrementing ints4: MyArray copy constructor&#13;
{11, 21, 31}&#13;
MyArray destructor&#13;
&#13;
ints4 now contains: {12, 22, 32}</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec40">Adding a Value to Every <code>ints4</code> Element with the Overloaded <strong><code>+=</code></strong> Operator</h5>&#13;
<p>Class <code>MyArray</code> also provides a broadcast-based <strong>overloaded addition assignment operator (<code>+=</code>)</strong> for adding an <code>int</code> value to every <code>MyArray</code> element. Line 115 adds 7 to every <code>ints4</code> element then displays its new contents. Note that the non-overloaded versions of <code>++</code> and <code>+=</code> still work on individual <code>MyArray</code> elements too—those are simply <code>int</code> values.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p601pro03" id="p601pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>114</strong></span>      <span class="lgreen">// add a value to every element of ints4 using +=</span>&#13;
<span class="cviolet"><strong>115</strong></span>      cout &lt;&lt; <span class="green">"\n\nAdd 7 to every ints4 element: "</span> &lt;&lt; (ints4 += <span class="green">7</span>) &lt;&lt; <span class="green">"\n\n"</span>;&#13;
<span class="cviolet"><strong>116</strong></span>   }</pre>&#13;
<pre class="pre1">Add 7 to every ints4 element: {19, 29, 39}</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec41">Destroying the <code>MyArray</code> Objects That Remain</h5>&#13;
<p>When function <code>main</code> terminates, the <strong>destructors</strong> are called for the five <code>MyArray</code> objects created in <code>main</code>, producing the last five lines of the program’s output.</p>&#13;
<pre class="pre1">MyArray destructor&#13;
MyArray destructor&#13;
MyArray destructor&#13;
MyArray destructor&#13;
MyArray destructor</pre>&#13;
<h4 class="h4" id="sec11_6_3">11.6.3 <code>MyArray</code> Class Definition</h4>&#13;
<p>Now, let’s walk through <code>MyArray</code>’s header (<a href="ch11.xhtml#fig11_4">Fig. 11.4</a>). As we refer to each member function in the header, we discuss that function’s implementation in <a href="ch11.xhtml#fig11_5">Fig. 11.5</a>. We’ve broken the member-function implementation file into small segments for discussion purposes.</p>&#13;
<p>In <a href="ch11.xhtml#fig11_4">Fig. 11.4</a>, lines 53–54 declare <code>MyArray</code>’s <code>private</code> data members:</p>&#13;
<p class="bull">• <code>m_size</code> stores its number of elements, and</p>&#13;
<p class="bull">• <code>m_ptr</code> is a <code>unique_ptr</code> that manages a dynamically allocated pointer-based <code>int</code> array containing the <code>MyArray</code> object’s elements. When a <code>MyArray</code> goes out of scope, its destructor will call the <code>unique_ptr</code>’s destructor which will automatically delete the dynamically allocated memory.</p>&#13;
<p>Throughout this class’s member-function implementations, we use some of C++’s declarative, functional-style programming capabilities discussed in <a href="ch06.xhtml#ch06">Chapters 6</a> and <a href="ch07.xhtml#ch07">7</a>. We also introduce three additional standard library algorithms—<code>copy</code>, <code>for_each</code> and <code>equal</code>.</p>&#13;
<div class="group" id="fig11_4">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p11pro04" id="p11pro04a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 11.4: MyArray.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// MyArray class definition with overloaded operators.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;initializer_list&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;memory&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">class</span> MyArray <span class="blue">final</span> {&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// overloaded stream extraction operator</span>&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">friend</span> std::istream&amp; <span class="blue">operator</span>&gt;&gt;(std::istream&amp; in, MyArray&amp; a);&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="lgreen">// used by copy assignment operator to implement copy-and-swap idiom</span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">friend void</span> swap(MyArray&amp; a, MyArray&amp; b) <span class="blue">noexcept</span>;&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">explicit</span> MyArray(<span class="blue">size_t</span> size); <span class="lgreen">// construct a MyArray of size elements</span>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="lgreen">// construct a MyArray with a braced-initializer list of ints</span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">explicit</span> MyArray(std::initializer_list&lt;<span class="blue">int</span>&gt; list);&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      MyArray(<span class="blue">const</span> MyArray&amp; original); <span class="lgreen">// copy constructor</span>&#13;
<span class="cviolet"><strong>22</strong></span>      MyArray&amp; <span class="blue">operator</span>=(<span class="blue">const</span> MyArray&amp; right); <span class="lgreen">// copy assignment operator</span>&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>      MyArray(MyArray&amp;&amp; original) <span class="blue">noexcept</span>; <span class="lgreen">// move constructor</span>&#13;
<span class="cviolet"><strong>25</strong></span>      MyArray&amp; <span class="blue">operator</span>=(MyArray&amp;&amp; right) <span class="blue">noexcept</span>; <span class="lgreen">// move assignment</span>&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>      ~MyArray(); <span class="lgreen">// destructor</span>&#13;
<span class="cviolet"><strong>28</strong></span>&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="blue">size_t</span> size() <span class="blue">const noexcept</span> {<span class="blue">return</span> m_size;}; <span class="lgreen">// return size</span>&#13;
<span class="cviolet"><strong>30</strong></span>      std::string toString() <span class="blue">const</span>; <span class="lgreen">// create string representation</span>&#13;
<span class="cviolet"><strong>31</strong></span>&#13;
<span class="cviolet"><strong>32</strong></span>      <span class="lgreen">// equality operator</span>&#13;
<span class="cviolet"><strong>33</strong></span>      <span class="blue">bool</span> <span class="blue">operator</span>==(<span class="blue">const</span> MyArray&amp; right) <span class="blue">const noexcept</span>;&#13;
<span class="cviolet"><strong>34</strong></span>&#13;
<span class="cviolet"><strong>35</strong></span>      <span class="lgreen">// subscript operator for non-const objects returns modifiable lvalue</span>&#13;
<span class="cviolet"><strong>36</strong></span>      <span class="blue">int</span>&amp; <span class="blue">operator</span>[](<span class="blue">size_t</span> index);&#13;
<span class="cviolet"><strong>37</strong></span>&#13;
<span class="cviolet"><strong>38</strong></span>      <span class="lgreen">// subscript operator for const objects returns non-modifiable lvalue</span>&#13;
<span class="cviolet"><strong>39</strong></span>      <span class="blue">const int</span>&amp; <span class="blue">operator</span>[](<span class="blue">size_t</span> index) <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>40</strong></span>&#13;
<span class="cviolet"><strong>41</strong></span>      <span class="lgreen">// convert MyArray to a bool value: true if non-empty; false if empty</span>&#13;
<span class="cviolet"><strong>42</strong></span>      <span class="blue">explicit</span> <span class="blue">operator bool</span>() <span class="blue">const</span> <span class="blue">noexcept</span> {<span class="blue">return</span> size() != <span class="green">0</span>;}&#13;
<span class="cviolet"><strong>43</strong></span>&#13;
<span class="cviolet"><strong>44</strong></span>      <span class="lgreen">// preincrement every element, then return updated MyArray</span>&#13;
<span class="cviolet"><strong>45</strong></span>      <code>MyArray&amp; operator++();</code>&#13;
<span class="cviolet"><strong>46</strong></span>&#13;
<span class="cviolet"><strong>47</strong></span>      <span class="lgreen">// postincrement every element, and return copy of original MyArray</span>&#13;
<span class="cviolet"><strong>48</strong></span>      MyArray operator++(<span class="blue">int</span>);&#13;
<span class="cviolet"><strong>49</strong></span>&#13;
<span class="cviolet"><strong>50</strong></span>      <span class="lgreen">// add value to every element, then return updated MyArray</span>&#13;
<span class="cviolet"><strong>51</strong></span>      MyArray&amp; operator+=(<span class="blue">int</span> value);&#13;
<span class="cviolet"><strong>52</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>53</strong></span>      <span class="blue">size_t</span> m_size{<span class="green">0</span>}; <span class="lgreen">// pointer-based array size</span>&#13;
<span class="cviolet"><strong>54</strong></span>      std::unique_ptr&lt;<span class="blue">int</span>[]&gt; m_ptr; <span class="lgreen">// smart pointer to integer array</span>&#13;
<span class="cviolet"><strong>55</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>56</strong></span>&#13;
<span class="cviolet"><strong>57</strong></span>   <span class="lgreen">// overloaded operator&lt;&lt; is not a friend--does not access private data</span>&#13;
<span class="cviolet"><strong>58</strong></span>   std::ostream&amp; <span class="blue">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="blue">const</span> MyArray&amp; a);</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 11.4</strong></span> | <code>MyArray</code> class definition with overloaded operators. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h4 class="h4" id="sec11_6_4">11.6.4 Constructor That Specifies a <code>MyArray</code>’s Size</h4>&#13;
<p>Line 16 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p603pro01" id="p603pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">explicit</span> MyArray(<span class="blue">size_t</span> size); <span class="lgreen">// construct a MyArray of size elements</span></pre>&#13;
<p>declares a <strong>constructor</strong> that specifies the number of <code>MyArray</code> elements. The constructor’s definition (<a href="ch11.xhtml#fig11_5">Fig. 11.5</a>, lines 16–19) performs several tasks:</p>&#13;
<p class="bull">• Line 17 initializes the <code>m_size</code> member using the argument <code>size</code>.</p>&#13;
<p class="bull">• Line 17 initializes the <code>m_ptr</code> member to a <code>unique_ptr</code> returned by the standard library’s <code>make_unique</code> function template (see <a href="ch11.xhtml#sec11_5">Section 11.5</a>). Here, we use it to create a dynamically allocated <code>int</code> array of <code>size</code> elements. The function <code>make_unique</code> <strong>value initializes the dynamic memory</strong> it allocates, so the <code>int</code> array’s elements are set to 0.</p>&#13;
<p class="bull">• For pedagogic purposes, line 18 displays that the constructor was called. We do this in all of <code>MyArray</code>’s <strong>special member functions and other constructors</strong> to give you visual confirmation that the functions are being called.</p>&#13;
<div class="group" id="fig11_5">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p11pro05" id="p11pro05a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 11.5: MyArray.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// MyArray class member- and friend-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;initializer_list&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;memory&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;span&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;sstream&gt;&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">#include</span> &lt;utility&gt;&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">#include</span> <span class="green">"MyArray.h"</span> <span class="lgreen">// MyArray class definition</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// MyArray constructor to create a MyArray of size elements containing 0</span>&#13;
<span class="cviolet"><strong>16</strong></span>   MyArray::MyArray<span class="blue">(size_t</span> size)&#13;
<span class="cviolet"><strong>17</strong></span>          : m_size{size}, m_ptr{make_unique&lt;<span class="blue">int</span>[]&gt;(size)} {&#13;
<span class="cviolet"><strong>18</strong></span>          cout &lt;&lt; <span class="green">"MyArray(size_t) constructor\n"</span>;&#13;
<span class="cviolet"><strong>19</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>20</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 11.5</strong></span> | <code>MyArray</code> class member- and friend-function definitions.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec11_6_5"><span class="size">11</span> 11.6.5 C++11 Passing a Braced Initializer to a Constructor</h4>&#13;
<p>In <a href="ch06.xhtml#fig6_2">Fig. 6.2</a>, we initialized a <code>std::array</code> object with braced-initializer list, as in</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p604pro01" id="p604pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">array&lt;<span class="blue">int</span>, <span class="green">5</span>&gt; n{<span class="green">32</span>, <span class="green">27</span>, <span class="green">64</span>, <span class="green">18</span>, <span class="green">95</span>};</pre>&#13;
<p>You can use <strong>braced initializers</strong> for objects of your own classes by providing a <strong>constructor</strong> with a <span class="violet"><strong><code>std::initializer_list</code></strong></span> parameter, as declared in line 19 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a>:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p604pro02" id="p604pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">explicit</span> MyArray(std::initializer_list&lt;<span class="blue">int</span>&gt; list);</pre>&#13;
<p>The <code>std::initializer_list</code> class template is defined in the header <span class="violet"><strong><code>&lt;initializer_list&gt;</code></strong></span>. With this constructor, we can create <code>MyArray</code> objects that initialize their elements as they’re constructed, as in:</p>&#13;
<pre class="pre">MyArray ints{<span class="green">10</span>, <span class="green">20</span>, <span class="green">30</span>};</pre>&#13;
<p>or</p>&#13;
<pre class="pre">MyArray ints = {<span class="green">10</span>, <span class="green">20</span>, <span class="green">30</span>};</pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Each creates a three-element <code>MyArray</code> containing <code>10</code>, <code>20</code> and <code>30</code>. <strong>In a class that provides an <code>initializer_list</code> constructor, the class’s other single-argument constructors must be called using parentheses rather than braces.</strong> The <strong>braced initialization constructor</strong> (lines 22–29) has one <code>initializer_list&lt;int&gt;</code> parameter named <code>list</code>. You can determine <code>list</code>’s number of elements by calling its <span class="violet"><strong><code>size</code></strong></span><strong><span class="violet"> member function</span></strong> (line 23).</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p605pro01" id="p605pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>21</strong></span>   <span class="lgreen">// MyArray constructor that accepts an initializer list</span>&#13;
<span class="cviolet"><strong>22</strong></span>   MyArray::MyArray(initializer_list<span class="blue">&lt;in</span>t&gt; list)&#13;
<span class="cviolet"><strong>23</strong></span>      : m_size{list.size()}, m_ptr{make_unique&lt;<span class="blue">int</span>[]&gt;(list.size())} {&#13;
<span class="cviolet"><strong>24</strong></span>      cout &lt;&lt; <span class="green">"MyArray(initializer_list) constructor\n"</span>;&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>      <span class="lgreen">// copy list argument's elements into m_ptr's underlying int array</span>&#13;
<span class="cviolet"><strong>27</strong></span>      <span class="lgreen">// m_ptr.get() returns the int array's starting memory location</span>&#13;
<span class="cviolet"><strong>28</strong></span>      <code>copy(begin(list), end(list), m_ptr.get());</code>&#13;
<span class="cviolet"><strong>29</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>30</strong></span></pre>&#13;
</div>&#13;
<p>To copy each initializer list value into the new <code>MyArray</code> object, line 28 uses the standard library <span class="violet"><strong><code>copy</code></strong></span> algorithm (from header <span class="violet"><strong><code>&lt;algorithm&gt;</code></strong></span>) to copy each <code>initializer_list</code> element into the new <code>MyArray</code>. The algorithm copies each element in the range specified by its first two arguments—the beginning and end of the <code>initializer_list</code>. These elements are copied into the destination specified by <code>copy</code>’s third argument. The <code>unique_ptr</code>’s <span class="violet"><strong><code>get</code></strong></span><strong><span class="violet"> member function</span></strong> returns the <code>int*</code> that points to the first element of the <code>MyArray</code>’s underlying <code>int</code> array.</p>&#13;
<h4 class="h4" id="sec11_6_6">11.6.6 Copy Constructor and Copy Assignment Operator</h4>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <a href="ch09.xhtml#ch09lev1sec15">Sections 9.15</a> and <a href="ch09.xhtml#ch09lev1sec17">9.17</a> introduced the <strong>compiler-generated default copy assignment operator</strong> and <strong>default copy constructor</strong>. These performed <strong>memberwise copy operations by default</strong>. The C++ Core Guidelines recommend designing your classes such that the compiler can autogenerate the copy constructor, copy assignment operator, move constructor, move assignment operator and destructor. This is known as the <strong><span class="violet">Rule of Zero</span></strong>.<sup><a id="ch11fn16a" href="ch11.xhtml#ch11fn16">16</a></sup> You can accomplish this by composing each class’s data using fundamental-type members and objects of classes that do not require you to implement custom resource processing, such as standard library classes like <code>array</code> and <code>vector</code>, which each use RAII to manage resources.</p>&#13;
<p class="footnote"><a id="ch11fn16" href="ch11.xhtml#ch11fn16a">16</a>. “C.20: If you can avoid defining any default operations, do.” Accessed March 3, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero</a></code>.</p>&#13;
<h5 class="h5" id="ch11lev3sec42">The Rule of Five</h5>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The default special member functions work well for fundamental-type values like <code>int</code>s and <code>double</code>s. But what about objects of types that manage their own resources, such as pointers to dynamically allocated memory? Classes that manage their own resources should explicitly define the five special member functions. The C++ Core Guidelines state that if a class requires one special member function, it should define them all,<sup><a id="ch11fn17a" href="ch11.xhtml#ch11fn17">17</a></sup> as we do in this case study. This is known as the <strong><span class="violet">Rule of Five</span></strong>.</p>&#13;
<p class="footnote"><a id="ch11fn17" href="ch11.xhtml#ch11fn17a">17</a>. “C.21: If you define or <code>=delete</code> any copy, move, or destructor function, define or <code>=delete</code> them all.” Accessed March 3, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-five">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-five</a></code>.</p>&#13;
<p><span class="size">11</span> Even for classes with the compiler-generated special member functions, some experts recommend declaring them explicitly in the class definition with <code>= default</code> (introduced in <a href="ch10.xhtml#ch10">Chapter 10</a>). This is called the <strong><span class="violet">Rule of Five</span></strong> <span class="violet"><strong><code>default</code>s</strong></span>.<sup><a id="ch11fn18a" href="ch11.xhtml#ch11fn18">18</a></sup> You also can explicitly remove compiler-generated special member functions to prevent the specified functionality by following their function prototypes with C++11’s <span class="violet"><strong><code>= delete</code></strong></span>. Class <code>unique_ptr</code> actually does this for the copy constructor and copy assignment operator.</p>&#13;
<p class="footnote"><a id="ch11fn18" href="ch11.xhtml#ch11fn18a">18</a>. Scott Meyers, “A Concern about the Rule of Zero,” March 13, 2014. Accessed March 6, 2021. <code><a href="http://scottmeyers.blogspot.com/2014/03/a-concern-about-rule-of-zero.html">http://scottmeyers.blogspot.com/2014/03/a-concern-about-rule-of-zero.html</a></code>.</p>&#13;
<h5 class="h5" id="ch11lev3sec43">Shallow Copy</h5>&#13;
<p>The compiler-generated copy constructor and copy assignment operator perform memberwise <strong><span class="violet">shallow copies</span></strong>. If the member is a pointer to dynamically allocated memory, only the address in the pointer is copied. In the following diagram, consider the object <code>x</code>, which contains its number of elements (<code>3</code>) and a pointer to a dynamically allocated array. For this discussion, let’s assume the pointer member is just an <code>int*</code>, not a <code>unique_ptr</code>.</p>&#13;
<div class="image"><img src="Images/606fig01.jpg" alt="Images" width="628" height="198"/></div>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Now, assume we’d like to copy <code>x</code> into a new object <code>y</code>. If the <strong>copy constructor</strong> simply copied the pointer in <code>x</code> into the target object <code>y</code>’s pointer, both would point to the same <strong>dynamically allocated memory</strong>, as in the right side of the diagram. <strong>The first destructor to execute would delete the memory that is shared between these two objects</strong>. <strong>The other object’s pointer would then point to memory that’s no longer allocated.</strong> This situation is called a <strong><span class="violet">dangling pointer</span></strong>, and typically would result in a serious runtime error (such as early program termination) if the program were to dereference that pointer—accessing deleted memory is undefined behavior.</p>&#13;
<h5 class="h5" id="ch11lev3sec44">Deep Copy</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <strong>In classes that manage their own resources, copying must be done carefully to avoid the pitfalls of shallow copy.</strong> Classes that manage their objects’ resources should define their own <strong>copy constructor</strong> and <strong>overloaded copy assignment operator</strong> to perform <strong><span class="violet">deep copies</span></strong>. The following diagram shows that after the object <code>x</code> is deep copied into the object <code>y</code>, both objects have their own copies of the dynamically allocated array containing <code>10</code>, <code>20</code> and <code>30</code>. Not providing a copy constructor and overloaded assignment operator for a class when objects of that class contain pointers to dynamically allocated memory is a potential logic error.</p>&#13;
<div class="image"><img src="Images/606fig02.jpg" alt="Images" width="606" height="199"/></div>&#13;
<h5 class="h5" id="ch11lev3sec45">Implementing the Copy Constructor</h5>&#13;
<p>Line 21 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p607pro01" id="p607pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">MyArray(<span class="blue">const</span> MyArray&amp; original); <span class="lgreen">// copy constructor</span></pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> declares the class’s <strong>copy constructor</strong> (defined lines 32–39). The copy constructor’s argument must be a <strong><code>const</code> reference</strong> to prevent the constructor from modifying the argument object’s data.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p607pro02" id="p607pro02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>31</strong></span>   <span class="lgreen">// copy constructor: must receive a reference to a MyArray</span>&#13;
<span class="cviolet"><strong>32</strong></span>   MyArray::MyArray<span class="blue">(const</span> MyArray&amp; original)&#13;
<span class="cviolet"><strong>33</strong></span>      : m_size{original.size()}, m_ptr{make_unique&lt;<span class="blue">int</span>[]&gt;(original.size())} {&#13;
<span class="cviolet"><strong>34</strong></span>      cout &lt;&lt; <span class="green">"MyArray copy constructor\n"</span>;&#13;
<span class="cviolet"><strong>35</strong></span>&#13;
<span class="cviolet"><strong>36</strong></span>      <span class="lgreen">// copy original's elements into m_ptr's underlying int array</span>&#13;
<span class="cviolet"><strong>37</strong></span>      <span class="blue">const</span> span&lt;<span class="blue">const int</span>&gt; source{original.m_ptr.get(), original.size()};&#13;
<span class="cviolet"><strong>38</strong></span>      <code>copy(begin(source), end(source), m_ptr.get());</code>&#13;
<span class="cviolet"><strong>39</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>40</strong></span></pre>&#13;
</div>&#13;
<p>When the <strong>copy constructor</strong> is called to initialize a new <code>MyArray</code> by copying an existing one, it performs the following tasks:</p>&#13;
<p class="bull">• Line 33 initializes the <code>m_size</code> member using the return value of <code>original</code>’s <code>size</code> member function.</p>&#13;
<p class="bull">• Line 33 initializes the <code>m_ptr</code> member to a <code>unique_ptr</code> returned by the standard library’s <code>make_unique</code> function template, which creates a dynamically allocated <code>int</code> array containing <code>original.size()</code> elements.</p>&#13;
<p class="bull">• Line 34 outputs that the <strong>copy constructor</strong> was called.</p>&#13;
<p class="bull">• Recall that a <code>span</code> is a view into a contiguous collection of items, such as an array. Line 37 creates a <strong><code>span</code></strong> named <code>source</code> representing the argument <code>MyArray</code>’s <strong>dynamically allocated <code>int</code> array</strong> from which we’ll copy elements.</p>&#13;
<p class="bull">• Line 38 uses the <strong><code>copy</code> algorithm</strong> to copy the elements in the range represented by the beginning and end of the <code>source span</code> into the <code>MyArray</code>’s underlying <code>int</code> array.</p>&#13;
<h5 class="h5" id="ch11lev3sec46">Copy Assignment Operator (<strong><code>=</code></strong>)</h5>&#13;
<p>Line 22 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p607pro03" id="p607pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">MyArray&amp; <span class="blue">operator</span>=(<span class="blue">const</span> MyArray&amp; right); <span class="lgreen">// copy assignment operator</span></pre>&#13;
<p>declares the class’s <strong>overloaded copy assignment operator (<code>=</code>)</strong>.<sup><a id="ch11fn19a" href="ch11.xhtml#ch11fn19">19</a></sup> This function’s definition (lines 42–47) enables one <code>MyArray</code> to be assigned to another, copying the contents from the right operand into the left. When the compiler sees the statement</p>&#13;
<p class="footnote"><a id="ch11fn19" href="ch11.xhtml#ch11fn19a">19</a>. This copy assignment operator ensures that the <code>MyArray</code> object is not modified and no memory resources are leaked if an exception occurs. This is known as a strong exception guarantee, which we discuss in <a href="ch12.xhtml#sec12_3">Section 12.3</a>.</p>&#13;
<pre class="pre">ints1 = ints2;</pre>&#13;
<p>it invokes member function <code>operator=</code> with the call</p>&#13;
<pre class="pre">ints1.<span class="blue">operator</span>=(ints2)</pre>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p608pro01" id="p608pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>41</strong></span>   <span class="lgreen">// copy assignment operator: implemented with copy-and-swap idiom</span>&#13;
<span class="cviolet"><strong>42</strong></span>   MyArray&amp; MyArray::operator=<span class="blue">(const</span> MyArray&amp; right) {&#13;
<span class="cviolet"><strong>43</strong></span>      cout &lt;&lt; <span class="green">"MyArray copy assignment operator\n"</span>;&#13;
<span class="cviolet"><strong>44</strong></span>      MyArray temp{right}; <span class="lgreen">// invoke copy constructor</span>&#13;
<span class="cviolet"><strong>45</strong></span>      swap(*<span class="blue">this</span>, temp); <span class="lgreen">// exchange contents of this object and temp</span>&#13;
<span class="cviolet"><strong>46</strong></span>      <span class="blue">return</span> *<span class="blue">this</span>;&#13;
<span class="cviolet"><strong>47</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>48</strong></span></pre>&#13;
</div>&#13;
<p>We could implement the <strong>overloaded copy assignment operator</strong> similarly to the <strong>copy constructor</strong>. However, there’s an elegant way to use the <strong>copy constructor</strong> to implement the <strong>overloaded copy assignment operator</strong>—the <strong><span class="violet">copy-and-swap idiom</span></strong>.<sup><a id="ch11fn20a" href="ch11.xhtml#ch11fn20">20</a>,<a id="ch11fn21a" href="ch11.xhtml#ch11fn21">21</a></sup> The idiom operates as follows:</p>&#13;
<p class="footnote"><a id="ch11fn20" href="ch11.xhtml#ch11fn20a">20</a>. Sutter, Herb. “Exception-Safe Class Design, Part 1: Copy Assignment.” Accessed February 25, 2021. <code><a href="http://www.gotw.ca/gotw/059.htm">http://www.gotw.ca/gotw/059.htm</a></code>.</p>&#13;
<p class="footnote"><a id="ch11fn21" href="ch11.xhtml#ch11fn21a">21</a>. “What is the copy-and-swap idiom?” Accessed February 25, 2021. <code><a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom</a></code>.</p>&#13;
<p class="bull">• First, it copies the argument <code>right</code> into a local <code>MyArray</code> object (<code>temp</code>) using the <strong>copy constructor</strong> (line 44). If this operation fails to allocate memory for <code>temp</code>’s array, a <strong><code>bad_alloc</code> exception</strong> will occur. In this case, the <strong>overloaded copy assignment operator</strong> will immediately terminate without modifying the object on the assignment’s left.</p>&#13;
<p class="bull">• Line 45 uses class <code>MyArray</code>’s <code>friend</code> function <code>swap</code> (defined in lines 165–168) to exchange the contents of <code>*this</code> (the object on the assignment’s left) with <code>temp</code>.</p>&#13;
<p class="bull">• Finally, the function returns a reference to the current object (<code>*this</code> in line 46), enabling cascaded <code>MyArray</code> assignments such as <code>x=y= z</code>.</p>&#13;
<p>When the function returns to its caller, the <code>temp</code> object’s <strong>destructor</strong> is called to <strong>release the memory</strong> managed by the <code>temp</code> object’s <code>unique_ptr</code>. Line 44’s copy constructor call and the destructor call when <code>temp</code> goes out of scope are the reason for the two additional lines of output you saw when we demonstrated assigning <code>ints2</code> to <code>ints1</code> in line 48 of <a href="ch11.xhtml#fig11_3">Fig. 11.3</a>.</p>&#13;
<h4 class="h4" id="sec11_6_7">11.6.7 Move Constructor and Move Assignment Operator</h4>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Often an object being copied is about to be destroyed, such as a local object returned from a function by value. It’s more efficient to move that object’s contents into the destination object to eliminate the copying overhead. That’s the purpose of the <strong>move constructor</strong> and <strong>move assignment operator</strong> declared in lines 24–25 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p608pro02" id="p608pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">MyArray(MyArray&amp;&amp; original) <span class="blue">noexcept</span>; <span class="lgreen">// move constructor</span>&#13;
MyArray&amp; <span class="blue">operator</span>=(MyArray&amp;&amp; right) <span class="blue">noexcept</span>; <span class="lgreen">// move assignment</span></pre>&#13;
<p>Each receives an <strong><em>rvalue</em> reference</strong> declared with <code>&amp;&amp;</code> to distinguish it from an <em>lvalue</em><strong/> reference <code>&amp;</code>. <strong><em>Rvalue</em> references</strong> help implement <strong>move semantics</strong>. Rather than copying the argument, the <strong>move constructor</strong> and <strong>move assignment operator</strong> each move their argument object’s data, leaving the original object in a state that can be destructed properly.</p>&#13;
<h5 class="h5" id="ch11lev3sec47"><code>noexcept</code> Specifier</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> As of C++11, if a function does not throw any exceptions <em>and</em> does not call any functions that throw exceptions, you should explicitly state that the function does not throw exceptions.<sup><a id="ch11fn22a" href="ch11.xhtml#ch11fn22">22</a></sup> Simply add <span class="violet"><strong><code>noexcept</code></strong></span> after the function’s signature in both the prototype and the definition. For a <code>const</code> member function, keyword <code>noexcept</code> must be placed after <code>const</code>. If a <code>noexcept</code> function calls another function that throws an exception and the <code>noexcept</code> function does not handle that exception, the program terminates immediately.</p>&#13;
<p class="footnote"><a id="ch11fn22" href="ch11.xhtml#ch11fn22a">22</a>. “F.6: If your function may not throw, declare it <code>noexcept</code>.” Accessed February 25, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-noexcept">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-noexcept</a></code>.</p>&#13;
<p>The <code>noexcept</code> specification can optionally be followed by parentheses containing a <code>bool</code> expression that evaluates to <code>true</code> or <code>false</code>. <code>noexcept</code> by itself is equivalent to <code>noexcept(true)</code>. Following a function’s signature with <code>noexcept(false)</code> indicates that the class’s designer has thought about whether the function might throw exceptions and has decided it might. In such cases, client code programmers can decide whether to wrap calls to the function in <code>try</code> statements.</p>&#13;
<h5 class="h5" id="ch11lev3sec48">Class <code>MyArray</code>’s Move Constructor</h5>&#13;
<p>The <strong>move constructor</strong> (lines 50–54) declares its parameter as an <strong><em>rvalue</em> reference (<code>&amp;&amp;</code>)</strong> to indicate that its <code>MyArray</code> argument must be a temporary object. The member initializer list moves members <code>m_size</code> and <code>m_ptr</code> from the argument into the object being constructed.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p609pro01" id="p609pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>49</strong></span>   <span class="lgreen">// move constructor: must receive an rvalue reference to a MyArray</span>&#13;
<span class="cviolet"><strong>50</strong></span>   MyArray::MyArray(MyArray&amp;&amp; original) <span class="blue">noexcept</span>&#13;
<span class="cviolet"><strong>51</strong></span>      : m_size{std::exchange(original.m_size, <span class="green">0</span>)},&#13;
<span class="cviolet"><strong>52</strong></span>        m_ptr{std::move(original.m_ptr)} { <span class="lgreen">// move original.m_ptr into m_ptr</span>&#13;
<span class="cviolet"><strong>53</strong></span>      cout &lt;&lt; <span class="green">"MyArray move constructor\n"</span>;&#13;
<span class="cviolet"><strong>54</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>55</strong></span></pre>&#13;
</div>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Recall from <a href="ch11.xhtml#sec11_6_2">Section 11.6.2</a> that the only valid operations on a moved-from object are assigning another object to it or destroying it. <strong>When moving resources from an object, it should be left in a state that allows it to be properly destructed. Also, it should no longer refer to the resources that were moved to the new object</strong>.<sup><a id="ch11fn23a" href="ch11.xhtml#ch11fn23">23</a></sup> To accomplish this for the <code>m_size</code> member, line 51</p>&#13;
<p class="footnote"><a id="ch11fn23" href="ch11.xhtml#ch11fn23a">23</a>. “C.64: A move operation should move and leave its source in a valid state.” Accessed February 26, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-semantic">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-semantic</a></code>.</p>&#13;
<p class="bull">• calls the standard library <span class="violet"><strong><code>exchange</code></strong></span> <strong><span class="violet">function</span></strong> (header <code>&lt;utility&gt;</code>), which sets its first argument (<code>original.m_size</code>) to its second argument’s value (<code>0</code>) and returns its first argument’s original value, then</p>&#13;
<p class="bull">• initializes the new object’s <code>m_size</code> data member with the value that exchange returns.</p>&#13;
<p>When a <code>unique_ptr</code> is <strong>move constructed</strong>, as in line 52, its <strong>move constructor</strong> transfers ownership of the source <code>unique_ptr</code>’s dynamic memory to the target <code>unique_ptr</code> and sets the source <code>unique_ptr</code> to <code>nullptr</code>.<sup><a id="ch11fn24a" href="ch11.xhtml#ch11fn24">24</a></sup> If your class manages raw pointers, you’d have to explicitly set the source pointer to <code>nullptr</code>—or use <code>exchange</code>, similar to line 51.</p>&#13;
<p class="footnote"><a id="ch11fn24" href="ch11.xhtml#ch11fn24a">24</a>. “<code>std::unique_ptr&lt;T,Deleter&gt;::unique_ptr</code>.” Accessed February 26, 2021. <code><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr">https://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr</a></code>.</p>&#13;
<h5 class="h5" id="ch11lev3sec49">Moving Does Not Move Anything</h5>&#13;
<p>Though we said the move constructor “moves the <code>m_size</code> and <code>m_ptr</code> members from the argument object into the object being constructed,” it does not actually move anything:<sup><a id="ch11fn25a" href="ch11.xhtml#ch11fn25">25</a></sup></p>&#13;
<p class="footnote"><a id="ch11fn25" href="ch11.xhtml#ch11fn25a">25</a>. Topher Winward, “C++ moves for people who don’t know or care what rvalues are,” January 17, 2019. Accessed March 3, 2021. <code><a href="https://medium.com/@winwardo/c-moves-for-people-whodont-know-or-care-what-rvalues-are-%EF%B8%8F-56ee122dda7">https://medium.com/@winwardo/c-moves-for-people-whodont-know-or-care-what-rvalues-are-%EF%B8%8F-56ee122dda7</a></code>.</p>&#13;
<p class="bull">• For fundamental types like <code>size_t</code>, which is simply an unsigned integer, <strong>the value is copied</strong> from the source object’s member to the new object’s member.</p>&#13;
<p class="bull">• For a raw pointer, the address stored in the source object’s pointer is copied to the new object’s pointer.</p>&#13;
<p class="bull">• For an object, the object’s move constructor is called. A <code>unique_ptr</code>’s move constructor <strong>transfers ownership</strong> of the dynamic memory by copying the dynamically allocated memory’s address from the source <code>unique_ptr</code>’s underlying raw pointer into the new object’s underlying raw pointer, then assigning <code>nullptr</code> to the source <code>unique_ptr</code> to indicate it no longer manages any data.</p>&#13;
<p>The diagram below shows the concept of moving a source object <code>x</code> with a raw pointer member into a new object <code>y</code>. Note that both members of <code>x</code> are <code>0</code> after the move—0 in a pointer member represents a null pointer.</p>&#13;
<div class="image"><img src="Images/610fig01.jpg" alt="Images" width="574" height="198"/></div>&#13;
<h5 class="h5" id="ch11lev3sec50">Class <code>MyArray</code>’s Move Assignment Operator (<strong><code>=</code></strong>)</h5>&#13;
<p>The <strong>move assignment operator (<code>=</code>)</strong> (lines 57–67) defines an <strong><em>rvalue</em> reference (<code>&amp;&amp;</code>)</strong> parameter to indicate that its <code>MyArray</code> argument’s resources should be moved (not copied). Line 60 tests for <strong><span class="violet">self-assignment</span></strong> in which a <code>MyArray</code> object is being <strong>assigned to itself</strong>.<sup><a id="ch11fn26a" href="ch11.xhtml#ch11fn26">26</a></sup> When <code>this</code> is equal to the <code>right</code> operand’s address, the same object is on both sides of the assignment, so there’s no need to move anything.</p>&#13;
<p class="footnote"><a id="ch11fn26" href="ch11.xhtml#ch11fn26a">26</a>. “C.65: Make move assignment safe for self-assignment.” Accessed March 3, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-self">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-self</a></code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p611pro01" id="p611pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>56</strong></span>   <span class="lgreen">// move assignment operator</span>&#13;
<span class="cviolet"><strong>57</strong></span>   MyArray&amp; MyArray::operator=(MyArray&amp;&amp; right) <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>58</strong></span>      cout &lt;&lt; <span class="green">"MyArray move assignment operator\n"</span>;&#13;
<span class="cviolet"><strong>59</strong></span>&#13;
<span class="cviolet"><strong>60</strong></span>      <span class="blue">if</span> (<span class="blue">this</span> != &amp;right) { <span class="lgreen">// avoid self-assignment</span>&#13;
<span class="cviolet"><strong>61</strong></span>         <span class="lgreen">// move right's data into this MyArray</span>&#13;
<span class="cviolet"><strong>62</strong></span>         m_size = std::exchange(right.m_size, <span class="green">0</span>); <span class="lgreen">// indicate right is empty</span>&#13;
<span class="cviolet"><strong>63</strong></span>         <code>m_ptr = std::move(right.m_ptr);</code>&#13;
<span class="cviolet"><strong>64</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>65</strong></span>&#13;
<span class="cviolet"><strong>66</strong></span>      <span class="blue">return</span> *<span class="blue">this</span>; <span class="lgreen">// enables x = y = z, for example</span>&#13;
<span class="cviolet"><strong>67</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>68</strong></span></pre>&#13;
</div>&#13;
<p>If it is not a <strong>self-assignment</strong>, lines 62–63:</p>&#13;
<p class="bull">• move <code>right.m_size</code> into the target <code>MyArray</code>’s <code>m_size</code> by calling <code>exchange</code>—this sets <code>right.m_size</code> to <code>0</code> and returns its original value, which we use to set the target <code>MyArray</code>’s <code>m_size</code> member, and</p>&#13;
<p class="bull">• move <code>right.m_ptr</code> into the target <code>MyArray</code>’s <code>m_ptr</code>.</p>&#13;
<p>As in the <strong>move constructor</strong>, when a <code>unique_ptr</code> is <strong>move assigned</strong>, ownership of its dynamic memory transfers to the new <code>unique_ptr</code>, and the <strong>move assignment operator</strong> sets the original <code>unique_ptr</code> to <code>nullptr</code>. Regardless of whether this is a self-assignment, the member function returns the current object (<code>*this</code>), which enables cascaded <code>MyArray</code> assignments such as <code>x=y=</code> z.</p>&#13;
<h5 class="h5" id="ch11lev3sec51"><span class="size">11</span> Move Operations Should Be <code>noexcept</code></h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <strong>Move constructors and move assignment operators should never throw exceptions</strong>. They do not acquire any new resources—they simply <em>move</em> existing ones. For this reason, the C++ Core Guidelines recommend declaring <strong>move constructors</strong> and <strong>move assignment operators</strong> <code>noexcept</code>.<sup><a id="ch11fn27a" href="ch11.xhtml#ch11fn27">27</a></sup> This also is a requirement to be able to use your class’s move capabilities with the standard library’s containers like <code>vector</code>.</p>&#13;
<p class="footnote"><a id="ch11fn27" href="ch11.xhtml#ch11fn27a">27</a>. “C.66: Make move operations <code>noexcept</code>.” Accessed February 25, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-noexcept">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-noexcept</a></code>.</p>&#13;
<h4 class="h4" id="sec11_6_8">11.6.8 Destructor</h4>&#13;
<p>Line 27 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<pre class="pre">~MyArray(); <span class="lgreen">// destructor</span></pre>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> declares the class’s <strong>destructor</strong> (defined in lines 71–73), which is invoked when a <code>MyArray</code> object goes out of scope. This will automatically call <code>m_ptr</code>’s destructor, which will <strong>release the dynamically allocated <code>int</code> array created when the <code>MyArray</code> object was constructed</strong>. <strong>The C++ Core Guidelines indicate that it’s poor design if destructors throw exceptions. For this reason, they recommend declaring destructors <code>noexcept</code></strong>.<sup><a id="ch11fn28a" href="ch11.xhtml#ch11fn28">28</a></sup> However, unless your class is derived from a base class with a destructor that’s declared <code>noexcept(false)</code>, the compiler implicitly declares the destructor <code>noexcept</code> by default.</p>&#13;
<p class="footnote"><a id="ch11fn28" href="ch11.xhtml#ch11fn28a">28</a>. “C.37: Make destructors <code>noexcept</code>.” Accessed February 25, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-noexcept">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-noexcept</a></code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p612pro01" id="p612pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>69</strong></span>   <span class="lgreen">// destructor: This could be compiler-generated. We included it here so</span>&#13;
<span class="cviolet"><strong>70</strong></span>   <span class="lgreen">// we could output when each MyArray is destroyed.</span>&#13;
<span class="cviolet"><strong>71</strong></span>   <code>MyArray::~MyArray() {</code>&#13;
<span class="cviolet"><strong>72</strong></span>      cout &lt;&lt; <span class="green">"MyArray destructor\n"</span>;&#13;
<span class="cviolet"><strong>73</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>74</strong></span></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec11_6_9">11.6.9 <code>toString</code> and <code>size</code> Functions</h4>&#13;
<p>Line 29 in <a href="ch11.xhtml#fig11_4">Fig. 11.4</a>:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p612pro02" id="p612pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">size_t</span> size() <span class="blue">const</span> <span class="blue">noexcept</span> {<span class="blue">return</span> m_size;}; <span class="lgreen">// return size</span></pre>&#13;
<p>defines an inline <code>size</code> member function, which returns a <code>MyArray</code>’s number of elements.</p>&#13;
<p>Line 30 in <a href="ch11.xhtml#fig11_4">Fig. 11.4</a>:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p612pro03" id="p612pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">std::string toString() <span class="blue">const</span>; <span class="lgreen">// create string representation</span></pre>&#13;
<p>declares a <code>toString</code> member function (defined in lines 76–89), which returns the <code>string</code> representation of a <code>MyArray</code>’s contents. Function <code>toString</code> uses an <code>ostringstream</code> (introduced in <a href="ch08.xhtml#ch08lev1sec17">Section 8.17</a>) to build a <code>string</code> containing the <code>MyArray</code>’s element values enclosed in braces (<code>{}</code>) and separating each <code>int</code> from the next by a comma and a space.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p612pro04" id="p612pro04a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>75</strong></span>   <span class="lgreen">// return a string representation of a MyArray</span>&#13;
<span class="cviolet"><strong>76</strong></span>   string MyArray::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>77</strong></span>      <span class="blue">const</span> span&lt;<span class="blue">const int</span>&gt; items{m_ptr.get(), m_size};&#13;
<span class="cviolet"><strong>78</strong></span>      <code>ostringstream output;</code>&#13;
<span class="cviolet"><strong>79</strong></span>      output &lt;&lt; <span class="green">"{"</span>;&#13;
<span class="cviolet"><strong>80</strong></span>&#13;
<span class="cviolet"><strong>81</strong></span>      <span class="lgreen">// insert each item in the dynamic array into the ostringstream</span>&#13;
<span class="cviolet"><strong>82</strong></span>      <span class="blue">for</span> (<span class="blue">size_t</span> count{<span class="green">0</span>}; <span class="blue">const auto</span>&amp; item : items) {&#13;
<span class="cviolet"><strong>83</strong></span>         <code>++count;</code>&#13;
<span class="cviolet"><strong>84</strong></span>         output &lt;&lt; item &lt;&lt; (count &lt; m_size ? <span class="green">", "</span> : <span class="green">""</span>);&#13;
<span class="cviolet"><strong>85</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>86</strong></span>&#13;
<span class="cviolet"><strong>87</strong></span>      output &lt;&lt; <span class="green">"}"</span>;&#13;
<span class="cviolet"><strong>88</strong></span>      <span class="blue">return</span> output.str();&#13;
<span class="cviolet"><strong>89</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>90</strong></span></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec11_6_10">11.6.10 Overloading the Equality (<code>==</code>) and Inequality (<code>!=</code>) Operators</h4>&#13;
<p>Line 33 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a>:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p612pro05" id="p612pro05a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">bool</span> <span class="blue">operator</span>==(<span class="blue">const</span> MyArray&amp; right) <span class="blue">const noexcept</span>;</pre>&#13;
<p>declares the <strong>overloaded equality operator (<code>==</code>)</strong>. Comparisons should not throw exceptions, so they should be declared <code>noexcept</code>.<sup><a id="ch11fn29a" href="ch11.xhtml#ch11fn29">29</a></sup></p>&#13;
<p class="footnote"><a id="ch11fn29" href="ch11.xhtml#ch11fn29a">29</a>. “C.86: Make == symmetric with respect of operand types and noexcept.” Accessed February 25, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-eq">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-eq</a></code>.</p>&#13;
<p>When the compiler sees an expression like <code>ints1 == ints2</code>, it invokes this overloaded operator with the call</p>&#13;
<pre class="pre">ints1.<span class="blue">operator</span>==(ints2)</pre>&#13;
<p><strong>Member function <code>operator==</code></strong> (defined in lines 93–102) operates as follows:</p>&#13;
<p class="bull">• Line 95 creates the <code>span lhs</code> representing the dynamically allocated <code>int</code> array in the left-hand-side operand (<code>ints1</code>).</p>&#13;
<p class="bull">• Line 96 creates the <code>span rhs</code> representing the dynamically allocated <code>int</code> array in the right-hand-side operand (<code>ints2</code>).</p>&#13;
<p class="bull">• Line 97 uses the standard library algorithm <span class="violet"><strong><code>equal</code></strong></span> (from header <span class="violet"><strong><code>&lt;algorithm&gt;</code></strong></span>) to compare corresponding elements from each <code>span</code>s. The first two arguments specify the <code>lhs</code> object’s range of elements. The last two specify the <code>rhs</code> object’s range of elements. If the <code>lhs</code> and <code>rhs</code> objects have different lengths or if any pair of corresponding elements differ, <code>equal</code> returns <code>false</code>. If every pair of elements is equal, <code>equal</code> returns <code>true</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p613pro01" id="p613pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>91</strong></span>   <span class="lgreen">// determine if two MyArrays are equal and</span>&#13;
<span class="cviolet"><strong>92</strong></span>   <span class="lgreen">// return true, otherwise return false</span>&#13;
<span class="cviolet"><strong>93</strong></span>   <span class="blue">bool</span> MyArray::operator==(<span class="blue">const</span> MyArray&amp; right) <span class="blue">const noexcept</span> {&#13;
<span class="cviolet"><strong>94</strong></span>      <span class="lgreen">// compare corresponding elements of both MyArrays</span>&#13;
<span class="cviolet"><strong>95</strong></span>      <span class="blue">const</span> span&lt;<span class="blue">const int</span>&gt; lhs{m_ptr.get(), size()};&#13;
<span class="cviolet"><strong>96</strong></span>      <span class="blue">const</span> span&lt;<span class="blue">const int</span>&gt; rhs{right.m_ptr.get(), right.size()};&#13;
<span class="cviolet"><strong>97</strong></span>      <span class="blue">return</span> equal(begin(lhs), end(lhs), begin(rhs), end(rhs));&#13;
<span class="cviolet"><strong>98</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>99</strong></span></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec52">Complier Generates the <code>!=</code> Operator</h5>&#13;
<p><span class="size">20</span> As of C++20, <strong>the compiler autogenerates a <code>!=</code> operator function for you if you provide the <code>==</code> operator for your type</strong>. Prior to C++20, if your class required a custom <strong>overloaded inequality operator (</strong><code>!=</code>) operator, you’d define <code>!=</code> to call the <code>==</code> operator function and return the opposite result.</p>&#13;
<h5 class="h5" id="ch11lev3sec53">Defining Comparison Operators as Non-Member Functions</h5>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> Each class we’ve defined so far, including <code>MyArray</code>, declared its single-argument constructor(s) <code>explicit</code> to prevent implicit conversions, as recommended by the C++ Core Guide-line “C.164: Avoid implicit conversion operators.”<sup><a id="ch11fn30a" href="ch11.xhtml#ch11fn30">30</a></sup> You may also come across the C++ Core Guideline “C.86: Make <code>==</code> symmetric with respect to operand types and <code>noexcept</code>,”<sup><a id="ch11fn31a" href="ch11.xhtml#ch11fn31">31</a></sup> which recommends making comparison operators non-member functions <strong>if your class supports implicitly converting objects of other types to your class’s type, or vice versa</strong>. This guideline applies to all comparison operators, but we’ll discuss <code>==</code> here, as it’s the only comparison operator defined in our <code>MyArray</code> class.</p>&#13;
<p class="footnote"><a id="ch11fn30" href="ch11.xhtml#ch11fn30a">30</a>. “C.164: Avoid implicit conversion operators,” Accessed April 9, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion</a></code>.</p>&#13;
<p class="footnote"><a id="ch11fn31" href="ch11.xhtml#ch11fn31a">31</a>. “C.86: Make <code>==</code> symmetric with respect to operand types and <code>noexcept</code>.” Accessed April 9, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-eq">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-eq</a></code>.</p>&#13;
<p>Assume <code>ints</code> is a <code>MyArray</code> and <code>other</code> is an object of class <code>OtherType</code>, which is <strong>implicitly convertible to a <code>MyArray</code></strong>. To satisfy Core Guideline C.86, we’d define <code>operator==</code> as a non-member function with the prototype:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p614pro01" id="p614pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">bool</span> operator==(<span class="blue">const</span> MyArray&amp; left, <span class="blue">const</span> MyArray&amp; right) <span class="blue">noexcept</span>;</pre>&#13;
<p>This would allow the following mixed-type expressions:</p>&#13;
<pre class="pre">ints == other</pre>&#13;
<p>or</p>&#13;
<pre class="pre">other == ints</pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> There is no <code>operator==</code> definition that provides parameters exactly matching operands of types <code>MyArray</code> and <code>OtherType</code> or <code>OtherType</code> and <code>MyArray</code>. However, <strong>C++ allows one user-defined conversion per expression</strong>. So, if <code>OtherType</code> objects can be implicitly converted to <code>MyArray</code> objects, the compiler will convert <code>other</code> to a <code>MyArray</code>, then call the <code>operator==</code> that receives two <code>MyArray</code>s.</p>&#13;
<p>C++ follows a complex set of overload-resolution rules to determine which function to call for each operator expression.<sup><a id="ch11fn32a" href="ch11.xhtml#ch11fn32">32</a></sup> If <code>operator==</code> is a <code>MyArray</code> member function, <strong>the <em>left</em> operand must be a <code>MyArray</code></strong>. C++ will not implicitly convert <code>other</code> to a <code>MyArray</code> to call the member function, so the expression</p>&#13;
<p class="footnote"><a id="ch11fn32" href="ch11.xhtml#ch11fn32a">32</a>. “Overload resolution.” Accessed April 10, 2021. <code><a href="https://en.cppreference.com/w/cpp/language/overload_resolution">https://en.cppreference.com/w/cpp/language/overload_resolution</a></code>.</p>&#13;
<pre class="pre">other == ints</pre>&#13;
<p>with an <code>OtherType</code> object on the left causes a compilation error. This might confuse programmers who’d expect this expression to compile, which is why Core Guideline C.86 recommends using a non-member <code>operator==</code> function.</p>&#13;
<h4 class="h4" id="sec11_6_11">11.6.11 Overloading the Subscript (<code>[]</code>) Operator</h4>&#13;
<p>Lines 36 and 39 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p614pro02" id="p614pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span>&amp; <span class="blue">operator</span>[](<span class="blue">size_t</span> index);&#13;
<span class="blue">int</span> <span class="blue">operator</span>[](<span class="blue">size_t</span> index) <span class="blue">const</span>;</pre>&#13;
<p>declare <strong>overloaded subscript operators</strong> (defined in lines 102–109 and 113–120). When the compiler sees an expression like <code>ints1[5]</code>, it invokes the appropriate <strong>overloaded <code>operator[]</code> member function</strong> by generating the call</p>&#13;
<pre class="pre">ints1.<span class="blue">operator</span>[](<span class="green">5</span>)</pre>&#13;
<p>The compiler calls the <code>const</code> version of <strong><code>operator[]</code></strong> (lines 113–120) when the <strong>subscript operator</strong> is used on a <code>const MyArray</code> object. For example, if you pass a <code>MyArray</code> to a function that receives the <code>MyArray</code> as a <code>const MyArray&amp;</code> named <code>z</code>, then the <strong><code>const</code> version of <code>operator[]</code></strong> is required to execute a statement such as</p>&#13;
<pre class="pre">cout &lt;&lt; z[<span class="green">3</span>];</pre>&#13;
<p>Remember that when an object is <code>const</code>, a program can invoke only the object’s <code>const</code> member functions.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p615pro01" id="p615pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>100</strong></span>   <span class="lgreen">// overloaded subscript operator for non-const MyArrays;</span>&#13;
<span class="cviolet"><strong>101</strong></span>   <span class="lgreen">// reference return creates a modifiable lvalue</span>&#13;
<span class="cviolet"><strong>102</strong></span>   <span class="blue">in</span>t&amp; MyArray::operator[]<span class="blue">(size_t</span> index) {&#13;
<span class="cviolet"><strong>103</strong></span>      <span class="lgreen">// check for index out-of-range error</span>&#13;
<span class="cviolet"><strong>104</strong></span>      <span class="blue">if</span> (index &gt;= m_size) {&#13;
<span class="cviolet"><strong>105</strong></span>         <span class="blue">throw</span> out_of_range{<span class="green">"Index out of range"</span>};&#13;
<span class="cviolet"><strong>106</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>107</strong></span>&#13;
<span class="cviolet"><strong>108</strong></span>      <span class="blue">return</span> m_ptr[index]; <span class="lgreen">// reference return</span>&#13;
<span class="cviolet"><strong>109</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>110</strong></span>&#13;
<span class="cviolet"><strong>111</strong></span>   <span class="lgreen">// overloaded subscript operator for const MyArrays</span>&#13;
<span class="cviolet"><strong>112</strong></span>   <span class="lgreen">// const reference return creates a non-modifiable lvalue</span>&#13;
<span class="cviolet"><strong>113</strong></span>   <span class="blue">const in</span>t&amp; MyArray::operator[]<span class="blue">(size_t</span> index) <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>114</strong></span>      <span class="lgreen">// check for subscript out-of-range error</span>&#13;
<span class="cviolet"><strong>115</strong></span>      <span class="blue">if</span> (index &gt;= m_size) {&#13;
<span class="cviolet"><strong>116</strong></span>         <span class="blue">throw</span> out_of_range{<span class="green">"Index out of range"</span>};&#13;
<span class="cviolet"><strong>117</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>118</strong></span>&#13;
<span class="cviolet"><strong>119</strong></span>      <span class="blue">return</span> m_ptr[index]; <span class="lgreen">// returns copy of this element</span>&#13;
<span class="cviolet"><strong>120</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>121</strong></span></pre>&#13;
</div>&#13;
<p>Each <strong><code>operator[]</code></strong> definition determines whether argument <code>index</code> is in range. If not, it throws an <strong><code>out_of_range</code> exception</strong> (header <code>&lt;stdexcept&gt;</code>). If <code>index</code> is in range, the <strong>non-<code>const</code> version of <code>operator[]</code></strong> returns the appropriate <code>MyArray</code> element as a reference. This may be used as a modifiable <em>lvalue</em> on an assignment’s left side to modify an array element. The <strong><code>const</code> version of <code>operator[]</code></strong> returns a <code>const</code> reference to the appropriate array element.</p>&#13;
<p>The subscript operators used in lines 108 and 119 belong to class <code>unique_ptr</code>. When a <code>unique_ptr</code> manages a dynamically allocated array, <code>unique_ptr</code>’s overloaded <code>[]</code> operator enables you to access the array’s elements.</p>&#13;
<h4 class="h4" id="sec11_6_12">11.6.12 Overloading the Unary <code>bool</code> Conversion Operator</h4>&#13;
<p>You can define your own <strong><span class="violet">conversion operators</span></strong> for converting between types—these are also called <strong><span class="violet">overloaded cast operators</span></strong>. Line 42 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p615pro02" id="p615pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">explicit operator</span> <span class="blue">bool</span>() <span class="blue">const noexcept</span> {<span class="blue">return</span> size() != <span class="green">0</span>;}</pre>&#13;
<p>defines an <strong>inline</strong> overloaded <code>operator bool</code> that converts a <code>MyArray</code> object to the <code>bool</code> value <code>true</code> if the <code>MyArray</code> is not empty or <code>false</code> if it is. Like single-argument constructors, we declared this operator explicit to prevent the compiler from using it for implicit conversions (we say more about this in <a href="ch11.xhtml#sec11_9">Section 11.9</a>). <strong>Overloaded conversion operators do not specify a return type to the left of the <code>operator</code> keyword. The return type is the conversion operator’s type—<code>bool</code> in this case</strong>.</p>&#13;
<p>In <a href="ch11.xhtml#fig11_3">Fig. 11.3</a>, line 99 used the <code>MyArray ints5</code> as an <code>if</code> statement’s condition to determine whether it contained elements. In that case, <strong>C++ called this <code>operator bool</code> function to perform a contextual conversion of the <code>ints5</code> object to a <code>bool</code> value for use as a condition</strong>. You also may call this function explicitly using an expression like:</p>&#13;
<pre class="pre"><span class="blue">static_cast</span>&lt;<span class="blue">bool</span>&gt;(ints5)</pre>&#13;
<p>We say more about converting between types in <a href="ch11.xhtml#sec11_8">Section 11.8</a>.</p>&#13;
<h4 class="h4" id="sec11_6_13">11.6.13 Overloading the Preincrement Operator</h4>&#13;
<p>You can overload the prefix and postfix increment and decrement operators. The concepts we show here and in <a href="ch11.xhtml#sec11_6_14">Section 11.6.14</a> for <code>++</code> also apply to the <code>--</code> operators. <a href="ch11.xhtml#sec11_6_14">Section 11.6.14</a> shows how the compiler distinguishes between the prefix and postfix versions.</p>&#13;
<p>Line 45 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<pre class="pre">MyArray&amp; operator++();</pre>&#13;
<p>declares <code>MyArray</code>’s unary <strong>overloaded preincrement operator (<code>++</code>)</strong>. When the compiler sees an expression like ++<code>ints4</code>, it invokes <code>MyArray</code>’s overloaded preincrement operator (<code>++</code>) function by generating the call</p>&#13;
<pre class="pre">ints4.<span class="blue">operator</span>++()</pre>&#13;
<p>This invokes the function’s definition (lines 123–128), which adds one to each element by:</p>&#13;
<p class="bull">• creating the <code>span items</code> to represent the dynamically allocated <code>int</code> array, then</p>&#13;
<p class="bull">• using the standard library’s <span class="violet"><strong><code>for_each</code></strong></span> algorithm to call a function that performs a task once for each element of the <code>span</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p616pro01" id="p616pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>122</strong></span>   <span class="lgreen">// preincrement every element, then return updated MyArray</span>&#13;
<span class="cviolet"><strong>123</strong></span>   <code>MyArray&amp; MyArray::operator++() {</code>&#13;
<span class="cviolet"><strong>124</strong></span>      <span class="lgreen">// use a span and for_each to increment every element</span>&#13;
<span class="cviolet"><strong>125</strong></span>      <span class="blue">const</span> span&lt;<span class="blue">int</span>&gt; items{m_ptr.get(), m_size};&#13;
<span class="cviolet"><strong>126</strong></span>      for_each(begin(items), end(items), [](<span class="blue">auto</span>&amp; item){++item;});&#13;
<span class="cviolet"><strong>127</strong></span>      <span class="blue">return</span> *<span class="blue">this</span>;&#13;
<span class="cviolet"><strong>128</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>129</strong></span></pre>&#13;
</div>&#13;
<p>Like the <code>copy</code> algorithm, <code>for_each</code>’s first two arguments represent the range of elements to process. The third argument is a function that receives one argument and performs a task with it. In this case, we specify a <strong>lambda expression</strong> that is called once for each element in the range. As <code>for_each</code> iterates internally through the <code>span</code>’s elements, it passes the current element as the lambda’s argument (<code>item</code>). The lambda then performs a task using that value. This lambda’s argument is a non-<code>const</code> reference (<code>auto&amp;</code>), so the expression <code>++item</code> in the lambda’s body modifies the original element in the <code>MyArray</code>.</p>&#13;
<p>The operator returns a reference to the <code>MyArray</code> object it just incremented. This enables a preincremented <code>MyArray</code> object to be used as an <em>lvalue</em>, which is how the builtin prefix increment operator works for fundamental types.</p>&#13;
<h4 class="h4" id="sec11_6_14">11.6.14 Overloading the Postincrement Operator</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Overloading the postfix increment operator presents a challenge. The compiler must be able to distinguish between the signatures of the overloaded prefix and postfix increment operator functions. By convention, when the compiler sees a postincrement expression like <code>ints4++</code>, it generates the member-function call</p>&#13;
<pre class="pre">ints4.<span class="blue">operator</span>++(<span class="green">0</span>)</pre>&#13;
<p>The argument <code>0</code> is strictly a <strong>dummy value</strong> that the compiler uses to distinguish between the prefix and postfix increment operator functions. The same syntax is used to differentiate between the prefix and postfix decrement operator functions.</p>&#13;
<p>Line 48 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a>:</p>&#13;
<pre class="pre"> MyArray operator++(i<span class="blue">nt)</span>;</pre>&#13;
<p>declares <code>MyArray</code>’s unary <strong>overloaded postincrement operator (<code>++</code>)</strong> with the <code>int</code> parameter that receives the dummy value <code>0</code>. The parameter is not used, so it’s declared without a parameter name. To emulate the effect of the postincrement, we must return an <strong>unincremented copy</strong> of the <code>MyArray</code> object. So, the function’s definition (lines 131–135):</p>&#13;
<p class="bull">• uses the <code>MyArray</code> <strong>copy constructor</strong> to make a local copy of the original <code>MyArray</code>,</p>&#13;
<p class="bull">• calls the preincrement operator to add one to every element of the <code>MyArray</code><sup><a id="ch11fn33a" href="ch11.xhtml#ch11fn33">33</a></sup>, then</p>&#13;
<p class="footnote"><a id="ch11fn33" href="ch11.xhtml#ch11fn33a">33</a>. Herb Sutter, “GotW #2 Solution: Temporary Objects,” May 13, 2013. Accessed February 26, 2021. <code><a href="https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/">https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/</a></code>.</p>&#13;
<p class="bull">• <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> returns the unincremented local copy of the <code>MyArray</code> <em>by value</em>—this is another case in which compilers can use the <strong>named return value optimization (NRVO)</strong>.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> The extra local object created by the postfix increment (or decrement) operator can result in a performance problem, especially if the operator is used in a loop. For this reason, you should <strong>prefer the prefix increment and decrement operators.</strong></p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p617pro01" id="p617pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>130</strong></span>   <span class="lgreen">// postincrement every element, and return copy of original MyArray</span>&#13;
<span class="cviolet"><strong>131</strong></span>   MyArray MyArray::operator++<span class="blue">(in</span>t) {&#13;
<span class="cviolet"><strong>132</strong></span>      MyArray temp(*<span class="blue">this</span>);&#13;
<span class="cviolet"><strong>133</strong></span>      ++(*<span class="blue">this</span>); <span class="lgreen">// call preincrement operator++ to do the incrementing</span>&#13;
<span class="cviolet"><strong>134</strong></span>      <span class="blue">return</span> temp; <span class="lgreen">// return the temporary copy made before incrementing</span>&#13;
<span class="cviolet"><strong>135</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>136</strong></span></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec11_6_15">11.6.15 Overloading the Addition Assignment Operator (<code>+=</code>)</h4>&#13;
<p>Line 51 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p617pro02" id="p617pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">MyArray&amp; operator+=(<span class="blue">int</span> value);</pre>&#13;
<p>declares <code>MyArray</code>’s <strong>overloaded addition assignment operator (<code>+=</code>)</strong>, which adds a value to every element of a <code>MyArray</code>, then <strong>returns a reference to the modified object</strong> to enable cascaded calls. Like the preincrement operator, we use a <code>span</code> and the standard library function <code>for_each</code> to process every element in the <code>MyArray</code>. In this case, the lambda we pass as <code>for_each</code>’s last argument (line 142) uses the <code>operator+=</code> function’s <code>value</code> parameter in its body. The <strong>lambda introducer</strong> <code>[value]</code> specifies that the compiler should allow <code>value</code> to be used in the lambda’s body—this is known as <strong><span class="violet">capturing</span></strong> the variable. We’ll say more about capturing lambdas in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p617pro03" id="p617pro03a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>137</strong></span>   <span class="lgreen">// add value to every element, then return updated MyArray</span>&#13;
<span class="cviolet"><strong>138</strong></span>   MyArray&amp; MyArray::operator+=<span class="blue">(int</span> value) {&#13;
<span class="cviolet"><strong>139</strong></span>      <span class="lgreen">// use a span and for_each to increment every element</span>&#13;
<span class="cviolet"><strong>140</strong></span>      <span class="blue">const</span> span&lt;<span class="blue">int</span>&gt; items{m_ptr.get(), m_size};&#13;
<span class="cviolet"><strong>141</strong></span>      <span class="blue">for_each</span>(begin(items), end(items),&#13;
<span class="cviolet"><strong>142</strong></span>         [value](aut<span class="blue">o&amp; i</span>tem) {item += value;});&#13;
<span class="cviolet"><strong>143</strong></span>      <span class="blue">return</span> *<span class="blue">this</span>;&#13;
<span class="cviolet"><strong>144</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>145</strong></span></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec11_6_16">11.6.16 Overloading the Binary Stream Extraction (<code>&gt;&gt;</code>) and Stream Insertion (<code>&lt;&lt;</code>) Operators</h4>&#13;
<p>You can input and output fundamental-type data using the <strong>stream extraction operator (<code>&gt;&gt;</code>)</strong> and the <strong>stream insertion operator (<code>&lt;&lt;</code>)</strong>. The C++ standard library overloads these operators for each fundamental type, including pointers and <code>char*</code> strings. You also can overload these to perform input and output for custom types.</p>&#13;
<p>Line 10 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p618pro01" id="p618pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">friend</span> std::istream&amp; operator&gt;&gt;(std::istream&amp; in, MyArray&amp; a);</pre>&#13;
<p>and line 58 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p618pro02" id="p618pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, <span class="blue">const</span> MyArray&amp; a);</pre>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> declare the non-member <strong>overloaded stream-extraction operator (<code>&gt;&gt;</code>)</strong> and <strong>overloaded stream-insertion operator (<code>&lt;&lt;</code>)</strong>. We declared <strong><code>operator&gt;&gt;</code></strong> in the class as a <code>friend</code> because it will access a <code>MyArray</code>’s <code>private</code> data directly for performance. The <strong><code>operator&lt;&lt;</code></strong> is not declared as a <code>friend</code>. As you’ll see, it calls <code>MyArray</code>’s <code>toString</code> member function to get a <code>MyArray</code>’s <code>string</code> representation then outputs it.</p>&#13;
<h5 class="h5" id="ch11lev3sec54">Implementing the Stream Extraction Operator</h5>&#13;
<p>The <strong>overloaded stream-extraction operator (<code>&gt;&gt;</code>)</strong> (lines 147–156) takes as arguments an <code>istream</code> reference and a <code>MyArray</code> reference. It returns the <code>istream</code> reference argument to enable <strong>cascaded inputs</strong>, like</p>&#13;
<pre class="pre">cin &gt;&gt; ints1 &gt;&gt; ints2;</pre>&#13;
<p>When the compiler sees an expression like <code>cin &gt;&gt; ints1</code>, it invokes <strong>non-member function <code>operator&gt;&gt;</code></strong> with the call</p>&#13;
<pre class="pre"><span class="blue">operator</span>&gt;&gt;(cin, ints1)</pre>&#13;
<p>We’ll say why this needs to be a <strong>non-member function</strong> momentarily. When this call completes, it returns a reference to <code>cin</code>, which would then be used in the <code>cin</code> statement above to input values into <code>ints2</code>. The function creates a <code>span</code> (line 149) representing <code>MyArray</code>’s dynamically allocated <code>int</code> array. Then lines 151–153 iterate through the <code>span</code>’s elements, reading one value at a time from the input stream and placing the value in the corresponding element of the dynamically allocated <code>int</code> array.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p618pro03" id="p618pro03a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>146</strong></span>   <span class="lgreen">// overloaded input operator for class MyArray;</span>&#13;
<span class="cviolet"><strong>147</strong></span>   <span class="lgreen">// inputs values for entire MyArray</span>&#13;
<span class="cviolet"><strong>148</strong></span>   <code>istream&amp; operator&gt;&gt;(istream&amp; in, MyArray&amp; a) {</code>&#13;
<span class="cviolet"><strong>149</strong></span>      span&lt;<span class="blue">int</span>&gt; items{a.m_ptr.get(), a.m_size};&#13;
<span class="cviolet"><strong>150</strong></span>&#13;
<span class="cviolet"><strong>151</strong></span>      <span class="blue">for</span> (<span class="blue">auto</span>&amp; item : items) {&#13;
<span class="cviolet"><strong>152</strong></span>         <code>in &gt;&gt; item;</code>&#13;
<span class="cviolet"><strong>153</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>154</strong></span>&#13;
<span class="cviolet"><strong>155</strong></span>      <span class="blue">return</span> in; <span class="lgreen">// enables cin &gt;&gt; x &gt;&gt; y;</span>&#13;
<span class="cviolet"><strong>156</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>157</strong></span></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec55">Implementing the Stream Insertion Operator</h5>&#13;
<p>The <strong>overloaded stream insertion function (<code>&lt;&lt;</code>)</strong> (lines 159–162) receives an <code>ostream</code> reference and a <code>const MyArray</code> reference as arguments and returns an <code>ostream</code> reference. The function calls <code>MyArray</code>’s <code>toString</code> member function then outputs the resulting <code>string</code>. The function returns the <code>ostream</code> reference argument to enable <strong>cascaded output statements</strong>, like</p>&#13;
<pre class="pre">cout &lt;&lt; ints1 &lt;&lt; ints2;</pre>&#13;
<p>When the compiler sees an expression like <code>cout &lt;&lt; ints1</code>, it invokes <strong>non-member function <code>operator&lt;&lt;</code></strong> with the call</p>&#13;
<pre class="pre"><span class="blue">operator</span>&lt;&lt;(cout, ints1)</pre>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p619pro01" id="p619pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>158</strong></span>   <span class="lgreen">// overloaded output operator for class MyArray</span>&#13;
<span class="cviolet"><strong>159</strong></span>   ostream&amp; operator&lt;&lt;(ostream&amp; out, <span class="blue">const</span> MyArray&amp; a) {&#13;
<span class="cviolet"><strong>160</strong></span>      <code>out &lt;&lt; a.toString();</code>&#13;
<span class="cviolet"><strong>161</strong></span>      <span class="blue">return</span> out; <span class="lgreen">// enables cout &lt;&lt; x &lt;&lt; y;</span>&#13;
<span class="cviolet"><strong>162</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>163</strong></span></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec56">Why <code>operator&gt;&gt;</code> and <strong><code>operator&lt;&lt;</code></strong> Must Be Nonmember Functions</h5>&#13;
<p>The <strong><code>operator&gt;&gt;</code></strong> and <strong><code>operator&lt;&lt;</code></strong> functions are defined as <strong>non-member functions</strong>, so we can specify their operands’ order in each function’s parameter list. In a binary overloaded operator implemented as a <strong>non-member function</strong>, the first parameter is the left operand, and the second is the right operand.</p>&#13;
<p>For the operators <strong><code>&gt;&gt;</code></strong> and <strong><code>&lt;&lt;</code></strong>, <strong>the <code>MyArray</code> object should be each operator’s <em>right</em> operand, so you can use them the way C++ programmers expect</strong>, as in the statements:</p>&#13;
<pre class="pre">cin &gt;&gt; ints4;&#13;
cout &lt;&lt; ints4;</pre>&#13;
<p>If we defined these functions as <code>MyArray</code> member functions, programmers would have to write the following awkward statements to input or output <code>MyArray</code> objects:</p>&#13;
<pre class="pre">ints4 &gt;&gt; cin;&#13;
ints4 &lt;&lt; cout;</pre>&#13;
<p>Such statements would be confusing and, in some cases, would lead to compilation errors. Programmers are familiar with <code>cin</code> and <code>cout</code> always appearing to the <em>left</em> of these operators.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Overloaded binary operators may be member functions only for the class of the operator’s <em>left</em> operand. For <code>operator&gt;&gt;</code></strong> and <strong><code>operator&lt;&lt;</code> to be member functions, we’d have to modify the standard library classes <code>istream</code> and <code>ostream</code>, which is not allowed.</strong></p>&#13;
<h5 class="h5" id="ch11lev3sec57">Choosing Member vs. Non-Member Functions</h5>&#13;
<p>Overloaded operator functions, and functions in general, can be:</p>&#13;
<p class="bull">• member functions with direct access to the class’s internal implementation details,</p>&#13;
<p class="bull">• <code>friend</code> functions with direct access to the class’s internal implementation details, or</p>&#13;
<p class="bull">• non-member, non-<code>friend</code> functions—often called <strong>free functions</strong>—that interact with objects of the class through its <code>public</code> interface.</p>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The C++ Core Guidelines say a function should be a member only if it needs direct access to the class’s internal implementation details, such as its <code>private</code> data.<sup><a id="ch11fn34a" href="ch11.xhtml#ch11fn34">34</a></sup> Another reason to</p>&#13;
<p class="footnote"><a id="ch11fn34" href="ch11.xhtml#ch11fn34a">34</a>. “C.4: Make a function a member only if it needs direct access to the representation of a class.” Accessed March 6, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-member">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-member</a></code>.</p>&#13;
<p>use non-member functions is to define <strong><span class="violet">commutative operators</span></strong>. Consider a class <code>HugeInt</code> for</p>&#13;
<p>arbitrary-sized integers. With a <code>HugeInt</code> named <code>bigInt</code>, we might write expressions like:</p>&#13;
<pre class="pre">bigInt + 7&#13;
7 + bigInt</pre>&#13;
<p>Each would sum an <code>int</code> value and a <code>HugeInt</code>. Like the built-in + operator for fundamental types, each would produce temporary <code>HugeInt</code> containing the sum. To support these expressions, you define two versions of <code>operator+</code>, typically as non-member <code>friend</code> functions:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p620pro01" id="p620pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">friend</span> HugeInt <span class="blue">operator</span>+(<span class="blue">const</span> HugeInt&amp; left, <span class="blue">int</span> right);&#13;
<span class="blue">friend</span> HugeInt <span class="blue">operator</span>+(<span class="blue">int</span> left, <span class="blue">const</span> HugeInt&amp; right);</pre>&#13;
<p>To avoid code duplication, the second function typically would call the first.</p>&#13;
<h4 class="h4" id="sec11_6_17">11.6.17 <code>friend</code> Function <code>swap</code></h4>&#13;
<p>Line 13 of <a href="ch11.xhtml#fig11_4">Fig. 11.4</a></p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p620pro02" id="p620pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">friend void</span> swap(MyArray&amp; a, MyArray&amp; b) <span class="blue">noexcept</span>;</pre>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> declares the <code>swap</code> function used by the <strong>copy assignment operator</strong> to implement the <strong>copy-and-swap idiom</strong>. This function is declared <code>noexcept</code>—exchanging the contents of two existing objects does not allocate new resources, so it should not fail.<sup><a id="ch11fn35a" href="ch11.xhtml#ch11fn35">35</a></sup> The function (lines 165–168) receives two <code>MyArray</code>s. It uses the <strong><span class="violet">standard library</span></strong> <span class="violet"><strong><code>swap</code></strong></span> <strong><span class="violet">function</span></strong> to exchange the contents of each object’s <code>m_size</code> members. It uses the <code>unique_ptr</code>’s <span class="violet"><strong><code>swap</code></strong></span><strong><span class="violet"> member function</span></strong> to exchange the contents of the each object’s <code>m_ptr</code> members.</p>&#13;
<p class="footnote"><a id="ch11fn35" href="ch11.xhtml#ch11fn35a">35</a>. “C.84: A <code>swap</code> function may not fail.” Accessed February 25, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-swap-fail">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-swap-fail</a></code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p620pro03" id="p620pro03a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>164</strong></span>   <span class="lgreen">// swap function used to implement copy-and-swap copy assignment operator</span>&#13;
<span class="cviolet"><strong>165</strong></span>   <span class="blue">void</span> swap(MyArray&amp; a, MyArray&amp; b) <span class="blue">noexcept</span> {&#13;
<span class="cviolet"><strong>166</strong></span>      std::swap(a.m_size, b.m_size); <span class="lgreen">// swap using std::swap</span>&#13;
<span class="cviolet"><strong>167</strong></span>      a.m_ptr.swap(b.m_ptr); <span class="lgreen">// swap using unique_ptr swap member function</span>&#13;
<span class="cviolet"><strong>168</strong></span>   <code>}</code></pre>&#13;
</div>&#13;
<h3 class="h3" id="sec11_7"><span class="size">20</span> <span class="violet">11.7</span> C++20 Three-Way Comparison Operator (<code>&lt;=&gt;</code>)</h3>&#13;
<p>You’ll often compare objects of your custom class types. For example, to sort objects into ascending or descending order using the standard library’s <code>sort</code> function (<a href="ch06.xhtml#ch06lev1sec12">Section 6.12</a>; more details in <a href="ch14.xhtml#ch14">Chapter 14</a>), the objects must be comparable. To support comparisons, you can overload the equality (<code>==</code> and <code>!=</code>) and relational (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>) operators for your classes. A common practice is to define the &lt; and <code>==</code> operator functions, then define <code>!=</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> operators in terms of &lt; and <code>==</code>. For instance, for a class <code>Time</code> that represents the time of day, its <code>&lt;=</code> operator could be implemented as an inline member function in terms of the <code>&lt;</code> operator:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p621pro01" id="p621pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">bool</span> operator&lt;=(<span class="blue">const</span> Time&amp; right) <span class="blue">const</span> {&#13;
   <span class="blue">return</span> !(right &lt; *<span class="blue">this</span>);&#13;
}</pre>&#13;
<p>This leads to lots of “boilerplate” code in which the only difference in the definitions of the overloaded <code>!=</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> operators among classes is the argument type.</p>&#13;
<p>For most types, the compiler can handle the comparison operators for you via the compiler-generated <code>default</code> implementation of C++20’s <strong><span class="violet">three-way comparison operator (&lt;=&gt;)</span></strong>,<sup><a id="ch11fn36a" href="ch11.xhtml#ch11fn36">36</a>,<a id="ch11fn37a" href="ch11.xhtml#ch11fn37">37</a>,<a id="ch11fn38a" href="ch11.xhtml#ch11fn38">38</a></sup> which is also referred to as the spaceship operator<sup><a id="ch11fn39a" href="ch11.xhtml#ch11fn39">39</a></sup> and requires the header <span class="violet"><strong><code>&lt;compare&gt;</code></strong></span>. <a href="ch11.xhtml#fig11_6">Figure 11.6</a> demonstrates <code>&lt;=&gt;</code> for a class <code>Time</code> (lines 9–24), which contains:</p>&#13;
<p class="footnote"><a id="ch11fn36" href="ch11.xhtml#ch11fn36a">36</a>. “C++ Russia 2018: Herb Sutter, New in C++20: The spaceship operator,” YouTube Video, June 25, 2018, <code><a href="https://www.youtube.com/watch?v=ULkwKsag0Yk">https://www.youtube.com/watch?v=ULkwKsag0Yk</a></code>.</p>&#13;
<p class="footnote"><a id="ch11fn37" href="ch11.xhtml#ch11fn37a">37</a>. Sy Brand, “Spaceship Operator,” August 23, 2018. Accessed March 6, 2021. <code><a href="https://blog.tartanllama.xyz/spaceship-operator/">https://blog.tartanllama.xyz/spaceship-operator/</a></code>.</p>&#13;
<p class="footnote"><a id="ch11fn38" href="ch11.xhtml#ch11fn38a">38</a>. Cameron DaCamara, “Simplify Your Code With Rocket Science: C++20’s Spaceship Operator,” June 27, 2019. Accessed March 6, 2021. <code><a href="https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/">https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/</a></code>.</p>&#13;
<p class="footnote"><a id="ch11fn39" href="ch11.xhtml#ch11fn39a">39</a>. “Spaceship operator” was coined by Randal L. Schwartz when he was teaching the same operator in a Perl programming course—the operator reminded him of a spaceship in an early video game. <code><a href="https://groups.google.com/a/dartlang.org/g/misc/c/WS5xftItpl4/m/jcIttrMq8agJ?pli=1">https://groups.google.com/a/dartlang.org/g/misc/c/WS5xftItpl4/m/jcIttrMq8agJ?pli=1</a></code>.</p>&#13;
<p class="bull">• a constructor (lines 11–12) to initialize its <code>private</code> data members (lines 21–23),</p>&#13;
<p class="bull">• a <code>toString</code> function (lines 14–16) to create a <code>Time</code>’s <code>string</code> representation, and</p>&#13;
<p class="bull">• a <strong><code>default</code>ed definition of the overloaded <code>&lt;=&gt;</code> operator</strong> (line 19) that the compiler will generate.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>The <code>default</code> compiler-generated <code>operator&lt;=&gt;</code> works for any class containing data members that all support the equality and relational operators</strong>. Also, for classes containing built-in arrays as data members, the compiler applies the overloaded <code>operator&lt;=&gt;</code> element-by-element as it compares two objects of the arrays’ enclosing class type.</p>&#13;
<div class="group" id="fig11_6">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p11pro06" id="p11pro06a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig11_06.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// C++20 three-way comparison (spaceship) operator.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;compare&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">using</span> <span class="blue">namespace</span> std;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">class</span> Time {&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>11</strong></span>      Time(<span class="blue">int</span> hr, <span class="blue">int</span> min, <span class="blue">int</span> sec) <span class="blue">noexcept</span>&#13;
<span class="cviolet"><strong>12</strong></span>         <code>: m_hr{hr}, m_min{min}, m_sec{sec} {}</code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      string toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>15</strong></span>         <span class="blue">return</span> fmt::format(<span class="green">"hr={}, min={}, sec={}"</span>, m_hr, m_min, m_sec);&#13;
<span class="cviolet"><strong>16</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="lgreen">// &lt;=&gt; operator automatically supports equality/relational operators</span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">auto</span> <span class="blue">operator</span>&lt;=&gt;(<span class="blue">const</span> Time&amp; t) <span class="blue">const</span> <span class="blue">noexcept</span> = <span class="blue">default</span>;&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">int</span> m_hr{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">int</span> m_min{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">int</span> m_sec{<span class="green">0</span>};&#13;
<span class="cviolet"><strong>24</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>27</strong></span>      <span class="blue">const</span> Time t1(<span class="green">12</span>, <span class="green">15</span>, <span class="green">30</span>);&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="blue">const</span> Time t2(<span class="green">12</span>, <span class="green">15</span>, <span class="green">30</span>);&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="blue">const</span> Time t3(<span class="green">6</span>, <span class="green">30</span>, <span class="green">0</span>);&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"t1: {}\nt2: {}\nt3: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>32</strong></span>                 <code>t1.toString(), t2.toString(), t3.toString());</code>&#13;
<span class="cviolet"><strong>33</strong></span></pre>&#13;
<pre class="pre1">t1: hr=12, min=15, sec=30&#13;
t2: hr=12, min=15, sec=30&#13;
t3: hr=6, min=30, sec=0</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 11.6</strong></span> | C++20 three-way comparison (spaceship) operator.</p>&#13;
</div>&#13;
<p>In <code>main</code>, lines 27–29 create three <code>Time</code> objects that we’ll use in various comparisons, then display their <code>string</code> representations. <code>Time</code> objects <code>t1</code> and <code>t2</code> both represent 12:15:30 PM, and <code>t3</code> represents 6:30:00 AM. The rest of this program is broken into smaller pieces for discussion purposes.</p>&#13;
<h5 class="h5" id="ch11lev3sec58">With <code>&lt;=&gt;</code>, the Compiler Supports All the Comparison Operators</h5>&#13;
<p>When you let the compiler generate the overloaded three-way comparison operator (<code>&lt;=&gt;</code>) for you, your class supports all the relational and equality operators, which we demonstrate in lines 35–47. In each case, the compiler rewrites an expression like</p>&#13;
<pre class="pre">t1 == t2</pre>&#13;
<p>into an expression that uses the &lt;=&gt; operator, as in</p>&#13;
<pre class="pre">(t1 &lt;=&gt; t2) == 0</pre>&#13;
<p>The expression <code>t1 &lt;=&gt; t2</code> evaluates to <code>0</code> if the objects are equal, a negative value if <code>t1</code> is less than <code>t2</code> and a positive value if <code>t1</code> is greater than <code>t2</code>. As you can see, lines 35–47 compiled and produced correct outputs, even though class <code>Time</code> did not define any equality or relational operators.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p622pro01" id="p622pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>34</strong></span>   <span class="lgreen">// using the equality and relational operators</span>&#13;
<span class="cviolet"><strong>35</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 == t2: {}\n"</span>, t1 == t2);&#13;
<span class="cviolet"><strong>36</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 != t2: {}\n"</span>, t1 != t2);&#13;
<span class="cviolet"><strong>37</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 &lt; t2: {}\n"</span>, t1 &lt; t2);&#13;
<span class="cviolet"><strong>38</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 &lt;= t2: {}\n"</span>, t1 &lt;= t2);&#13;
<span class="cviolet"><strong>39</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 &gt; t2: {}\n"</span>, t1 &gt; t2);&#13;
<span class="cviolet"><strong>40</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 &gt;= t2: {}\n\n"</span>, t1 &gt;= t2);&#13;
<span class="cviolet"><strong>41</strong></span>&#13;
<span class="cviolet"><strong>42</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 == t3: {}\n"</span>, t1 == t3);&#13;
<span class="cviolet"><strong>43</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 != t3: {}\n"</span>, t1 != t3);&#13;
<span class="cviolet"><strong>44</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 &lt; t3: {}\n"</span>, t1 &lt; t3);&#13;
<span class="cviolet"><strong>45</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 &lt;= t3: {}\n"</span>, t1 &lt;= t3);&#13;
<span class="cviolet"><strong>46</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 &gt; t3: {}\n"</span>, t1 &gt; t3);&#13;
<span class="cviolet"><strong>47</strong></span>   cout &lt;&lt; fmt::format(<span class="green">"t1 &gt;= t3: {}\n\n"</span>, t1 &gt;= t3);&#13;
<span class="cviolet"><strong>48</strong></span></pre>&#13;
<pre class="pre1">t1 == t2: true&#13;
t1 != t2: false&#13;
t1 &lt; t2: false&#13;
t1 &lt;= t2: true&#13;
t1 &gt; t2: false&#13;
t1 &gt;= t2: true&#13;
&#13;
t1 == t3: false&#13;
t1 != t3: true&#13;
t1 &lt; t3: false&#13;
t1 &lt;= t3: false&#13;
t1 &gt; t3: true&#13;
t1 &gt;= t3: true</pre>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec59">Using &lt;=&gt; Explicitly</h5>&#13;
<p>You also can use <code>&lt;=&gt;</code> in expressions. An <code>&lt;=&gt;</code> expression’s result is not convertible to <code>bool</code>, so you must compare it to 0 to use <code>&lt;=&gt;</code> in a condition, as shown in lines 50, 54 and 58.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p623pro01" id="p623pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>49</strong></span>      <span class="lgreen">// using &lt;=&gt; to perform comparisons</span>&#13;
<span class="cviolet"><strong>50</strong></span>      <span class="blue">if</span> ((t1 &lt;=&gt; t2) == <span class="green">0</span>) {&#13;
<span class="cviolet"><strong>51</strong></span>         cout &lt;&lt; <span class="green">"t1 is equal to t2\n"</span>;&#13;
<span class="cviolet"><strong>52</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>53</strong></span>&#13;
<span class="cviolet"><strong>54</strong></span>      <span class="blue">if</span> ((t1 &lt;=&gt; t3) &gt; <span class="green">0</span>) {&#13;
<span class="cviolet"><strong>55</strong></span>         cout &lt;&lt; <span class="green">"t1 is greater than t3\n"</span>;&#13;
<span class="cviolet"><strong>56</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>57</strong></span>&#13;
<span class="cviolet"><strong>58</strong></span>      <span class="blue">if</span> ((t3 &lt;=&gt; t1) &lt; <span class="green">0</span>) {&#13;
<span class="cviolet"><strong>59</strong></span>         cout &lt;&lt; <span class="green">"t3 is less than t1\n"</span>;&#13;
<span class="cviolet"><strong>60</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>61</strong></span>   }</pre>&#13;
<pre class="pre1">t1 is equal to t2&#13;
t1 is greater than t3&#13;
t3 is less than t1</pre>&#13;
</div>&#13;
<p>In <a href="ch19.xhtml#ch19">Chapter 19</a>, Other Topics and a Look Toward the Future of C++, we’ll discuss overloading this operator for more complex types, like our <code>MyArray</code> class that contains dynamically allocated memory.</p>&#13;
<h3 class="h3" id="sec11_8"><span class="violet">11.8</span> Converting Between Types</h3>&#13;
<p>Most programs process information of many types. Sometimes all the operations “stay within a type.” For example, adding an <code>int</code> to an <code>int</code> produces an <code>int</code>. It’s often necessary, however, to convert data of one type to data of another type. This can happen in assignments, calculations, passing values to functions and returning values from functions. The compiler knows how to perform certain conversions among fundamental types. You can use cast operators to force conversions among fundamental types.</p>&#13;
<p>But what about user-defined types? The compiler does not know how to convert among user-defined types or between user-defined types and fundamental types. You must specify how to do this. Such conversions can be performed with <strong><span class="violet">conversion constructors</span></strong>. These constructors are called with one argument (we refer to these as <strong>single-argument constructors</strong>). Such constructors can turn objects of other types (including fundamental types) into objects of a particular class.</p>&#13;
<h5 class="h5" id="ch11lev3sec60">Conversion Operators</h5>&#13;
<p>A <strong><span class="violet">conversion operator</span></strong> (also called a <strong>cast operator</strong>) also can convert an object of a class to another type. Such a conversion operator must be a <em>nonstatic member function</em>. In the <code>MyArray</code> case study, we implemented an overloaded conversion operator that converted a <code>MyArray</code> to a <code>bool</code> value to determine whether the <code>MyArray</code> contained elements.</p>&#13;
<h5 class="h5" id="ch11lev3sec61">Implicit Calls to Cast Operators and Conversion Constructors</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>A feature of cast operators and conversion constructors is that the compiler can call them <em>implicitly</em> to create objects</strong>. For example, you saw that when an object of our class <code>MyArray</code> appears in a program where a <code>bool</code> is expected, such as</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p624pro01" id="p624pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">if</span> (ints1) { <span class="lgreen">// if expects a condition</span>&#13;
   ...&#13;
}</pre>&#13;
<p>the compiler can call the overloaded cast-operator function <code>operator bool</code> to convert the object into a <code>bool</code> and use the resulting <code>bool</code> in the expression.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>When a conversion constructor or conversion operator is used to perform an implicit conversion, C++ can apply only one implicit constructor or operator function call (i.e., a single user-defined conversion) per expression to try to match the needs of that expression. The compiler will not satisfy an expression’s needs by performing a series of implicit, user-defined conversions.</strong></p>&#13;
<h3 class="h3" id="sec11_9"><span class="violet">11.9</span> <code>explicit</code> Constructors and Conversion Operators</h3>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Recall that we’ve been declaring as <code>explicit</code> every constructor that can be called with one argument, including multiparameter constructors for which we specify default arguments. <strong>Except for copy and move constructors, any constructor that can be called with a <em>single argument</em> and is <em>not</em> declared <code>explicit</code> can be used by the compiler to perform an <em>implicit conversion</em>. The constructor’s argument is converted to an object of the class in which the constructor is defined.</strong> The conversion is automatic—a cast is not required.</p>&#13;
<p><strong>In some situations, implicit conversions are undesirable or error-prone</strong>. For example, our <code>MyArray</code> class defines a constructor that takes a single <code>size_t</code> argument. The intent of this constructor is to create a <code>MyArray</code> object containing a specified number of elements. However, if this constructor were not declared <code>explicit</code> it could be misused by the compiler to perform an <strong>implicit conversion</strong>.</p>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <strong>Unfortunately, the compiler might use implicit conversions in cases that you do not expect, resulting in execution-time logic errors or ambiguous expressions that generate compilation errors.</strong></p>&#13;
<h5 class="h5" id="ch11lev3sec62">Accidentally Using a Single-Argument Constructor as a Conversion Constructor</h5>&#13;
<p>The program (<a href="ch11.xhtml#fig11_7">Fig. 11.7</a>) uses <a href="ch11.xhtml#sec11_6">Section 11.6</a>’s <code>MyArray</code> class to demonstrate an improper implicit conversion. To allow this implicit conversion, we removed the <code>explicit</code> keyword from line 16 in <code>MyArray.h</code> (<a href="ch11.xhtml#fig11_4">Fig. 11.4</a>).</p>&#13;
<div class="group" id="fig11_7">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p11pro07" id="p11pro07a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig11_07.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Single-argument constructors and implicit conversions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"MyArray.h"</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">void</span> outputArray(<span class="blue">const</span> MyArray&amp;); <span class="lgreen">// prototype</span>&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      MyArray ints1(<span class="green">7</span>); <span class="lgreen">// 7-element MyArray</span>&#13;
<span class="cviolet"><strong>11</strong></span>      outputArray(ints1); <span class="lgreen">// output MyArray ints1</span>&#13;
<span class="cviolet"><strong>12</strong></span>      outputArray(<span class="green">3</span>); <span class="lgreen">// convert 3 to a MyArray and output the contents</span>&#13;
<span class="cviolet"><strong>13</strong></span>   } <span class="lgreen"/>&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// print MyArray contents</span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">void</span> outputArray(<span class="blue">const</span> MyArray&amp; arrayToOutput) {&#13;
<span class="cviolet"><strong>17</strong></span>      cout &lt;&lt; <span class="green">"The MyArray received has "</span> &lt;&lt; arrayToOutput.size()&#13;
<span class="cviolet"><strong>18</strong></span>         &lt;&lt; <span class="green">" elements. The contents are: "</span> &lt;&lt; arrayToOutput &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>19</strong></span>   }</pre>&#13;
<pre class="pre1">MyArray(size_t) constructor&#13;
The MyArray received has 7 elements. The contents are: {0, 0, 0, 0, 0, 0, 0}&#13;
MyArray(size_t) constructor&#13;
The MyArray received has 3 elements. The contents are: {0, 0, 0}&#13;
MyArray destructor&#13;
MyArray destructor</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 11.7</strong></span> | Single-argument constructors and implicit conversions.</p>&#13;
</div>&#13;
<p>Line 10 in <code>main</code> (<a href="ch11.xhtml#fig11_7">Fig. 11.7</a>) instantiates <code>MyArray</code> object <code>ints1</code> and calls the <em>single-argument constructor</em> with the value <code>7</code> to specify <code>ints1</code>’s number of elements. Recall that the <code>MyArray</code> constructor that receives a <code>size_t</code> argument initializes all the <code>MyArray</code> elements to 0. Line 11 calls function <code>outputArray</code> (defined in lines 16–19), which receives as its argument a <code>const MyArray&amp;</code>. The function outputs its argument’s number of elements and contents. In this case, the <code>MyArray</code>’s size is <code>7</code>, so <code>outputArray</code> displays seven <code>0</code>s.</p>&#13;
<p>Line 12 calls <code>outputArray</code> with the value <code>3</code> as an argument. This program does <em>not</em> contain an <code>outputArray</code> function that takes an <code>int</code> argument. So, the compiler determines whether the argument <code>3</code> can be converted to an <code>MyArray</code> object. Because class <code>MyArray</code> provides a constructor with one <code>size_t</code> argument (which can receive an <code>int</code>) and that constructor is not declared <code>explicit</code>, the compiler assumes the constructor is a <strong>conversion constructor</strong> and uses it to convert the argument <code>3</code> into a temporary <code>MyArray</code> object containing three elements. Then, the compiler passes this temporary <code>MyArray</code> object to function <code>outputArray</code>, which displays the temporary <code>MyArray</code>’s size and contents. Thus, even though we do not <em>explicitly</em> provide an <code>outputArray</code> function that receives an <code>int</code>, the compiler can compile line 12. The output shows the contents of the three-element <code>MyArray</code> containing <code>0</code>s.</p>&#13;
<h5 class="h5" id="ch11lev3sec63">Preventing Implicit Conversions with Single-Argument Constructors</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>The reason we’ve been declaring every single-argument constructor preceded by the keyword <code>explicit</code> is to <em>suppress implicit conversions via conversion constructors when such conversions should not be allowed</em>. A constructor that’s declared <code>explicit</code> <em>cannot</em> be used in an <em>implicit</em> conversion.</strong> Our next program uses the original <code>MyArray</code> version from <a href="ch11.xhtml#sec11_6">Section 11.6</a>, which included the keyword <code>explicit</code> in the declaration of its <strong>single-argument constructor</strong> that receives a <code>size_t</code>:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p626pro01" id="p626pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">explicit</span> MyArray(<span class="blue">size_t</span> size);</pre>&#13;
<p><a href="ch11.xhtml#fig11_8">Figure 11.8</a> presents a slightly modified version of the program in <a href="ch11.xhtml#fig11_7">Fig. 11.7</a>. When this program in <a href="ch11.xhtml#fig11_8">Fig. 11.8</a> is compiled, the compiler produces an error message, such as</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p626pro02" id="p626pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">error: invalid initialization of reference of type ‘const MyArray&amp;’&#13;
from expression of type ‘int’</pre>&#13;
<p>on g++, indicating that the integer value passed to <code>outputArray</code> in line 12 <em>cannot</em> be converted to a <code>const MyArray&amp;</code>. Line 13 demonstrates how the <code>explicit</code> constructor can be used explicitly to create a temporary <code>MyArray</code> of <code>3</code> elements and pass it to <code>outputArray</code>.</p>&#13;
<div class="group" id="fig11_8">&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p11pro08" id="p11pro08a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig11_08.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating an explicit constructor.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"MyArray.h"</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">void</span> outputArray(<span class="blue">const</span> MyArray&amp;); <span class="lgreen">// prototype</span>&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      MyArray ints1{<span class="green">7</span>}; <span class="lgreen">// 7-element MyArray</span>&#13;
<span class="cviolet"><strong>11</strong></span>      outputArray(ints1); <span class="lgreen">// output MyArray ints1</span>&#13;
<span class="cviolet"><strong>12</strong></span>      outputArray(<span class="green">3</span>); <span class="lgreen">// convert 3 to a MyArray and output its contents</span>&#13;
<span class="cviolet"><strong>13</strong></span>      outputArray(MyArray(<span class="green">3</span>)); <span class="lgreen">// explicit single-argument constructor call</span>&#13;
<span class="cviolet"><strong>14</strong></span>   }&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="lgreen">// print MyArray contents</span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="blue">void</span> outputArray(<span class="blue">const</span> MyArray&amp; arrayToOutput) {&#13;
<span class="cviolet"><strong>18</strong></span>      cout &lt;&lt; <span class="green">"The MyArray received has "</span> &lt;&lt; arrayToOutput.size()&#13;
<span class="cviolet"><strong>19</strong></span>         &lt;&lt; <span class="green">" elements. The contents are: "</span> &lt;&lt; arrayToOutput &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>20</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 11.8</strong></span> | Demonstrating an <code>explicit</code> constructor.</p>&#13;
</div>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">20</span> <strong>You should always use the <code>explicit</code> keyword on single-argument constructors unless they’re intended to be used implicitly as conversion constructors. In this case, you should declare the single-argument constructor <code>explicit(false)</code>. This documents for your class’s users that you wish to allow implicit conversions to be performed with that constructor</strong>. This new use of <code>explicit</code> was introduced in C++20.</p>&#13;
<h5 class="h5" id="ch11lev3sec64"><span class="size">11</span> C++11 <code>explicit</code> Conversion Operators</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">20</span> <strong>Just as you can declare single-argument constructors <code>explicit</code>, you can declare conversion operators <code>explicit</code>—or in C++20, <code>explicit(true)</code>—to prevent the compiler from using them to perform implicit conversions.</strong> For example, in class <code>MyArray</code>, the prototype</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p627pro01" id="p627pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">explicit</span> <span class="blue">operator</span> <span class="blue">bool</span>() <span class="blue">const noexcept</span>;</pre>&#13;
<p>declares the <code>bool</code> cast operator <code>explicit</code>, so you’d generally have to invoke it explicitly with <code>static_cast</code>, as in:</p>&#13;
<p class="codelink"><a href="Images/ch11_images.xhtml#p627pro02" id="p627pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">static_cast&lt;<span class="blue">bool</span>&gt;(myArrayObject)</pre>&#13;
<p>As we showed in the <code>MyArray</code> case study, C++ can still perform contextual conversions using an <code>explicit bool</code> conversion operator to convert an object to a <code>bool</code> value in a condition.</p>&#13;
<h3 class="h3" id="sec11_10"><span class="violet">11.10</span> Overloading the Function Call Operator <code>()</code></h3>&#13;
<p>Overloading the <strong><span class="violet">function-call operator</span></strong> <span class="violet"><strong><code>()</code></strong></span> is powerful because functions can take an arbitrary number of comma-separated parameters. We demonstrate the overloaded function-call operator in a natural context in <a href="ch14.xhtml#sec14_5">Section 14.5</a>.</p>&#13;
<h3 class="h3" id="sec11_11"><span class="violet">11.11</span> Wrap-Up</h3>&#13;
<p>This chapter demonstrated how to craft valuable classes, using operator overloading to enable C++’s existing operators to work with custom class objects. First, you used several <code>string</code>-class overloaded operators. Next, we presented operator-overloading fundamentals, including which operators can be overloaded and various rules and restrictions on operator overloading.</p>&#13;
<p>We introduced dynamic memory management with operators <code>new</code> and <code>delete</code>, which acquire and release the memory for objects and built-in, pointer-based arrays at runtime. We discussed the problems with using old-style <code>new</code> and <code>delete</code> statements, such as forgetting to use <code>delete</code> to release memory that’s no longer needed. We introduced RAII (Resource Acquisition Is Initialization) and demonstrated smart pointers. You saw how to dynamically allocate memory as you created a <code>unique_ptr</code> smart pointer object. The <code>unique_ptr</code> automatically released the memory when the object went out of scope, preventing a memory leak.</p>&#13;
<p>Next, we presented the chapter’s substantial capstone <code>MyArray</code> case study, which used overloaded operators and other capabilities to solve various problems with pointer-based arrays. We implemented the five special member functions typically defined in classes that manage their own resources—the copy constructor, copy assignment operator, move constructor, move assignment operator and destructor. We also discussed how to autogenerate these special member functions with <code>= default</code> and remove them with <code>= delete</code>. The class overloaded many operators and defined a conversion from <code>MyArray</code> to <code>bool</code> for determining whether a <code>MyArray</code> was empty or contained elements.</p>&#13;
<p>We introduced C++20’s new three-way comparison operator (&lt;=&gt;)—also called the spaceship operator. You saw that for some classes, the default compiler-generated <code>&lt;=&gt;</code> operator enables a class to support all six equality and relational operators without you having to explicitly overload them. We discussed in more detail converting between types, problems with implicit conversions defined by single-argument constructors and how to prevent those problems with the keyword <code>explicit</code>. Finally, we discussed overloading the function-call operator, <code>()</code>, which we’ll demonstrate in later chapters.</p>&#13;
<p>We’ve introduced some exception-handling fundamentals. The next chapter discusses exception handling in detail, so you can create more robust and fault-tolerant applications that can deal with problems and continue executing, or terminate gracefully. We’ll show how to handle exceptions if operator <code>new</code> fails to allocate memory for an object. We’ll also introduce several C++ standard library exception-handling classes and show how to create your own.</p>&#13;
</div></body>
</html>