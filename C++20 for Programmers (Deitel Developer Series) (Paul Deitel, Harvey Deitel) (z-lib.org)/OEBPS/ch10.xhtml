<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch10">Chapter 10. OOP: Inheritance and Runtime Polymorphism</h2>&#13;
<div class="image"><img src="Images/common.jpg" alt="Images" width="370" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Use traditional and modern inheritance idioms, and understand base classes and derived classes.</p>&#13;
<p class="squ"><span class="red">■</span> Understand the order in which C++ calls constructors and destructors in inheritance hierarchies.</p>&#13;
<p class="squ"><span class="red">■</span> See how runtime polymorphism can make programming more convenient and systems more easily extensible.</p>&#13;
<p class="squ"><span class="red">■</span> Use <code>override</code> to tell the compiler that a derived-class function overrides a base-class <code>virtual</code> function.</p>&#13;
<p class="squ"><span class="red">■</span> Use <code>final</code> at the end of a function’s prototype to indicate that function may not be overridden.</p>&#13;
<p class="squ"><span class="red">■</span> Use <code>final</code> after a class’s name in its definition to indicate that a class cannot be a base class.</p>&#13;
<p class="squ"><span class="red">■</span> Perform inheritance with abstract and concrete classes.</p>&#13;
<p class="squ"><span class="red">■</span> See how C++ can implement <code>virtual</code> functions and dynamic binding—and you’ll estimate <code>virtual</code> function overhead.</p>&#13;
<p class="squ"><span class="red">■</span> Use the non-<code>virtual</code> interface idiom (NVI) with <code>public</code> non-<code>virtual</code> and <code>private</code>/<code>protected virtual</code> functions.</p>&#13;
<p class="squ"><span class="red">■</span> Use interfaces to create more flexible runtime-polymorphism systems.</p>&#13;
<p class="squ"><span class="red">■</span> Implement runtime polymorphism without class hierarchies via <code>std::variant</code> and <code>std::visit</code>.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_1"><span class="violet"><strong>10.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_2"><span class="violet"><strong>10.2</strong></span> Base Classes and Derived Classes</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_2_1">10.2.1 <code>CommunityMember</code> Class Hierarchy</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_2_2">10.2.2 <code>Shape</code> Class Hierarchy and <code>public</code> Inheritance</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_3"><span class="violet"><strong>10.3</strong></span> Relationship between Base and Derived Classes</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_3_1">10.3.1 Creating and Using a <code>SalariedEmployee</code> Class</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_3_2">10.3.2 Creating a <code>SalariedEmployee</code>–<code>SalariedCommissionEmployee</code> Inheritance Hierarchy</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_4"><span class="violet"><strong>10.4</strong></span> Constructors and Destructors in Derived Classes</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_5"><span class="violet"><strong>10.5</strong></span> Intro to Runtime Polymorphism: Polymorphic Video Game</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_6"><span class="violet"><strong>10.6</strong></span> Relationships Among Objects in an Inheritance Hierarchy</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_6_1">10.6.1 Invoking Base-Class Functions from Derived-Class Objects</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_6_2">10.6.2 Aiming Derived-Class Pointers at Base-Class Objects</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_6_3">10.6.3 Derived-Class Member-Function Calls via Base-Class Pointers</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_7"><span class="violet"><strong>10.7</strong></span> Virtual Functions and Virtual Destructors</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_7_1">10.7.1 Why <code>virtual</code> Functions Are Useful</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_7_2">10.7.2 Declaring <code>virtual</code> Functions</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_7_3">10.7.3 Invoking a <code>virtual</code> Function</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_7_4">10.7.4 <code>virtual</code> Functions in the <code>SalariedEmployee</code> Hierarchy</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_7_5">10.7.5 <code>virtual</code> Destructors</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_7_6">10.7.6 <code>final</code> Member Functions and Classes</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_8"><span class="violet"><strong>10.8</strong></span> Abstract Classes and Pure <code>virtual</code> Functions</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_8_1">10.8.1 Pure <code>virtual</code> Functions</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_8_2">10.8.2 Device Drivers: Polymorphism in Operating Systems</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_9"><span class="violet"><strong>10.9</strong></span> Case Study: Payroll System Using Runtime Polymorphism</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_9_1">10.9.1 Creating Abstract Base-Class <code>Employee</code></a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_9_2">10.9.2 Creating Concrete Derived-Class <code>SalariedEmployee</code></a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_9_3">10.9.3 Creating Concrete Derived-Class <code>CommissionEmployee</code></a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_9_4">10.9.4 Demonstrating Runtime Polymorphic Processing</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_10"><span class="violet"><strong>10.10</strong></span> Runtime Polymorphism, Virtual Functions and Dynamic Binding “Under the Hood”</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_11"><span class="violet"><strong>10.11</strong></span> Non-Virtual Interface (NVI) Idiom</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_12"><span class="violet"><strong>10.12</strong></span> Program to an Interface, Not an Implementation</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_12_1">10.12.1 Rethinking the Employee Hierarchy— <code>CompensationModel</code> Interface</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_12_2">10.12.2 Class <code>Employee</code></a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_12_3">10.12.3 <code>CompensationModel</code> Implementations</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_12_4">10.12.4 Testing the New Hierarchy</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_13"><span class="violet"><strong>10.13</strong></span> Runtime Polymorphism with <code>std::variant</code> and <code>std::visit</code></a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_14"><span class="violet"><strong>10.14</strong></span> Multiple Inheritance</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_14_1">10.14.1 Diamond Inheritance</a></p>&#13;
<p class="chap-lev2"><a href="ch10.xhtml#sec10_14_2">10.14.2 Eliminating Duplicate Subobjects with <code>virtual</code> Base-Class Inheritance</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_15"><span class="violet"><strong>10.15</strong></span> <code>protected</code> Class Members</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_16"><span class="violet"><strong>10.16</strong></span> <code>public</code>, <code>protected</code> and <code>private</code> Inheritance</a></p>&#13;
<p class="chap-lev1"><a href="ch10.xhtml#sec10_17"><span class="violet"><strong>10.17</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="sec10_1"><span class="violet">10.1</span> Introduction</h3>&#13;
<p>This chapter continues our object-oriented programming (OOP) discussion by introducing inheritance and runtime polymorphism. With <strong><span class="violet">inheritance</span></strong>, you’ll create classes that absorb existing classes’ capabilities, then customize or enhance them.</p>&#13;
<p>When creating a class, you can specify that the new class should <strong><span class="violet">inherit</span></strong> an existing class’s members. This existing class is called the <strong><span class="violet">base class</span></strong>, and the new class is called the <strong><span class="violet">derived class</span></strong>. Some programming languages, such as Java and C#, use the terms <strong><span class="violet">superclass</span></strong> and <strong><span class="violet">subclass</span></strong> for base class and derived class.</p>&#13;
<h5 class="h5" id="ch10lev3sec1"><em>Has-a</em> vs. <em>Is-a</em> Relationships</h5>&#13;
<p>We distinguish between the <em>has-a</em> relationship and the <em>is-a</em> relationship:</p>&#13;
<p class="bull">• The <em>has-a</em> relationship represents composition (<a href="ch09.xhtml#ch09lev1sec17">Section 9.17</a>) in whih an object <em>contains</em> as members one or more objects of other classes. For example, a <code>Car</code> <em>has a</em> steering wheel, <em>has a</em> brake pedal, <em>has an</em> engine, <em>has a</em> transmission, etc.</p>&#13;
<p class="bull">• The <span class="violet"><strong><em>is-a</em> relationship</strong></span> represents inheritance. In an <em>is-a</em> relationship, a derived-class object also can be treated as an object of its base-class type. For example, a <code>Car</code> <em>is a</em> <code>Vehicle</code>, so a <code>Car</code> also exhibits a <code>Vehicle</code>’s behaviors and attributes.<sup><a id="ch10fn1a" href="ch10.xhtml#ch10fn1">1</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn1" href="ch10.xhtml#ch10fn1a">1</a>. We’ll see that a base-class object cannot implicitly be treated as an object of any of its derived classes.</p>&#13;
<h5 class="h5" id="ch10lev3sec2">Runtime Polymorphism</h5>&#13;
<p>We’ll explain and demonstrate runtime polymorphism with inheritance hierarchies.<sup><a id="ch10fn2a" href="ch10.xhtml#ch10fn2">2</a></sup> <strong><span class="violet">Runtime polymorphism</span> enables you to conveniently “program in the general” rather than “program in the specific</strong>.” Programs can process objects of classes related by inheritance as if they’re all objects of the base-class type. You’ll see that runtime polymorphic code—as we’ll initially implement it with inheritance and <code>virtual</code> functions—refers to objects via base-class pointers or base-class references.</p>&#13;
<p class="footnote"><a id="ch10fn2" href="ch10.xhtml#ch10fn2a">2</a>. We’ll see later that runtime polymorphism does not have to be done with inheritance hierarchies, and we’ll also discuss compile-time polymorphism.</p>&#13;
<h5 class="h5" id="ch10lev3sec3">Implementing for Extensibility</h5>&#13;
<p>With runtime polymorphism, you can design and implement systems that are more easily <strong><span class="violet">extensible</span></strong>—new classes can be added with little or no modification to the program’s general portions, as long as the new classes are part of the program’s inheritance hierarchy. You modify only code that requires direct knowledge of the new classes. Suppose a new class <code>Car</code> inherits from class <code>Vehicle</code>. We need to write only the new class and code that creates <code>Car</code> objects and adds them to the system—the new class simply “plugs right in.” The general code that processes <code>Vehicles</code> can remain the same.</p>&#13;
<h5 class="h5" id="ch10lev3sec4">Discussion of Runtime Polymorphism with Virtual Functions “Under the Hood”</h5>&#13;
<p>A key feature of this chapter is its discussion of runtime polymorphism, <code>virtual</code> functions and dynamic binding “under the hood.” The C++ standard document does not specify how language features should be implemented. We use a detailed illustration to explain how runtime polymorphism with virtual functions <em>can</em> be implemented in C++.</p>&#13;
<p>This chapter presents a traditional introduction to inheritance and runtime polymorphism to acquaint you with basic-through-intermediate-level thinking and ensure that you understand the mechanics of how these technologies work. Later in this chapter and in the remainder of the book, we’ll address current thinking and programming idioms.</p>&#13;
<h5 class="h5" id="ch10lev3sec5">Non-Virtual Interface Idiom</h5>&#13;
<p>Next, we consider another runtime polymorphism approach—the non-virtual interface idiom (NVI), in which each base-class function serves only one purpose:</p>&#13;
<p class="bull">• as a function that client code can call to perform a task, or</p>&#13;
<p class="bull">• as a function that derived classes can customize.</p>&#13;
<p>The customizable functions are internal implementation details of the classes, making systems easier to maintain and evolve without requiring code changes in client applications.</p>&#13;
<h5 class="h5" id="ch10lev3sec6">Interfaces and Dependency Injection</h5>&#13;
<p>To explain the mechanics of inheritance, our first few examples focus on <strong>implementation inheritance</strong>, which is primarily used to define closely related classes with many of the same data members and member-function implementations. For decades, this style of inheritance was widely practiced in the object-oriented programming community. Over time, though, experience revealed its weaknesses. C++ is used to build real-world, business-critical and mission-critical systems—often at a grand scale. The empirical results from years of building such implementation-inheritance-based systems show that they can be challenging to modify.</p>&#13;
<p>So, we’ll refactor one of our examples to use <strong>interface inheritance</strong>. The base class will not provide any implementation details. Instead, it will contain “placeholders” that tell derived classes the functions they’re required to implement. The derived classes will provide the implementation details—that is, the data members and member-function implementations. As part of this example, we’ll introduce <strong>dependency injection</strong> in which a class contains a pointer to an object that provides a behavior required by objects of the class—in our example, calculating an employee’s earnings. This pointer can be re-aimed—for example, if an employee gets promoted, we can change the earnings calculation by aiming the pointer at an appropriate object. Then, we’ll discuss how this refactored example is easier to evolve.</p>&#13;
<h5 class="h5" id="ch10lev3sec7">Runtime Polymorphism Via <code>std::variant</code> and <strong><code>std::visit</code></strong></h5>&#13;
<p><span class="size">17</span> Next, we’ll implement runtime polymorphism for objects of classes that are <em>not</em> related by inheritance and do <em>not</em> have <code>virtual</code> functions. To accomplish this, we’ll use C++17’s class template <code>std::variant</code> and the standard-library function <code>std::visit</code>. <strong>Invoking common functionality on objects of unrelated types is called duck typing</strong>.</p>&#13;
<h5 class="h5" id="ch10lev3sec8">Multiple Inheritance</h5>&#13;
<p>We’ll demonstrate <strong>multiple inheritance</strong>, which enables a derived class to inherit the members of several base classes. We discuss potential problems with multiple inheritance and how virtual inheritance can be used to solve them.</p>&#13;
<h5 class="h5" id="ch10lev3sec9">Other Ways to Implement Polymorphism</h5>&#13;
<p><span class="size">20</span> Finally, we’ll overview other runtime-polymorphism techniques and several template-based <strong>compile-time polymorphism</strong> approaches. We’ll implement some of these in <a href="ch15.xhtml#ch15">Chapter 15</a>, Templates, C++20 Concepts and Metaprogramming. There you’ll see that C++20’s new <strong>concepts</strong> feature obviates some older techniques and expands your “toolkit” for creating compile-time, template-based solutions. We’ll also provide links to advanced resources for developers who wish to dig deeper.</p>&#13;
<h5 class="h5" id="ch10lev3sec10">Chapter Goal</h5>&#13;
<p>A goal of this chapter is to familiarize you with inheritance and runtime polymorphism mechanics, so you’ll be able to better appreciate modern polymorphism idioms and techniques that can promote ease of modifiability and better performance.</p>&#13;
<h3 class="h3" id="sec10_2"><span class="violet">10.2</span> Base Classes and Derived Classes</h3>&#13;
<p>The following table lists several simple base-class and derived-class examples. Base classes tend to be <em>more general</em> and derived classes <em>more specific</em>:</p>&#13;
<div class="image"><img src="Images/493tab01.jpg" alt="Images" width="551" height="222"/></div>&#13;
<p>Every derived-class object <em>is an</em> object of its base-class type, and one base class can have many derived classes. So, the set of objects a base class represents typically is larger than the set of objects a derived class represents. For example, the base class <code>Vehicle</code> represents all vehicles, including cars, trucks, boats, airplanes, bicycles, etc. By contrast, the derived-class <code>Car</code> represents a smaller, more specific subset of all <code>Vehicle</code>s.</p>&#13;
<h4 class="h4" id="sec10_2_1">10.2.1 <code>CommunityMember</code> Class Hierarchy</h4>&#13;
<p>Inheritance relationships naturally form <strong><span class="violet">class hierarchies</span></strong>. A base class exists in a hierarchical relationship with its derived classes. Once classes are employed in inheritance hierarchies, they become coupled with other classes.<sup><a id="ch10fn3a" href="ch10.xhtml#ch10fn3">3</a></sup> A class can be</p>&#13;
<p class="footnote"><a id="ch10fn3" href="ch10.xhtml#ch10fn3a">3</a>. We’ll see that tightly coupled classes can make systems difficult to modify. We’ll show alternatives to avoid tight coupling.</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> a base class that supplies members to other classes,</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> a derived class that inherits members from other classes, or</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> both.<sup><a id="ch10fn4a" href="ch10.xhtml#ch10fn4">4</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn4" href="ch10.xhtml#ch10fn4a">4</a>. Some leaders in the software-engineering community discourage the last option. See Scott Meyers, “Item 33: Make non-leaf classes abstract,” <em>More Effective C++: 35 New Ways to Improve Your Programs and Designs</em>. Addison-Wesley, 1995. Also see, Herb Sutter, <em>“</em>Virtuality,” <em>C/C++ Users Journal</em>, vol. 19, no. 9, September 2001. <code><a href="http://www.gotw.ca/publications/mill18.htm">http://www.gotw.ca/publications/mill18.htm</a></code>.</p>&#13;
<p>Let’s develop a simple inheritance hierarchy, represented by the following <strong><span class="violet">UML class diagram</span></strong>—such diagrams illustrate the relationships among classes in a hierarchy:</p>&#13;
<div class="image"><img src="Images/493fig01.jpg" alt="Images" width="701" height="338"/></div>&#13;
<p>A university community might have thousands of <code>CommunityMember</code>s, such as <code>Employee</code>s, <code>Student</code>s and alumni (each of class <code>Alumnus</code>). <code>Employee</code>s are either <code>Faculty</code> or <code>Staff</code>, and <code>Faculty</code> are either <code>Administrator</code>s or <code>Teacher</code>s. Some <code>Administrator</code>s are also <code>Teacher</code>s. With <strong><span class="violet">single inheritance</span></strong>, a derived class inherits from <em>one</em> base class. With <strong><span class="violet">multiple inheritance</span></strong>, a derived class inherits from two or more base classes. In this hierarchy, we’ve used multiple inheritance to form class <code>AdministratorTeacher</code>.</p>&#13;
<p>Each upward-pointing arrow in the diagram represents an <em>is-a</em> relationship. As we follow the arrows upward, we can state “an <code>Employee</code> <em>is a</em> <code>CommunityMember</code>” and “a <code>Teacher</code> <em>is a</em> <code>Faculty</code> member.” <code>CommunityMember</code> is the <strong><span class="violet">direct base class</span></strong> of <code>Employee</code>, <code>Student</code> and <code>Alumnus</code>. <code>CommunityMember</code> is an <strong><span class="violet">indirect base class</span></strong> of all the hierarchy’s other classes. An indirect base class is two or more levels up the class hierarchy from its derived classes.</p>&#13;
<p>You can follow the arrows upward several levels, applying the <em>is-a</em> relationship. So, an <code>AdministratorTeacher</code> <em>is an</em> <code>Administrator</code> (and <em>is also a</em> <code>Teacher</code>), <em>is a</em> <code>Faculty</code> member, <em>is an</em> <code>Employee</code> and <em>is a</em> <code>CommunityMember</code>.</p>&#13;
<h4 class="h4" id="sec10_2_2">10.2.2 <code>Shape</code> Class Hierarchy and <code>public</code> Inheritance</h4>&#13;
<p>Let’s consider a <code>Shape</code> inheritance hierarchy that begins with base-class <code>Shape</code>:</p>&#13;
<div class="image"><img src="Images/494fig01.jpg" alt="Images" width="714" height="189"/></div>&#13;
<p>Classes <code>TwoDimensionalShape</code> and <code>ThreeDimensionalShape</code> derive from <code>Shape</code>, so a <code>TwoDimensionalShape</code> <em>is a</em> <code>Shape</code>, and a <code>ThreeDimensionalShape</code> <em>is a</em> <code>Shape</code>. The hierarchy’s third level contains specific <code>TwoDimensionalShape</code>s and <code>ThreeDimensionalShape</code>s. We can follow the arrows upward to identify direct and indirect <em>is-a</em> relationships. For instance, a <code>Triangle</code> <em>is a</em> <code>TwoDimensionalShape</code> and <em>is a</em> <code>Shape</code>, while a <code>Sphere</code> <em>is a</em> <code>ThreeDimensionalShape</code> and <em>is a</em> <code>Shape</code>.</p>&#13;
<p>The following class header specifies that <code>TwoDimensionalShape</code> inherits from <code>Shape</code>:</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p496pro01" id="p496pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">class</span> TwoDimensionalShape : <span class="blue">public</span> Shape</pre>&#13;
<p>This is <span class="violet"><strong><code>public</code></strong></span><strong><span class="violet"> inheritance</span></strong>, which we’ll use in this chapter. With <code>public</code> inheritance, <code>public</code> base-class members become <code>public</code> derived-class members and, as we’ll discuss later in this chapter, <code>protected</code> base-class members become <code>protected</code> derived-class members. <code>private</code> base-class members are not directly accessible in that class’s derived classes. However, these members are still inherited and part of the derived-class objects. The derived class can manipulate <code>private</code> base-class members through inherited base-class <code>public</code> and <code>protected</code> member functions—if these base-class member functions provide such functionality. We’ll also discuss <code>private</code> and <code>protected</code> inheritance (<a href="ch10.xhtml#sec10_16">Section 10.16</a>).</p>&#13;
<p><span class="size">SE</span> <img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Inheritance is not appropriate for every class relationship</strong>. Composition’s <em>has-a</em> relationship sometimes is more appropriate. For example, given <code>Employee</code>, <code>BirthDate</code> and <code>PhoneNumber</code> classes, it’s improper to say that an <code>Employee</code> <em>is a</em> <code>BirthDate</code> or that an <code>Employee</code> <em>is a</em> <code>PhoneNumber</code>. However, an <code>Employee</code> <em>has a</em> <code>BirthDate</code> and <em>has a</em> <code>PhoneNumber</code>.</p>&#13;
<p><strong>It’s possible to treat base-class objects and derived-class objects similarly—their commonalities are expressed in the base-class members.</strong> Later in this chapter, we’ll consider examples that take advantage of that relationship.</p>&#13;
<h3 class="h3" id="sec10_3"><span class="violet">10.3</span> Relationship between Base and Derived Classes</h3>&#13;
<p>This section uses an inheritance hierarchy of employee types in a company’s payroll application to demonstrate the relationship between base and derived classes:</p>&#13;
<p class="bull">• Base-class salaried employees are paid a fixed weekly salary.</p>&#13;
<p class="bull">• Derived-class salaried commission employees receive a weekly salary <em>plus</em> a percentage of their sales.</p>&#13;
<h4 class="h4" id="sec10_3_1">10.3.1 Creating and Using a <code>SalariedEmployee</code> Class</h4>&#13;
<p>Let’s examine <code>SalariedEmployee</code>’s class definition (Figs. 10.1–10.2). Its header (<a href="ch10.xhtml#fig10_1">Fig. 10.1</a>) specifies the class’s <code>public</code> services:</p>&#13;
<p class="bull">• a constructor (line 9),</p>&#13;
<p class="bull">• member function <code>earnings</code> (line 17),</p>&#13;
<p class="bull">• member function <code>toString</code> (line 18), and</p>&#13;
<p class="bull">• <code>public</code> <em>get</em> and <em>set</em> functions that manipulate the class’s data members <code>m_name</code> and <code>m_salary</code> (declared in lines 20–21).</p>&#13;
<p>Member function <code>setSalary</code>’s implementation (<a href="ch10.xhtml#fig10_2">Fig. 10.2</a>, lines 23–29) validates its argument before modifying the data member <code>m_salary</code>.</p>&#13;
<div class="group" id="fig10_1">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro01" id="p10pro01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.1: SalariedEmployee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// SalariedEmployee class definition.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">class</span> SalariedEmployee {&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>9</strong></span>      SalariedEmployee(std::string_view name, <span class="blue">double</span> salary);&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">void</span> setName(std::string_view name);&#13;
<span class="cviolet"><strong>12</strong></span>      std::string getName() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">void</span> setSalary(<span class="blue">double</span> salary);&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="blue">double</span> getSalary() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>18</strong></span>      std::string toString() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>20</strong></span>      std::string m_name{};&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">double</span> m_salary{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>22</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.1</strong></span> | <code>SalariedEmployee</code> class definition.</p>&#13;
</div>&#13;
<div class="group" id="fig10_2">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro02" id="p10pro02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.2: SalariedEmployee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Class SalariedEmployee member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span> <span class="lgreen">// SalariedEmployee class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   SalariedEmployee::SalariedEmployee(string_view name, <span class="blue">double</span> salary)&#13;
<span class="cviolet"><strong>10</strong></span>      : m_name{name} {&#13;
<span class="cviolet"><strong>11</strong></span>      setSalary(salary);&#13;
<span class="cviolet"><strong>12</strong></span>   }&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="lgreen">// set name</span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">void</span> SalariedEmployee::setName(string_view name) {&#13;
<span class="cviolet"><strong>16</strong></span>      m_name = name; <span class="lgreen">// should validate</span>&#13;
<span class="cviolet"><strong>17</strong></span>   }&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="lgreen">// return name</span>&#13;
<span class="cviolet"><strong>20</strong></span>   string SalariedEmployee::getName() <span class="blue">const</span> {<span class="blue">return</span> m_name;}&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>   <span class="lgreen">// set salary</span>&#13;
<span class="cviolet"><strong>23</strong></span>   <span class="blue">void</span> SalariedEmployee::setSalary(<span class="blue">double</span> salary) {&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="blue">if</span> (salary &lt; <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>25</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Salary must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>26</strong></span>      }&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>      m_salary = salary;&#13;
<span class="cviolet"><strong>29</strong></span>   }&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>   <span class="lgreen">// return salary</span>&#13;
<span class="cviolet"><strong>32</strong></span>   <span class="blue">double</span> SalariedEmployee::getSalary() <span class="blue">const</span> {<span class="blue">return</span> m_salary;}&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>   <span class="lgreen">// calculate earnings</span>&#13;
<span class="cviolet"><strong>35</strong></span>   <span class="blue">double</span> SalariedEmployee::earnings() <span class="blue">const</span> {<span class="blue">return</span> getSalary();}&#13;
<span class="cviolet"><strong>36</strong></span>&#13;
<span class="cviolet"><strong>37</strong></span>   <span class="lgreen">// return string representation of SalariedEmployee object</span>&#13;
<span class="cviolet"><strong>38</strong></span>   string SalariedEmployee::toString() <span class="blue">const</span> {<span class="blue"/>&#13;
<span class="cviolet"><strong>39</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"name: {}\nsalary: ${:.2f}\n"</span>, getName(),&#13;
<span class="cviolet"><strong>40</strong></span>                getSalary());&#13;
<span class="cviolet"><strong>41</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.2</strong></span> | Class <code>SalariedEmployee</code> member-function definitions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec11"><code>SalariedEmployee</code> Constructor</h5>&#13;
<p>The class’s constructor (<a href="ch10.xhtml#fig10_2">Fig. 10.2</a>, lines 9–12) uses a member initializer list to initialize <code>m_name</code>. We could validate the name, perhaps by ensuring that it’s of a reasonable length. The constructor calls <code>setSalary</code> to validate and initialize data member <code>m_salary</code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec12"><code>SalariedEmployee</code> Member Functions <strong><code>earnings</code></strong> and <strong><code>toString</code></strong></h5>&#13;
<p>Function <code>earnings</code> (line 35) calls <code>getSalary</code> and returns the result, and <code>toString</code> (lines 38–41) returns a string containing a <code>SalariedEmployee</code> object’s data-member values.</p>&#13;
<h5 class="h5" id="ch10lev3sec13">Testing Class <code>SalariedEmployee</code></h5>&#13;
<p><a href="ch10.xhtml#fig10_3">Figure 10.3</a> tests class <code>SalariedEmployee</code>. Line 10 creates the <code>SalariedEmployee</code> object <code>employee</code>. Lines 13–15 demonstrate the <code>employee</code>’s <em>get</em> functions. Line 17 uses <code>setSalary</code> to change the <code>employee</code>’s <code>m_salary</code> value. Then, lines 18–19 call <code>employee</code>’s <code>toString</code> member function to get and output the <code>employee</code>’s updated information. Finally, line 22 displays the <code>employee</code>’s <code>earnings</code>, using the updated <code>m_salary</code> value.</p>&#13;
<div class="group" id="fig10_3">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro03" id="p10pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_03.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// SalariedEmployee class test program.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span> <span class="lgreen">// SalariedEmployee class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// instantiate a SalariedEmployee object</span>&#13;
<span class="cviolet"><strong>10</strong></span>      SalariedEmployee employee{<span class="green">"Sue Jones"</span>, <span class="green">300.0</span>};&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="lgreen">// get SalariedEmployee data</span>&#13;
<span class="cviolet"><strong>13</strong></span>      cout &lt;&lt; <span class="green">"Employee information obtained by get functions:\n"</span>&#13;
<span class="cviolet"><strong>14</strong></span>           &lt;&lt; fmt::format(<span class="green">"name: {}\nsalary: ${:.2f}\n"</span>, employee.getName(),&#13;
<span class="cviolet"><strong>15</strong></span>                 employee.getSalary());&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      employee.setSalary(<span class="green">500.0</span>); <span class="lgreen">// change salary</span>&#13;
<span class="cviolet"><strong>18</strong></span>      cout &lt;&lt; <span class="green">"\nUpdated employee information from function toString:\n"</span>&#13;
<span class="cviolet"><strong>19</strong></span>         &lt;&lt; employee.toString();&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="lgreen">// display only the employee's earnings</span>&#13;
<span class="cviolet"><strong>22</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"\nearnings: ${:.2f}\n"</span>, employee.earnings());&#13;
<span class="cviolet"><strong>23</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Employee information obtained by get functions:&#13;
name: Sue Jones&#13;
salary: $300.00&#13;
&#13;
Updated employee information from function toString:&#13;
name: Sue Jones&#13;
salary: $500.00&#13;
&#13;
earnings: $500.00</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.3</strong></span> | <code>SalariedEmployee</code> class test program.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec10_3_2">10.3.2 Creating a <code>SalariedEmployee</code> – <code>SalariedCommissionEmployee</code> Inheritance Hierarchy</h4>&#13;
<p>Let’s create a <code>SalariedCommissionEmployee</code> class (Figs. 10.4–10.5) that inherits from <code>SalariedEmployee</code> (Figs. 10.1–10.2). In this example, a <code>SalariedCommissionEmployee</code> object <em>is a</em> <code>SalariedEmployee</code>—<code>public</code> inheritance passes on <code>SalariedEmployee</code>’s capabilities. A <code>SalariedCommissionEmployee</code> also has <code>m_grossSales</code> and <code>m_commissionRate</code> data members (<a href="ch10.xhtml#fig10_4">Fig. 10.4</a>, lines 22–23), which we’ll multiply to calculate the commission earned. Lines 13–17 declare <code>public</code> <em>get</em> and <em>set</em> functions that manipulate the class’s data members.</p>&#13;
<div class="group" id="fig10_4">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro04" id="p10pro04a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.4: SalariedCommissionEmployee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// SalariedCommissionEmployee class derived from class SalariedEmployee.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">class</span> SalariedCommissionEmployee : <span class="blue">public</span> SalariedEmployee {&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>10</strong></span>      SalariedCommissionEmployee(std::string_view name, <span class="blue">double</span> salary,&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="blue">double</span> grossSales, <span class="blue">double</span> commissionRate);&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">void</span> setGrossSales(<span class="blue">double</span> grossSales);&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">double</span> getGrossSales() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">void</span> setCommissionRate(<span class="blue">double</span> commissionRate);&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">double</span> getCommissionRate() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>20</strong></span>      std::string toString() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">double</span> m_grossSales{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">double</span> m_commissionRate{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>24</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.4</strong></span> | <code>SalariedCommissionEmployee</code> class definition indicating inheritance relationship with class <code>CommissionEmployee</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec14">Inheritance</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The <strong><span class="violet">colon (<code>:</code>)</span></strong> in line 8 indicates inheritance. The keyword <code>public</code> specifies the inheritance type. With <code>public</code> inheritance, <code>public</code> base-class members remain <code>public</code> in the derived class and, as you’ll see later, <code>protected</code> base-class members remain <code>protected</code> in the derived class. <code>SalariedCommissionEmployee</code> inherits all of <code>SalariedEmployee</code>’s members, <em>except</em> its constructor(s) and destructor. <strong>Constructors and destructors are specific to the class that defines them, so derived classes have their own.</strong><sup><a id="ch10fn5a" href="ch10.xhtml#ch10fn5">5</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn5" href="ch10.xhtml#ch10fn5a">5</a>. It’s common in a derived-class constructor to simply pass its arguments to a corresponding base-class constructor and do nothing else. We’ll see in <a href="ch19.xhtml#ch19">Chapter 19</a>, Other Topics, that inserting a <code>using</code> declaration in a derived class enables you to inherit the base class’s constructors.</p>&#13;
<h5 class="h5" id="ch10lev3sec15"><code>SalariedCommissionEmployee</code> Member Functions</h5>&#13;
<p>Class <code>SalariedCommissionEmployee</code>’s <code>public</code> services (<a href="ch10.xhtml#fig10_4">Fig. 10.4</a>) include:</p>&#13;
<p class="bull">• its own constructor (lines 10–11),</p>&#13;
<p class="bull">• the member functions <code>setGrossSales</code>, <code>getGrossSales</code>, <code>setCommissionRate</code>, <code>getCommissionRate</code>, <code>earnings</code> and <code>toString</code> (lines 13–20), and</p>&#13;
<p class="bull">• the <code>public</code> member functions inherited from class <code>SalariedEmployee</code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Although <code>SalariedCommissionEmployee</code>’s source code does not contain these inherited members, they’re nevertheless a part of the class</strong>. A <code>SalariedCommissionEmployee</code> object also contains <code>SalariedEmployee</code>’s <code>private</code> members, but <strong>they’re not directly accessible</strong> within the derived class. You can access them only via the inherited <code>SalariedEmployee public</code> (or <code>protected</code>) member functions.</p>&#13;
<h5 class="h5" id="ch10lev3sec16"><code>SalariedCommissionEmployee</code>’s Implementation</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <a href="ch10.xhtml#fig10_5">Figure 10.5</a> shows <code>SalariedCommissionEmployee</code>’s member-function implementations. <strong>Each derived-class constructor must call a base-class constructor</strong>. We do this explicitly via a <strong><span class="violet">base-class initializer</span></strong> (line 11)—that is, a member initializer that passes arguments to a base-class constructor. In the <code>SalariedCommissionEmployee</code> constructor (lines 9–15), line 11 calls <code>SalariedEmployee</code>’s constructor, which initializes the inherited data members with the arguments <code>name</code> and <code>salary</code>. A base-class initializer explicitly invokes the base-class constructor by name. Member functions <code>setGrossSales</code> (lines 18–24) and <code>setCommissionRate</code> (lines 32–40) validate their arguments before modifying the data members <code>m_grossSales</code> and <code>m_commissionRate</code>.</p>&#13;
<div class="group" id="fig10_5">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro05" id="p10pro05a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.5: SalariedCommissionEmployee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Class SalariedCommissionEmployee member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedCommissionEmployee.h"</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   SalariedCommissionEmployee::SalariedCommissionEmployee(string_view name,&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">double</span> salary, <span class="blue">double</span> grossSales, <span class="blue">double</span> commissionRate)&#13;
<span class="cviolet"><strong>11</strong></span>      : SalariedEmployee{name, salary} { <span class="lgreen">// call base-class constructor</span>&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      setGrossSales(grossSales); <span class="lgreen">// validate &amp; store gross sales</span>&#13;
<span class="cviolet"><strong>14</strong></span>      setCommissionRate(commissionRate); <span class="lgreen">// validate &amp; store commission rate</span>&#13;
<span class="cviolet"><strong>15</strong></span>   }&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// set gross sales amount</span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">void</span> SalariedCommissionEmployee::setGrossSales(<span class="blue">double</span> grossSales) {&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">if</span> (grossSales &lt; <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>20</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Gross sales must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>21</strong></span>      }&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>      m_grossSales = grossSales;&#13;
<span class="cviolet"><strong>24</strong></span>   }&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="lgreen">// return gross sales amount</span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="blue">double</span> SalariedCommissionEmployee::getGrossSales() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="blue">return</span> m_grossSales;&#13;
<span class="cviolet"><strong>29</strong></span>   }&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>   <span class="lgreen">// set commission rate</span>&#13;
<span class="cviolet"><strong>32</strong></span>   <span class="blue">void</span> SalariedCommissionEmployee::setCommissionRate(&#13;
<span class="cviolet"><strong>33</strong></span>      <span class="blue">double</span> commissionRate) {&#13;
<span class="cviolet"><strong>34</strong></span>&#13;
<span class="cviolet"><strong>35</strong></span>      <span class="blue">if</span> (commissionRate &lt;= <span class="green">0.0</span> || commissionRate &gt;= <span class="green">1.0</span>) {&#13;
<span class="cviolet"><strong>36</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Commission rate must be &gt; 0.0 and &lt; 1.0"</span>);&#13;
<span class="cviolet"><strong>37</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>38</strong></span>&#13;
<span class="cviolet"><strong>39</strong></span>      m_commissionRate = commissionRate;&#13;
<span class="cviolet"><strong>40</strong></span>   }&#13;
<span class="cviolet"><strong>41</strong></span>&#13;
<span class="cviolet"><strong>42</strong></span>   <span class="lgreen">// get commission rate</span>&#13;
<span class="cviolet"><strong>43</strong></span>   <span class="blue">double</span> SalariedCommissionEmployee::getCommissionRate() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>44</strong></span>      <span class="blue">return</span> m_commissionRate;&#13;
<span class="cviolet"><strong>45</strong></span>   }&#13;
<span class="cviolet"><strong>46</strong></span>&#13;
<span class="cviolet"><strong>47</strong></span>   <span class="lgreen">// calculate earnings--uses SalariedEmployee::earnings()</span>&#13;
<span class="cviolet"><strong>48</strong></span>   <span class="blue">double</span> SalariedCommissionEmployee::earnings() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>49</strong></span>      <span class="blue">return</span> SalariedEmployee::earnings() +&#13;
<span class="cviolet"><strong>50</strong></span>         getGrossSales() * getCommissionRate();&#13;
<span class="cviolet"><strong>51</strong></span>   }&#13;
<span class="cviolet"><strong>52</strong></span>&#13;
<span class="cviolet"><strong>53</strong></span>   <span class="lgreen">// returns string representation of SalariedCommissionEmployee object</span>&#13;
<span class="cviolet"><strong>54</strong></span>   <span class="blue">string</span> SalariedCommissionEmployee::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>55</strong></span>      <span class="blue">return</span> fmt::format(&#13;
<span class="cviolet"><strong>56</strong></span>         <span class="green">"{}gross sales: ${:.2f}\ncommission rate: {:.2f}\n"</span>,&#13;
<span class="cviolet"><strong>57</strong></span>         SalariedEmployee::toString(), getGrossSales(), getCommissionRate());&#13;
<span class="cviolet"><strong>58</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.5</strong></span> | Class <code>SalariedCommissionEmployee</code> member-function definitions. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec17"><code>SalariedCommissionEmployee</code> Member Function <strong><code>earnings</code></strong></h5>&#13;
<p><code>SalariedCommissionEmployee</code>’s <code>earnings</code> function (lines 48–51) redefines <code>earnings</code> from class <code>SalariedEmployee</code> (<a href="ch10.xhtml#fig10_2">Fig. 10.2</a>, line 35) to calculate a <code>SalariedCommissionEmployee</code>’s earnings. Line 49 in <code>SalariedCommissionEmployee</code>’s version uses the expression</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p500pro01" id="p500pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>SalariedEmployee::earnings()</code></pre>&#13;
<p>to get the portion of the earnings based on salary, then adds that value to the commission to calculate the total earnings.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <strong>To call a redefined base-class member function from the derived class, place the base-class name and the scope resolution operator (<code>::</code>) before the base-class member-function name. <code>SalariedEmployee::</code> is required here to avoid infinite recursion.</strong> Also, by calling <code>SalariedEmployee</code>’s <code>earnings</code> function from <code>SalariedCommissionEmployee</code>’s <code>earnings</code> function, <strong>we avoid duplicating code</strong>.<sup><a id="ch10fn6a" href="ch10.xhtml#ch10fn6">6</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn6" href="ch10.xhtml#ch10fn6a">6</a>. That’s the upside. The downside is that this creates a coupling between base and derived classes that can make large-scale systems difficult to modify.</p>&#13;
<h5 class="h5" id="ch10lev3sec18"><code>SalariedCommissionEmployee</code> Member Function <strong><code>toString</code></strong></h5>&#13;
<p>Similarly, <code>SalariedCommissionEmployee</code>’s <code>toString</code> function (<a href="ch10.xhtml#fig10_5">Fig. 10.5</a>, lines 54–58) <strong>redefines</strong> class <code>SalariedEmployee</code>’s <code>toString</code> function (<a href="ch10.xhtml#fig10_2">Fig. 10.2</a>, lines 38–41). The new version returns a <code>string</code> containing:</p>&#13;
<p class="bull">• the result of calling <code>SalariedEmployee::toString()</code> (<a href="ch10.xhtml#fig10_5">Fig. 10.5</a>, line 57), and</p>&#13;
<p class="bull">• the <code>SalariedCommissionEmployee</code>’s gross sales and commission rate.</p>&#13;
<h5 class="h5" id="ch10lev3sec19">Testing Class <code>SalariedCommissionEmployee</code></h5>&#13;
<p><a href="ch10.xhtml#fig10_6">Figure 10.6</a> creates the <code>SalariedCommissionEmployee</code> object <code>employee</code> (line 10). Lines 13–17 output the <code>employee</code>’s data by calling its <em>get</em> functions to retrieve the object’s data member values. Lines 19–20 use <code>setGrossSales</code> and <code>setCommissionRate</code> to change the <code>employee</code>’s <code>m_grossSales</code> and <code>m_commissionRate</code> values, respectively. Then, lines 21–22 call <code>employee</code>’s <code>toString</code> member function to get and output the <code>employee</code>’s updated information. Finally, line 25 displays the <code>employee</code>’s earnings, which are calculated using the updated <code>m_grossSales</code> and <code>m_commissionRate</code> values.</p>&#13;
<div class="group" id="fig10_6">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro06" id="p10pro06a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_06.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// SalariedCommissionEmployee class test program.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedCommissionEmployee.h"</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// instantiate SalariedCommissionEmployee object</span>&#13;
<span class="cviolet"><strong>10</strong></span>      SalariedCommissionEmployee employee{<span class="green">"Bob Lewis"</span>, <span class="green">300.0</span>, <span class="green">5000.0</span>, <span class="green">.04</span>};&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="lgreen">// get SalariedCommissionEmployee data</span>&#13;
<span class="cviolet"><strong>13</strong></span>      cout &lt;&lt; <span class="green">"Employee information obtained by get functions:\n"</span>&#13;
<span class="cviolet"><strong>14</strong></span>           &lt;&lt; fmt::format(<span class="green">"{}: {}\n{}: {:.2f}\n{}: {:.2f}\n{}: {:.2f}\n"</span>,&#13;
<span class="cviolet"><strong>15</strong></span>                 <span class="green">"name"</span>, employee.getName(), <span class="green">"salary"</span>, employee.getSalary(),&#13;
<span class="cviolet"><strong>16</strong></span>                 <span class="green">"gross sales"</span>, employee.getGrossSales(),&#13;
<span class="cviolet"><strong>17</strong></span>                 <span class="green">"commission"</span>, employee.getCommissionRate());&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      employee.setGrossSales(<span class="green">8000.0</span>); <span class="lgreen">// change gross sales</span>&#13;
<span class="cviolet"><strong>20</strong></span>      employee.setCommissionRate(<span class="green">0.1</span>); <span class="lgreen">// change commission rate</span>&#13;
<span class="cviolet"><strong>21</strong></span>      cout &lt;&lt; <span class="green">"\nUpdated employee information from function toString:\n"</span>&#13;
<span class="cviolet"><strong>22</strong></span>         &lt;&lt; employee.toString();&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="lgreen">// display the employee's earnings</span>&#13;
<span class="cviolet"><strong>25</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"\nearnings: ${:.2f}\n"</span>, employee.earnings());&#13;
<span class="cviolet"><strong>26</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">Employee information obtained by get functions:&#13;
name: Bob Lewis&#13;
salary: $300.00&#13;
gross sales: $5000.00&#13;
commission: 0.04&#13;
&#13;
Updated employee information from function toString:&#13;
name: Bob Lewis&#13;
salary: $300.00&#13;
gross sales: $8000.00&#13;
commission rate: 0.10&#13;
&#13;
earnings: $1100.00</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.6</strong></span> | <code>SalariedCommissionEmployee</code> class test program.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec20">A Derived-Class Constructor Must Call Its Base Class’s Constructor</h5>&#13;
<p>The compiler would issue an error if <code>SalariedCommissionEmployee</code>’s constructor did not invoke class <code>SalariedEmployee</code>’s constructor explicitly. In this case, the compiler would attempt to call class <code>SalariedEmployee</code>’s default constructor, which does not exist because the base class explicitly defined a constructor. <strong>If the base-class provides a default constructor, the derived-class constructor can call the base-class constructor implicitly.</strong></p>&#13;
<h5 class="h5" id="ch10lev3sec21">Notes on Constructors in Derived Classes</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <strong>A derived-class constructor must call its base class’s constructor with any required arguments; otherwise, a compilation error occurs. This ensures that inherited <code>private</code> base-class members, which the derived class cannot access directly, get initialized.</strong> The derived class’s data-member initializers are typically placed after base-class initializers in the member-initializer list.</p>&#13;
<h5 class="h5" id="ch10lev3sec22">Base-Class <code>private</code> Members Are Not Directly Accessible in a Derived Class</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> C++ rigidly enforces restrictions on accessing <code>private</code> data members. <strong>Even a derived class, which is intimately related to its base class, cannot directly access its base class’s <code>private</code> data</strong>. For example, class <code>SalariedEmployee</code>’s <code>private m_salary</code> data member, though part of each <code>SalariedCommissionEmployee</code> object, cannot be accessed by class <code>Salaried-CommissionEmployee</code>’s member functions directly. If they try, the compiler produces an error message, such as the following from GNU <code>g++</code>:</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p502pro01" id="p502pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>‘double SalariedEmployee::m_salary’ is private within this context</code></pre>&#13;
<p>However, as you saw in <a href="ch10.xhtml#fig10_5">Fig. 10.5</a>, <code>SalariedCommissionEmployee</code>’s member functions can access the <code>public</code> members inherited from class <code>SalariedEmployee</code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec23">Including the Base-Class Header in the Derived-Class Header</h5>&#13;
<p>Notice that we <code>#include</code> the base class’s header in the derived class’s header (<a href="ch10.xhtml#fig10_4">Fig. 10.4</a>, line 6). This is necessary for several reasons:</p>&#13;
<p class="bull">• For the derived class to inherit from the base class in line 8 (<a href="ch10.xhtml#fig10_4">Fig. 10.4</a>), the compiler requires the base-class definition from <code>SalariedEmployee.h</code>.</p>&#13;
<p class="bull">• <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/>  <strong>The compiler determines an object’s size from its class’s definition.</strong> A program that creates an object must know the class definition so the compiler can reserve the proper amount of memory for the object. <strong>A derived-class object’s size depends on the data members declared explicitly in its class definition <em>and</em> the data members inherited from its direct and indirect base classes</strong>.<sup><a id="ch10fn7a" href="ch10.xhtml#ch10fn7">7</a></sup> Including the base class’s definition allows the compiler to determine the complete memory requirements for all the data members that contribute to a derived-class object’s total size.</p>&#13;
<p class="footnote"><a id="ch10fn7" href="ch10.xhtml#ch10fn7a">7</a>. All objects of a class share one copy of the class’s member functions, which are stored separately from those objects and are not part of their size.</p>&#13;
<p class="bull">• The base-class definition also enables the compiler to determine whether the derived class uses the base class’s inherited members properly. For example, <strong>the compiler prevents a derived class from accessing the base class’s <code>private</code> data directly</strong>. <strong>The compiler also uses the base class’s function prototypes to validate derived-class function calls to inherited base-class functions</strong>.</p>&#13;
<h5 class="h5" id="ch10lev3sec24">Eliminating Repeated Code Via Implementation Inheritance</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> With implementation inheritance, the base class declares the common data members and member functions of all the classes in the hierarchy. When changes are required for these common features, you make the changes only in the base class. The derived classes then inherit the changes and must be recompiled. Without inheritance, changes would need to be made to all the source-code files that contain a copy of the code in question.<sup><a id="ch10fn8a" href="ch10.xhtml#ch10fn8">8</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn8" href="ch10.xhtml#ch10fn8a">8</a>. Again, the downside of implementation inheritance, especially in deep inheritance hierarchies, is that it creates a tight coupling among the classes in the inheritance hierarchy, making it difficult to modify.</p>&#13;
<h3 class="h3" id="sec10_4"><span class="violet">10.4</span> Constructors and Destructors in Derived Classes</h3>&#13;
<h5 class="h5" id="ch10lev3sec25">Order of Constructor Calls</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Instantiating a derived-class object begins a <strong><span class="violet">chain of constructor calls</span></strong>. <strong><em>Before</em> performing its own tasks, a derived-class constructor invokes its direct base class’s constructor either explicitly via a base-class member initializer or implicitly by calling the base class’s default constructor</strong>. The last constructor called in this chain is for the base class at the top of the hierarchy. That constructor finishes executing <em>first</em>, and the most-derived-class constructor’s body finishes executing <em>last</em>.</p>&#13;
<p>Each base-class constructor initializes the base-class data members that its derived-classes inherit. In the <code>SalariedEmployee</code>/<code>SalariedCommissionEmployee</code> hierarchy we’ve been studying, when we create a <code>SalariedCommissionEmployee</code> object:</p>&#13;
<p class="bull">• Its constructor immediately calls the <code>SalariedEmployee</code> constructor.</p>&#13;
<p class="bull">• <code>SalariedEmployee</code> is this hierarchy’s base class, so the <code>SalariedEmployee</code> constructor executes, initializing the <code>SalariedCommissionEmployee</code> object’s inherited <code>SalariedEmployee m_name</code> and <code>m_salary</code> data members.</p>&#13;
<p class="bull">• <code>SalariedEmployee</code>’s constructor then returns control to <code>SalariedCommission-Employee</code>’s constructor to initialize <code>m_grossSales</code> and <code>m_commissionRate</code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec26">Order of Destructor Calls</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> When a derived-class object is destroyed, the program calls that object’s destructor. This begins a <strong><span class="violet">chain of destructor calls</span></strong>. <strong>The destructors execute in the reverse order of the constructors</strong>. When a derived-class object’s destructor is called, it performs its task, then invokes the destructor of the next class up the hierarchy. This repeats until the destructor of the base class at the hierarchy’s top is called.</p>&#13;
<h5 class="h5" id="ch10lev3sec27">Constructors and Destructors for Composed Objects</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Suppose we create a derived-class object where both the base class and the derived class are composed of objects of other classes. When a derived-class object is created:</p>&#13;
<p class="bull">• First, the constructors for the base class’s member objects execute in the order those objects were declared,</p>&#13;
<p class="bull">• then the base-class constructor body executes,</p>&#13;
<p class="bull">• then the constructors for the derived class’s member objects execute in the order those objects were declared in the derived class,</p>&#13;
<p class="bull">• then the derived class’s constructor body executes.</p>&#13;
<p><strong>Destructors for data members are called in the reverse of the order from which their corresponding constructors were called</strong>.</p>&#13;
<h3 class="h3" id="sec10_5"><span class="violet">10.5</span> Intro to Runtime Polymorphism: Polymorphic Video Game</h3>&#13;
<p>Suppose we’re designing a video game containing <code>Martian</code>s, <code>Venusian</code>s, <code>Plutonian</code>s, <code>SpaceShip</code>s and <code>LaserBeam</code>s. Each inherits from a <code>SpaceObject</code> base class with the member function <code>draw</code> and implements this function in a manner appropriate to the derived class.</p>&#13;
<h5 class="h5" id="ch10lev3sec28">Screen Manager</h5>&#13;
<p>A screen-manager program maintains a <code>vector</code> of <code>SpaceObject</code> pointers to objects of the various classes. <strong>To refresh the screen, the screen manager periodically sends each object the same <code>draw</code> message, and each object responds in its unique way</strong>. For example,</p>&#13;
<p class="bull">• a <code>Martian</code> might draw itself in red with the appropriate number of antennae,</p>&#13;
<p class="bull">• a <code>SpaceShip</code> might draw itself as a silver flying saucer, and</p>&#13;
<p class="bull">• a <code>LaserBeam</code> might draw itself as a bright red beam across the screen.</p>&#13;
<p>The same <code>draw</code> message has <strong>many forms</strong> of results—hence the term <strong>polymorphism</strong>.</p>&#13;
<h5 class="h5" id="ch10lev3sec29">Adding New Classes to the System</h5>&#13;
<p>A polymorphic screen manager facilitates adding new classes to a system with minimal code modifications. Suppose we want to add <code>Mercurian</code> objects to our game. We build a class <code>Mercurian</code> that inherits from <code>SpaceObject</code> and defines <code>draw</code>, then add the object’s address to the <code>vector</code> of <code>SpaceObject</code> pointers. The screen-manager code invokes member function <code>draw</code> the same way for every object the <code>vector</code> points to, regardless of the object’s type. So, the new <code>Mercurian</code> objects just “<strong>plug right in</strong>.” <strong>Without modifying the system—other than to create objects of the new classes—you can use runtime polymorphism to accommodate additional classes, including ones not envisioned when the system was created.</strong></p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Runtime polymorphism enables you to deal in <strong>generalities</strong> and let the execution-time environment concern itself with the <strong>specifics</strong>. You can direct objects to behave in appropriate manners without knowing their types, as long as those objects belong to the same class hierarchy and are being accessed via a common base-class pointer or reference.<sup><a id="ch10fn9a" href="ch10.xhtml#ch10fn9">9</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn9" href="ch10.xhtml#ch10fn9a">9</a>. We’ll see that there are forms of runtime polymorphism and compile-time polymorphism that do not depend on inheritance hierarchies.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Runtime polymorphism promotes <strong>extensibility</strong>. Software that invokes polymorphic behavior is written independently of the specific object types to which messages are sent. Thus, new object types that can respond to existing messages can simply be plugged into such a system without modifying the base system. Only client code that instantiates new objects must be modified to accommodate new types.</p>&#13;
<h3 class="h3" id="sec10_6"><span class="violet">10.6</span> Relationships Among Objects in an Inheritance Hierarchy</h3>&#13;
<p><a href="ch10.xhtml#sec10_3">Section 10.3</a> created a <code>SalariedEmployee</code>–<code>SalariedCommissionEmployee</code> class hierarchy. Let’s examine the relationships among classes in an inheritance hierarchy more closely.</p>&#13;
<p>The next several sections present examples demonstrating how base-class and derived-class pointers can be aimed at base-class and derived-class objects, and how those pointers can be used to invoke member functions that manipulate those objects:</p>&#13;
<p class="bull">• In <a href="ch10.xhtml#sec10_6_1">Section 10.6.1</a>, we assign a derived-class object’s address to a base-class pointer, then show that invoking a function via the base-class pointer invokes the <em>base-class</em> functionality in the derived-class object. <strong>The handle’s type determines which function is called</strong>.</p>&#13;
<p class="bull">• In <a href="ch10.xhtml#sec10_6_2">Section 10.6.2</a>, we assign a base-class object’s address to a derived-class pointer to show the resulting compilation error. We discuss the error message and investigate why the compiler does not allow such an assignment.</p>&#13;
<p class="bull">• In <a href="ch10.xhtml#sec10_6_3">Section 10.6.3</a>, we assign a derived-class object’s address to a base-class pointer, then examine how the base-class pointer can be used to invoke only the base-class functionality. <strong>When we attempt to invoke derived-class-only member functions through the base-class pointer, compilation errors occur.</strong></p>&#13;
<p class="bull">• Finally, in <a href="ch10.xhtml#sec10_7">Section 10.7</a>, we introduce <strong>virtual functions</strong> to demonstrate how to get <strong>runtime polymorphic behavior</strong> from base-class pointers aimed at derived-class objects. We then <strong>assign a derived-class object’s address to a base-class pointer and use that pointer to invoke derived-class functionality—precisely what we need to achieve runtime polymorphic behavior.</strong></p>&#13;
<p>These examples demonstrate that <strong>with <code>public</code> inheritance, an object of a derived class can be treated as an object of its base class</strong>. This enables various interesting manipulations. For example, a program can create a <code>vector</code> of base-class pointers that point to objects of many derived-class types. The compiler allows this because each derived-class object <em>is an</em> object of its base class.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> On the other hand, <strong>you cannot treat a base-class object as an object of a derived class</strong>. For example, a <code>SalariedEmployee</code> is not a <code>SalariedCommissionEmployee</code>—it’s missing the data members <code>m_grossSales</code> or <code>m_commissionRate</code> and does not have their corresponding <em>set</em> and <em>get</em> member functions. <strong>The <em>is-a</em> relationship applies only from a derived class to its direct and indirect base classes.</strong></p>&#13;
<h4 class="h4" id="sec10_6_1">10.6.1 Invoking Base-Class Functions from Derived-Class Objects</h4>&#13;
<p><a href="ch10.xhtml#fig10_7">Figure 10.7</a> reuses classes <code>SalariedEmployee</code> and <code>SalariedCommissionEmployee</code> from <a href="ch10.xhtml#sec10_3_1">Sections 10.3.1</a>–<a href="ch10.xhtml#sec10_3_2">10.3.2</a>. The example demonstrates aiming base-class and derived-class pointers at base-class and derived-class objects. The first two are natural and straightforward:</p>&#13;
<p class="bull">• we aim a base-class pointer at a base-class object and invoke base-class functionality, and</p>&#13;
<p class="bull">• we aim a derived-class pointer at a derived-class object and invoke derived-class functionality.</p>&#13;
<p>Then, we demonstrate the <em>is-a</em> relationship between derived classes and base classes by aiming a base-class pointer at a derived-class object and showing that <strong>the base-class functionality is indeed available in the derived-class object</strong>.</p>&#13;
<div class="group" id="fig10_7">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro07" id="p10pro07a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_07.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Aiming base-class and derived-class pointers at base-class</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// and derived-class objects, respectively.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedCommissionEmployee.h"</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="lgreen">// create base-class object</span>&#13;
<span class="cviolet"><strong>12</strong></span>      SalariedEmployee salaried{<span class="green">"Sue Jones"</span>, <span class="green">500.0</span>};&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="lgreen">// create derived-class object</span>&#13;
<span class="cviolet"><strong>15</strong></span>      SalariedCommissionEmployee salariedCommission{&#13;
<span class="cviolet"><strong>16</strong></span>         <span class="green">"Bob Lewis"</span>, <span class="green">300.0</span>, <span class="green">5000.0</span>, <span class="green">.04</span>};&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="lgreen">// output objects salaried and salariedCommission</span>&#13;
<span class="cviolet"><strong>19</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}:\n{}\n{}\n"</span>,&#13;
<span class="cviolet"><strong>20</strong></span>                 <span class="green">"DISPLAY BASE-CLASS AND DERIVED-CLASS OBJECTS"</span>,&#13;
<span class="cviolet"><strong>21</strong></span>                 salaried.toString(), <span class="lgreen">// base-class toString</span>&#13;
<span class="cviolet"><strong>22</strong></span>                 salariedCommission.toString()); <span class="lgreen">// derived-class toString</span>&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="lgreen">// natural: aim base-class pointer at base-class object</span>&#13;
<span class="cviolet"><strong>25</strong></span>      SalariedEmployee* salariedPtr{&amp;salaried};&#13;
<span class="cviolet"><strong>26</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\n{}:\n{}\n"</span>,&#13;
<span class="cviolet"><strong>27</strong></span>                 <span class="green">"CALLING TOSTRING WITH BASE-CLASS POINTER TO"</span>,&#13;
<span class="cviolet"><strong>28</strong></span>                 <span class="green">"BASE-CLASS OBJECT INVOKES BASE-CLASS FUNCTIONALITY"</span>,&#13;
<span class="cviolet"><strong>29</strong></span>                 salariedPtr-&gt;toString()); <span class="lgreen">// base-class version</span>&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>      <span class="lgreen">// natural: aim derived-class pointer at derived-class object</span>&#13;
<span class="cviolet"><strong>32</strong></span>      SalariedCommissionEmployee* salariedCommissionPtr{&amp;salariedCommission};&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\n{}:\n{}\n"</span>,&#13;
<span class="cviolet"><strong>35</strong></span>                 <span class="green">"CALLING TOSTRING WITH DERIVED-CLASS POINTER TO"</span>,&#13;
<span class="cviolet"><strong>36</strong></span>                 <span class="green">"DERIVED-CLASS OBJECT INVOKES DERIVED-CLASS FUNCTIONALITY"</span>,&#13;
<span class="cviolet"><strong>37</strong></span>                 salariedCommissionPtr-&gt;toString()); <span class="lgreen">// derived-class version</span>&#13;
<span class="cviolet"><strong>38</strong></span>&#13;
<span class="cviolet"><strong>39</strong></span>      <span class="lgreen">// aim base-class pointer at derived-class object</span>&#13;
<span class="cviolet"><strong>40</strong></span>      salariedPtr = &amp;salariedCommission;&#13;
<span class="cviolet"><strong>41</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\n{}:\n{}\n"</span>,&#13;
<span class="cviolet"><strong>42</strong></span>                 <span class="green">"CALLING TOSTRING WITH BASE-CLASS POINTER TO DERIVED-CLASS"</span>,&#13;
<span class="cviolet"><strong>43</strong></span>                 <span class="green">"OBJECT INVOKES BASE-CLASS FUNCTIONALITY"</span>,&#13;
<span class="cviolet"><strong>44</strong></span>                 salariedPtr-&gt;toString()); <span class="lgreen">// base version</span>&#13;
<span class="cviolet"><strong>45</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">DISPLAY BASE-CLASS AND DERIVED-CLASS OBJECTS:&#13;
name: Sue Jones&#13;
salary: $500.00&#13;
&#13;
name: Bob Lewis&#13;
salary: $300.00&#13;
gross sales: $5000.00&#13;
commission rate: 0.04&#13;
&#13;
CALLING TOSTRING WITH BASE-CLASS POINTER TO&#13;
BASE-CLASS OBJECT INVOKES BASE-CLASS FUNCTIONALITY:&#13;
name: Sue Jones&#13;
salary: $500.00&#13;
&#13;
CALLING TOSTRING WITH DERIVED-CLASS POINTER TO&#13;
DERIVED-CLASS OBJECT INVOKES DERIVED-CLASS FUNCTIONALITY:&#13;
name: Bob Lewis&#13;
salary: $300.00&#13;
gross sales: $5000.00&#13;
commission rate: 0.04&#13;
&#13;
CALLING TOSTRING WITH BASE-CLASS POINTER TO DERIVED-CLASS&#13;
OBJECT INVOKES BASE-CLASS FUNCTIONALITY:&#13;
name: Bob Lewis&#13;
salary: $300.00</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.7</strong></span> | Assigning addresses of base-class and derived-class objects to base-class and derived-class pointers. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>Recall that a <code>SalariedCommissionEmployee</code> object <em>is a</em> <code>SalariedEmployee</code> that also earns a commission based on gross sales. <code>SalariedCommissionEmployee</code>’s <code>earnings</code> member function (<a href="ch10.xhtml#fig10_5">Fig. 10.5</a>, lines 48–51) <strong>redefines</strong> <code>SalariedEmployee</code>’s version (<a href="ch10.xhtml#fig10_2">Fig. 10.2</a>, line 35) to include the commission. <code>SalariedCommissionEmployee</code>’s <code>toString</code> member function (<a href="ch10.xhtml#fig10_5">Fig. 10.5</a>, lines 54–58) <strong>redefines</strong> <code>SalariedEmployee</code>’s version (<a href="ch10.xhtml#fig10_2">Fig. 10.2</a>, lines 38–41) to return the same information and the employee’s commission.</p>&#13;
<h5 class="h5" id="ch10lev3sec30">Creating Objects and Displaying Their Contents</h5>&#13;
<p>In <a href="ch10.xhtml#fig10_7">Fig. 10.7</a>, line 12 creates a <code>SalariedEmployee</code> object and lines 15–16 create a <code>SalariedCommissionEmployee</code> object. Lines 21 and 22 use each object’s name to invoke its <code>toString</code> member function.</p>&#13;
<h5 class="h5" id="ch10lev3sec31">Aiming a Base-Class Pointer at a Base-Class Object</h5>&#13;
<p>Line 25 initializes the <code>SalariedEmployee</code> pointer <code>salariedPtr</code> with the base-class object <code>salaried</code>’s address. Line 29 uses the pointer to invoke the <code>salaried</code> object’s <code>toString</code> member function from base-class <code>SalariedEmployee</code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec32">Aiming a Derived-Class Pointer at a Derived-Class Object</h5>&#13;
<p>Line 32 initializes <code>SalariedCommissionEmployee</code> pointer <code>salariedCommissionPtr</code> with derived-class object <code>salariedCommission</code>’s address. Line 37 uses the pointer to invoke the <code>salariedCommission</code> object’s <code>toString</code> member function from derived-class <code>Salaried-CommissionEmployee</code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec33">Aiming a Base-Class Pointer at a Derived-Class Object</h5>&#13;
<p>Line 40 assigns derived-class object <code>salariedCommission</code>’s address to <code>salariedPtr</code>—a base-class pointer. <strong>This “crossover” is allowed because a derived-class object <em>is an</em> object of its base class.</strong> Line 44 uses this pointer to invoke member function <code>toString</code>. <strong>Even though the base-class <code>SalariedEmployee</code> pointer points to a <code>SalariedCommissionEmployee</code> derived-class object, the <em>base class’s</em> <code>toString</code> member function is invoked</strong>. The gross sales and the commission rate are not displayed because they are not base-class members.</p>&#13;
<p>This program’s output shows that <strong>the invoked function depends on the pointer type (or reference type, as you’ll see) used to invoke the function</strong>, <em>not</em> the object type for which the member function is called. In <a href="ch10.xhtml#sec10_7">Section 10.7</a>, we’ll see that <strong>with <code>virtual</code> functions, it’s possible to invoke the object type’s functionality rather than that of the pointer (or reference) type</strong>—an important aspect of implementing runtime polymorphic behavior.</p>&#13;
<h4 class="h4" id="sec10_6_2">10.6.2 Aiming Derived-Class Pointers at Base-Class Objects</h4>&#13;
<p>Now, let’s try to aim a derived-class pointer at a base-class object (<a href="ch10.xhtml#fig10_8">Fig. 10.8</a>). Line 7 creates a <code>SalariedEmployee</code> object. Line 11 attempts to initialize a <code>SalariedCommissionEmployee</code> pointer with the base-class <code>salaried</code> object’s address. The compiler generates an error because a <code>SalariedEmployee</code> is <em>not</em> a <code>SalariedCommissionEmployee</code>.</p>&#13;
<div class="group" id="fig10_8">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro08" id="p10pro08a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_08.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Aiming a derived-class pointer at a base-class object.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedCommissionEmployee.h"</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>7</strong></span>      SalariedEmployee salaried{<span class="green">"Sue Jones"</span>, <span class="green">500.0</span>};&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// aim derived-class pointer at base-class object</span>&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="lgreen">// Error: a SalariedEmployee is not a SalariedCommissionEmployee</span>&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="red">SalariedCommissionEmployee* salariedCommissionPtr{&amp;salaried};</span>&#13;
<span class="cviolet"><strong>12</strong></span>   <code>}</code></pre>&#13;
<p><em>Microsoft Visual C++ compiler error message:</em></p>&#13;
<pre class="pre1">fig10_08.cpp(11,63): error C2440: 'initializing': cannot convert from&#13;
'SalariedEmployee *' to 'SalariedCommissionEmployee *'</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.8</strong></span> | Aiming a derived-class pointer at a base-class object.</p>&#13;
</div>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Consider the consequences if the compiler were to allow this assignment. Through a <code>SalariedCommissionEmployee</code> pointer, we can invoke any of that class’s member functions, including <code>setGrossSales</code> and <code>setCommissionRate</code>, for the object to which the pointer points—the base-class object <code>salaried</code>. However, a <code>SalariedEmployee</code> object has neither <code>setGrossSales</code> and <code>setCommissionRate</code> member functions nor data members <code>m_grossSales</code> and <code>m_commissionRate</code> to set. <strong>This could lead to problems because member functions <code>setGrossSales</code> and <code>setCommissionRate</code> would assume data members <code>m_grossSales</code> and <code>m_commissionRate</code> exist at their “usual locations” in a <code>SalariedCommissionEmployee</code> object. A <code>SalariedEmployee</code> object’s memory does not have these data members, so <code>setGrossSales</code> and <code>setCommissionRate</code> might overwrite other data in memory, possibly data belonging to a different object.</strong></p>&#13;
<h4 class="h4" id="sec10_6_3">10.6.3 Derived-Class Member-Function Calls via Base-Class Pointers</h4>&#13;
<p><strong>The compiler allows us to invoke only base-class member functions via a base-class pointer.</strong> So, if a base-class pointer is aimed at a derived-class object, and an attempt is made to access a derived-class-only member function, a compilation error occurs. <a href="ch10.xhtml#fig10_9">Figure 10.9</a> shows the compiler errors for invoking a derived-class-only member function via a base-class pointer (lines 23–25).</p>&#13;
<div class="group" id="fig10_9">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro09" id="p10pro09a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_09.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Attempting to call derived-class-only functions</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// via a base-class pointer.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedCommissionEmployee.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      SalariedCommissionEmployee salariedCommission{&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="green">"Bob Lewis"</span>, <span class="green">300.0</span>, <span class="green">5000.0</span>, <span class="green">.04</span>};&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="lgreen">// aim base-class pointer at derived-class object (allowed)</span>&#13;
<span class="cviolet"><strong>14</strong></span>      SalariedEmployee* salariedPtr{&amp;salariedCommission};&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="lgreen">// invoke base-class member functions on derived-class</span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="lgreen">// object through base-class pointer (allowed)</span>&#13;
<span class="cviolet"><strong>18</strong></span>      string name{salariedPtr-&gt;getName()};&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">double</span> salary{salariedPtr-&gt;getSalary()};&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="lgreen">// attempt to invoke derived-class-only member functions</span>&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="lgreen">// on derived-class object through base-class pointer (disallowed)</span>&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="red">double grossSales{salariedPtr-&gt;getGrossSales()};</span>&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="red">double commissionRate{salariedPtr-&gt;getCommissionRate()};</span>&#13;
<span class="cviolet"><strong>25</strong></span>      <span class="red">salariedPtr-&gt;setGrossSales(8000.0); </span>&#13;
<span class="cviolet"><strong>26</strong></span>   <code>}</code></pre>&#13;
<p><em>GNU C++ compiler error messages:</em></p>&#13;
<pre class="pre1">fig10_09.cpp: In function ‘int main()’:&#13;
fig10_09.cpp:23:35: error: ‘class SalariedEmployee’ has no member named&#13;
‘getGrossSales’&#13;
   23 |     double grossSales{salariedPtr-&gt;getGrossSales()};&#13;
      |                                    ^~~~~~~~~~~~~&#13;
fig10_09.cpp:24:39: error: ‘class SalariedEmployee’ has no member named&#13;
‘getCommissionRate’&#13;
   24 |     double commissionRate{salariedPtr-&gt;getCommissionRate()};&#13;
      |                                        ^~~~~~~~~~~~~~~~~&#13;
fig10_09.cpp:25:17: error: ‘class SalariedEmployee’ has no member named&#13;
‘setGrossSales’&#13;
   25 | salariedPtr-&gt;setGrossSales(8000.0);&#13;
      |              ^~~~~~~~~~~~~</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.9</strong></span> | Attempting to call derived-class-only functions via a base-class pointer.</p>&#13;
</div>&#13;
<p>Lines 10–11 create a <code>SalariedCommissionEmployee</code> object. Line 14 initializes the base-class pointer <code>salariedPtr</code> with the derived-class object <code>salariedCommission</code>’s address. Again, this is allowed because a <code>SalariedCommissionEmployee</code> <em>is a</em> <code>SalariedEmployee</code>.</p>&#13;
<p>Lines 18–19 invoke base-class member functions via the base-class pointer. These calls are allowed because <code>SalariedCommissionEmployee</code> inherits these functions.</p>&#13;
<p>We know that <code>salariedPtr</code> is aimed at a <code>SalariedCommissionEmployee</code> object, so lines 23–25 try to invoke <code>SalariedCommissionEmployee</code>-only member functions <code>getGrossSales</code>, <code>getCommissionRate</code> and <code>setGrossSales</code>. The compiler generates errors because these functions are not base-class <code>SalariedEmployee</code> member functions. Through <code>salariedPtr</code> we can invoke only those functions that are members of the handle’s class type—in this case, only base-class <code>SalariedEmployee</code> member functions.</p>&#13;
<h3 class="h3" id="sec10_7"><span class="violet">10.7</span> Virtual Functions and Virtual Destructors</h3>&#13;
<p>In <a href="ch10.xhtml#sec10_6_1">Section 10.6.1</a>, we aimed a base-class <code>SalariedEmployee</code> pointer at a derived-class <code>SalariedCommissionEmployee</code> object, then used it to invoke member function <code>toString</code>. In that case, the <code>SalariedEmployee</code> class’s <code>toString</code> was called. How can we invoke the derived-class <code>toString</code> function via a base-class pointer?</p>&#13;
<h4 class="h4" id="sec10_7_1">10.7.1 Why <code>virtual</code> Functions Are Useful</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Suppose the shape classes <code>Circle</code>, <code>Triangle</code>, <code>Rectangle</code> and <code>Square</code> all derive from base-class <code>Shape</code>. Each class might be endowed with the ability to draw objects of that class via a member function <code>draw</code>, but each shape’s implementation is quite different. In a program that draws many different types of shapes, it would be convenient to treat them all generally as base-class <code>Shape</code> objects. We could then draw any shape by using a base-class <code>Shape</code> pointer to invoke function <code>draw</code>. The program would determine dynamically at runtime which derived-class <code>draw</code> function to use, based on the type of the object to which the base-class <code>Shape</code> pointer points. This is runtime polymorphic behavior. <strong>With</strong> <span class="violet"><strong><code>virtual</code></strong></span><span class="violet"> <strong>functions</strong></span><strong>, the type of the object pointed to (or referenced)—not the type of the pointer (or reference) handle—determines which member function to invoke.</strong></p>&#13;
<h4 class="h4" id="sec10_7_2">10.7.2 Declaring <code>virtual</code> Functions</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> To enable this runtime polymorphic behavior, we declare the base-class member function <code>draw</code> as <code>virtual</code><sup><a id="ch10fn10a" href="ch10.xhtml#ch10fn10">10</a></sup>, then <strong><span class="violet">override</span></strong> it in each derived class to draw the appropriate shape. <strong>An overridden function in a derived class must have the <em>same signature</em> as the base-class function it overrides.</strong> To declare a <code>virtual</code> function, precede its prototype with the keyword <code>virtual</code>. For example,</p>&#13;
<p class="footnote"><a id="ch10fn10" href="ch10.xhtml#ch10fn10a">10</a>. Some programming languages, such as Java and Python, treat all member functions (methods) like C++ <code>virtual</code> functions. As we’ll see in <a href="ch10.xhtml#sec10_10">Section 10.10</a>, <code>virtual</code> functions have a slight execution-time performance hit and a slight memory consumption hit. C++ allows you to choose whether to make each function <code>virtual</code> or not, based on the performance requirements of your applications.</p>&#13;
<pre class="pre"><span class="blue">virtual void</span> draw() <span class="blue">const</span>;</pre>&#13;
<p>would appear in base-class <code>Shape</code>. The preceding prototype declares that function <code>draw</code> is a <code>virtual</code> function that takes no arguments and returns nothing. This function is declared <code>const</code> because a <code>draw</code> function should not modify the <code>Shape</code> object on which it’s invoked.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Virtual functions do not have to be <code>const</code> and can receive arguments and return values as appropriate. <strong>Once a function is declared <code>virtual</code>, it’s <code>virtual</code> in all classes derived directly or indirectly from that base class</strong>. If a derived class does not override a <code>virtual</code> function from its base class, the derived class simply inherits its base class’s <code>virtual</code> function implementation.</p>&#13;
<h4 class="h4" id="sec10_7_3">10.7.3 Invoking a <code>virtual</code> Function</h4>&#13;
<p>If a program invokes a <code>virtual</code> function through</p>&#13;
<p class="bull">• a base-class pointer to a derived-class object (e.g., <code>shapePtr-&gt;draw()</code>) or</p>&#13;
<p class="bull">• a base-class reference to a derived-class object (e.g., <code>shapeRef.draw()</code>),</p>&#13;
<p>the program will choose the correct <em>derived-class</em> function at execution time, based on the object’s type—<em>not</em> the pointer or reference type. Choosing the appropriate function to call at execution time is known as <strong><span class="violet">dynamic binding</span></strong> or <strong><span class="violet">late binding</span></strong>.</p>&#13;
<p>When a <code>virtual</code> function is called by referring to a specific object <em>by name</em> and using the dot operator (e.g., <code>squareObject.draw()</code>), an optimizing compiler can resolve at <em>compile time</em> the function to call. This is called <strong><span class="violet">static binding</span></strong>. The <code>virtual</code> function that will be called is the one defined for that object’s class.</p>&#13;
<h4 class="h4" id="sec10_7_4">10.7.4 <code>virtual</code> Functions in the <code>SalariedEmployee</code> Hierarchy</h4>&#13;
<p>Let’s see how <code>virtual</code> functions could enable runtime polymorphic behavior in our hierarchy. To enable the behavior you’ll see in <a href="ch10.xhtml#fig10_10">Fig. 10.10</a>, we made only two modifications to each class’s header. In class <code>SalariedEmployee</code>’s header (<a href="ch10.xhtml#fig10_1">Fig. 10.1</a>), we modified the <code>earnings</code> and <code>toString</code> prototypes (lines 17–18)</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p511pro01" id="p511pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">double</span> earnings() <span class="blue">const</span>;&#13;
std::string toString() <span class="blue">const</span>;</pre>&#13;
<p>to <strong>include the <code>virtual</code> keyword</strong>, as in:</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p511pro02" id="p511pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">virtual double</span> earnings() <span class="blue">const</span>;&#13;
<span class="blue">virtual</span> std::string toString() <span class="blue">const</span>;</pre>&#13;
<p>In class <code>SalariedCommissionEmployee</code>’s header (<a href="ch10.xhtml#fig10_4">Fig. 10.4</a>), we modified the <code>earnings</code> and <code>toString</code> prototypes (lines 19–20)</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p511pro03" id="p511pro03a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">double</span> earnings() <span class="blue">const</span>;&#13;
std::string toString() <span class="blue">const</span>;</pre>&#13;
<p>to <strong>include the <code>override</code> keyword</strong> (discussed after <a href="ch10.xhtml#fig10_10">Fig. 10.10</a>), as in:</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p511pro04" id="p511pro04a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">double</span> earnings() <span class="blue">const override</span>;&#13;
std::string toString() <span class="blue">const override</span>;</pre>&#13;
<p><code>SalariedEmployee</code>’s <code>earnings</code> and <code>toString</code> functions are <code>virtual</code>, so derived-class <code>SalariedCommissionEmployee</code>’s versions <em>override</em> <code>SalariedEmployee</code>’s versions. There were no changes to the <code>SalariedEmployee</code> and <code>SalariedCommissionEmployee</code> member-function implementations, so we reuse the versions of Figs. 10.2 and 10.5.</p>&#13;
<h5 class="h5" id="ch10lev3sec34">Runtime Polymorphic Behavior</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Now, if we aim a base-class <code>SalariedEmployee</code> pointer at a derived-class <code>SalariedCommissionEmployee</code> object and use that pointer to call either <code>earnings</code> or <code>toString</code>, the derived-class object’s function will be invoked polymorphically</strong>. <a href="ch10.xhtml#fig10_10">Figure 10.10</a> demonstrates this runtime polymorphic behavior. First, lines 11–22 create a <code>SalariedEmployee</code> and a <code>SalariedCommissionEmployee</code>, then use static binding to get and output their <code>toString</code> results. This will help you confirm the dynamic binding results later in the program. Lines 28–40 show again that a <code>SalariedEmployee</code> pointer aimed at a <code>SalariedEmployee</code> object can be used to invoke <code>SalariedEmployee</code> functionality, and a <code>SalariedCommissionEmployee</code> pointer aimed at a <code>SalariedCommissionEmployee</code> object can be used to invoke <code>Salaried-CommissionEmployee</code> functionality. Line 43 aims the base-class pointer <code>salariedPtr</code> at the derived-class object <code>salariedCommission</code>. Line 51 invokes member function <code>toString</code> via the base-class pointer. As you can see in the output, the derived-class <code>salariedCommission</code> object’s <code>toString</code> member function is invoked. <strong>Declaring the member function <code>virtual</code> and invoking it through a base-class pointer or reference causes the program to determine at execution time which function to invoke based on the type of object to which the handle points, rather than on the type of the handle.</strong></p>&#13;
<div class="group" id="fig10_10">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro10" id="p10pro10a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_10.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Introducing polymorphism, virtual functions and dynamic binding.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedCommissionEmployee.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="lgreen">// create base-class object</span>&#13;
<span class="cviolet"><strong>11</strong></span>      SalariedEmployee salaried{<span class="green">"Sue Jones"</span>, <span class="green">500.0</span>};&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="lgreen">// create derived-class object</span>&#13;
<span class="cviolet"><strong>14</strong></span>      SalariedCommissionEmployee salariedCommission{&#13;
<span class="cviolet"><strong>15</strong></span>         <span class="green">"Bob Lewis"</span>, <span class="green">300.0</span>, <span class="green">5000.0</span>, <span class="green">.04</span>};&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="lgreen">// output objects using static binding</span>&#13;
<span class="cviolet"><strong>18</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\n{}:\n{}\n{}\n"</span>,&#13;
<span class="cviolet"><strong>19</strong></span>                 <span class="green">"INVOKING TOSTRING FUNCTION ON BASE-CLASS AND"</span>,&#13;
<span class="cviolet"><strong>20</strong></span>                 <span class="green">"DERIVED-CLASS OBJECTS WITH STATIC BINDING"</span>,&#13;
<span class="cviolet"><strong>21</strong></span>                 salaried.toString(), <span class="lgreen">// static binding</span>&#13;
<span class="cviolet"><strong>22</strong></span>                 salariedCommission.toString()); <span class="lgreen">// static binding</span>&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>      cout &lt;&lt; <span class="green">"INVOKING TOSTRING FUNCTION ON BASE-CLASS AND\n"</span>&#13;
<span class="cviolet"><strong>25</strong></span>           &lt;&lt; <span class="green">"DERIVED-CLASS OBJECTS WITH DYNAMIC BINDING\n\n"</span>;&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>      <span class="lgreen">// natural: aim base-class pointer at base-class object</span>&#13;
<span class="cviolet"><strong>28</strong></span>      SalariedEmployee* salariedPtr{&amp;salaried};&#13;
<span class="cviolet"><strong>29</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\n{}:\n{}\n"</span>,&#13;
<span class="cviolet"><strong>30</strong></span>                 <span class="green">"CALLING VIRTUAL FUNCTION TOSTRING WITH BASE-CLASS POINTER"</span>,&#13;
<span class="cviolet"><strong>31</strong></span>                 <span class="green">"TO BASE-CLASS OBJECT INVOKES BASE-CLASS FUNCTIONALITY"</span>,&#13;
<span class="cviolet"><strong>32</strong></span>                 salariedPtr-&gt;toString()); <span class="lgreen">// base-class version</span>&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>      <span class="lgreen">// natural: aim derived-class pointer at derived-class object</span>&#13;
<span class="cviolet"><strong>35</strong></span>      SalariedCommissionEmployee* salariedCommissionPtr{&amp;salariedCommission};&#13;
<span class="cviolet"><strong>36</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\n{}{}:\n{}\n"</span>,&#13;
<span class="cviolet"><strong>37</strong></span>                 <span class="green">"CALLING VIRTUAL FUNCTION TOSTRING WITH DERIVED-CLASS"</span>,&#13;
<span class="cviolet"><strong>38</strong></span>                 <span class="green">"POINTER TO DERIVED-CLASS OBJECT INVOKES DERIVED-CLASS "</span>,&#13;
<span class="cviolet"><strong>39</strong></span>                 <span class="green">"FUNCTIONALITY"</span>,&#13;
<span class="cviolet"><strong>40</strong></span>                 salariedCommissionPtr-&gt;toString()); <span class="lgreen">// derived-class version</span>&#13;
<span class="cviolet"><strong>41</strong></span>&#13;
<span class="cviolet"><strong>42</strong></span>      <span class="lgreen">// aim base-class pointer at derived-class object</span>&#13;
<span class="cviolet"><strong>43</strong></span>      salariedPtr = &amp;salariedCommission;&#13;
<span class="cviolet"><strong>44</strong></span>&#13;
<span class="cviolet"><strong>45</strong></span>      <span class="lgreen">// runtime polymorphism: invokes SalariedCommissionEmployee</span>&#13;
<span class="cviolet"><strong>46</strong></span>      <span class="lgreen">// via base-class pointer to derived-class object</span>&#13;
<span class="cviolet"><strong>47</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\n{}{}:\n{}\n"</span>,&#13;
<span class="cviolet"><strong>48</strong></span>                 <span class="green">"CALLING VIRTUAL FUNCTION TOSTRING WITH BASE-CLASS POINTER"</span>,&#13;
<span class="cviolet"><strong>49</strong></span>                 <span class="green">"TO DERIVED-CLASS OBJECT INVOKES DERIVED-CLASS "</span>,&#13;
<span class="cviolet"><strong>50</strong></span>                 <span class="green">"FUNCTIONALITY"</span>,&#13;
<span class="cviolet"><strong>51</strong></span>                 salariedPtr-&gt;toString()); <span class="lgreen">// derived-class version</span>&#13;
<span class="cviolet"><strong>52</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">INVOKING TOSTRING FUNCTION ON BASE-CLASS AND&#13;
DERIVED-CLASS OBJECTS WITH STATIC BINDING:&#13;
name: Sue Jones&#13;
salary: $500.00&#13;
&#13;
name: Bob Lewis&#13;
salary: $300.00&#13;
gross sales: $5000.00&#13;
commission rate: 0.04&#13;
&#13;
INVOKING TOSTRING FUNCTION ON BASE-CLASS AND&#13;
DERIVED-CLASS OBJECTS WITH DYNAMIC BINDING&#13;
&#13;
CALLING VIRTUAL FUNCTION TOSTRING WITH BASE-CLASS POINTER&#13;
TO BASE-CLASS OBJECT INVOKES BASE-CLASS FUNCTIONALITY:&#13;
name: Sue Jones&#13;
salary: $500.00&#13;
&#13;
CALLING VIRTUAL FUNCTION TOSTRING WITH DERIVED-CLASS&#13;
POINTER TO DERIVED-CLASS OBJECT INVOKES DERIVED-CLASS FUNCTIONALITY:&#13;
name: Bob Lewis&#13;
salary: $300.00&#13;
gross sales: $5000.00&#13;
commission rate: 0.04&#13;
&#13;
CALLING VIRTUAL FUNCTION TOSTRING WITH BASE-CLASS POINTER&#13;
TO DERIVED-CLASS OBJECT INVOKES DERIVED-CLASS FUNCTIONALITY:&#13;
name: Bob Lewis&#13;
salary: $300.00&#13;
gross sales: $5000.00&#13;
commission rate: 0.04</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.10</strong></span> | Demonstrating polymorphism by invoking a derived-class <code>virtual</code> function via a base-class pointer to a derived-class object. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>When <code>salariedPtr</code> points to a <code>SalariedEmployee</code> object, class <code>SalariedEmployee</code>’s <code>toString</code> function is invoked (line 32). When <code>salariedPtr</code> points to a <code>SalariedCommissionEmployee</code> object, class <code>SalariedCommissionEmployee</code>’s <code>toString</code> function is invoked (line 51). So, <strong>the same <code>toString</code> call via a base-class pointer to various objects takes on many forms (in this case, two forms). This is runtime polymorphic behavior</strong>.</p>&#13;
<h5 class="h5" id="ch10lev3sec35">Do Not Call Virtual Functions from Constructors and Destructors</h5>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> Calling a <code>virtual</code> function from a base class’s constructor or destructor <strong>invokes the base-class version</strong>, even if the base-class constructor or destructor is called while creating or destroying a derived-class object. This is not the behavior you expect for <code>virtual</code> functions, so the C++ Core Guidelines recommend that you do not call them from constructors or destructors.<sup><a id="ch10fn11a" href="ch10.xhtml#ch10fn11">11</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn11" href="ch10.xhtml#ch10fn11a">11</a>. “C.82: Don’t call virtual functions in constructors and destructors.” Accessed February 8, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-ctor-virtual">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-ctor-virtual</a></code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec36"><span class="size">11</span> C++11 <code>override</code> Keyword</h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Declaring <code>SalariedCommissionEmployee</code>’s <code>earnings</code> and <code>toString</code> functions using the <span class="violet"><strong><code>override</code></strong></span> keyword tells the compiler to check whether the base class has a <code>virtual</code> member function with the <strong>same signature</strong>. If not, the compiler generates an error. This ensures that you override the appropriate base-class function. <strong>It also prevents you from accidentally hiding a base-class function with the same name but a different signature</strong>. <strong>So, to help you prevent errors, apply <code>override</code> to the prototype of every derived-class function that overrides a <code>virtual</code> base-class function.</strong></p>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> The C++ Core Guidelines state that:</p>&#13;
<p class="bull">• <code>virtual</code> specifically introduces a new <code>virtual</code> function in a hierarchy, and</p>&#13;
<p class="bull">• <code>override</code> specifically indicates that a derived-class function overrides a base-class <code>virtual</code> function.</p>&#13;
<p>So, you should use only <code>virtual</code> or <code>override</code> in each <code>virtual</code> function’s prototype.<sup><a id="ch10fn12a" href="ch10.xhtml#ch10fn12">12</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn12" href="ch10.xhtml#ch10fn12a">12</a>. “C.128: Virtual functions should specify exactly one of <code>virtual</code>, <code>override</code>, or <code>final</code>.” Accessed January 21, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-override">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-override</a></code>.</p>&#13;
<h4 class="h4" id="sec10_7_5">10.7.5 <code>virtual</code> Destructors</h4>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The C++ Core Guidelines recommend including a <span class="violet"><strong><code>virtual</code></strong></span><strong><span class="violet"> destructor</span></strong> in <em>every</em> class that contains <code>virtual</code> functions.<sup><a id="ch10fn13a" href="ch10.xhtml#ch10fn13">13</a></sup> This helps prevent subtle errors when a derived class has a custom destructor. <strong>In a class that does not have a destructor, the compiler generates one for you, but the generated one is not <code>virtual</code></strong>. So, in Modern C++, the <code>virtual</code> destructor definition for most classes is written as:</p>&#13;
<p class="footnote"><a id="ch10fn13" href="ch10.xhtml#ch10fn13a">13</a>. “C.35: A base class destructor should be either <code>public</code> and <code>virtual</code>, or <code>protected</code> and non-<code>virtual</code>.” Accessed January 25, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-virtual">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-virtual</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p514pro01" id="p514pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">virtual</span> ~SalariedEmployee() = <span class="blue">default</span>;</pre>&#13;
<p>This enables you to declare the destructor <code>virtual</code> and still have the compiler generate a default destructor for the class—via the notation <code>=</code><span class="violet"> <strong><code>default</code></strong></span>.</p>&#13;
<h4 class="h4" id="sec10_7_6"><span class="size">11</span> 10.7.6 <code>final</code> Member Functions and Classes</h4>&#13;
<p>Before C++11, a derived class could override any base-class <code>virtual</code> function. In C++11 and beyond, a <code>virtual</code> function that’s declared <span class="violet"><strong><code>final</code></strong></span> in its prototype, as in</p>&#13;
<p class="pren"><em>returnType someFunction</em><code>(</code><em>parameters</em>) <span class="blue"><code>final</code></span>;</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <em>cannot</em> be overridden in any derived class. <strong>In a multi-level class hierarchy, this guarantees that the <code>final</code> member-function definition will be used by all subsequent direct <em>and</em> indirect derived classes</strong>.</p>&#13;
<p>Similarly, before C++11, any existing class could be used as a base class at any point in a hierarchy. In C++11 and beyond, you can declare a class <code>final</code> to prevent it from being used as a base class, as in:</p>&#13;
<pre class="pre"><span class="blue">class</span> MyClass <span class="blue">final</span> {&#13;
   <span class="lgreen">// class body</span>&#13;
};</pre>&#13;
<p>or:</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p515pro01" id="p515pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">class</span> DerivedClass : <span class="blue">public</span> BaseClass <span class="blue">final</span> {&#13;
   <span class="lgreen">// class body</span>&#13;
};</pre>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Attempting to override a <code>final</code> member function or inherit from a <code>final</code> base class results in a compilation error.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> A benefit of declaring a <code>virtual</code> function <code>final</code> is that once the compiler knows a <code>virtual</code> function cannot be overridden, it can perform various optimizations. For instance, the compiler might be able to determine at compile time the correct function to call.<sup><a id="ch10fn14a" href="ch10.xhtml#ch10fn14">14</a></sup> This optimization is called <strong><span class="violet">devirtualization</span></strong>.<sup><a id="ch10fn15a" href="ch10.xhtml#ch10fn15">15</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn14" href="ch10.xhtml#ch10fn14a">14</a>. Godbolt, Matt. “Optimizations in C++ Compilers.” Accessed February 8, 2021. <code><a href="https://queue.acm.org/detail.cfm?id=3372264">https://queue.acm.org/detail.cfm?id=3372264</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn15" href="ch10.xhtml#ch10fn15a">15</a>. Although the C++ standard document discusses a number of possible optimizations, it does not require them. They happen at the discretion of the compiler implementers.</p>&#13;
<p>There are cases in which the compiler can devirtualize <code>virtual</code> function calls even if the <code>virtual</code> functions are not declared <code>final</code>. For example, sometimes the compiler can recognize at compile time the type of object that will be used at runtime. In this case, a call to a non-<code>final virtual</code> function can be bound at compile time.<sup><a id="ch10fn16a" href="ch10.xhtml#ch10fn16">16</a>,<a id="ch10fn17a" href="ch10.xhtml#ch10fn17">17</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn16" href="ch10.xhtml#ch10fn16a">16</a>. Godbolt, Matt. “Optimizations in C++ Compiler.” Accessed February 8, 2021. <code><a href="https://queue.acm.org/detail.cfm?id=3372264">https://queue.acm.org/detail.cfm?id=3372264</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn17" href="ch10.xhtml#ch10fn17a">17</a>. Brand, Sy. “The Performance Benefits of Final Classes.” Accessed February 8, 2021. <code><a href="https://devblogs.microsoft.com/cppblog/the-performance-benefits-of-final-classes/">https://devblogs.microsoft.com/cppblog/the-performance-benefits-of-final-classes/</a></code>.</p>&#13;
<h3 class="h3" id="sec10_8"><span class="violet">10.8</span> Abstract Classes and Pure <code>virtual</code> Functions</h3>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>There are cases in which it’s useful to define classes from which you never intend to instantiate any objects. Such an</strong> <span class="violet"><strong>abstract class</strong></span> <strong>defines a common <code>public</code> interface for the classes derived from it in a class hierarchy</strong>. Because abstract classes are used as base classes in inheritance hierarchies, we refer to them as <strong><span class="violet">abstract base classes</span></strong>. Such classes cannot be used to create objects because, as we’ll see, abstract classes are missing pieces. Derived classes must define the “missing pieces” before derived-class objects can be instantiated. We build programs with abstract classes in <a href="ch10.xhtml#sec10_9">Sections 10.9</a>, <a href="ch10.xhtml#sec10_12">10.12</a> and <a href="ch10.xhtml#sec10_14">10.14</a>.</p>&#13;
<p>Classes that can be used to instantiate objects are called <strong><span class="violet">concrete classes</span></strong>. Such classes define or inherit implementations of <em>every</em> member function they or their base classes declare. A good example of this is <a href="ch10.xhtml#sec10_2">Section 10.2</a>’s shape hierarchy, which begins with abstract base-class <code>Shape</code>. We then have an abstract base-class <code>TwoDimensionalShape</code> with derived concrete classes <code>Circle</code>, <code>Square</code> and <code>Triangle</code>. We also have an abstract base class, <code>ThreeDimensionalShape</code>, with derived concrete classes <code>Cube</code>, <code>Sphere</code> and <code>Tetrahedron</code>. <strong>Abstract base classes are too general to define real objects—we need to be more specific before instantiating objects.</strong> For example, if someone tells you to “draw the two-dimensional shape,” what shape would you draw? <strong>Concrete classes provide the specifics that make it possible to instantiate objects.</strong></p>&#13;
<h4 class="h4" id="sec10_8_1">10.8.1 Pure <code>virtual</code> Functions</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>A class is made abstract by declaring one or more</strong> <span class="violet"><strong>pure <code>virtual</code></strong></span> <span class="violet"><strong>functions</strong></span><strong>, each specified by placing “<code>= 0</code>” in its function prototype</strong>, as in</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p516pro01" id="p516pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">virtual void</span> draw() <span class="blue">const</span> = <span class="green">0</span>; <span class="lgreen">// pure virtual function</span></pre>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>The “<code>= 0</code>” is a <span class="violet">pure specifier</span></strong>. Pure <code>virtual</code> functions do not provide implementations. <strong>Each derived class that hopes to instantiate objects must override all of its base class’s pure <code>virtual</code> functions with concrete implementations.</strong> Otherwise, the derived class is also abstract. By contrast, a regular <code>virtual</code> function has an implementation, giving the derived class the <em>option</em> of overriding the function or simply inheriting the base class’s implementation. An abstract class also can have data members and concrete functions. As you’ll see in <a href="ch10.xhtml#sec10_12">Section 10.12</a>, <strong>an abstract class that has all pure <code>virtual</code> functions is sometimes called a</strong> <span class="violet"><strong>pure abstract class</strong></span> <strong>or an</strong> <span class="violet"><strong>interface</strong></span>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Pure <code>virtual</code> functions are used when the base class does not know how to implement a function, but all concrete derived classes should implement it.</strong> Returning to our earlier <code>SpaceObject</code>s example, it does not make sense for the base-class <code>SpaceObject</code> to have a <code>draw</code> function implementation. There’s no way to draw a generic space object without knowing which specific type of space object is being drawn.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Although we cannot instantiate objects of an abstract base class, <strong>we can declare pointers and references of the abstract-base-class type. These can refer to objects of any concrete classes derived from the abstract base class.</strong> Programs typically use such pointers and references to manipulate derived-class objects polymorphically at runtime.</p>&#13;
<h4 class="h4" id="sec10_8_2">10.8.2 Device Drivers: Polymorphism in Operating Systems</h4>&#13;
<p>Polymorphism is particularly effective for implementing layered software systems. For example, in operating systems, each type of physical input/output device could operate quite differently from the others. Even so, commands to read or write data from and to devices, respectively, may have a certain uniformity. The write message sent to a device-driver object needs to be interpreted specifically in the context of that device driver and how that device driver manipulates devices of a specific type. However, the write call itself really is no different from the write to any other device in the system—place some bytes from memory onto that device.</p>&#13;
<p>An object-oriented operating system could use an abstract base class to provide an interface appropriate for all device drivers. Then, through inheritance from that abstract base class, derived classes are formed that all operate similarly. The <code>public</code> functions offered by the device drivers are pure <code>virtual</code> functions in the abstract base class. The implementations of these pure <code>virtual</code> functions are provided in the derived classes that correspond to the specific types of device drivers.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>This architecture also allows new devices to be added to a system easily. The user can just plug in the device and install its new device driver. The operating system “talks” to this new device through its device driver, which has the same public member functions as all other device drivers—those defined in the device-driver abstract base class.</strong></p>&#13;
<h3 class="h3" id="sec10_9"><span class="violet">10.9</span> Case Study: Payroll System Using Runtime Polymorphism</h3>&#13;
<p>In this example, we use an abstract class and runtime polymorphism to perform payroll calculations for two employee types. We create an <code>Employee</code> hierarchy to solve the following problem:</p>&#13;
<p class="pren"><em>A company pays its employees weekly. The employees are of two types:</em></p>&#13;
<p class="num"><em>1. Salaried employees are paid a fixed salary regardless of the number of hours worked.</em></p>&#13;
<p class="num"><em>2. Commission employees are paid a percentage of their sales.</em></p>&#13;
<p class="pren"><em>The company wants to implement a C++ program that performs its payroll calculations polymorphically.</em></p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Many hierarchies start with an abstract base class followed by a row of derived classes that are <code>final</code>. We use abstract class <code>Employee</code> to represent the <em>general concept</em> of an employee and define the interface to the hierarchy—that is, the functions that all <code>Employee</code> derived classes must have.</strong> The <code>final</code> classes that derive directly from <code>Employee</code> are <code>SalariedEmployee</code> and <code>CommissionEmployee</code>—each of these classes is a <strong><span class="violet">leaf node</span></strong> in the class hierarchy and cannot be a base class. The following UML class diagram shows the employee inheritance hierarchy for our runtime polymorphic payroll application. The abstract class name <code>Employee</code> is <em>italicized</em>, per the UML’s convention:</p>&#13;
<div class="image"><img src="Images/517fig01.jpg" alt="Images" width="548" height="147"/></div>&#13;
<p><strong>Abstract base-class <code>Employee</code> declares the “interface” to the hierarchy—that is, the set of member functions that a program can invoke on <em>all</em> <code>Employee</code> objects.</strong> Each employee, regardless of how earnings are calculated, has a name. So, we chose to define a <code>private</code> data member <code>m_name</code> in abstract base class <code>Employee</code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> A derived class can inherit interface and/or implementation from a base class. <strong>Hierarchies designed for</strong> <span class="violet"><strong>interface inheritance</strong></span> <strong>tend to have their functionality lower in the hierarchy.</strong> A base class specifies one or more functions that should be defined by every derived class, but the individual derived classes provide their own implementations of the function(s).</p>&#13;
<p>The following subsections implement the <code>Employee</code> class hierarchy. The first three each implement one of the abstract or concrete classes. The last implements a test program that builds concrete-class objects and processes them with runtime polymorphism.</p>&#13;
<h4 class="h4" id="sec10_9_1">10.9.1 Creating Abstract Base-Class <code>Employee</code></h4>&#13;
<p>Class <code>Employee</code> (Figs. 10.11–10.12, discussed in further detail shortly) provides functions <code>earnings</code> and <code>toString</code>, and <em>get</em> and <em>set</em> functions that manipulate <code>Employee</code>’s <code>m_name</code> data member. An <code>earnings</code> function certainly applies generally to all <code>Employee</code>s, but each earnings calculation depends on its class. So we declare <code>earnings</code> as pure <code>virtual</code> in base-class <code>Employee</code> because a default implementation does not make sense for that function. There’s not enough information to determine what amount <code>earnings</code> should return.</p>&#13;
<p>Each derived class overrides <code>earnings</code> with an appropriate implementation. To calculate an employee’s earnings, the program assigns an employee object’s address to a base-class <code>Employee</code> pointer, then invokes the object’s <code>earnings</code> function.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The test program maintains a <code>vector</code> of <code>Employee</code> pointers, each of which points to an object that <em>is an</em> <code>Employee</code>—that is, any object of a concrete derived class of <code>Employee</code>. The program iterates through the <code>vector</code> and calls each <code>Employee</code>’s <code>earnings</code> function. C++ processes these function calls polymorphically. <strong>Including <code>earnings</code> as a pure <code>virtual</code> function in <code>Employee</code> forces every derived class of <code>Employee</code> that wishes to be a <em>concrete</em> class to override <code>earnings</code>.</strong></p>&#13;
<p><code>Employee</code>’s <code>toString</code> function returns a <code>string</code> containing the <code>Employee</code>’s name. As we’ll see, each class derived from <code>Employee</code> overrides function <code>toString</code> to return the <code>Employee</code>’s name followed by the rest of the <code>Employee</code>’s information. Each derived class’s <code>toString</code> could also call <code>earnings</code>, even though <code>earnings</code> is a pure <code>virtual</code> function in base-class <code>Employee</code>. Each concrete class is guaranteed to have an <code>earnings</code> implementation. Even class <code>Employee</code>’s <code>toString</code> function can call <code>earnings</code>. When you call <code>toString</code> through an <code>Employee</code> pointer or reference at runtime, you’re always calling it on a concrete derived-class object.</p>&#13;
<p>The following diagram shows the hierarchy’s three classes down the left and functions <code>earnings</code> and <code>toString</code> across the top. For each class, the diagram shows the desired return value of each function:</p>&#13;
<div class="image"><img src="Images/518fig01.jpg" alt="Images" width="673" height="218"/></div>&#13;
<p>Italic text represents where the values from a particular object are used in the <code>earnings</code> and <code>toString</code> functions. Class <code>Employee</code> specifies “pure <code>virtual</code>” for function <code>earnings</code> to indicate that it’s a pure <code>virtual</code> function with no implementation. Each derived class overrides this function to provide an appropriate implementation. We do not list baseclass <code>Employee</code>’s <em>get</em> and <em>set</em> functions because the derived classes do not override them. Each of these functions is inherited and used “as is” by the derived classes.</p>&#13;
<h5 class="h5" id="ch10lev3sec37"><code>Employee</code> Class Header</h5>&#13;
<p>Consider class <code>Employee</code>’s header (<a href="ch10.xhtml#fig10_11">Fig. 10.11</a>). Its <code>public</code> member functions include:</p>&#13;
<p class="bull">• a constructor that takes the name as an argument (line 9),</p>&#13;
<p class="bull">• <span class="size">11</span> a C++11 <code>default</code>ed virtual destructor (line 10),</p>&#13;
<p class="bull">• a <em>set</em> function that sets the name (line 12),</p>&#13;
<p class="bull">• a <em>get</em> function that returns the name (line 13),</p>&#13;
<p class="bull">• pure <code>virtual</code> function <code>earnings</code> (line 16), and</p>&#13;
<p class="bull">• <code>virtual</code> function <code>toString</code> (line 17).</p>&#13;
<p>Recall that we declared <code>earnings</code> as a pure <code>virtual</code> function because, first, we must know the specific <code>Employee</code> type to determine the appropriate <code>earnings</code> calculation. Each concrete derived class must provide an <code>earnings</code> implementation. Then, using a base-class <code>Employee</code> pointer or reference, a program can invoke function <code>earnings</code> polymorphically for an object of any concrete derived-class of <code>Employee</code>.</p>&#13;
<div class="group" id="fig10_11">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro11" id="p10pro11a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.11: Employee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Employee abstract base class.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">class</span> Employee {&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">explicit</span> Employee(std::string_view name);&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">virtual</span> ~Employee() = <span class="blue">default</span>; <span class="lgreen">// compiler generates virtual destructor</span>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">void</span> setName(std::string_view name);&#13;
<span class="cviolet"><strong>13</strong></span>      std::string getName() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="lgreen">// pure virtual function makes Employee an abstract base class</span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">virtual</span> <span class="blue">double</span> earnings() <span class="blue">const</span> = <span class="green">0</span>; <span class="lgreen">// pure virtual</span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">virtual</span> std::string toString() <span class="blue">const</span>; <span class="lgreen">// virtual</span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>19</strong></span>      std::string m_name;&#13;
<span class="cviolet"><strong>20</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.11</strong></span> | <code>Employee</code> abstract base class.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec38"><code>Employee</code> Class Member-Function Definitions</h5>&#13;
<p><a href="ch10.xhtml#fig10_12">Figure 10.12</a> contains <code>Employee</code>’s member-function definitions. No implementation is provided for <code>virtual</code> function <code>earnings</code>. The <code>virtual</code> function <code>toString</code> implementation (lines 18–20) will be overridden in each derived class. Those derived-class <code>toString</code> functions will call <code>Employee</code>’s <code>toString</code> to get a <code>string</code> containing the information common to all classes in the <code>Employee</code> hierarchy (i.e., the name).</p>&#13;
<div class="group" id="fig10_12">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro12" id="p10pro12a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.12: Employee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Abstract-base-class Employee member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// Note: No definitions are given for pure virtual functions.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span> <span class="lgreen">// Employee class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   Employee::Employee(string_view name) : m_name{name} {} <span class="lgreen">// empty body</span>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="lgreen">// set name</span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">void</span> Employee::setName(string_view name) {m_name = name;}&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="lgreen">// get name</span>&#13;
<span class="cviolet"><strong>15</strong></span>   string Employee::getName() <span class="blue">const</span> {<span class="blue">return</span> m_name;}&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// return string representation of an Employee</span>&#13;
<span class="cviolet"><strong>18</strong></span>   string Employee::toString() <span class="blue">const</span> {<span class="blue"/>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"name: {}"</span>, getName());&#13;
<span class="cviolet"><strong>20</strong></span>   } <span class="lgreen"/></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.12</strong></span> | <code>Employee</code> class implementation file.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec10_9_2">10.9.2 Creating Concrete Derived-Class <code>SalariedEmployee</code></h4>&#13;
<p>Class <code>SalariedEmployee</code> (Figs. 10.13–10.14) derives from class <code>Employee</code> (<a href="ch10.xhtml#fig10_13">Fig. 10.13</a>, line 8). <code>SalariedEmployee</code>’s <code>public</code> member functions include:</p>&#13;
<p class="bull">• a constructor that takes a name and a salary as arguments (line 10),</p>&#13;
<p class="bull">• <span class="size">11</span> a C++11 <code>default virtual</code> destructor (line 11),</p>&#13;
<p class="bull">• a <em>set</em> function to assign a new nonnegative value to data member <code>m_salary</code> (line 13) and a <em>get</em> function to return <code>m_salary</code>’s value (line 14),</p>&#13;
<p class="bull">• an <code>override</code> of <code>Employee</code>’s <code>virtual</code> function <code>earnings</code> that calculates a <code>SalariedEmployee</code>’s earnings (line 17), and</p>&#13;
<p class="bull">• an <code>override</code> of <code>Employee</code>’s <code>virtual</code> function <code>toString</code> (line 18) that returns a <code>SalariedEmployee</code>’s string representation.</p>&#13;
<div class="group" id="fig10_13">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro13" id="p10pro13a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.13: SalariedEmployee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// SalariedEmployee class derived from Employee.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt; <span class="lgreen">// C++ standard string class</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span> <span class="lgreen">// Employee class definition</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">class</span> SalariedEmployee <span class="blue">final</span> : <span class="blue">public</span> Employee {&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>10</strong></span>      SalariedEmployee(std::string_view name, <span class="blue">double</span> salary);&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">virtual</span> ~SalariedEmployee() = <span class="blue">default</span>; <span class="lgreen">// virtual destructor</span>&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">void</span> setSalary(<span class="blue">double</span> salary); <span class="lgreen"/>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">double</span> getSalary() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="lgreen">// keyword override signals intent to override</span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const override</span>; <span class="lgreen">// calculate earnings</span>&#13;
<span class="cviolet"><strong>18</strong></span>      std::string toString() <span class="blue">const override</span>; <span class="lgreen">// string representation</span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">double</span> m_salary{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>21</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.13</strong></span> | <code>SalariedEmployee</code> class header. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec39"><code>SalariedEmployee</code> Class Member-Function Definitions</h5>&#13;
<p><a href="ch10.xhtml#fig10_14">Figure 10.14</a> defines <code>SalariedEmployee</code>’s member functions:</p>&#13;
<p class="bull">• Its constructor passes the <code>name</code> argument to the <code>Employee</code> constructor (line 10) to initialize the inherited <code>private</code> data member that’s not directly accessible in the derived class.</p>&#13;
<p class="bull">• Function <code>earnings</code> (line 28) overrides <code>Employee</code>’s pure <code>virtual</code> function <code>earnings</code> to provide a concrete implementation that returns the weekly salary. If we did not override <code>earnings</code>, <code>SalariedEmployee</code> would inherit <code>Employee</code>’s pure <code>virtual earnings</code> function and would be abstract.</p>&#13;
<p class="bull">• <code>SalariedEmployee</code>’s <code>toString</code> function (lines 31–34) overrides <code>Employee</code>’s <code>toString</code>. If it did not, the class would inherit <code>Employee</code>’s version that returns a <code>string</code> containing only the employee’s name. <code>SalariedEmployee</code>’s <code>toString</code> returns a <code>string</code> containing the <code>Employee::toString()</code> result and the <code>Salaried-Employee</code>’s salary.</p>&#13;
<p><code>SalariedEmployee</code>’s header declared member functions <code>earnings</code> and <code>toString</code> as <code>override</code> to ensure that we correctly override them. Recall that these are <code>virtual</code> in base-class <code>Employee</code>, so they remain <code>virtual</code> throughout the class hierarchy.</p>&#13;
<div class="group" id="fig10_14">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro14" id="p10pro14a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.14: SalariedEmployee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// SalariedEmployee class member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span> <span class="lgreen">// SalariedEmployee class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   SalariedEmployee::SalariedEmployee(string_view name, <span class="blue">double</span> salary)&#13;
<span class="cviolet"><strong>10</strong></span>      : Employee{name} {&#13;
<span class="cviolet"><strong>11</strong></span>      setSalary(salary);&#13;
<span class="cviolet"><strong>12</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="lgreen">// set salary</span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">void</span> SalariedEmployee::setSalary(<span class="blue">double</span> salary) {&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">if</span> (salary &lt; <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>17</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Weekly salary must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>18</strong></span>      }&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>      m_salary = salary;&#13;
<span class="cviolet"><strong>21</strong></span>   }&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>   <span class="lgreen">// return salary</span>&#13;
<span class="cviolet"><strong>24</strong></span>   <span class="blue">double</span> SalariedEmployee::getSalary() <span class="blue">const</span> {<span class="blue">return</span> m_salary;}&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="lgreen">// calculate earnings;</span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// override pure virtual function earnings in Employee</span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">double</span> SalariedEmployee::earnings() <span class="blue">const</span> {<span class="blue">return</span> getSalary();}&#13;
<span class="cviolet"><strong>29</strong></span>&#13;
<span class="cviolet"><strong>30</strong></span>   <span class="lgreen">// return a string representation of SalariedEmployee</span>&#13;
<span class="cviolet"><strong>31</strong></span>   <span class="blue">string</span> SalariedEmployee::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>32</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"{}\n{}: ${:.2f}"</span>, Employee::toString(),&#13;
<span class="cviolet"><strong>33</strong></span>                <span class="green">"salary"</span>, getSalary());&#13;
<span class="cviolet"><strong>34</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.14</strong></span> | <code>SalariedEmployee</code> class implementation file. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h4 class="h4" id="sec10_9_3">10.9.3 Creating Concrete Derived-Class <code>CommissionEmployee</code></h4>&#13;
<p>Class <code>CommissionEmployee</code> (Figs. 10.15–10.16) derives from <code>Employee</code> (<a href="ch10.xhtml#fig10_15">Fig. 10.15</a>, line 8). The member-function implementations in <a href="ch10.xhtml#fig10_16">Fig. 10.16</a> include:</p>&#13;
<p class="bull">• a constructor (lines 9–13) that takes a name, sales amount and commission rate, then passes the name to <code>Employee</code>’s constructor (line 10) to initialize the inherited data members,</p>&#13;
<p class="bull">• <em>set</em> functions (lines 16–22 and 28–34) to assign new values to data members <code>m_grossSales</code> and <code>m_commissionRate</code>,</p>&#13;
<p class="bull">• <em>get</em> functions (lines 25 and 37–39) that return the values of <code>m_grossSales</code> and <code>m_commissionRate</code>,</p>&#13;
<p class="bull">• an <code>override</code> of <code>Employee</code>’s <code>earnings</code> function (lines 42–44) that calculates a <code>CommissionEmployee</code>’s earnings, and</p>&#13;
<p class="bull">• an <code>override</code> of <code>Employee</code>’s <code>toString</code> function (lines 47–51) that returns a string containing the <code>Employee::toString()</code> result, the gross sales and the commission rate.</p>&#13;
<div class="group" id="fig10_15">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro15" id="p10pro15a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.15: CommissionEmployee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// CommissionEmployee class derived from Employee.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span> <span class="lgreen">// Employee class definition</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">class</span> CommissionEmployee <span class="blue">final</span> : <span class="blue">public</span> Employee {&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>10</strong></span>      CommissionEmployee(std::string_view name, <span class="blue">double</span> grossSales,&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="blue">double</span> commissionRate);&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">virtual</span> ~CommissionEmployee() = <span class="blue">default</span>; <span class="lgreen">// virtual destructor</span>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">void</span> setGrossSales(<span class="blue">double</span> grossSales);&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="blue">double</span> getGrossSales() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">void</span> setCommissionRate(<span class="blue">double</span> commissionRate);&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="blue">double</span> getCommissionRate() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="lgreen">// keyword override signals intent to override</span>&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const override</span>; <span class="lgreen">// calculate earnings</span>&#13;
<span class="cviolet"><strong>22</strong></span>      std::string toString() <span class="blue">const override</span>; <span class="lgreen">// string representation</span>&#13;
<span class="cviolet"><strong>23</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="blue">double</span> m_grossSales{<span class="green">0.0</span>}; <span class="lgreen"/>&#13;
<span class="cviolet"><strong>25</strong></span>      <span class="blue">double</span> m_commissionRate{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>26</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.15</strong></span> | <code>CommissionEmployee</code> class header. (Part 1 of 2.)</p>&#13;
</div>&#13;
<div class="group" id="fig10_16">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro16" id="p10pro16a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.16: CommissionEmployee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// CommissionEmployee class member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"CommissionEmployee.h"</span> <span class="lgreen">// CommissionEmployee class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   CommissionEmployee::CommissionEmployee(string_view name,&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">double</span> grossSales, <span class="blue">double</span> commissionRate) : Employee{name} {&#13;
<span class="cviolet"><strong>11</strong></span>      setGrossSales(grossSales);&#13;
<span class="cviolet"><strong>12</strong></span>      setCommissionRate(commissionRate);&#13;
<span class="cviolet"><strong>13</strong></span>   }&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// set gross sales amount</span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">void</span> CommissionEmployee::setGrossSales(<span class="blue">double</span> grossSales) {&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">if</span> (grossSales &lt; <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>18</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Gross sales must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>19</strong></span>      }&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      m_grossSales = grossSales;&#13;
<span class="cviolet"><strong>22</strong></span>   }&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>   <span class="lgreen">// return gross sales amount</span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="blue">double</span> CommissionEmployee::getGrossSales() <span class="blue">const</span> {<span class="blue">return</span> m_grossSales;}&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// set commission rate</span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">void</span> CommissionEmployee::setCommissionRate(<span class="blue">double</span> commissionRate) {&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="blue">if</span> (commissionRate &lt;= <span class="green">0.0</span> || commissionRate &gt;= <span class="green">1.0</span>) {&#13;
<span class="cviolet"><strong>30</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Commission rate must be &gt; 0.0 and &lt; 1.0"</span>);&#13;
<span class="cviolet"><strong>31</strong></span>      }&#13;
<span class="cviolet"><strong>32</strong></span>&#13;
<span class="cviolet"><strong>33</strong></span>      m_commissionRate = commissionRate;&#13;
<span class="cviolet"><strong>34</strong></span>   }&#13;
<span class="cviolet"><strong>35</strong></span>&#13;
<span class="cviolet"><strong>36</strong></span>   <span class="lgreen">// return commission rate</span>&#13;
<span class="cviolet"><strong>37</strong></span>   <span class="blue">double</span> CommissionEmployee::getCommissionRate() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>38</strong></span>      <span class="blue">return</span> m_commissionRate;&#13;
<span class="cviolet"><strong>39</strong></span>   }&#13;
<span class="cviolet"><strong>40</strong></span>&#13;
<span class="cviolet"><strong>41</strong></span>   <span class="lgreen">// calculate earnings</span>&#13;
<span class="cviolet"><strong>42</strong></span>   <span class="blue">double</span> CommissionEmployee::earnings() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>43</strong></span>      <span class="blue">return</span> getGrossSales() * getCommissionRate();&#13;
<span class="cviolet"><strong>44</strong></span>   }&#13;
<span class="cviolet"><strong>45</strong></span>&#13;
<span class="cviolet"><strong>46</strong></span>   <span class="lgreen">// return string representation of CommissionEmployee object</span>&#13;
<span class="cviolet"><strong>47</strong></span>   string CommissionEmployee::toString() <span class="blue">const</span> {<span class="blue"/>&#13;
<span class="cviolet"><strong>48</strong></span>     <span class="blue">return</span> fmt::format(<span class="green">"{}\n{}: ${:.2f}\n{}: {:.2f}"</span>, Employee::toString(),&#13;
<span class="cviolet"><strong>49</strong></span>               <span class="green">"gross sales"</span>, getGrossSales(),&#13;
<span class="cviolet"><strong>50</strong></span>               <span class="green">"commission rate"</span>, getCommissionRate());&#13;
<span class="cviolet"><strong>51</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.16</strong></span> | <code>CommissionEmployee</code> class implementation file. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h4 class="h4" id="sec10_9_4">10.9.4 Demonstrating Runtime Polymorphic Processing</h4>&#13;
<p>To test our <code>Employee</code> hierarchy, the program in <a href="ch10.xhtml#fig10_17">Fig. 10.17</a> creates an object of each concrete class—<code>SalariedEmployee</code> and <code>CommissionEmployee</code>. The program manipulates these objects first via their object names, then with runtime polymorphism, using a <code>vector</code> of <code>Employee</code> base-class pointers. Lines 17–18 create objects of each concrete derived class. Lines 21–24 output each employee’s information and earnings. <strong>These lines use variable-name handles, so the compiler can identify at compile-time each object’s type to determine which <code>toString</code> and <code>earnings</code> functions to call.</strong></p>&#13;
<div class="group" id="fig10_17">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro17" id="p10pro17a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_17.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Processing Employee derived-class objects with variable-name handles</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// then polymorphically using base-class pointers and references</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> <span class="green">"CommissionEmployee.h"</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">void</span> virtualViaPointer(<span class="blue">const</span> Employee* baseClassPtr); <span class="lgreen">// prototype</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">void</span> virtualViaReference(<span class="blue">const</span> Employee&amp; baseClassRef); <span class="lgreen">// prototype</span>&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="lgreen">// create derived-class objects</span>&#13;
<span class="cviolet"><strong>17</strong></span>      SalariedEmployee salaried{<span class="green">"John Smith"</span>, <span class="green">800.0</span>};&#13;
<span class="cviolet"><strong>18</strong></span>      CommissionEmployee commission{<span class="green">"Sue Jones"</span>, <span class="green">10000</span>, <span class="green">.06</span>};&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="lgreen">// output each Employee</span>&#13;
<span class="cviolet"><strong>21</strong></span>      cout &lt;&lt; <span class="green">"EMPLOYEES PROCESSED INDIVIDUALLY USING STATIC BINDING\n"</span>&#13;
<span class="cviolet"><strong>22</strong></span>           &lt;&lt; fmt::format("{}\n<span class="green">{}{:.2f}\n\n{}\n{}{:.2f}\n\n"</span>,&#13;
<span class="cviolet"><strong>23</strong></span>                 salaried.toString(), <span class="green">"earned $"</span>, salaried.earnings(),&#13;
<span class="cviolet"><strong>24</strong></span>                 commission.toString(), <span class="green">"earned $"</span>, commission.earnings());&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>      <span class="lgreen">// create and initialize vector of base-class pointers</span>&#13;
<span class="cviolet"><strong>27</strong></span>      vector&lt;Employee*&gt; employees{&amp;salaried, &amp;commission};&#13;
<span class="cviolet"><strong>28</strong></span>&#13;
<span class="cviolet"><strong>29</strong></span>      cout &lt;&lt; <span class="green">"EMPLOYEES PROCESSED POLYMORPHICALLY VIA DYNAMIC BINDING\n\n"</span>;&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>      <span class="lgreen">// call virtualViaPointer to print each Employee</span>&#13;
<span class="cviolet"><strong>32</strong></span>      <span class="lgreen">// and earnings using dynamic binding</span>&#13;
<span class="cviolet"><strong>33</strong></span>      cout &lt;&lt; <span class="green">"VIRTUAL FUNCTION CALLS MADE VIA BASE-CLASS POINTERS\n"</span>;&#13;
<span class="cviolet"><strong>34</strong></span>&#13;
<span class="cviolet"><strong>35</strong></span>      <span class="blue">for</span> (<span class="blue">const</span> Employee* employeePtr : employees) {&#13;
<span class="cviolet"><strong>36</strong></span>         virtualViaPointer(employeePtr);&#13;
<span class="cviolet"><strong>37</strong></span>      }&#13;
<span class="cviolet"><strong>38</strong></span>&#13;
<span class="cviolet"><strong>39</strong></span>      <span class="lgreen">// call virtualViaReference to print each Employee</span>&#13;
<span class="cviolet"><strong>40</strong></span>      <span class="lgreen">// and earnings using dynamic binding</span>&#13;
<span class="cviolet"><strong>41</strong></span>      cout &lt;&lt; <span class="green">"VIRTUAL FUNCTION CALLS MADE VIA BASE-CLASS REFERENCES\n"</span>;&#13;
<span class="cviolet"><strong>42</strong></span>&#13;
<span class="cviolet"><strong>43</strong></span>      <span class="blue">for</span> (<span class="blue">const</span> Employee* employeePtr : employees) {&#13;
<span class="cviolet"><strong>44</strong></span>         virtualViaReference(*employeePtr); <span class="lgreen">// note dereferenced pointer</span>&#13;
<span class="cviolet"><strong>45</strong></span>      }&#13;
<span class="cviolet"><strong>46</strong></span>   }&#13;
<span class="cviolet"><strong>47</strong></span>&#13;
<span class="cviolet"><strong>48</strong></span>   <span class="lgreen">// call Employee virtual functions toString and earnings via a</span>&#13;
<span class="cviolet"><strong>49</strong></span>   <span class="lgreen">// base-class pointer using dynamic binding</span>&#13;
<span class="cviolet"><strong>50</strong></span>   <span class="blue">void</span> virtualViaPointer(<span class="blue">const</span> Employee* baseClassPtr) {&#13;
<span class="cviolet"><strong>51</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\nearned ${:.2f}\n\n",</span>&#13;
<span class="cviolet"><strong>52</strong></span>                 baseClassPtr-&gt;toString(), baseClassPtr-&gt;earnings());&#13;
<span class="cviolet"><strong>53</strong></span>   }&#13;
<span class="cviolet"><strong>54</strong></span>&#13;
<span class="cviolet"><strong>55</strong></span>   <span class="lgreen">// call Employee virtual functions toString and earnings via a</span>&#13;
<span class="cviolet"><strong>56</strong></span>   <span class="lgreen">// base-class reference using dynamic binding</span>&#13;
<span class="cviolet"><strong>57</strong></span>   <span class="blue">void</span> virtualViaReference(<span class="blue">const</span> Employee&amp; baseClassRef) {&#13;
<span class="cviolet"><strong>58</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\nearned ${:.2f}\n\n",</span>&#13;
<span class="cviolet"><strong>59</strong></span>                 baseClassRef.toString(), baseClassRef.earnings());&#13;
<span class="cviolet"><strong>60</strong></span>   }</pre>&#13;
<pre class="pre1">EMPLOYEES PROCESSED INDIVIDUALLY USING STATIC BINDING&#13;
name: John Smith&#13;
salary: $800.00&#13;
earned $800.00&#13;
&#13;
name: Sue Jones&#13;
gross sales: $10000.00&#13;
commission rate: 0.06&#13;
earned $600.00&#13;
&#13;
EMPLOYEES PROCESSED POLYMORPHICALLY VIA DYNAMIC BINDING&#13;
&#13;
VIRTUAL FUNCTION CALLS MADE VIA BASE-CLASS POINTERS&#13;
name: John Smith&#13;
salary: $800.00&#13;
earned $800.00&#13;
&#13;
name: Sue Jones&#13;
gross sales: $10000.00&#13;
commission rate: 0.06&#13;
earned $600.00&#13;
&#13;
VIRTUAL FUNCTION CALLS MADE VIA BASE-CLASS REFERENCES&#13;
name: John Smith&#13;
salary: $800.00&#13;
earned $800.00&#13;
&#13;
name: Sue Jones&#13;
gross sales: $10000.00&#13;
commission rate: 0.06&#13;
earned $600.00</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.17</strong></span> | Processing <code>Employee</code> derived-class objects with variable-name handles then polymorphically using base-class pointers and references. (Part 3 of 3.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec40">Creating a <code>vector</code> of Employee Pointers</h5>&#13;
<p>Line 27 creates and initializes the <code>vector employees</code>, which contains two <code>Employee</code> pointers aimed at the objects <code>salaried</code> and <code>commission</code>, respectively. The compiler allows the elements to be initialized with these objects’ addresses because a <code>SalariedEmployee</code> <em>is an</em> <code>Employee</code> and a <code>CommissionEmployee</code> <em>is an</em> <code>Employee</code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec41">Function <code>virtualViaPointer</code></h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Lines 35–37 traverse the <code>vector employees</code> and invoke function <code>virtualViaPointer</code> (lines 50–53) with each element as an argument. Function <code>virtualViaPointer</code> receives in its parameter <code>baseClassPtr</code> the address stored in a given <code>employees</code> element, then uses the pointer to invoke <code>virtual</code> functions <code>toString</code> and <code>earnings</code>. The function does not contain any <code>SalariedEmployee</code> or <code>CommissionEmployee</code> type information—it knows only about base-class <code>Employee</code>. The program repeatedly aims <code>baseClassPtr</code> at different concrete derived-class objects, so <strong>the compiler cannot know which concrete class’s functions to call through <code>baseClassPtr</code>—it must resolve these calls at runtime using dynamic binding.</strong> At execution time, each <code>virtual</code>-function call correctly invokes the function on the object to which <code>baseClassPtr</code> currently points. The output shows that each class’s appropriate functions are invoked and that each object’s correct information is displayed. Obtaining each <code>Employee</code>’s <code>earnings</code> via runtime polymorphism produces the same results as shown in lines 23 and 24.</p>&#13;
<h5 class="h5" id="ch10lev3sec42">Function <code>virtualViaReference</code></h5>&#13;
<p>Lines 43–45 traverse <code>employees</code> and invoke function <code>virtualViaReference</code> (lines 57–60) with each element as an argument. Function <code>virtualViaReference</code> receives in its parameter <code>baseClassRef</code> (of type <code>const Employee&amp;</code>) a reference to the object obtained by dereferencing the pointer stored in an element of <code>vector employees</code> (line 44). Each call to this function invokes <code>virtual</code> functions <code>toString</code> and <code>earnings</code> via <code>baseClassRef</code> to demonstrate that runtime polymorphic processing occurs with base-class references as well. Each <code>virtual</code> function invocation calls the function on the object to which <code>baseClassRef</code> refers at runtime. This is another example of dynamic binding. The output produced using base-class references is identical to the output produced using base-class pointers and via static binding earlier in the program.</p>&#13;
<h3 class="h3" id="sec10_10"><span class="violet">10.10</span> Runtime Polymorphism, Virtual Functions and Dynamic Binding “Under the Hood”</h3>&#13;
<p>Let’s consider how C++ can implement runtime polymorphism, <code>virtual</code> functions and dynamic binding internally. This will give you a solid understanding of how these capabilities can work. More importantly, <strong>you’ll appreciate the overhead of runtime polymorphism—in terms of additional memory consumption and processor time</strong>. This can help you determine when to use runtime polymorphism and when to avoid it. <strong>C++ standard-library classes generally are implemented without <code>virtual</code> functions to avoid the associated execution-time overhead and achieve optimal performance.</strong></p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> First, we’ll explain the data structures that the compiler can build at compile time to support polymorphism at execution time. You’ll see that this can be accomplished through three levels of pointers, i.e., <em>triple indirection</em>. Then we’ll show how an executing program can use these data structures to execute <code>virtual</code> functions and achieve the dynamic binding associated with polymorphism. Our discussion explains a possible implementation.</p>&#13;
<h5 class="h5" id="ch10lev3sec43">Virtual-Function Tables</h5>&#13;
<p>When C++ compiles a class with one or more <code>virtual</code> functions, it builds a <strong><span class="violet">virtual function table (<em>vtable</em>)</span></strong> for that class. The <em>vtable</em> contains pointers to the class’s <code>virtual</code> functions. A <strong><span class="violet">pointer to a function</span></strong> contains the starting address in memory of the code that performs the function’s task. Just as an array name is implicitly convertible to the address of the array’s first element, a function name is implicitly convertible to the starting address of its code.</p>&#13;
<p>With dynamic binding, an executing program uses a class’s <em>vtable</em> to select the proper function implementation each time a <code>virtual</code> function is called on an object of that class. The leftmost column of <a href="ch10.xhtml#fig10_18">Fig. 10.18</a> illustrates the <em>vtables</em> for the classes <code>Employee</code>, <code>SalariedEmployee</code> and <code>CommissionEmployee</code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec44"><code>Employee</code> Class vtable</h5>&#13;
<p>In the <code>Employee</code> class <em>vtable</em>, the first function pointer is set to <code>0</code> (i.e., <code>nullptr</code>) because function <code>earnings</code> is a pure <code>virtual</code> function—it does not have an implementation. The second function pointer points to function <code>toString</code>, which returns a <code>string</code> containing the employee’s name. We’ve abbreviated each <code>toString</code> function’s output in this figure to conserve space. <strong>Any class with one or more pure <code>virtual</code> functions (represented with the value <code>0</code>) in its <em>vtable</em> is an abstract class.</strong> Classes <code>SalariedEmployee</code> and <code>CommissionEmployee</code>, which have no <code>nullptr</code>s in their <em>vtables</em>, are concrete classes.</p>&#13;
<div class="image" id="fig10_18"><img src="Images/10fig18.jpg" alt="Images" width="738" height="643"/></div>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.18</strong></span> | How <code>virtual</code> function calls work.</p>&#13;
<h5 class="h5" id="ch10lev3sec45"><code>SalariedEmployee</code> Class vtable</h5>&#13;
<p>Class <code>SalariedEmployee</code> overrides function <code>earnings</code> to return the employee’s salary, so the function pointer points to <code>SalariedEmployee</code>’s <code>earnings</code> function, which returns the salary. <code>SalariedEmployee</code> also overrides <code>toString</code>, so the corresponding function pointer points to <code>SalariedEmployee</code>’s <code>toString</code> function, which returns the employee’s name and salary.</p>&#13;
<h5 class="h5" id="ch10lev3sec46"><code>CommissionEmployee</code> Class vtable</h5>&#13;
<p>The <code>earnings</code> function pointer in the <code>CommissionEmployee</code> <em>vtable</em> points to the <code>CommissionEmployee</code>’s <code>earnings</code> function, which returns the employee’s gross sales multiplied by the commission rate. The <code>toString</code> function pointer points to the <code>CommissionEmployee</code> version of the function, which returns the employee’s name, commission rate and gross sales. As in class <code>SalariedEmployee</code>, both functions override class <code>Employee</code>’s functions.</p>&#13;
<h5 class="h5" id="ch10lev3sec47">Inheriting Concrete <code>virtual</code> Functions</h5>&#13;
<p>In our <code>Employee</code> case study, each concrete class provides its own <code>virtual earnings</code> and <code>toString</code> implementations. You’ve learned that, because <code>earnings</code> is a pure <code>virtual</code> function, each <em>direct</em> derived class of <code>Employee</code> must implement <code>earnings</code> to be a concrete class. Direct derived classes do not need to implement <code>toString</code> to be considered concrete—they can inherit class <code>Employee</code>’s <code>toString</code> implementation. In our case, both derived classes override <code>Employee</code>’s <code>toString</code>.</p>&#13;
<p><strong>If a derived class in our hierarchy were to inherit <code>toString</code> and not override it, this function’s <em>vtable</em> pointer would simply point to the inherited implementation</strong>. For example, if <code>CommissionEmployee</code> did not override <code>toString</code>, <code>CommissionEmployee</code>’s <code>toString</code> function pointer in the <em>vtable</em> would point to the same <code>toString</code> function as in class <code>Employee</code>’s <em>vtable</em>.</p>&#13;
<h5 class="h5" id="ch10lev3sec48">Three Levels of Pointers to Implement Runtime Polymorphism</h5>&#13;
<p>Runtime polymorphism can be accomplished through an elegant data structure involving three levels of pointers. We’ve discussed one level—the function pointers in the <em>vtable</em>. These point to the actual functions that execute when a <code>virtual</code> function is invoked.</p>&#13;
<p>Now we consider the second level of pointers. <strong>Whenever an object with one or more <code>virtual</code> functions is instantiated, the compiler attaches to the object a pointer to the <em>vtable</em> for that class<em>.</em></strong> This pointer is normally at the front of the object, but it isn’t required to be implemented that way. In the <em>vtable</em> diagram, these pointers are associated with the <code>SalariedEmployee</code> and <code>CommissionEmployee</code> objects defined in <a href="ch10.xhtml#fig10_17">Fig. 10.17</a>. The diagram shows each object’s data member values.</p>&#13;
<p>The third level of pointers are handles to the objects on which the <code>virtual</code> function will be called. The <em>vtable</em> diagram depicts the <code>vector employees</code> containing <code>Employee</code> pointers.</p>&#13;
<p>Now let’s see how a typical <code>virtual</code> function call executes. Consider in the function <code>virtualViaPointer</code> the call <code>baseClassPtr-&gt;toString()</code> (<a href="ch10.xhtml#fig10_17">Fig. 10.17</a>, line 52). Assume that <code>baseClassPtr</code> contains <code>employees[1]</code>, <code>commission</code>’s address in <code>employees</code>. When this statement is compiled, the compiler sees that the call is made via a base-class pointer and that <code>toString</code> is a <code>virtual</code> function. The compiler sees that <code>toString</code> is the second entry in each <em>vtable</em>. So it includes an <strong><span class="violet">offset</span></strong> into the table of machine-language object-code pointers to find the code that will execute the <code>virtual</code> function call.</p>&#13;
<p>The compiler generates code that performs the following operations—the numbers in the list correspond to the circled numbers in <a href="ch10.xhtml#fig10_18">Fig. 10.18</a>:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> Select the <em>i</em>th <code>employees</code> entry—the <code>commission</code> object’s address—and pass it as an argument to function <code>virtualViaPointer</code>. This aims parameter <code>base-ClassPtr</code> at the <code>commission</code> object.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> Dereference that pointer to get to the <code>commission</code> object, which begins with a pointer to class <code>CommissionEmployee</code>’s <em>vtable</em>.</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> Dereference the <em>vtable</em> pointer to get to class <code>CommissionEmployee</code>’s <em>vtable</em>.</p>&#13;
<p class="num"><span class="red"><strong>4.</strong></span> Skip the offset of eight bytes to select the <code>toString</code> function pointer.<sup><a id="ch10fn18a" href="ch10.xhtml#ch10fn18">18</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn18" href="ch10.xhtml#ch10fn18a">18</a>. In practice, <em>Steps 3</em> and <em>4</em> can be implemented as a single machine instruction.</p>&#13;
<p class="num"><span class="red"><strong>5.</strong></span> Execute <code>toString</code> for the <code>commission</code> object, returning a <code>string</code> containing the employee’s name, gross sales and commission rate.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <strong>The <em>vtable</em> diagram’s data structures may appear complex, but this complexity is managed by the compiler and hidden from you, making runtime polymorphic programming straightforward.</strong> The pointer dereferencing operations and memory accesses for each <code>virtual</code> function call require additional execution time, and the <em>vtables</em> and <em>vtable</em> pointers added to the objects require some additional memory.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <strong>Runtime polymorphism, as typically implemented with <code>virtual</code> functions and dynamic binding in C++, is efficient.</strong> For most applications, you can use these capabilities with nominal impact on execution performance and memory consumption. In some situations, polymorphism’s overhead may be too high—such as in real-time applications with stringent execution-timing performance requirements, or in an application with an enormous number of <em>small</em> objects in which the size of the <em>vtable</em> pointer is large when compared to the size of each object.</p>&#13;
<h3 class="h3" id="sec10_11"><span class="violet">10.11</span> Non-Virtual Interface (NVI) Idiom</h3>&#13;
<p>The <strong><span class="violet">non-virtual interface idiom (NVI)</span></strong><sup><a id="ch10fn19a" href="ch10.xhtml#ch10fn19">19</a>,<a id="ch10fn20a" href="ch10.xhtml#ch10fn20">20</a></sup> is another way to implement runtime polymorphism using class hierarchies. The idiom was first proposed by Herb Sutter in his paper, “Virtuality.”<sup><a id="ch10fn21a" href="ch10.xhtml#ch10fn21">21</a></sup> Sutter lists four guidelines for implementing class hierarchies, each of which we’ll use in this example:</p>&#13;
<p class="footnote"><a id="ch10fn19" href="ch10.xhtml#ch10fn19a">19</a>. “Non-virtual interface (NVI) pattern.” Accessed February 8, 2021. <code><a href="https://w.wiki/yRF">https://w.wiki/yRF</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn20" href="ch10.xhtml#ch10fn20a">20</a>. Marius Bancila. <em>Modern C++ Programming Cookbook: Master C++ Core Language and Standard Library Features, with over 100 Recipes, Updated to C++20</em>, pp. 562–67. Birmingham: Packt Publishing, 2020.</p>&#13;
<p class="footnote"><a id="ch10fn21" href="ch10.xhtml#ch10fn21a">21</a>. Sutter, Herb. "Virtuality," C/C++ Users Journal, vol. 19, no. 9, September 2001. Accessed February 16, 2021. <code><a href="http://www.gotw.ca/publications/mill18.htm">http://www.gotw.ca/publications/mill18.htm</a></code>.</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> “Prefer to make interfaces non-<code>virtual</code>, using Template Method”—an object-oriented design pattern.<sup><a id="ch10fn22a" href="ch10.xhtml#ch10fn22">22</a>,<a id="ch10fn23a" href="ch10.xhtml#ch10fn23">23</a></sup> Sutter explains that a <code>public virtual</code> function serves <em>two</em> purposes—it describes part of a class’s interface, and it enables derived classes to customize behavior by overriding the <code>virtual</code> function. He recommends that each function should serve only <em>one</em> purpose.</p>&#13;
<p class="footnote"><a id="ch10fn22" href="ch10.xhtml#ch10fn22a">22</a>. “Template Method Pattern.” Accessed February 3, 2021. <code><a href="https://w.wiki/yFd">https://w.wiki/yFd</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn23" href="ch10.xhtml#ch10fn23a">23</a>. Erich Gamma et al. <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Reading, MA: Addison-Wesley, 1995, pp. 325–330.</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> “Prefer to make <code>virtual</code> functions <code>private</code>.” <strong>A derived class can override its base class’s <code>private virtual</code> functions.</strong> By making a <code>virtual</code> function <code>private</code>, it serves one purpose—enabling derived classes to customize behavior by overriding the <code>virtual</code> function. In the base class, a non-<code>virtual</code> function invokes the <code>private virtual</code> function internally as an implementation detail.</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> “Only if derived classes need to invoke the base implementation of a <code>virtual</code> function, make the <code>virtual</code> function <code>protected</code>.” This enables derived classes to override the base-class <code>virtual</code> function and take advantage of its base-class implementation to avoid duplicating code in the derived class.</p>&#13;
<p class="num"><span class="red"><strong>4.</strong></span> “A base-class destructor should be either <code>public</code> and <code>virtual</code>, or <code>protected</code> and non-<code>virtual</code>.” Here, we’ll again make the <code>Employee</code> base class’s destructor <code>public</code> and <code>virtual</code>. In <a href="ch11.xhtml#ch11">Chapter 11</a>, you’ll see that <code>public virtual</code> destructors are important when deleting dynamically allocated derived-class objects via base-class pointers.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Sutter’s paper demonstrates each recommendation, focusing on separating a class’s interface from its implementation as a good software-engineering practice.<sup><a id="ch10fn24a" href="ch10.xhtml#ch10fn24">24</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn24" href="ch10.xhtml#ch10fn24a">24</a>. For some related inheritance discussions, see the ISO C++ FAQ, “Inheritance — What your mother never told you” at <code><a href="https://isocpp.org/wiki/faq/strange-inheritance">https://isocpp.org/wiki/faq/strange-inheritance</a></code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec49">Refactoring Class <code>Employee</code> for the NVI Idiom</h5>&#13;
<p>Per Sutter’s guidelines, let’s refactor our <code>Employee</code> class (Figs. 10.19–10.20). Most of the code is identical to <a href="ch10.xhtml#sec10_9">Section 10.9</a>, so we focus here on only the changes. There are several key changes in <a href="ch10.xhtml#fig10_19">Fig. 10.19</a>:</p>&#13;
<p class="bull">• <code>Employee</code>’s <code>public earnings</code> (line 15) and <code>toString</code> (line 16) member functions are no longer declared <code>virtual</code>, and, as you’ll see, <code>earnings</code> will have an implementation. Functions <code>earnings</code> and <code>toString</code> each now serve <em>one</em> purpose—to allow client code to get an <code>Employee</code>’s earnings and <code>string</code> representation, respectively. Their original second purpose as customization points for derived classes will now be implemented via new member functions.</p>&#13;
<p class="bull">• We added the <code>protected virtual</code> function <code>getString</code> (line 18) to serve as a customization point for derived classes. This function is called by the non-<code>virtual toString</code> function. As you’ll see, our derived classes’ <code>getString</code> functions will both override and call class <code>Employee</code>’s <code>getString</code>.</p>&#13;
<p class="bull">• We added the <code>private</code> pure <code>virtual</code> function <code>getPay</code> (line 21) to serve as a customization point for derived classes. This function is called by the non-<code>virtual earnings</code> function. Derived classes override <code>getPay</code> to specify custom earnings calculations.</p>&#13;
<div class="group" id="fig10_19">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro19" id="p10pro19a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.19: Employee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Employee abstract base class.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">class</span> Employee {&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>9</strong></span>      Employee(std::string_view name);&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">virtual</span> ~Employee() = <span class="blue">default</span>;&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">void</span> setName(std::string_view name);&#13;
<span class="cviolet"><strong>13</strong></span>      std::string getName() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const</span>; <span class="lgreen">// not virtual</span>&#13;
<span class="cviolet"><strong>16</strong></span>      std::string toString() <span class="blue">const</span>; <span class="lgreen">// not virtual</span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="blue">protected</span>:&#13;
<span class="cviolet"><strong>18</strong></span>      virtual std::string getString() <span class="blue">const</span>; <span class="lgreen">// virtual</span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>20</strong></span>      std::string m_name;&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">virtual double</span> getPay() <span class="blue">const</span> = <span class="green">0</span>; <span class="lgreen">// pure virtual</span>&#13;
<span class="cviolet"><strong>22</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.19</strong></span> | Employee abstract base class.</p>&#13;
</div>&#13;
<p>There are several key changes in class <code>Employee</code>’s member-function implementations (<a href="ch10.xhtml#fig10_20">Fig. 10.20</a>):</p>&#13;
<p class="bull">• Member-function <code>earnings</code> (line 18) now provides a concrete implementation that returns the result of calling the <code>private</code> pure <code>virtual</code> function <code>getPay</code>.</p>&#13;
<p class="bull">• Member-function <code>toString</code> (line 21) now returns the result of calling the <code>protected virtual</code> function <code>getString</code>.</p>&#13;
<p class="bull">• We now define the <code>protected</code> member-function <code>getString</code> to specify an <code>Employee</code>’s default <code>string</code> representation containing an <code>Employee</code>’s name. This function is <code>protected</code> so derived classes can both override it <em>and</em> call it to get the base-class part of the derived-class <code>string</code> representations.</p>&#13;
<div class="group" id="fig10_20">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro20" id="p10pro20a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.20: Employee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Abstract-base-class Employee member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// Note: No definitions are given for pure virtual functions.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span> <span class="lgreen">// Employee class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   Employee::Employee(string_view name) : m_name{name} {} <span class="lgreen">// empty body</span>&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="lgreen">// set name</span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">void</span> Employee::setName(string_view name) {m_name = name;}&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="lgreen">// get name</span>&#13;
<span class="cviolet"><strong>15</strong></span>   string Employee::getName() <span class="blue">const</span> {<span class="blue">return</span> m_name;}&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// public non-virtual function; returns Employee's earnings</span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">double</span> Employee::earnings() <span class="blue">const</span> {<span class="blue">return</span> getPay();}&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="lgreen">// public non-virtual function; returns Employee's string representation</span>&#13;
<span class="cviolet"><strong>21</strong></span>   string Employee::toString() <span class="blue">const</span> {<span class="blue">return</span> getString();}&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>   <span class="lgreen">// protected virtual function that derived classes can override and call</span>&#13;
<span class="cviolet"><strong>24</strong></span>   string Employee::getString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>25</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"name: {}"</span>, getName());&#13;
<span class="cviolet"><strong>26</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.20</strong></span> | Abstract-base-class <code>Employee</code> member-function definitions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec50">Updated Class <code>SalariedEmployee</code></h5>&#13;
<p>Our refactored <code>SalariedEmployee</code> class (Figs. 10.21–10.22) has several key changes:</p>&#13;
<p class="bull">• The class’s header (<a href="ch10.xhtml#fig10_21">Fig. 10.21</a>) no longer contains prototypes for the <code>earnings</code> and <code>toString</code> member functions. These <code>public</code> non-<code>virtual</code> base-class functions are now inherited by class <code>SalariedEmployee</code>.</p>&#13;
<p class="bull">• The class’s <code>private</code> section now declares overrides for the base-class’s <code>private</code> pure <code>virtual</code> function <code>getPay</code> and <code>protected virtual</code> function <code>getString</code> (<a href="ch10.xhtml#fig10_21">Fig. 10.21</a>, lines 19–20). We made <code>getString private</code> here because this class is <code>final</code>, so no other classes can derive from it.</p>&#13;
<p class="bull">• The class’s member-function implementations (<a href="ch10.xhtml#fig10_22">Fig. 10.22</a>) now include the overridden <code>private getPay</code> function (line 28), which returns the salary, and <code>private getString</code> function (lines 31–34), which specifies a <code>SalariedEmployee</code>’s <code>string</code> representation. Note that <code>SalariedEmployee</code>’s <code>getString</code> calls class <code>Employee</code>’s <code>protected getString</code> to get part of the <code>string</code> representation.</p>&#13;
<div class="group" id="fig10_21">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro21" id="p10pro21a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.21: SalariedEmployee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// SalariedEmployee class derived from Employee.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt; <span class="lgreen">// C++ standard string class</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> "Employee.h" <span class="lgreen">// Employee class definition</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">class</span> SalariedEmployee <span class="blue">final</span> : <span class="blue">public</span> Employee {&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>10</strong></span>      SalariedEmployee(std::string_view name, <span class="blue">double</span> salary);&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">virtual</span> ~SalariedEmployee() = <span class="blue">default</span>; <span class="lgreen">// virtual destructor</span>&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">void</span> setSalary(double salary);&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">double</span> getSalary() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">double</span> m_salary{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="lgreen">// keyword override signals intent to override</span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">double</span> getPay() <span class="blue">const override</span>; <span class="lgreen">// calculate earnings</span>&#13;
<span class="cviolet"><strong>20</strong></span>      std::string getString() <span class="blue">const override</span>; <span class="lgreen">// string representation</span>&#13;
<span class="cviolet"><strong>21</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.21</strong></span> | <code>SalariedEmployee</code> class derived from <code>Employee</code>.</p>&#13;
</div>&#13;
<div class="group" id="fig10_22">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro22" id="p10pro22a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.22: SalariedEmployee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// SalariedEmployee class member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"SalariedEmployee.h"</span> <span class="lgreen">// SalariedEmployee class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   SalariedEmployee::SalariedEmployee(string_view name, double salary)&#13;
<span class="cviolet"><strong>10</strong></span>      : Employee{name} {&#13;
<span class="cviolet"><strong>11</strong></span>      setSalary(salary);&#13;
<span class="cviolet"><strong>12</strong></span>   }&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="lgreen">// set salary</span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">void</span> SalariedEmployee::setSalary(<span class="blue">double</span> salary) {&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">if</span> (salary &lt; <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>17</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Weekly salary must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>18</strong></span>      }&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>      m_salary = salary;&#13;
<span class="cviolet"><strong>21</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>   <span class="lgreen">// return salary</span>&#13;
<span class="cviolet"><strong>24</strong></span>   <span class="blue">double</span> SalariedEmployee::getSalary() <span class="blue">const</span> {<span class="blue">return</span> m_salary;}&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="lgreen">// calculate earnings;</span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// override pure virtual function getPay in Employee</span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">double</span> SalariedEmployee::getPay() <span class="blue">const</span> {<span class="blue">return</span> getSalary();}&#13;
<span class="cviolet"><strong>29</strong></span>&#13;
<span class="cviolet"><strong>30</strong></span>   <span class="lgreen">// return a string representation of SalariedEmployee</span>&#13;
<span class="cviolet"><strong>31</strong></span>   string SalariedEmployee::getString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>32</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"{}\n{}: ${:.2f}"</span>, Employee::getString(),&#13;
<span class="cviolet"><strong>33</strong></span>                <span class="green">"salary"</span>, getSalary());&#13;
<span class="cviolet"><strong>34</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.22</strong></span> | <code>SalariedEmployee</code> class member-function definitions. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec51">Updated Class <code>CommissionEmployee</code></h5>&#13;
<p>Our refactored <code>CommissionEmployee</code> class (Figs. 10.23–10.24) has several key changes:</p>&#13;
<p class="bull">• The class’s header (<a href="ch10.xhtml#fig10_23">Fig. 10.23</a>) no longer contains prototypes for the <code>earnings</code> and <code>toString</code> member functions. These <code>public</code> non-<code>virtual</code> base-class functions are now inherited by class <code>CommissionEmployee</code>.</p>&#13;
<p class="bull">• The class’s <code>private</code> section now declares overrides for the base-class’s <code>private</code> pure <code>virtual</code> function <code>getPay</code> and <code>protected virtual</code> function <code>getString</code> (<a href="ch10.xhtml#fig10_23">Fig. 10.23</a>, lines 24–25). Again, we made <code>getString private</code> because this class is <code>final</code>, so no other classes can derive from it.</p>&#13;
<p class="bull">• The class’s member-function implementations (<a href="ch10.xhtml#fig10_24">Fig. 10.24</a>) now include the overridden <code>getPay</code> function (lines 42–44), which returns the result of the commission calculation, and <code>getString</code> function (lines 47–51), which specifies a <code>CommissionEmployee</code>’s <code>string</code> representation. <code>CommissionEmployee</code>’s <code>get-String</code> calls class <code>Employee</code>’s <code>protected getString</code> to get part of the <code>string</code> representation.</p>&#13;
<div class="group" id="fig10_23">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro23" id="p10pro23a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.23: CommissionEmployee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// CommissionEmployee class derived from Employee.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span> <span class="lgreen">// Employee class definition</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">class</span> CommissionEmployee <span class="blue">final</span> : <span class="blue">public</span> Employee {&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>10</strong></span>      CommissionEmployee(std::string_view name, <span class="blue">double</span> grossSales,&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="blue">double</span> commissionRate);&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">virtual</span> ~CommissionEmployee() = <span class="blue">default</span>; <span class="lgreen">// virtual destructor</span>&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">void</span> setGrossSales(double grossSales);&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="blue">double</span> getGrossSales() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">void</span> setCommissionRate(<span class="blue">double</span> commissionRate);&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="blue">double</span> getCommissionRate() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">double</span> m_grossSales{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="blue">double</span> m_commissionRate{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="lgreen">// keyword override signals intent to override</span>&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="blue">double</span> getPay() <span class="blue">const</span> <span class="blue">override</span>; <span class="lgreen">// calculate earnings</span>&#13;
<span class="cviolet"><strong>25</strong></span>      std::string getString() <span class="blue">const override</span>; <span class="lgreen">// string representation</span>&#13;
<span class="cviolet"><strong>26</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.23</strong></span> | <code>CommissionEmployee</code> class derived from <code>Employee</code>. (Part 1 of 2.)</p>&#13;
</div>&#13;
<div class="group" id="fig10_24">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro24" id="p10pro24a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.24: CommissionEmployee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// CommissionEmployee class member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"CommissionEmployee.h"</span> <span class="lgreen">// CommissionEmployee class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   CommissionEmployee::CommissionEmployee(string_view name,&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">double</span> grossSales, <span class="blue">double</span> commissionRate) : Employee{name} {&#13;
<span class="cviolet"><strong>11</strong></span>      setGrossSales(grossSales);&#13;
<span class="cviolet"><strong>12</strong></span>      setCommissionRate(commissionRate);&#13;
<span class="cviolet"><strong>13</strong></span>   }&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// set gross sales amount</span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">void</span> CommissionEmployee::setGrossSales(<span class="blue">double</span> grossSales) {&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">if</span> (grossSales &lt; <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>18</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Gross sales must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>19</strong></span>      }&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      m_grossSales = grossSales;&#13;
<span class="cviolet"><strong>22</strong></span>   }&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>   <span class="lgreen">// return gross sales amount</span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="blue">double</span> CommissionEmployee::getGrossSales() <span class="blue">const</span> {<span class="blue">return</span> m_grossSales;}&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// set commission rate</span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">void</span> CommissionEmployee::setCommissionRate(<span class="blue">double</span> commissionRate) {&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="blue">if</span> (commissionRate &lt;= <span class="green">0.0</span> || commissionRate &gt;= <span class="green">1.0</span>) {&#13;
<span class="cviolet"><strong>30</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Commission rate must be &gt; 0.0 and &lt; 1.0"</span>);&#13;
<span class="cviolet"><strong>31</strong></span>      }&#13;
<span class="cviolet"><strong>32</strong></span>&#13;
<span class="cviolet"><strong>33</strong></span>      m_commissionRate = commissionRate;&#13;
<span class="cviolet"><strong>34</strong></span>   }&#13;
<span class="cviolet"><strong>35</strong></span>&#13;
<span class="cviolet"><strong>36</strong></span>   <span class="lgreen">// return commission rate</span>&#13;
<span class="cviolet"><strong>37</strong></span>   <span class="blue">double</span> CommissionEmployee::getCommissionRate() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>38</strong></span>      <span class="blue">return</span> m_commissionRate;&#13;
<span class="cviolet"><strong>39</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>40</strong></span>&#13;
<span class="cviolet"><strong>41</strong></span>   <span class="lgreen">// calculate earnings</span>&#13;
<span class="cviolet"><strong>42</strong></span>   <span class="blue">double</span> CommissionEmployee::getPay() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>43</strong></span>      <span class="blue">return</span> getGrossSales() * getCommissionRate();&#13;
<span class="cviolet"><strong>44</strong></span>   }&#13;
<span class="cviolet"><strong>45</strong></span>&#13;
<span class="cviolet"><strong>46</strong></span>   <span class="lgreen">// return string representation of CommissionEmployee object</span>&#13;
<span class="cviolet"><strong>47</strong></span>   string CommissionEmployee::getString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>48</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"{}\n{}: ${:.2f}\n{}: {:.2f}"</span>, Employee::getString(),&#13;
<span class="cviolet"><strong>49</strong></span>                "gross sales", getGrossSales(),&#13;
<span class="cviolet"><strong>50</strong></span>                "commission rate", getCommissionRate());&#13;
<span class="cviolet"><strong>51</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.24</strong></span> | <code>CommissionEmployee</code> class member-function definitions. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec52">Runtime Polymorphism with the Employee Hierarchy Using NVI</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The test application for this example is identical to the one in <a href="ch10.xhtml#fig10_17">Fig. 10.17</a>, so we show only the output in <a href="ch10.xhtml#fig10_25">Fig. 10.25</a>. The program’s output also is identical to <a href="ch10.xhtml#fig10_17">Fig. 10.17</a>, demonstrating that we still get polymorphic processing even with <code>protected</code> and <code>private</code> base-class <code>virtual</code> functions. <strong>Our client code now calls only non-<code>virtual</code> functions, yet each derived class was able to provide custom behavior by overriding the <code>protected</code> and <code>private</code> base-class <code>virtual</code> functions. The <code>virtual</code> functions are now internal implementation details of the class hierarchy, hidden from the client-code programmer. We can change those <code>virtual</code> function implementations—and potentially even their signatures—without affecting the client code.</strong></p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro25" id="p10pro25a">Click here to view code image</a></p>&#13;
<pre class="pre1">EMPLOYEES PROCESSED INDIVIDUALLY USING STATIC BINDING&#13;
name: John Smith&#13;
salary: $800.00&#13;
earned $800.00&#13;
&#13;
name: Sue Jones&#13;
gross sales: $10000.00&#13;
commission rate: 0.06&#13;
earned $600.00&#13;
&#13;
EMPLOYEES PROCESSED POLYMORPHICALLY VIA DYNAMIC BINDING&#13;
&#13;
VIRTUAL FUNCTION CALLS MADE VIA BASE-CLASS POINTERS&#13;
name: John Smith&#13;
salary: $800.00&#13;
earned $800.00&#13;
&#13;
name: Sue Jones&#13;
gross sales: $10000.00&#13;
commission rate: 0.06&#13;
earned $600.00&#13;
&#13;
VIRTUAL FUNCTION CALLS MADE VIA BASE-CLASS REFERENCES&#13;
name: John Smith&#13;
salary: $800.00&#13;
earned $800.00&#13;
&#13;
name: Sue Jones&#13;
gross sales: $10000.00&#13;
commission rate: 0.06&#13;
earned $600.00</pre>&#13;
<p class="fig-caption" id="fig10_25"><span class="red"><strong>Fig. 10.25</strong></span> | Processing <code>Employee</code> derived-class objects with static binding, then polymorphically using dynamic binding. (Part 2 of 2.)</p>&#13;
<h3 class="h3" id="sec10_12"><span class="violet">10.12</span> Program to an Interface, Not an Implementation<sup><a id="ch10fn25a" href="ch10.xhtml#ch10fn25">25</a></sup></h3>&#13;
<p class="footnote"><a id="ch10fn25" href="ch10.xhtml#ch10fn25a">25</a>. Defined in Erich Gamma et al. <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Reading, MA: Addison-Wesley, 1995, pp. 17–18; also discussed in Joshua Bloch. <em>Effective Java</em>. Upper Saddle River, NJ: Addison-Wesley, 2008.</p>&#13;
<p><strong>Implementation inheritance</strong> is primarily used to define closely related classes with many of the same data members and member function implementations. This kind of inheritance tends to create <strong><span class="violet">tightly coupled</span></strong> classes in which the base class’s data members and member functions are inherited into derived classes. Changes to a base class directly affect all corresponding derived classes.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Tight coupling can make modifying class hierarchies difficult</strong>. Consider how you might modify <a href="ch10.xhtml#sec10_9">Section 10.9</a>’s <code>Employee</code> hierarchy so that it also supports retirement plans. There are many different retirement plan types, including 401Ks and IRAs. We might add a pure <code>virtual makeRetirementDeposit</code> member function to the class <code>Employee</code>. Then we’d define various derived classes such as <code>SalariedEmployeeWith401K</code>, <code>SalariedEmployeeWithIRA</code>, <code>CommissionEmployeeWith401K</code>, <code>CommissionEmployeeWithIRA</code>, etc., each with an appropriate <code>makeRetirementDeposit</code> implementation. As you can see, you quickly wind up with a proliferation of derived classes, making the hierarchy more challenging to implement and maintain.</p>&#13;
<p>Small inheritance hierarchies under the control of one person tend to be more manageable than large ones maintained by many people. This is true even with the tight coupling associated with implementation inheritance.</p>&#13;
<h5 class="h5" id="ch10lev3sec53">Rethinking the <code>Employee</code> Hierarchy Using Composition and Dependency Injection</h5>&#13;
<p>Over the years, programmers have written numerous papers, articles and blog posts about the problems with tightly coupled class hierarchies like <a href="ch10.xhtml#sec10_9">Section 10.9</a>’s <code>Employee</code> hierarchy. In this example, we’ll refactor our <code>Employee</code> hierarchy so that the <code>Employee</code>’s compensation model is not “hardwired” into the class hierarchy.<sup><a id="ch10fn26a" href="ch10.xhtml#ch10fn26">26</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn26" href="ch10.xhtml#ch10fn26a">26</a>. We’d like to thank Brian Goetz, Oracle’s Java Language Architect, for suggesting the class architecture we use in this section when he reviewed a recent edition of our book <em>Java How to Program</em>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>To do so, we’ll use composition and dependency injection in which a class contains a pointer to an object that provides a behavior required by objects of the class.</strong> In our <code>Employee</code> payroll example, that behavior is calculating each <code>Employee</code>’s earnings. We’ll define a new <code>Employee</code> class that <em>has a</em> pointer to a <code>CompensationModel</code> object with <code>earnings</code> and <code>toString</code> member functions. This class will not be a base class—to emphasize that we’ll make it <code>final</code>. We’ll then define derived classes of class <code>CompensationModel</code> that implement how <code>Employee</code>s get compensated:</p>&#13;
<p class="bull">• fixed salary, and</p>&#13;
<p class="bull">• commission based on gross sales.</p>&#13;
<p>Of course, we could define other <code>CompensationModel</code>s, too.</p>&#13;
<h5 class="h5" id="ch10lev3sec54">Interface Inheritance Is Best for Flexibility</h5>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> For our <code>CompensationModel</code>s, we’ll use <strong><span class="violet">interface inheritance</span></strong>. Each <code>CompensationModel</code> concrete class will inherit from a class containing <strong>only pure <code>virtual</code> functions</strong>. Such a class is called an <strong>interface</strong> or a <strong>pure abstract class</strong>. The C++ Core Guidelines recommend inheriting from pure abstract classes rather than classes with implementation details.<sup><a id="ch10fn27a" href="ch10.xhtml#ch10fn27">27</a>,<a id="ch10fn28a" href="ch10.xhtml#ch10fn28">28</a>,<a id="ch10fn29a" href="ch10.xhtml#ch10fn29">29</a>,<a id="ch10fn30a" href="ch10.xhtml#ch10fn30">30</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn27" href="ch10.xhtml#ch10fn27a">27</a>. “I.25: Prefer abstract classes as interfaces to class hierarchies.” Accessed February 8, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-abstract">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-abstract</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn28" href="ch10.xhtml#ch10fn28a">28</a>. “C.121: If a base class is used as an interface, make it a pure abstract class.” Accessed February 8, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn29" href="ch10.xhtml#ch10fn29a">29</a>. “C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed.” Accessed February 8, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-separation">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-separation</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn30" href="ch10.xhtml#ch10fn30a">30</a>. “C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance.” Accessed February 8, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind</a></code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Interfaces typically do not have data members</strong>. Interface inheritance may require more work than implementation inheritance because concrete classes must provide both data and implementations of the interface’s pure <code>virtual</code> member functions, even if the data and member-function implementations are similar or identical among classes. As we’ll discuss at the end of the example, this approach gives you additional flexibility by eliminating the tight coupling between classes. The discussion of device drivers in the context of abstract classes at the end of <a href="ch10.xhtml#sec10_8">Section 10.8</a> is a good example of how interfaces enable systems to be modified easily.</p>&#13;
<h4 class="h4" id="sec10_12_1">10.12.1 Rethinking the Employee Hierarchy—<code>CompensationModel</code> Interface</h4>&#13;
<p>Let’s reconsider <a href="ch10.xhtml#sec10_9">Section 10.9</a>’s <code>Employee</code> hierarchy with composition and an interface. We can say that each <code>Employee</code> <em>has a</em> <code>CompensationModel</code>. <a href="ch10.xhtml#fig10_26">Figure 10.26</a> defines the <strong>interface <code>CompensationModel</code></strong>, which is a pure abstract class, so it does not have a <code>.cpp</code> file. The class has a compiler-generated <code>virtual</code> destructor and two pure <code>virtual</code> functions:</p>&#13;
<p class="bull">• <code>earnings</code> to calculate an employee’s pay, based on its <code>CompensationModel</code>, and</p>&#13;
<p class="bull">• <code>toString</code> to create a string representation of a <code>CompensationModel</code>.</p>&#13;
<p>Any class that inherits from <code>CompensationModel</code> and overrides its pure <code>virtual</code> functions <em>is a</em> <code>CompensationModel</code> that implements this interface.</p>&#13;
<div class="group" id="fig10_26">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro26" id="p10pro26a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.26: CompensationModel.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// CompensationModel "interface" is a pure abstract base class.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> once <span class="lgreen">// prevent multiple inclusions of header</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">class</span> CompensationModel {&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">virtual</span> ~CompensationModel() = <span class="blue">default</span>; <span class="lgreen">// generated destructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">virtual double</span> earnings() <span class="blue">const</span> = <span class="green">0</span>; <span class="lgreen">// pure virtual</span>&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">virtual</span> std::string toString() <span class="blue">const</span> = <span class="green">0</span>; <span class="lgreen">// pure virtual</span>&#13;
<span class="cviolet"><strong>11</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.26</strong></span> | <code>CompensationModel</code> “interface” is a pure abstract base class.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec10_12_2">10.12.2 Class <code>Employee</code></h4>&#13;
<p><a href="ch10.xhtml#fig10_27">Figure 10.27</a> defines our new <code>Employee</code> class. <strong>Each <code>Employee</code> <em>has a</em> pointer to the implementation of its <code>CompensationModel</code></strong> (line 16). Note that this class has been declared <code>final</code> so that it cannot be used as a base class.</p>&#13;
<div class="group" id="fig10_27">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro27" id="p10pro27a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.27: Employee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// An Employee "has a" CompensationModel.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"CompensationModel.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">class</span> Employee <span class="blue">final</span> {&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>10</strong></span>      Employee(std::string_view name, CompensationModel* modelPtr);&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">void</span> setCompensationModel(CompensationModel *modelPtr);&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>13</strong></span>      std::string toString() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>15</strong></span>      std::string m_name{};&#13;
<span class="cviolet"><strong>16</strong></span>      CompensationModel* m_modelPtr{}; <span class="lgreen">// pointer to an implementation object</span>&#13;
<span class="cviolet"><strong>17</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.27</strong></span> | An <code>Employee</code> “has a” <code>CompensationModel</code>.</p>&#13;
</div>&#13;
<p><a href="ch10.xhtml#fig10_28">Figure 10.28</a> defines class <code>Employee</code>’s member functions:</p>&#13;
<p class="bull">• The constructor (lines 11–12) initializes the <code>Employee</code>’s name and aims its <code>CompensationModel</code> pointer at an object that implements the <code>CompensationModel</code> interface. This technique is known as <strong><span class="violet">constructor injection</span></strong>. The constructor receives a pointer (or reference) to another object and stores it in the object being constructed.</p>&#13;
<p class="bull">• The <code>setCompensationModel</code> member function (lines 16–18) enables the client code to change an <code>Employee</code>’s <code>CompensationModel</code> by aiming <code>m_modelPtr</code> at a different <code>CompensationModel</code> implementation. This technique is known as <strong><span class="violet">property injection</span></strong>.</p>&#13;
<p class="bull">• The <code>earnings</code> member function (lines 21–23) determines the <code>Employee</code>’s earnings by calling the <code>CompensationModel</code> implementation’s <code>earnings</code> member function via the <code>CompensationModel</code> pointer <code>m_modelPtr</code>.</p>&#13;
<p class="bull">• The <code>toString</code> member function (lines 26–28) creates an <code>Employee</code>’s <code>string</code> representation consisting of the <code>Employee</code>’s name, followed by the compensation information, which we get by calling the <code>CompensationModel</code> implementation’s <code>toString</code> member function via a the <code>CompensationModel</code> pointer <code>m_modelPtr</code></p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Constructor injection and property injection are both forms of</strong> <span class="violet"><strong>dependency injection</strong></span><strong>. You specify part of an object’s behavior by providing it with a pointer or reference to another object that defines the behavior.</strong><sup><a id="ch10fn31a" href="ch10.xhtml#ch10fn31">31</a></sup> In this example, a <code>CompensationModel</code> provides the behavior that enables an <code>Employee</code> to calculate its <code>earnings</code> and to generate a <code>string</code> representation.</p>&#13;
<p class="footnote"><a id="ch10fn31" href="ch10.xhtml#ch10fn31a">31</a>. “Dependency injection.” Accessed February 8, 2021. <code><a href="https://w.wiki/yQx">https://w.wiki/yQx</a></code>.</p>&#13;
<div class="group" id="fig10_28">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro28" id="p10pro28a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.28: Employee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Class Employee member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"CompensationModel.h"</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="lgreen">// constructor performs "constructor injection" to initialize</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="lgreen">// the CompensationModel pointer to a CompensationModel implementation</span>&#13;
<span class="cviolet"><strong>11</strong></span>   Employee::Employee(string_view name, CompensationModel* modelPtr)&#13;
<span class="cviolet"><strong>12</strong></span>      : m_name{name}, m_modelPtr{modelPtr} {}&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="lgreen">// set function performs "property injection" to change the</span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// CompensationModel pointer to a new CompensationModel implementation</span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">void</span> Employee::setCompensationModel(CompensationModel* modelPtr) {&#13;
<span class="cviolet"><strong>17</strong></span>      m_modelPtr = modelPtr;&#13;
<span class="cviolet"><strong>18</strong></span>   }&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="lgreen">// use the CompensationModel to calculate the Employee's earnings</span>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">double</span> Employee::earnings() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">return</span> m_modelPtr-&gt;earnings();&#13;
<span class="cviolet"><strong>23</strong></span>   };&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="lgreen">// return string representation of Employee object</span>&#13;
<span class="cviolet"><strong>26</strong></span>   string Employee::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>27</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"{}\n{}"</span>, m_name, m_modelPtr-&gt;toString());&#13;
<span class="cviolet"><strong>28</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.28</strong></span> | Class <code>Employee</code> member-function definitions.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec10_12_3">10.12.3 <code>CompensationModel</code> Implementations</h4>&#13;
<p>Next, let’s define our <code>CompensationModel</code> implementations. Objects of these classes will be injected into <code>Employee</code> objects to specify how to calculate their earnings.</p>&#13;
<h5 class="h5" id="ch10lev3sec55"><code>Salaried</code> Derived Class of <strong><code>CompensationModel</code></strong></h5>&#13;
<p>A <code>Salaried</code> compensation model (Figs. 10.29–10.30) defines how to pay an <code>Employee</code> who receives a fixed salary. The class contains an <code>m_salary</code> data member and overrides interface <code>CompensationModel</code>’s <code>earnings</code> and <code>toString</code> member functions. <strong><code>Salaried</code> is declared <code>final</code> (line 7), so it is a leaf node in the <code>CompensationModel</code> hierarchy. It may not be used as a base class.</strong></p>&#13;
<div class="group" id="fig10_29">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro29" id="p10pro29a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.29: Salaried.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Salaried implements the CompensationModel interface.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> once&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"CompensationModel.h"</span> <span class="lgreen">// CompensationModel definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">class</span> Salaried <span class="blue">final</span> : <span class="blue">public</span> CompensationModel {&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">explicit</span> Salaried(<span class="blue">double</span> salary);&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const override</span>;&#13;
<span class="cviolet"><strong>11</strong></span>      std::string toString() <span class="blue">const override</span>;&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">double</span> m_salary{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>14</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.29</strong></span> | <code>Salaried</code> implements the <code>CompensationModel</code> interface.</p>&#13;
</div>&#13;
<div class="group" id="fig10_30">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro30" id="p10pro30a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.30: Salaried.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Salaried compensation model member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"Salaried.h"</span> <span class="lgreen">// class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   Salaried::Salaried<span class="blue">(double</span> salary) : m_salary{salary} {&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">if</span> (m_salary &lt; <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Weekly salary must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>12</strong></span>      }&#13;
<span class="cviolet"><strong>13</strong></span>   }&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// override CompensationModel pure virtual function earnings</span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">double</span> Salaried::earnings() <span class="blue">const</span> {<span class="blue">return</span> m_salary;}&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="lgreen">// override CompensationModel pure virtual function toString</span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="blue">string</span> Salaried::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"salary: ${:.2f}"</span>, m_salary);&#13;
<span class="cviolet"><strong>21</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.30</strong></span> | <code>Salaried</code> compensation model member-function definitions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec56"><code>Commission</code> Derived Class of <strong><code>CompensationModel</code></strong></h5>&#13;
<p>A <code>Commission</code> compensation model (Figs. 10.31–10.32) defines how to pay an <code>Employee</code> commission based on gross sales. The class contains <code>m_grossSales</code> and <code>m_commission-Rate</code> data members and overrides interface <code>CompensationModel</code>’s <code>earnings</code> and <code>toString</code> member functions. Like class <code>Salaried</code>, class <code>Commission</code> is declared <code>final</code> (line 7), so it is a leaf node in the <code>CompensationModel</code> hierarchy. It may not be used as a base class.</p>&#13;
<div class="group" id="fig10_31">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro31" id="p10pro31a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.31: Commission.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Commission implements the CompensationModel interface.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"CompensationModel.h"</span> <span class="lgreen">// CompensationModel definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">class</span> Commission <span class="blue">final</span> : <span class="blue">public</span> CompensationModel {&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>9</strong></span>      Commission(<span class="blue">double</span> grossSales, <span class="blue">double</span> commissionRate);&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const override</span>;&#13;
<span class="cviolet"><strong>11</strong></span>      std::string toString() <span class="blue">const override</span>;&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">double</span> m_grossSales{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">double</span> m_commissionRate{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>15</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.31</strong></span> | <code>Commission</code> implements the <code>CompensationModel</code> interface.</p>&#13;
</div>&#13;
<div class="group" id="fig10_32">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro32" id="p10pro32a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.32: Commission.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Commission member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"Commission.h"</span> <span class="lgreen">// class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   Commission::Commission<span class="blue">(double</span> grossSales, <span class="blue">double</span> commissionRate)&#13;
<span class="cviolet"><strong>10</strong></span>      : m_grossSales{grossSales}, m_commissionRate{commissionRate} {&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">if</span> (m_grossSales &lt; <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>13</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Gross sales must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>14</strong></span>      }&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">if</span> (m_commissionRate &lt;= <span class="green">0.0</span> || m_commissionRate &gt;= <span class="green">1.0</span>) {&#13;
<span class="cviolet"><strong>17</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Commission rate must be &gt; 0.0 and &lt; 1.0"</span>);&#13;
<span class="cviolet"><strong>18</strong></span>      }&#13;
<span class="cviolet"><strong>19</strong></span>   }&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="lgreen">// override CompensationModel pure virtual function earnings</span>&#13;
<span class="cviolet"><strong>22</strong></span>   <span class="blue">double</span> Commission::earnings() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">return</span> m_grossSales * m_commissionRate;&#13;
<span class="cviolet"><strong>24</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="lgreen">// override CompensationModel pure virtual function toString</span>&#13;
<span class="cviolet"><strong>27</strong></span>   string Commission::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"gross sales: ${:.2f}; commission rate: {:.2f}"</span>,&#13;
<span class="cviolet"><strong>29</strong></span>         m_grossSales, m_commissionRate);&#13;
<span class="cviolet"><strong>30</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.32</strong></span> | <code>Commission</code> member-function definitions.</p>&#13;
</div>&#13;
<h4 class="h4" id="sec10_12_4">10.12.4 Testing the New Hierarchy</h4>&#13;
<p>We’ve created our <code>CompensationModel</code> <strong>interface</strong> and derived-class implementations defining how <code>Employee</code>s get paid. Now, let’s create <code>Employee</code> objects and initialize each with an appropriate concrete <code>CompensationModel</code> implementation (<a href="ch10.xhtml#fig10_33">Fig. 10.33</a>).</p>&#13;
<div class="group" id="fig10_33">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro33" id="p10pro33a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_33.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Processing Employees with various CompensationModels.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> <span class="green">"Salaried.h"</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> <span class="green">"Commission.h"</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="lgreen">// create CompensationModels and Employees</span>&#13;
<span class="cviolet"><strong>13</strong></span>      Salaried salaried{<span class="green">800.0</span>};&#13;
<span class="cviolet"><strong>14</strong></span>      Employee salariedEmployee{<span class="green">"John Smith"</span>, &amp;salaried};&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      Commission commission{<span class="green">10000</span>, <span class="green">.06</span>};&#13;
<span class="cviolet"><strong>17</strong></span>      Employee commissionEmployee{<span class="green">"Sue Jones"</span>, &amp;commission};&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="lgreen">// create and initialize vector of Employees</span>&#13;
<span class="cviolet"><strong>20</strong></span>      vector employees{salariedEmployee, commissionEmployee};&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="lgreen">// print each Employee's information and earnings</span>&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">for</span> (<span class="blue">const</span> Employee&amp; employee : employees) {&#13;
<span class="cviolet"><strong>24</strong></span>         cout &lt;&lt; fmt::format("{}<span class="green">\nearned: ${:.2f}\n\n",</span>&#13;
<span class="cviolet"><strong>25</strong></span>                    employee.toString(), employee.earnings());&#13;
<span class="cviolet"><strong>26</strong></span>      }&#13;
<span class="cviolet"><strong>27</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">John Smith&#13;
salary: $800.00&#13;
earned: $800.00&#13;
&#13;
Sue Jones&#13;
gross sales: $10000.00; commission rate: 0.06&#13;
earned: $600.00</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.33</strong></span> | Processing <code>Employee</code>s with various <code>CompensationModel</code>s.</p>&#13;
</div>&#13;
<p>Line 13 creates a <code>Salaried</code> compensation model object (<code>salaried</code>), then line 14 creates the <code>Employee salariedEmployee</code> and injects its <code>CompensationModel</code>, passing as the second constructor argument a pointer to <code>salaried</code>. Line 16 creates a <code>Commission</code> compensation model object (<code>commission</code>), then line 17 creates the <code>Employee commissionEmployee</code> and injects its <code>CompensationModel</code>, passing as the second constructor argument a pointer to <code>commission</code>. Line 20 creates a <code>vector</code> of <code>Employee</code>s and initializes it with the <code>salariedEmployee</code> and <code>commissionEmployee</code> objects. Finally, lines 23–26 iterate through the <code>vector</code>, displaying each <code>Employee</code>’s string representation and earnings.</p>&#13;
<h5 class="h5" id="ch10lev3sec57">Flexibility If <code>CompensationModel</code>s Change</h5>&#13;
<p>Declaring the <code>CompensationModel</code>s as separate classes that implement the same interface provides flexibility for future changes. Suppose a company adds new ways to pay employees. We can simply define a new <code>CompensationModel</code> derived class with an appropriate <code>earnings</code> function.</p>&#13;
<h5 class="h5" id="ch10lev3sec58">Flexibility If <code>Employee</code>s Are Promoted</h5>&#13;
<p><span class="size">SE</span> <img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> The interface-based composition and dependency-injection approach we used in this example is more flexible than <a href="ch10.xhtml#sec10_9">Section 10.9</a>’s class hierarchy. In <a href="ch10.xhtml#sec10_9">Section 10.9</a>, if an <code>Employee</code> were promoted, you’d need to change its object type by creating a new object of the appropriate <code>Employee</code> derived class, then moving data into the new object. <strong>Using dependency injection, you can simply call <code>Employee</code>’s <code>setCompensationModel</code> member function and inject a pointer to a different <code>CompensationModel</code> that replaces the existing one.</strong></p>&#13;
<h5 class="h5" id="ch10lev3sec59">Flexibility If <code>Employee</code>s Acquire New Capabilities</h5>&#13;
<p><strong>The interface-based composition and dependency-injection approach is also more flexible for enhancing class <code>Employee</code>.</strong> If we decide to support retirement plans (such as 401Ks and IRAs), we could say that every <code>Employee</code> <em>has a</em> <code>RetirementPlan</code>. First, we’d define interface <code>RetirementPlan</code> with a <code>makeRetirementDeposit</code> member function and provide appropriate derived-class implementations.</p>&#13;
<p>Using interface-based composition and dependency-injection, as shown in this example, requires only small changes to class <code>Employee</code> to support <code>RetirementPlan</code>s:</p>&#13;
<p class="bull">• a data member that points to a <code>RetirementPlan</code>,</p>&#13;
<p class="bull">• one more constructor argument to initialize the <code>RetirementPlan</code> pointer, and</p>&#13;
<p class="bull">• a <code>setRetirementPlan</code> member function we can call if we ever need to change the <code>RetirementPlan</code>.</p>&#13;
<h3 class="h3" id="sec10_13"><span class="violet">10.13</span> Runtime Polymorphism with <code>std::variant</code> and <code>std::visit</code></h3>&#13;
<p><span class="size">17</span> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> So far, we’ve achieved runtime polymorphism via implementation inheritance or interface inheritance. As you’ve seen, both techniques require class hierarchies. What if you have objects of <em>unrelated</em> classes, but you’d still like to process those objects polymorphically at runtime. You can achieve this with C++17’s <strong><span class="violet">class template <code>std::variant</code></span></strong> and the <strong><span class="violet">standardlibrary function</span></strong> <span class="violet"><strong><code>std::visit</code></strong></span> (both in header <span class="violet"><strong><code>&lt;variant&gt;</code></strong></span>).<sup><a id="ch10fn32a" href="ch10.xhtml#ch10fn32">32</a>,<a id="ch10fn33a" href="ch10.xhtml#ch10fn33">33</a>,<a id="ch10fn34a" href="ch10.xhtml#ch10fn34">34</a>,<a id="ch10fn35a" href="ch10.xhtml#ch10fn35">35</a></sup> <strong>The caveat is that you must know in advance all the types your program needs to process via runtime polymorphism—known as a</strong> <span class="violet"><strong>closed set of types</strong></span>. A <code>std::variant</code> object can store one object at a time of any type specified when you create the <code>std::variant</code> object. As you’ll see, you call functions on the objects in a <code>std::variant</code> object using the <code>std::visit</code> function.</p>&#13;
<p class="footnote"><a id="ch10fn32" href="ch10.xhtml#ch10fn32a">32</a>. Nevin Liber, “The Many Variants of <code>std::variant</code>,” YouTube Video, June 16, 2019, <code><a href="https://www.youtube.com/watch?v=JUxhwf7gYLg">https://www.youtube.com/watch?v=JUxhwf7gYLg</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn33" href="ch10.xhtml#ch10fn33a">33</a>. “<code>std::variant</code>.” Accessed January 30, 2021. <code><a href="https://en.cppreference.com/w/cpp/utility/variant">https://en.cppreference.com/w/cpp/utility/variant</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn34" href="ch10.xhtml#ch10fn34a">34</a>. Bartlomiej Filipek, “Runtime Polymorphism with <code>std::variant</code> and <code>std::visit</code>.” Accessed January 30, 2021. <code><a href="https://www.bfilipek.com/2020/04/variant-virtual-polymorphism.html">https://www.bfilipek.com/2020/04/variant-virtual-polymorphism.html</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn35" href="ch10.xhtml#ch10fn35a">35</a>. Bartlomiej Filipek, “Everything You Need to Know About <code>std::variant</code> from C++17.” Accessed January 30, 2021. <code><a href="https://www.bfilipek.com/2018/06/variant.html">https://www.bfilipek.com/2018/06/variant.html</a></code>.</p>&#13;
<p>To demonstrate runtime polymorphism with <code>std::variant</code>, we’ll reimplement our <a href="ch10.xhtml#sec10_12">Section 10.12</a> example. The classes used here are nearly identical, so we’ll point out only the differences.</p>&#13;
<h5 class="h5" id="ch10lev3sec60">Compensation Model <code>Salaried</code></h5>&#13;
<p>Class <code>Salaried</code> (Figs. 10.34–10.35) defines the compensation model for an <code>Employee</code> who gets paid a fixed salary. The only difference between this class and the one in <a href="ch10.xhtml#sec10_12">Section 10.12</a> is that <strong>this <code>Salaried</code> is <em>not</em> a derived class. So, its <code>earnings</code> and <code>toString</code> member functions do not override base-class <code>virtual</code> functions</strong>.</p>&#13;
<div class="group" id="fig10_34">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro34" id="p10pro34a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.34: Salaried.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Salaried compensation model.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">class</span> Salaried {&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>8</strong></span>      Salaried(double salary);&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>10</strong></span>      std::string toString() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">double</span> m_salary{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>13</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.34</strong></span> | Salaried compensation model.</p>&#13;
</div>&#13;
<div class="group" id="fig10_35">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro35" id="p10pro35a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.35: Salaried.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Salaried compensation model member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"Salaried.h"</span> <span class="lgreen">// class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   Salaried::Salaried<span class="blue">(double</span> salary) : m_salary{salary} {&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">if</span> (m_salary &lt; 0.0) {&#13;
<span class="cviolet"><strong>11</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Weekly salary must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>12</strong></span>      }&#13;
<span class="cviolet"><strong>13</strong></span>   }&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="lgreen">// calculate earnings</span>&#13;
<span class="cviolet"><strong>16</strong></span>   <span class="blue">double</span> Salaried::earnings() <span class="blue">const</span> {<span class="blue">return</span> m_salary;}&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="lgreen">// return string containing Salaried compensation model information</span>&#13;
<span class="cviolet"><strong>19</strong></span>   string Salaried::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"salary: ${:.2f}"</span>, m_salary);&#13;
<span class="cviolet"><strong>21</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.35</strong></span> | Salaried compensation model member-function definitions. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec61">Compensation Model <code>Commission</code></h5>&#13;
<p>Class <code>Commission</code> (Figs. 10.36–10.37) defines the compensation model for an <code>Employee</code> who gets paid commission based on gross sales. Like <code>Salaried</code>, this <code>Commission</code> is <em>not</em> a derived class. So, its <code>earnings</code> and <code>toString</code> member functions do not override base-class <code>virtual</code> functions, as they did in <a href="ch10.xhtml#sec10_12">Section 10.12</a>.</p>&#13;
<div class="group" id="fig10_36">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro36" id="p10pro36a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.36: Commission.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Commission compensation model.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">class</span> Commission {&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>8</strong></span>      Commission(<span class="blue">double</span> grossSales, <span class="blue">double</span> commissionRate);&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>10</strong></span>      std::string toString() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">double</span> m_grossSales{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">double</span> m_commissionRate{<span class="green">0.0</span>};&#13;
<span class="cviolet"><strong>14</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.36</strong></span> | Commission compensation model.</p>&#13;
</div>&#13;
<div class="group" id="fig10_37">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro37" id="p10pro37a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.37: Commission.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Commission member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;stdexcept&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"Commission.h"</span> <span class="lgreen">// class definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   Commission::Commission<span class="blue">(double</span> grossSales, <span class="blue">double</span> commissionRate)&#13;
<span class="cviolet"><strong>10</strong></span>      : m_grossSales{grossSales}, m_commissionRate{commissionRate} {&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">if</span> (m_grossSales &lt; <span class="green">0.0</span>) {&#13;
<span class="cviolet"><strong>13</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Gross sales must be &gt;= 0.0"</span>);&#13;
<span class="cviolet"><strong>14</strong></span>      }&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">if</span> (m_commissionRate &lt;= <span class="green">0.0</span> || m_commissionRate &gt;= <span class="green">1.0</span>) {&#13;
<span class="cviolet"><strong>17</strong></span>         <span class="blue">throw</span> invalid_argument(<span class="green">"Commission rate must be &gt; 0.0 and &lt; 1.0"</span>);&#13;
<span class="cviolet"><strong>18</strong></span>      }&#13;
<span class="cviolet"><strong>19</strong></span>   }&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="lgreen">// calculate earnings</span>&#13;
<span class="cviolet"><strong>22</strong></span>   <span class="blue">double</span> Commission::earnings() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">return</span> m_grossSales * m_commissionRate;&#13;
<span class="cviolet"><strong>24</strong></span>   }&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="lgreen">// return string containing Commission information</span>&#13;
<span class="cviolet"><strong>27</strong></span>   string Commission::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"gross sales: ${:.2f}; commission rate: {:.2f}"</span>,&#13;
<span class="cviolet"><strong>29</strong></span>         m_grossSales, m_commissionRate);&#13;
<span class="cviolet"><strong>30</strong></span>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.37</strong></span> | Commission member-function definitions. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec62"><code>Employee</code> Class Definition</h5>&#13;
<p>As in <a href="ch10.xhtml#sec10_12">Section 10.12</a>, each <code>Employee</code> (<a href="ch10.xhtml#fig10_38">Fig. 10.38</a>) has a compensation model (line 21). However, in this example, the compensation model is a <code>std::variant</code> object containing either a <code>Commission</code> <em>or</em> a <code>Salaried</code> object—note that this is an object, <em>not</em> a pointer to an object. Line 11’s <span class="violet"><strong><code>using</code></strong></span> declaration:</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p547pro01" id="p547pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">using</span> CompensationModel = std::variant&lt;Commission, Salaried&gt;;</pre>&#13;
<p>defines the alias <code>CompensationModel</code> for the <code>std::variant</code> type:</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p547pro02" id="p547pro02a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>std::variant&lt;Commission, Salaried&gt;</code></pre>&#13;
<p><span class="size">11</span> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Such <code>using</code> declarations (C++11) are known as <strong><span class="violet">alias declarations</span></strong> and are particularly useful when a <code>std::variant</code> type has many type parameters. <strong>At any given time, an object of our <code>std::variant</code> type can store <em>either</em> a <code>Commission</code> object <em>or</em> a <code>Salaried</code> object</strong>. We use our <code>CompensationModel</code> alias in line 21 to define the <code>std::variant</code> object that stores the <code>Employee</code>’s compensation model.</p>&#13;
<div class="group" id="fig10_38">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro38" id="p10pro38a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.38: Employee.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// An Employee "has a" CompensationModel.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;string_view&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;variant&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> <span class="green">"Commission.h"</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> <span class="green">"Salaried.h"</span>&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="lgreen">// define a convenient name for the std::variant type</span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">using</span> CompensationModel = std::variant&lt;Commission, Salaried&gt;;&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">class</span> Employee {&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>15</strong></span>      Employee(std::string_view name, CompensationModel model);&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">void</span> setCompensationModel(CompensationModel model);&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">double</span> earnings() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>18</strong></span>      std::string toString() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>20</strong></span>      std::string m_name{};&#13;
<span class="cviolet"><strong>21</strong></span>      CompensationModel m_model; <span class="lgreen">// note this is not a pointer</span>&#13;
<span class="cviolet"><strong>22</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.38</strong></span> | An <code>Employee</code> “has a” <code>CompensationModel</code>. (Part 1 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec63">Type-Safe union</h5>&#13;
<p>In C and C++, a <span class="violet"><strong><code>union</code></strong></span><sup><a id="ch10fn36a" href="ch10.xhtml#ch10fn36">36</a></sup> is a region of memory that, over time, can contain objects of a variety of types. However, a <code>union</code>’s members share the same storage space, so a <code>union</code> may contain a maximum of one object at a time and requires enough memory to hold the largest of its members. <strong>A <code>std::variant</code> object is often referred to as a type-safe <code>union</code>.</strong><sup><a id="ch10fn37a" href="ch10.xhtml#ch10fn37">37</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn36" href="ch10.xhtml#ch10fn36a">36</a>. Discussed in Section F.12.</p>&#13;
<p class="footnote"><a id="ch10fn37" href="ch10.xhtml#ch10fn37a">37</a>. “<code>std::variant</code>.” Accessed January 30, 2021. <code><a href="https://en.cppreference.com/w/cpp/utility/variant">https://en.cppreference.com/w/cpp/utility/variant</a></code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec64"><code>Employee</code> Constructor and <strong><code>setCompensationModel</code></strong> Member Function</h5>&#13;
<p>Class <code>Employee</code>’s member functions perform the same tasks as in <a href="ch10.xhtml#fig10_28">Fig. 10.28</a> with several modifications. The <code>Employee</code> class’s constructor (lines 9–10) and <code>setCompensationModel</code> member function (lines 13–15) each receive a <code>CompensationModel</code> <em>object</em>. Unlike the composition-and-dependency-injection approach, the <code>std::variant</code> object <strong>stores an actual object</strong>, not a pointer to an object.</p>&#13;
<div class="group" id="fig10_39">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro39" id="p10pro39a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.39: Employee.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Class Employee member-function definitions.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// constructor</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   Employee::Employee(string_view name, CompensationModel model)&#13;
<span class="cviolet"><strong>10</strong></span>      : m_name{name}, m_model{model} {}&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="lgreen">// change the Employee's CompensationModel</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">void</span> Employee::setCompensationModel(CompensationModel model) {&#13;
<span class="cviolet"><strong>14</strong></span>      m_model = model;&#13;
<span class="cviolet"><strong>15</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// return the Employee's earnings</span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">double</span> Employee::earnings() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">auto</span> getEarnings = [](<span class="blue">const auto</span>&amp; model){<span class="blue">return</span> model.earnings();};&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">return</span> std::visit(getEarnings, m_model);&#13;
<span class="cviolet"><strong>21</strong></span>   }&#13;
<span class="cviolet"><strong>22</strong></span>&#13;
<span class="cviolet"><strong>23</strong></span>   <span class="lgreen">// return string representation of an Employee object</span>&#13;
<span class="cviolet"><strong>24</strong></span>   string Employee::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>25</strong></span>      <span class="blue">auto</span> getString = [](<span class="blue">const auto</span>&amp; model){<span class="blue">return</span> model.toString();};&#13;
<span class="cviolet"><strong>26</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"{}\n{}"</span>, m_name, std::visit(getString, m_model));&#13;
<span class="cviolet"><strong>27</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.39</strong></span> | Class <code>Employee</code> member-function definitions. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec65"><code>Employee</code> <strong><code>earnings</code></strong> and <strong><code>toString</code></strong> Member Functions—Calling Member Functions with <strong><code>std::visit</code></strong></h5>&#13;
<p><strong>A key difference between runtime polymorphism via class hierarchies and runtime polymorphism via <code>std::variant</code> is that a <code>std::variant</code> object cannot call member functions of the object it contains. Instead, you use the standard library function <code>std::visit</code> to invoke a function on the object stored in the <code>std::variant</code>.</strong> Consider lines 19–20 in member-function <code>earnings</code>:</p>&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p549pro01" id="p549pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">auto</span> getEarnings = [](<span class="blue">const auto</span>&amp; model){<span class="blue">return</span> model.earnings();};&#13;
<span class="blue">return</span> std::visit(getEarnings, m_model);</pre>&#13;
<p>Line 19 defines the variable <code>getEarnings</code> and initializes it with a generic lambda expression (introduced in Fig. 6.14.2) that receives a reference to an object (<code>model</code>) and calls the object’s <code>earnings</code> member function. This lambda expression can call <code>earnings</code> on <em>any object</em> with an <code>earnings</code> member function that takes no arguments and returns a value. Line 20 passes to function <code>std::visit</code> the <code>getEarnings</code> lambda expression and the <code>std::variant</code> object <code>m_model</code>. Function <code>std::visit</code> passes <code>m_model</code> to the lambda expression, then returns the result of calling <code>m_model</code>’s <code>earnings</code> member function.</p>&#13;
<p>Similarly, line 25 in <code>Employee</code>’s <code>toString</code> member function creates a lambda expression that returns the result of calling some object’s <code>toString</code> member function. Line 26 calls <code>std::visit</code> to pass <code>m_model</code> to the lambda expression, which returns the result of calling <code>m_model</code>’s <code>toString</code> member function.</p>&#13;
<h5 class="h5" id="ch10lev3sec66">Testing Runtime Polymorphism with <code>std::variant</code> and <strong><code>std::visit</code></strong></h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> In <code>main</code>, lines 12–13 create two <code>Employee</code> objects—the first stores a <code>Salaried</code> object in its <code>std::variant</code> and the second stores a <code>Commission</code> object. Line 16 creates a <code>vector</code> of <code>Employee</code>s, then lines 19–22 iterate through it calling each <code>Employee</code>’s <code>earnings</code> and <code>toString</code> member functions to demonstrate the runtime polymorphic processing, producing the same results as in <a href="ch10.xhtml#sec10_12">Section 10.12</a>. <strong>This ability to invoke common functionality on objects whose types are not related by a class hierarchy is often called</strong> <span class="violet"><strong>duck typing</strong></span>:</p>&#13;
<p class="pren"><em>“If it walks like a duck and it quacks like a duck, then it must be a duck.”<sup><a id="ch10fn38a" href="ch10.xhtml#ch10fn38">38</a></sup></em></p>&#13;
<p class="footnote"><a id="ch10fn38" href="ch10.xhtml#ch10fn38a">38</a>. “Duck Typing.” Accessed January 30, 2021. <code><a href="https://w.wiki/Bin">https://w.wiki/Bin</a></code>.</p>&#13;
<p><strong>That is, if an object has the appropriate member functions and its type is specified as a member of the <code>std::variant</code>, the object will work in this code.</strong></p>&#13;
<div class="group" id="fig10_40">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro40" id="p10pro40a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_40.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Processing Employees with various compensation models.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"Employee.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> <span class="green">"Salaried.h"</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> <span class="green">"Commission.h"</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>12</strong></span>      Employee salariedEmployee{<span class="green">"John Smith"</span>, Salaried{<span class="green">800.0</span>}};&#13;
<span class="cviolet"><strong>13</strong></span>      Employee commissionEmployee{<span class="green">"Sue Jones"</span>, Commission{<span class="green">10000.0</span>, <span class="green">.06</span>}};&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="lgreen">// create and initialize vector of three Employees</span>&#13;
<span class="cviolet"><strong>16</strong></span>      vector employees{salariedEmployee, commissionEmployee};&#13;
<span class="cviolet"><strong>17</strong></span>&#13;
<span class="cviolet"><strong>18</strong></span>      <span class="lgreen">// print each Employee's information and earnings</span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">for</span> (<span class="blue">const</span> Employee&amp; employee : employees) {&#13;
<span class="cviolet"><strong>20</strong></span>         cout &lt;&lt; fmt::format("{}<span class="green">\nearned: ${:.2f}\n\n",</span>&#13;
<span class="cviolet"><strong>21</strong></span>                    employee.toString(), employee.earnings());&#13;
<span class="cviolet"><strong>22</strong></span>      }&#13;
<span class="cviolet"><strong>23</strong></span>   <code>}</code></pre>&#13;
<pre class="pre1">John Smith&#13;
salary: $800.00&#13;
earned: $800.00&#13;
&#13;
Sue Jones&#13;
gross sales: $10000.00; commission rate: 0.06&#13;
earned: $600.00</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.40</strong></span> | Processing <code>Employees</code> with various compensation models.</p>&#13;
</div>&#13;
<h3 class="h3" id="sec10_14"><span class="violet">10.14</span> Multiple Inheritance</h3>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> So far, we’ve discussed single inheritance, in which each class is derived from exactly one base class. C++ also supports <strong><span class="violet">multiple inheritance</span></strong>—a class may inherit the members of two or more base classes. <strong>Multiple inheritance is a complicated feature that should be used only by experienced programmers.</strong> Some of the problems associated with multiple inheritance are so subtle that newer programming languages, such as Java and C#, support only single inheritance.<sup><a id="ch10fn39a" href="ch10.xhtml#ch10fn39">39</a></sup> <strong>Great care is required to design a system to use multiple inheritance properly. It should not be used when single inheritance and/or composition will do the job.</strong></p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/>A common problem with multiple inheritance is that each base class might contain data members or member functions with the same name. This can lead to ambiguity problems when you attempt to compile. <strong>The ISO C++ FAQ recommends doing multiple inheritance from only pure abstract base classes</strong> to avoid this problem and others we’ll discuss in this section and <a href="ch10.xhtml#sec10_14_1">Section 10.14.1</a>.<sup><a id="ch10fn40a" href="ch10.xhtml#ch10fn40">40</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn39" href="ch10.xhtml#ch10fn39a">39</a>. More precisely, Java and C# only single <em>implementation</em> inheritance. They do allow multiple interface inheritance.</p>&#13;
<p class="footnote"><a id="ch10fn40" href="ch10.xhtml#ch10fn40a">40</a>. “Inheritance — Multiple and Virtual Inheritance.” Accessed February 7, 2021. <code><a href="https://isocpp.org/wiki/faq/multiple-inheritance">https://isocpp.org/wiki/faq/multiple-inheritance</a></code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec67">Multiple-Inheritance Example</h5>&#13;
<p>Let’s consider a multiple-inheritance example using implementation inheritance (Figs. 10.41–10.45). Class <code>Base1</code> (<a href="ch10.xhtml#fig10_41">Fig. 10.41</a>) contains:</p>&#13;
<p class="bull">• one <code>private int</code> data member (<code>m_value</code>; line 11),</p>&#13;
<p class="bull">• a constructor (line 8) that sets <code>m_value</code>, and</p>&#13;
<p class="bull">• a <code>public</code> member function <code>getData</code> (line 9) that returns <code>m_value</code>.</p>&#13;
<div class="group" id="fig10_41">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro41" id="p10pro41a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.41: Base1.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Definition of class Base1</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="lgreen">// class Base1 definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">class</span> Base1 {&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">explicit</span> Base1(<span class="blue">int</span> value) : m_value{value} {}&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">int</span> getData() <span class="blue">const</span> {<span class="blue">return</span> m_value;}&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">private</span>: <span class="lgreen">// accessible to derived classes via getData member function</span>&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">int</span> m_value;&#13;
<span class="cviolet"><strong>12</strong></span>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.41</strong></span> | Demonstrating multiple inheritance—<code>Base1.h</code>.</p>&#13;
</div>&#13;
<p>Class <code>Base2</code> (<a href="ch10.xhtml#fig10_42">Fig. 10.42</a>) is similar to class <code>Base1</code>, except that its <code>private</code> data is a <code>char</code> named <code>m_letter</code> (line 11). Like class <code>Base1</code>, <code>Base2</code> has a <code>public</code> member function <code>get-Data</code>, but this function returns <code>m_letter</code>’s value.</p>&#13;
<div class="group" id="fig10_42">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro42" id="p10pro42a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.42: Base2.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Definition of class Base2</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>4</strong></span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="lgreen">// class Base2 definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">class</span> Base2 {&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="blue">explicit</span> Base2(<span class="blue">char</span> letter) : m_letter{letter} {}&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">char</span> getData() <span class="blue">const</span> {<span class="blue">return</span> m_letter;}&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">private</span>: <span class="lgreen">// accessible to derived classes via getData member function</span>&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">char</span> m_letter;&#13;
<span class="cviolet"><strong>12</strong></span>   };</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.42</strong></span> | Demonstrating multiple inheritance—<code>Base2.h</code>.</p>&#13;
</div>&#13;
<p>Class <code>Derived</code> (Figs. 10.43–10.44) inherits from classes <code>Base1</code> and <code>Base2</code> via multiple inheritance. Class <code>Derived</code> has:</p>&#13;
<p class="bull">• a <code>private</code> data member of type <code>double</code> named <code>m_real</code> (<a href="ch10.xhtml#fig10_43">Fig. 10.43</a>, line 19),</p>&#13;
<p class="bull">• a constructor to initialize all the data of class <code>Derived</code>,</p>&#13;
<p class="bull">• a <code>public</code> member function <code>getReal</code> that returns the value of <code>m_real</code>, and</p>&#13;
<p class="bull">• a <code>public</code> member function <code>toString</code> that returns a <code>string</code> representation of a <code>Derived</code> object.</p>&#13;
<div class="group" id="fig10_43">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro43" id="p10pro43a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.43: Derived.h</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Definition of class Derived which inherits</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// multiple base classes (Base1 and Base2).</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#pragma</span> <span class="green">once</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;string&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> <span class="green">"Base1.h"</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> <span class="green">"Base2.h"</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="lgreen">// class Derived definition</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">class</span> Derived : <span class="blue">public</span> Base1, <span class="blue">public</span> Base2 {&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>15</strong></span>      Derived(<span class="blue">int</span> value, <span class="blue">char</span> letter, <span class="blue">double</span> real);&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">double</span> getReal() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>17</strong></span>      std::string toString() <span class="blue">const</span>;&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">private</span>:&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">double</span> m_real; <span class="lgreen">// derived class's private data</span>&#13;
<span class="cviolet"><strong>20</strong></span>   };</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.43</strong></span> | Demonstrating multiple inheritance—<code>Derived.h</code>.</p>&#13;
</div>&#13;
<div class="group" id="fig10_44">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro44" id="p10pro44a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// Fig. 10.44: Derived.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Member-function definitions for class Derived</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"Derived.h"</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="lgreen">// constructor for Derived calls Base1 and Base2 constructors</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   Derived::Derived<span class="blue">(int</span> value, <span class="blue">char</span> letter, <span class="blue">double</span> real)&#13;
<span class="cviolet"> <strong>8</strong></span>      : Base1{value}, Base2{letter}, m_real{real} {}&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="lgreen">// return real</span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">double</span> Derived::getReal() <span class="blue">const</span> {<span class="blue">return</span> m_real;}&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="lgreen">// display all data members of Derived</span>&#13;
<span class="cviolet"><strong>14</strong></span>   string Derived::toString() <span class="blue">const</span> {&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="blue">return</span> fmt::format(<span class="green">"int: {}; char: {}; double: {}"</span>,&#13;
<span class="cviolet"><strong>16</strong></span>                Base1::getData(), Base2::getData(), getReal());&#13;
<span class="cviolet"><strong>17</strong></span>   }</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.44</strong></span> | Demonstrating multiple inheritance—<code>Derived.cpp</code>.</p>&#13;
</div>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> For multiple inheritance (in <a href="ch10.xhtml#fig10_43">Fig. 10.43</a>), we follow the colon (<code>:</code>) after <code>class Derived</code> with a <strong>comma-separated list of base classes</strong> (line 13). In <a href="ch10.xhtml#fig10_44">Fig. 10.44</a>, notice that constructor <code>Derived</code> explicitly calls base-class constructors for each base class—<code>Base1</code> and <code>Base2</code>— using the member-initializer syntax (line 8). <strong>The base-class constructors are called in the order that the inheritance is specified</strong>. <strong>If the member-initializer list does not explicitly call a base class’s constructor, the base class’s default constructor will be called implicitly.</strong></p>&#13;
<h5 class="h5" id="ch10lev3sec68">Resolving Ambiguity Issues That Arise When a Derived Class Inherits Member Functions of the Same Name from Multiple Base Classes</h5>&#13;
<p>Member function <code>toString</code> (lines 14–17) returns a string representation of a <code>Derived</code> object’s contents. It uses all of the <code>Derived</code> class’s <em>get</em> member functions. However, there’s an ambiguity problem. A <strong><code>Derived</code> object contains <em>two</em> <code>getData</code> functions</strong>—one inherited from class <code>Base1</code> and one inherited from class <code>Base2</code>. This problem is easy to solve by using the scope-resolution operator. <code>Base1::getData()</code> gets the value of the variable inherited from class <code>Base1</code> (i.e., the <code>int</code> variable named <code>m_value</code>), and <code>Base2::getData()</code> gets the value of the variable inherited from class <code>Base2</code> (i.e., the <code>char</code> variable named <code>m_letter</code>).</p>&#13;
<h5 class="h5" id="ch10lev3sec69">Testing the Multiple-Inheritance Hierarchy</h5>&#13;
<p><a href="ch10.xhtml#fig10_45">Figure 10.45</a> tests the classes in Figs. 10.41–10.44. Line 11 creates <code>Base1</code> object <code>base1</code> and initializes it to the <code>int</code> value <code>10</code>. Line 12 creates <code>Base2</code> object <code>base2</code> and initializes it to the <code>char</code> value <code>'Z'</code>. Line 13 creates <code>Derived</code> object <code>derived</code> and initializes it to contain the <code>int</code> value <code>7</code>, the <code>char</code> value <code>'A'</code> and the <code>double</code> value <code>3.5</code>.</p>&#13;
<div class="group" id="fig10_45">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro45" id="p10pro45a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_45.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Driver for multiple-inheritance example.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> <span class="green">"fmt/format.h"</span> <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> <span class="green">"Base1.h"</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> <span class="green">"Base2.h"</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> <span class="green">"Derived.h"</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>9</strong></span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>11</strong></span>      Base1 base1{<span class="green">10</span>}; <span class="lgreen">// create Base1 object</span>&#13;
<span class="cviolet"><strong>12</strong></span>      Base2 base2{<span class="green">'Z'</span>}; <span class="lgreen">// create Base2 object</span>&#13;
<span class="cviolet"><strong>13</strong></span>      Derived derived{<span class="green">7</span>, <span class="green">'A'</span>, <span class="green">3.5</span>}; <span class="lgreen">// create Derived object</span>&#13;
<span class="cviolet"><strong>14</strong></span>&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="lgreen">// print data in each object</span>&#13;
<span class="cviolet"><strong>16</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}: {}\n{}: {}\n{}: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>17</strong></span>                 <span class="green">"Object base1 contains", base1.get</span>Data(),&#13;
<span class="cviolet"><strong>18</strong></span>                 <span class="green">"Object base2 contains the character"</span>, base2.getData(),&#13;
<span class="cviolet"><strong>19</strong></span>                 <span class="green">"Object derived contains"</span>, derived.toString());&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="lgreen">// print data members of derived-class object</span>&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="lgreen">// scope resolution operator resolves getData ambiguity</span>&#13;
<span class="cviolet"><strong>23</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"{}\n{}: {}\n{}: {}\n{}: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>24</strong></span>                 <span class="green">"Data members of Derived can be accessed individually:"</span>,&#13;
<span class="cviolet"><strong>25</strong></span>                 <span class="green">"int"</span>, derived.Base1::getData(),&#13;
<span class="cviolet"><strong>26</strong></span>                 <span class="green">"char"</span>, derived.Base2::getData(),&#13;
<span class="cviolet"><strong>27</strong></span>                 <span class="green">"double"</span>, derived.getReal());&#13;
<span class="cviolet"><strong>28</strong></span>&#13;
<span class="cviolet"><strong>29</strong></span>      cout &lt;&lt; <span class="green">"Derived can be treated as an object of either base class:\n"</span>;&#13;
<span class="cviolet"><strong>30</strong></span>&#13;
<span class="cviolet"><strong>31</strong></span>      <span class="lgreen">// treat Derived as a Base1 object</span>&#13;
<span class="cviolet"><strong>32</strong></span>      Base1* base1Ptr = &amp;derived;&#13;
<span class="cviolet"><strong>33</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"base1Ptr-&gt;getData() yields {}\n"</span>,&#13;
<span class="cviolet"><strong>34</strong></span>                 base1Ptr-&gt;getData());&#13;
<span class="cviolet"><strong>35</strong></span>&#13;
<span class="cviolet"><strong>36</strong></span>      <span class="lgreen">// treat Derived as a Base2 object</span>&#13;
<span class="cviolet"><strong>37</strong></span>      Base2* base2Ptr = &amp;derived;&#13;
<span class="cviolet"><strong>38</strong></span>      cout &lt;&lt; fmt::format(<span class="green">"base2Ptr-&gt;getData() yields {}\n"</span>,&#13;
<span class="cviolet"><strong>39</strong></span>                 base2Ptr-&gt;getData());&#13;
<span class="cviolet"><strong>40</strong></span>   }</pre>&#13;
<pre class="pre1">Object base1 contains: 10&#13;
Object base2 contains the character: Z&#13;
Object derived contains: int: 7; char: A; double: 3.5&#13;
&#13;
Data members of Derived can be accessed individually:&#13;
int: 7&#13;
char: A&#13;
double: 3.5&#13;
&#13;
Derived can be treated as an object of either base class:&#13;
base1Ptr-&gt;getData() yields 7&#13;
base2Ptr-&gt;getData() yields A</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.45</strong></span> | Demonstrating multiple inheritance. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>Lines 16–19 display each object’s data values. For objects <code>base1</code> and <code>base2</code>, we invoke each object’s <code>getData</code> member function. Even though there are <em>two</em> <code>getData</code> functions in this example, the calls are <em>not ambiguous</em>. In line 17, the compiler knows that <code>base1</code> is an object of class <code>Base1</code>, so class <code>Base1</code>’s <code>getData</code> is called. In line 18, the compiler knows that <code>base2</code> is an object of class <code>Base2</code>, so class <code>Base2</code>’s <code>getData</code> is called. Line 19 gets <code>derived</code>’s contents by calling its <code>toString</code> member function.</p>&#13;
<p>Lines 23–27 output <code>derived</code>’s contents again by using class <code>Derived</code>’s <em>get</em> member functions. Again, there is an <em>ambiguity</em> problem—this object contains <code>getData</code> functions from both class <code>Base1</code> and class <code>Base2</code>. The expression</p>&#13;
<pre class="pre"><code>derived.Base1::getData()</code></pre>&#13;
<p>gets the value of <code>m_value</code> inherited from class <code>Base1</code> and</p>&#13;
<pre class="pre"><code>derived.Base2::getData()</code></pre>&#13;
<p>gets the value of <code>m_letter</code> inherited from class <code>Base2</code>.</p>&#13;
<h5 class="h5" id="ch10lev3sec70">Demonstrating the <em>Is-a</em> Relationships in Multiple Inheritance</h5>&#13;
<p><strong>The <em>is-a</em> relationships of <em>single inheritance</em> also apply in <em>multiple-inheritance</em> relationships.</strong> To demonstrate this, line 32 assigns <code>derived</code>’s address to the <code>Base1</code> pointer <code>base1Ptr</code>. This is allowed because <strong>a <code>Derived</code> object <em>is a</em> <code>Base1</code> object</strong>. Line 34 invokes <code>Base1</code> member function <code>getData</code> via <code>base1Ptr</code> to obtain the value of only the <code>Base1</code> part of the object <code>derived</code>. Line 37 assigns <code>derived</code>’s address to the <code>Base2</code> pointer <code>base2Ptr</code>. This is allowed because <strong>a <code>Derived</code> object <em>is a</em> <code>Base2</code> object</strong>. Line 39 invokes <code>Base2</code> member function <code>getData</code> via <code>base2Ptr</code> to obtain the value of only the <code>Base2</code> part of the object <code>derived</code>.</p>&#13;
<h4 class="h4" id="sec10_14_1">10.14.1 Diamond Inheritance</h4>&#13;
<p>In <a href="ch10.xhtml#sec10_14">Section 10.14</a>, we discussed <em>multiple inheritance</em>, the process by which one class inherits from <em>two or more</em> classes. Multiple inheritance is used, for example, in the C++ standard library to form class <code>basic_iostream</code>, as shown in the following diagram:</p>&#13;
<div class="image"><img src="Images/555fig01.jpg" alt="Images" width="428" height="197"/></div>&#13;
<p>Class <code>basic_ios</code> is the base class of both <code>basic_istream</code> and <code>basic_ostream</code>. Each is formed with <em>single inheritance</em>. Class <code>basic_iostream</code> inherits from both <code>basic_istream</code> and <code>basic_ostream</code>. This enables class <code>basic_iostream</code> objects to provide the functionality of <code>basic_istream</code>s and <code>basic_ostream</code>s. In multiple-inheritance hierarchies, the inheritance described in this diagram is referred to as <strong><span class="violet">diamond</span> <span class="violet">inheritance</span></strong>.</p>&#13;
<p>Classes <code>basic_istream</code> and <code>basic_ostream</code> each inherit from <code>basic_ios</code>, so a potential problem exists for <code>basic_iostream</code>. It could inherit <em>two</em> copies of <code>basic_ios</code>’s members— one via <code>basic_istream</code> and one via <code>basic_ostream</code>. This would be <em>ambiguous</em> and would result in a compilation error—the compiler would not know which copy of <code>basic_ios</code>’s members to use. Let’s see how <strong>using <code>virtual</code> base classes solves this problem.</strong></p>&#13;
<h5 class="h5" id="ch10lev3sec71">Compilation Errors Produced When Ambiguity Arises in Diamond Inheritance</h5>&#13;
<p><a href="ch10.xhtml#fig10_46">Figure 10.46</a> demonstrates the <em>ambiguity</em> that can occur in <em>diamond inheritance</em>. Class <code>Base</code> (lines 8–11) contains pure <code>virtual</code> function <code>print</code> (line 10). Classes <code>DerivedOne</code> (lines 14–18) and <code>DerivedTwo</code> (lines 21–25) each publicly inherit from <code>Base</code> and override function <code>print</code>. Class <code>DerivedOne</code> and class <code>DerivedTwo</code> each contain a <strong><span class="violet">base-class subobject</span></strong>—i.e., the members of class <code>Base</code> in this example.</p>&#13;
<div class="group" id="fig10_46">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro46" id="p10pro46a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_46.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Attempting to polymorphically call a function that is</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// inherited from each of two base classes.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">using namespace</span> std;&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="lgreen">// class Base definition</span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">class</span> Base {&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>10</strong></span>      <span class="blue">virtual</span> <span class="blue">void</span> print() <span class="blue">const</span> = <span class="green">0</span>; <span class="lgreen">// pure virtual</span><br/>&#13;
<span class="cviolet"><strong>11</strong></span>   };&#13;
<span class="cviolet"><strong>12</strong></span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="lgreen">// class DerivedOne definition</span>&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">class</span> DerivedOne : <span class="blue">public</span> Base {&#13;
<span class="cviolet"><strong>15</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="lgreen">// override print function</span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">void</span> print() <span class="blue">const override</span> {cout &lt;&lt; <span class="green">"DerivedOne\n"</span>;}&#13;
<span class="cviolet"><strong>18</strong></span>   };&#13;
<span class="cviolet"><strong>19</strong></span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="lgreen">// class DerivedTwo definition</span>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">class</span> DerivedTwo : <span class="blue">public</span> Base {&#13;
<span class="cviolet"><strong>22</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="lgreen">// override print function</span>&#13;
<span class="cviolet"><strong>24</strong></span>      <span class="blue">void</span> print() <span class="blue">const</span> <span class="blue">override</span> {cout &lt;&lt; <span class="green">"DerivedTwo\n"</span>;}&#13;
<span class="cviolet"><strong>25</strong></span>   };&#13;
<span class="cviolet"><strong>26</strong></span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="lgreen">// class Multiple definition</span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">class</span> Multiple : <span class="blue">public</span> DerivedOne, <span class="blue">public</span> DerivedTwo {&#13;
<span class="cviolet"><strong>29</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>30</strong></span>      <span class="lgreen">// qualify which version of function print</span>&#13;
<span class="cviolet"><strong>31</strong></span>      <span class="blue">void</span> print() <span class="blue">const override</span> {DerivedTwo::print();}&#13;
<span class="cviolet"><strong>32</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>33</strong></span>&#13;
<span class="cviolet"><strong>34</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>35</strong></span>      Multiple both{}; <span class="lgreen">// instantiate a Multiple object</span>&#13;
<span class="cviolet"><strong>36</strong></span>      DerivedOne one{}; <span class="lgreen">// instantiate a DerivedOne object</span>&#13;
<span class="cviolet"><strong>37</strong></span>      DerivedTwo two{}; <span class="lgreen">// instantiate a DerivedTwo object</span>&#13;
<span class="cviolet"><strong>38</strong></span>      Base* array[<span class="green">3</span>]{}; <span class="lgreen">// create array of base-class pointers</span>&#13;
<span class="cviolet"><strong>39</strong></span>&#13;
<span class="cviolet"><strong>40</strong></span>      <span class="red">array[0] = &amp;both; // ERROR--ambiguous </span>&#13;
<span class="cviolet"><strong>41</strong></span>      array[<span class="green">1</span>] = &amp;one;&#13;
<span class="cviolet"><strong>42</strong></span>      array[<span class="green">2</span>] = &amp;two;&#13;
<span class="cviolet"><strong>43</strong></span>&#13;
<span class="cviolet"><strong>44</strong></span>      <span class="lgreen">// polymorphically invoke print</span>&#13;
<span class="cviolet"><strong>45</strong></span>      <span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">0</span>}; i &lt; <span class="green">3</span>; ++i) {&#13;
<span class="cviolet"><strong>46</strong></span>         array[i] -&gt;print();&#13;
<span class="cviolet"><strong>47</strong></span>      }&#13;
<span class="cviolet"><strong>48</strong></span>   <code>}</code></pre>&#13;
<p><em>Microsoft Visual C++ compiler error message:</em></p>&#13;
<pre class="pre1">c:\Users\PaulDeitel\Documents\examples\ch10\fig10_46\fig10_46.cpp(40,20):&#13;
error C2594: '=': ambiguous conversions from 'Multiple *' to 'Base *'</pre>&#13;
</div>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.46</strong></span> | Attempting to polymorphically call a function that is inherited from each of two base classes. (Part 2 of 2.)</p>&#13;
<p>Class <code>Multiple</code> (lines 28–32) inherits from <em>both</em> class <code>DerivedOne</code> and class <code>DerivedTwo</code>. In class <code>Multiple</code>, function <code>print</code> is overridden to call <code>DerivedTwo</code>’s <code>print</code> (line 31). Notice that we must <em>qualify</em> the <code>print</code> call with the class name <code>DerivedTwo</code> to specify which version of <code>print</code> to call.</p>&#13;
<p>Function <code>main</code> (lines 34–48) declares objects of classes <code>Multiple</code> (line 35), <code>Derived-One</code> (line 36) and <code>DerivedTwo</code> (line 37). Line 38 declares an array of <code>Base*</code> pointers. Each array element is initialized with the address of an object (lines 40–42). An error occurs when the address of <code>both</code>—an object of class <code>Multiple</code>—is assigned to <code>array[0]</code>. The object <code>both</code> actually contains two <code>Base</code> subobjects. The compiler does not know which subobject the pointer <code>array[0]</code> should point to, so it generates a compilation error indicating an <em>ambiguous conversion</em>.</p>&#13;
<h4 class="h4" id="sec10_14_2">10.14.2 Eliminating Duplicate Subobjects with <code>virtual</code> Base-Class Inheritance</h4>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>The problem of <em>duplicate subobjects</em> is resolved with</strong> <span class="violet"><strong><code>virtual</code></strong></span><strong><span class="violet"> inheritance</span></strong>. When a base class is inherited as <code>virtual</code>, only <em>one</em> subobject will appear in the derived class. <a href="ch10.xhtml#fig10_47">Figure 10.47</a> revises the program of <a href="ch10.xhtml#fig10_46">Fig. 10.46</a> to use a <code>virtual</code> base class.</p>&#13;
<div class="group" id="fig10_47">&#13;
<p class="codelink"><a href="Images/ch10_images.xhtml#p10pro47" id="p10pro47a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig10_47.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Using virtual base classes.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">using namespace</span> std;&#13;
&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="lgreen">// class Base definition</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">class</span> Base {&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="blue">virtual</span> <span class="blue">void</span> print() <span class="blue">const</span> = <span class="green">0</span>; <span class="lgreen">// pure virtual</span>&#13;
<span class="cviolet"><strong>10</strong></span>   };&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="lgreen">// class DerivedOne definition</span>&#13;
<span class="cviolet"><strong>13</strong></span>   <span class="blue">class</span> DerivedOne : <span class="blue">virtual public</span> Base {&#13;
<span class="cviolet"><strong>14</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>15</strong></span>      <span class="lgreen">// override print function</span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">void</span> print() <span class="blue">const override</span> {cout &lt;&lt; <span class="green">"DerivedOne\n"</span>;}&#13;
<span class="cviolet"><strong>17</strong></span>   };&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="lgreen">// class DerivedTwo definition</span>&#13;
<span class="cviolet"><strong>20</strong></span>   <span class="blue">class</span> DerivedTwo : <span class="blue">virtual public</span> Base {&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="lgreen">// override print function</span>&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">void</span> print() <span class="blue">const</span> <span class="blue">override</span> {cout &lt;&lt; <span class="green">"DerivedTwo\n"</span>;}&#13;
<span class="cviolet"><strong>24</strong></span>   };&#13;
<span class="cviolet"><strong>25</strong></span>&#13;
<span class="cviolet"><strong>26</strong></span>   <span class="lgreen">// class Multiple definition</span>&#13;
<span class="cviolet"><strong>27</strong></span>   <span class="blue">class</span> Multiple : <span class="blue">public</span> DerivedOne, <span class="blue">public</span> DerivedTwo {&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">public</span>:&#13;
<span class="cviolet"><strong>29</strong></span>      <span class="lgreen">// qualify which version of function print</span>&#13;
<span class="cviolet"><strong>30</strong></span>      <span class="blue">void</span> print() <span class="blue">const override</span> {DerivedTwo::print();}&#13;
<span class="cviolet"><strong>31</strong></span>   };&#13;
<span class="cviolet"><strong>32</strong></span>&#13;
<span class="cviolet"><strong>33</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>34</strong></span>      Multiple both; <span class="lgreen">// instantiate Multiple object</span>&#13;
<span class="cviolet"><strong>35</strong></span>      DerivedOne one; <span class="lgreen">// instantiate DerivedOne object</span>&#13;
<span class="cviolet"><strong>36</strong></span>      DerivedTwo two; <span class="lgreen">// instantiate DerivedTwo object</span>&#13;
<span class="cviolet"><strong>37</strong></span>      Base* array[<span class="green">3</span>];&#13;
<span class="cviolet"><strong>38</strong></span>&#13;
<span class="cviolet"><strong>39</strong></span>      array[<span class="green">0</span>] = &amp;both; <span class="lgreen">// allowed now</span>&#13;
<span class="cviolet"><strong>40</strong></span>      array[<span class="green">1</span>] = &amp;one;&#13;
<span class="cviolet"><strong>41</strong></span>      array[<span class="green">2</span>] = &amp;two;&#13;
<span class="cviolet"><strong>42</strong></span>&#13;
<span class="cviolet"><strong>43</strong></span>      <span class="lgreen">// polymorphically invoke function print</span>&#13;
<span class="cviolet"><strong>44</strong></span>      <span class="blue">for</span> (<span class="blue">int</span> i = <span class="green">0</span>; i &lt; <span class="green">3</span>; ++i) {&#13;
<span class="cviolet"><strong>45</strong></span>         array[i]-&gt;print();&#13;
<span class="cviolet"><strong>46</strong></span>      }&#13;
<span class="cviolet"><strong>47</strong></span>   }</pre>&#13;
<pre class="pre1">DerivedTwo&#13;
DerivedOne&#13;
DerivedTwo</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 10.47</strong></span> | Using <code>virtual</code> base classes. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>The key change is that classes <code>DerivedOne</code> (line 13) and <code>DerivedTwo</code> (line 20) each inherit from <code>Base</code> using <code>virtual public Base</code>. Since both classes inherit from <code>Base</code>, they each contain a <code>Base</code> subobject. The benefit of <code>virtual</code> inheritance is not apparent until class <code>Multiple</code> inherits from <code>DerivedOne</code> and <code>DerivedTwo</code> (line 27). <strong>Since each base class used <code>virtual</code> inheritance, the compiler ensures that <code>Multiple</code> inherits only <em>one</em> <code>Base</code> subobject.</strong> This eliminates the ambiguity error generated by the compiler in <a href="ch10.xhtml#fig10_46">Fig. 10.46</a>. The compiler now allows the implicit conversion of the derived-class pointer (<code>&amp;both</code>) to the base-class pointer <code>array[0]</code> in line 39 in <code>main</code>. The <code>for</code> statement in lines 44–46 polymorphically calls <code>print</code> for each object.</p>&#13;
<h5 class="h5" id="ch10lev3sec72">Constructors in Multiple-Inheritance Hierarchies with <code>virtual</code> Base Classes</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> Implementing hierarchies with <code>virtual</code> base classes is simpler if <em>default constructors</em> are used for the base classes. <a href="ch10.xhtml#fig10_46">Figures 10.46</a> and <a href="ch10.xhtml#fig10_47">10.47</a> use compiler-generated <em>default constructors</em>. If a <code>virtual</code> base class provides a constructor that requires arguments, the derived-class implementations become more complicated. <strong>The</strong> <span class="violet"><strong>most derived class</strong></span> <strong>must explicitly invoke the <code>virtual</code> base class’s constructor.</strong> For this reason, consider providing a default constructor for <code>virtual</code> base classes, so the derived classes do not need to explicitly invoke the <code>virtual</code> base class’s constructor.<sup><a id="ch10fn41a" href="ch10.xhtml#ch10fn41">41</a>,<a id="ch10fn42a" href="ch10.xhtml#ch10fn42">42</a></sup></p>&#13;
<p class="footnote"><a id="ch10fn41" href="ch10.xhtml#ch10fn41a">41</a>. “Inheritance — Multiple and Virtual Inheritance — What special considerations do I need to know about when I use virtual inheritance?” Accessed February 7, 2021. <code><a href="https://isocpp.org/wiki/faq/multiple-inheritance#virtual-inheritance-abcs">https://isocpp.org/wiki/faq/multiple-inheritance#virtual-inheritance-abcs</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn42" href="ch10.xhtml#ch10fn42a">42</a>. “Inheritance — Multiple and Virtual Inheritance — What special considerations do I need to know about when I inherit from a class that uses virtual inheritance?” Accessed February 7, 2021. <code><a href="https://isocpp.org/wiki/faq/multiple-inheritance#virtual-inheritance-ctors">https://isocpp.org/wiki/faq/multiple-inheritance#virtual-inheritance-ctors</a></code>.</p>&#13;
<h3 class="h3" id="sec10_15"><span class="violet">10.15</span> <code>protected</code> Class Members</h3>&#13;
<p><a href="ch09.xhtml#ch09">Chapter 9</a> introduced the access specifiers <code>public</code> and <code>private</code>. A base class’s <code>public</code> members are accessible within its class and anywhere that the program has access to an object of that class or one of its derived classes. A base class’s <code>private</code> members are accessible only within its body and to its <code>friend</code>s. The access specifier <span class="violet"><strong><code>protected</code></strong></span> offers an intermediate level of protection between <code>public</code> and <code>private</code> access. Such members are accessible within that base class, by members and <code>friend</code>s of that base class, and by members and <code>friend</code>s of any classes derived from that base class.</p>&#13;
<p>In public inheritance, all <code>public</code> and <code>protected</code> base-class members retain their original access when they become members of the derived class:</p>&#13;
<p class="bull">• <code>public</code> base-class members become <code>public</code> derived-class members, and</p>&#13;
<p class="bull">• <code>protected</code> base-class members become <code>protected</code> derived-class members.</p>&#13;
<p><strong>A base class’s <code>private</code> members are <em>not</em> accessible outside the class itself.</strong> Derived classes can access a base class’s <code>private</code> members only through the <code>public</code> or <code>protected</code> member functions inherited from the base class. Derived-class member functions can refer to <code>public</code> and <code>protected</code> members inherited from the base class by their member names.</p>&#13;
<h5 class="h5" id="ch10lev3sec73">Problems with <code>protected</code> Data</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> It’s best to avoid <code>protected</code> data members because they create some serious problems:</p>&#13;
<p class="bull">• <strong>A derived-class object does not have to use a member function to set a base-class <code>protected</code> data member’s value. So, an invalid value can be assigned, leaving the object in an inconsistent state.</strong> For example, if <code>CommissionEmployee</code>’s data member <code>m_grossSales</code> is <code>protected</code> (and the class is not <code>final</code>), a derived-class object can assign a negative value to <code>m_grossSales</code>.</p>&#13;
<p class="bull">• <span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <strong>Derived-class member functions are more likely to be written so that they depend on the base class’s data.</strong> Derived classes should depend only on the base-class non-<code>private</code> member functions. If we were to change the name of a base-class <code>protected</code> data member, we’d need to modify every derived class that references the data directly. Such software is said to be <strong><span class="violet">fragile</span></strong> or <strong><span class="violet">brittle</span></strong>. <strong>A small change in the base class can “break” the derived class. This is known as the fragile base-class problem</strong><sup><a id="ch10fn43a" href="ch10.xhtml#ch10fn43">43</a></sup> <strong>and is a key reason why the C++ Core Guidelines recommend avoiding <code>protected</code> data</strong>.<sup><a id="ch10fn44a" href="ch10.xhtml#ch10fn44">44</a></sup> You should be able to make changes in a base class without having to modify its derived classes.</p>&#13;
<p class="footnote"><a id="ch10fn43" href="ch10.xhtml#ch10fn43a">43</a>. “Fragile base class.” Accessed February 7, 2021. <code><a href="https://w.wiki/yFZ">https://w.wiki/yFZ</a></code>.</p>&#13;
<p class="footnote"><a id="ch10fn44" href="ch10.xhtml#ch10fn44a">44</a>. “C++ Core Guidelines — C.133: Avoid protected data.” Accessed February 7, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-protected">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-protected</a></code>.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> In most cases, it’s better to use <code>private</code> data members to encourage proper software engineering. <strong>Declaring base-class data members <code>private</code> allows you to change the base-class implementation without having to change derived-class implementations. This makes your code easier to maintain, modify and debug.</strong></p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> A derived class can change the state of <code>private</code> base-class data members only through non-<code>private</code> base-class member functions inherited into the derived class. <strong>If a derived class could access its base class’s <code>private</code> data members, classes that inherit from that derived class could access the data members as well</strong>, and the benefits of information hiding would be lost.</p>&#13;
<h5 class="h5" id="ch10lev3sec74"><code>protected</code> Base-Class Member Functions</h5>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> One use of <code>protected</code> is to <strong>define base-class member functions that should not be exposed to client code but should be accessible in derived classes</strong>. A use-case for this is to enable a derived class to override the base-class <code>protected virtual</code> function and also call the original base-class version from the derived class’s implementation.<sup><a id="ch10fn45a" href="ch10.xhtml#ch10fn45">45</a></sup> We used this capability in the example of <a href="ch10.xhtml#sec10_11">Section 10.11</a>, Non-Virtual Interface (NVI) Idiom.</p>&#13;
<p class="footnote"><a id="ch10fn45" href="ch10.xhtml#ch10fn45a">45</a>. Herb Sutter, “Virtuality.” Accessed February 3, 2021. <code><a href="http://www.gotw.ca/publications/mill18.htm">http://www.gotw.ca/publications/mill18.htm</a></code>.</p>&#13;
<h3 class="h3" id="sec10_16"><span class="violet">10.16</span> <code>public</code>, <code>protected</code> and <code>private</code> Inheritance</h3>&#13;
<p>You can choose between <span class="violet"><strong><code>public</code></strong></span>, <span class="violet"><strong><code>protected</code></strong></span> or <span class="violet"><strong><code>private</code></strong></span><strong><span class="violet"> inheritance</span></strong>. <code>public</code> inheritance is the most common, and <code>protected</code> inheritance is rare. The following diagram summarizes for each inheritance type the accessibility of base-class members in a derived class. The first column contains the base-class member access specifiers.</p>&#13;
<div class="image"><img src="Images/561tab01.jpg" alt="Images" width="813" height="634"/></div>&#13;
<p>When deriving a class with <code>public</code> inheritance:</p>&#13;
<p class="bull">• <code>public</code> base-class members become <code>public</code> derived-class members, and</p>&#13;
<p class="bull">• <code>protected</code> base-class members become <code>protected</code> derived-class members.</p>&#13;
<p>A base class’s <code>private</code> members are <em>never</em> accessible directly in the derived class but can be accessed by calling inherited <code>public</code> and <code>protected</code> base-class member functions designed to access those <code>private</code> members.</p>&#13;
<p>When deriving a class with <code>protected</code> inheritance, <code>public</code> and <code>protected</code> base-class members become <code>protected</code> derived-class members. When deriving a class with <code>private</code> inheritance, <code>public</code> and <code>protected</code> base-class members become <code>private</code> derived-class members.</p>&#13;
<p><span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <strong>Classes created with <code>private</code> and <code>protected</code> inheritance do not have <em>is-a</em> relation-ships with their base classes because the base class’s <code>public</code> members are not accessible to the derived class’s client code.</strong></p>&#13;
<h5 class="h5" id="ch10lev3sec75">Default Inheritance in <code>class</code>es vs. <strong><code>struct</code></strong>s</h5>&#13;
<p>Both <code>class</code> and <code>struct</code> (defined in <a href="ch09.xhtml#ch09lev1sec21">Section 9.21</a>) can be used to define new types. However, there are two key differences between a <code>class</code> definition and a <code>struct</code> definition. The first is that, by default, <code>class</code> members are <code>private</code> and <code>struct</code> members are <code>public</code>. The other difference is in the default inheritance type. A <code>class</code> definition like</p>&#13;
<pre class="pre"><span class="blue">class</span> Derived : Base {&#13;
   <span class="lgreen">// ...</span>&#13;
};</pre>&#13;
<p>uses <code>private</code> inheritance by default, whereas a <code>struct</code> definition like</p>&#13;
<pre class="pre"><span class="blue">struct</span> Derived : Base {&#13;
   <span class="lgreen">// ...</span>&#13;
};</pre>&#13;
<p>uses <code>public</code> inheritance by default.</p>&#13;
<h3 class="h3" id="sec10_17"><span class="violet">10.17</span> Wrap-Up</h3>&#13;
<p>This chapter continued our object-oriented programming (OOP) discussion with introductions to inheritance and runtime polymorphism. You created derived classes that inherited base classes’ capabilities, then customized or enhanced them. We distinguished between the <em>has-a</em> composition relationship and the <em>is-a</em> inheritance relationship.</p>&#13;
<p>We explained and demonstrated runtime polymorphism with inheritance hierarchies. You wrote programs that processed objects of classes that are part of the same class hierarchy as if they were all objects of the hierarchy’s base class. You manipulated those objects via base-class pointers and references.</p>&#13;
<p>We explained that runtime polymorphism helps you design and implement systems that are easier to extend, enabling you to add new classes with little or no modification to the program’s general portions. We used a detailed illustration to help you understand how runtime polymorphism, virtual functions and dynamic binding can be implemented “under the hood.”</p>&#13;
<p>We introduced the non-virtual interface idiom (NVI) in which each base-class function serves only one purpose—as either a <code>public</code> non-<code>virtual</code> function that client code calls to perform a task or as a <code>private</code> (or <code>protected</code>) <code>virtual</code> function that derived classes can customize. You saw that when using this idiom, the <code>virtual</code> functions are internal implementation details hidden from the client code, making systems easier to maintain and evolve.</p>&#13;
<p>We initially focused on implementation inheritance, then pointed out that decades of experience with real-world, business-critical and mission-critical systems has shown that it can be difficult to maintain and modify such systems. So, we refactored our <code>Employee-</code>payroll example to use interface inheritance in which the base class contained only pure <code>virtual</code> functions that derived concrete classes were required to implement. In that example, we introduced the composition-and-dependency-injection approach in which a class contains a pointer to an object that provides behaviors required by objects of the class. Then, we discussed how this interface-based approach makes the example easier to modify and evolve.</p>&#13;
<p>Next, we looked at another way to implement runtime polymorphism by processing objects of classes not related by inheritance, using duck typing via C++17’s class template <code>std::variant</code> and the standard-library function <code>std::visit</code>.</p>&#13;
<p>We demonstrated multiple inheritance, discussed its potential problems and showed how <code>virtual</code> inheritance can be used to solve them. We introduced the <code>protected</code> access specifier—derived-class member functions and <code>friend</code>s of the derived class can access <code>protected</code> base-class members. We also explained the three types of inheritance—<code>public</code>, <code>protected</code> and <code>private</code>—and the accessibility of base-class members in a derived class when using each type.</p>&#13;
<p>Finally, we overviewed other runtime-polymorphism techniques and several template-based compile-time polymorphism approaches. We’ll implement some of these in <a href="ch15.xhtml#ch15">Chapter 15</a>. There you’ll see that C++20’s new concepts capabilities obviate some older techniques and strengthen your “toolkit” for creating compile-time, template-based solutions. We also provided links to advanced resources for developers who wish to dig deeper.</p>&#13;
<p>A key goal of this chapter was to familiarize you with the mechanics of inheritance and runtime polymorphism with <code>virtual</code> functions. Now, you’ll be able to better appreciate newer polymorphism idioms and techniques that can promote ease of modifiability and better performance. We cover some of these modern idioms in later chapters.</p>&#13;
<p>In <a href="ch11.xhtml#ch11">Chapter 11</a>, we continue our object-oriented programming presentation with operator overloading, which enables existing operators to work with custom class-type objects as well. For example, you’ll see how to overload the <code>&lt;&lt;</code> operator to output a complete array without explicitly using an iteration statement. You’ll use “smart pointers” to manage dynamically allocated memory and ensure that it’s released when no longer needed. We’ll introduce the remaining special member functions and discuss rules and guidelines for using them. We’ll consider move semantics, which enable object resources (such as dynamically allocated memory) to move from one object to another when an object is going out of scope. As you’ll see, this can save memory and increase performance.</p>&#13;
</div></body>
</html>