<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch05">Chapter 5. Functions</h2>&#13;
<div class="image"><img src="Images/ch05.jpg" alt="Images" width="658" height="862"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Construct programs modularly from functions.</p>&#13;
<p class="squ"><span class="red">■</span> Use common math library functions and learn about math functions and constants added in C++20, C++17 and C++11.</p>&#13;
<p class="squ"><span class="red">■</span> Declare functions with function prototypes.</p>&#13;
<p class="squ"><span class="red">■</span> View many key C++ Standard Library headers.</p>&#13;
<p class="squ"><span class="red">■</span> Use random numbers to implement game-playing apps.</p>&#13;
<p class="squ"><span class="red">■</span> Declare constants in scoped <code>enum</code>s and use constants without their type names via C++20’s <code>using enum</code> declarations.</p>&#13;
<p class="squ"><span class="red">■</span> Make long numbers more readable with digit separators.</p>&#13;
<p class="squ"><span class="red">■</span> Understand the scope of identifiers.</p>&#13;
<p class="squ"><span class="red">■</span> Use inline functions, references and default arguments.</p>&#13;
<p class="squ"><span class="red">■</span> Define overloaded functions that perform different tasks based on the number and types of their arguments.</p>&#13;
<p class="squ"><span class="red">■</span> Define function templates that can generate families of overloaded functions.</p>&#13;
<p class="squ"><span class="red">■</span> Write and use recursive functions.</p>&#13;
<p class="squ"><span class="red">■</span> Use the C++17 and C++20 <code>[[nodiscard]]</code> attribute to indicate that a function’s return value should not be ignored.</p>&#13;
<p class="squ"><span class="red">■</span> Zajnropc vrq lnfylun-lhqtomh uyqmmhzg tupb j dvql psrpu iw dmwwqnddwjqz.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec1"><span class="violet"><strong>5.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec2"><span class="violet"><strong>5.2</strong></span> Program Components in C++</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec3"><span class="violet"><strong>5.3</strong></span> Math Library Functions</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec4"><span class="violet"><strong>5.4</strong></span> Function Definitions and Function Prototypes</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec5"><span class="violet"><strong>5.5</strong></span> Order of Evaluation of a Function’s Arguments</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec6"><span class="violet"><strong>5.6</strong></span> Function-Prototype and Argument-Coercion Notes</a></p>&#13;
<p class="chap-lev2"><a href="ch05.xhtml#ch05lev2sec1">5.6.1 Function Signatures and Function Prototypes</a></p>&#13;
<p class="chap-lev2"><a href="ch05.xhtml#ch05lev2sec2">5.6.2 Argument Coercion</a></p>&#13;
<p class="chap-lev2"><a href="ch05.xhtml#ch05lev2sec3">5.6.3 Argument-Promotion Rules and Implicit Conversions</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec7"><span class="violet"><strong>5.7</strong></span> C++ Standard Library Headers</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec8"><span class="violet"><strong>5.8</strong></span> Case Study: Random-Number Generation</a></p>&#13;
<p class="chap-lev2"><a href="ch05.xhtml#ch05lev2sec4">5.8.1 Rolling a Six-Sided Die</a></p>&#13;
<p class="chap-lev2"><a href="ch05.xhtml#ch05lev2sec5">5.8.2 Rolling a Six-Sided Die 60,000,000 Times</a></p>&#13;
<p class="chap-lev2"><a href="ch05.xhtml#ch05lev2sec6">5.8.3 Randomizing the Random-Number Generator with <code>srand</code></a></p>&#13;
<p class="chap-lev2"><a href="ch05.xhtml#ch05lev2sec7">5.8.4 Seeding the Random-Number Generator with the Current Time</a></p>&#13;
<p class="chap-lev2"><a href="ch05.xhtml#ch05lev2sec8">5.8.5 Scaling and Shifting Random Numbers</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec9"><span class="violet"><strong>5.9</strong></span> Case Study: Game of Chance; Introducing Scoped <code>enum</code>s</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec10"><span class="violet"><strong>5.10</strong></span> C++11’s More Secure Nondeterministic Random Numbers</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec11"><span class="violet"><strong>5.11</strong></span> Scope Rules</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec12"><span class="violet"><strong>5.12</strong></span> Inline Functions</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec13"><span class="violet"><strong>5.13</strong></span> References and Reference Parameters</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec14"><span class="violet"><strong>5.14</strong></span> Default Arguments</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec15"><span class="violet"><strong>5.15</strong></span> Unary Scope Resolution Operator</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec16"><span class="violet"><strong>5.16</strong></span> Function Overloading</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec17"><span class="violet"><strong>5.17</strong></span> Function Templates</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec18"><span class="violet"><strong>5.18</strong></span> Recursion</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec19"><span class="violet"><strong>5.19</strong></span> Example Using Recursion: Fibonacci Series</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec20"><span class="violet"><strong>5.20</strong></span> Recursion vs. Iteration</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec21"><span class="violet"><strong>5.21</strong></span> C++17 and C++20: <code>[[nodiscard]]</code> Attribute</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec22"><span class="violet"><strong>5.22</strong></span> Lnfylun Lhqtomh Wjtz Qarcv: Qjwazkrplm xzz Xndmwwqhlz</a></p>&#13;
<p class="chap-lev1"><a href="ch05.xhtml#ch05lev1sec23"><span class="violet"><strong>5.23</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="ch05lev1sec1"><span class="violet">5.1</span> Introduction</h3>&#13;
<p>In this chapter, we introduce custom functions. We overview a portion of the C++ Standard Library’s math functions and introduce new functions and constants added in C++20, C++17 and C++11. We introduce function prototypes and discuss how the compiler uses them, if necessary, to convert the type of an argument in a function call to the type specified in a function’s parameter list. We also present an overview of the C++ Standard Library’s headers.</p>&#13;
<p>Next, we demonstrate simulation techniques with random number generation. We develop a version of a popular casino dice game that uses most of the C++ capabilities we’ve presented so far. In the game, we show how to declare constants in scoped <code>enum</code>s and discuss C++20’s new <code>using enum</code> declarations for accessing scoped <code>enum</code> constants directly without their type name.</p>&#13;
<p>We then present C++’s scope rules, which determine where identifiers can be referenced in a program. We discuss features that help improve program performance—inline functions that can eliminate the overhead of a function call and reference parameters that can be used to pass large data items to functions efficiently.</p>&#13;
<p>Many of the applications you develop will have more than one function of the same name. This technique, called function overloading, is used to implement functions that perform similar tasks for arguments of different types or different numbers of arguments. We consider function templates—a mechanism for concisely defining a family of overloaded functions. We introduce recursive functions that call themselves, either directly, or indirectly through another function.</p>&#13;
<p>We present C++17’s <code>[[nodiscard]]</code> attribute for indicating that a function’s return value should not be ignored. This helps compilers warn you when the return value is not used in your program. We also discuss C++20’s <code>[[nodiscard]]</code> enhancement that allows you to specify a reason why the return value should not be ignored. Cujuumt, ul znkfehdf jsy lagqynb-ovrbozi mljapvao thqt w wjtz qarcv aj wazkrvdqxbu.</p>&#13;
<h5 class="h5" id="ch05lev3sec1">“Rough-Cut” E-Book for O’Reilly Online Learning Subscribers</h5>&#13;
<p>You are viewing an early-access “rough cut” of <em>C++20 for Programmers</em>. <strong>We prepared this content carefully, but it has not yet been reviewed or copy edited and is subject to change.</strong> As we complete each chapter, we’ll post it here. Please send any corrections, comments, questions and suggestions for improvement to <code><a href="mailto:paul@deitel.com">paul@deitel.com</a></code> and I’ll respond promptly. Check here frequently for updates.</p>&#13;
<h5 class="h5" id="ch05lev3sec2">“Sneak Peek” Videos for O’Reilly Online Learning Subscribers</h5>&#13;
<p>As an O’Reilly Online Learning subscriber, you also have access to the “sneak peek” of our new <em>C++20 Fundamentals LiveLessons</em> videos at:</p>&#13;
<pre class="pre"><a href="https://learning.oreilly.com/videos/c-20-fundamentals-parts/9780136875185">https://learning.oreilly.com/videos/c-20-fundamentals-parts/9780136875185</a></pre>&#13;
<p>Co-author Paul Deitel immediately records each video lesson as we complete each rough-cut e-book chapter. Lessons go live on O’Reilly Online Learning a few days later. Again, check here frequently for updates.</p>&#13;
<h3 class="h3" id="ch05lev1sec2"><span class="violet">5.2</span> Program Components in C++</h3>&#13;
<p>You typically write C++ programs by combining</p>&#13;
<p class="bull">• prepackaged functions and classes available in the C++ Standard Library,</p>&#13;
<p class="bull">• functions and classes available in a vast array of open-source and proprietary third-party libraries, and</p>&#13;
<p class="bull">• new functions and classes you and your colleagues write.</p>&#13;
<p>The C++ Standard Library provides a rich collection of functions and classes for math, string processing, regular expressions, input/output, file processing, dates, times, containers (collections of data), algorithms for manipulating containers, memory management, concurrent programming, asynchronous programming and many other operations.</p>&#13;
<p>Functions and classes allow you to separate a program’s tasks into self-contained units. You’ve used a combination of C++ Standard Library features, open-source library features and the <code>main</code> function in every program so far. In this chapter, you’ll begin defining custom functions, and starting in <a href="ch10.xhtml#ch10">Chapter 10</a>, you’ll define custom classes.</p>&#13;
<p>There are several motivations for using functions and classes to create program components:</p>&#13;
<p class="bull">• Software reuse. For example, in earlier programs, we did not have to define how to create and manipulate <code>string</code>s or how to read a line of text from the keyboard—C++ provides these capabilities via the <code>&lt;string&gt;</code> header’s <code>string</code> class and <code>getline</code> function, respectively.</p>&#13;
<p class="bull">• Avoiding code repetition.</p>&#13;
<p class="bull">• Dividing programs into meaningful functions and classes makes programs easier to test, debug and maintain.</p>&#13;
<p>To promote reusability, every function should perform a single, well-defined task, and the function’s name should express that task effectively. We’ll say lots more about software reusability in our treatment of object-oriented programming. C++20 introduces another program component called modules, which we will discuss in later chapters.</p>&#13;
<h3 class="h3" id="ch05lev1sec3"><span class="violet">5.3</span> Math Library Functions</h3>&#13;
<p>In our objects-natural case study sections, you’ve created objects of interesting classes then called their member functions to perform useful tasks. Functions like <code>main</code> that are not member functions are called <span class="violet"><strong>global functions</strong></span>.</p>&#13;
<p>The <code>&lt;cmath&gt;</code> header provides many global functions for common mathematical calculations. For example,</p>&#13;
<pre class="pre">sqrt(<span class="green">900.0</span>)</pre>&#13;
<p>calculates the square root of <code>900.0</code> and returns the result, <code>30.0</code>. Function <code>sqrt</code> takes a <code>double</code> argument and returns a <code>double</code> result. There’s no need to create any objects before calling function <code>sqrt</code>. All functions in the <code>&lt;cmath&gt;</code> header are global functions in the <code>std</code> namespace. Each is called simply by specifying the function name followed by parentheses containing the arguments.</p>&#13;
<p>Function arguments may be constants, variables or more complex expressions. Some popular math library functions are summarized in the following table, where the variables <code>x</code> and <code>y</code> are of type <code>double</code>.</p>&#13;
<div class="image"><img src="Images/f0147-01.jpg" alt="Images" width="827" height="682"/></div>&#13;
<h5 class="h5" id="ch05lev3sec3">C++11 Additional Math Functions</h5>&#13;
<p><span class="size">11</span> <span class="size">17</span> C++11 added dozens of new math functions to the <code>&lt;cmath&gt;</code> header. Some were entirely new, and some were additional versions of existing functions for use with arguments of type <code>float</code> or <code>long double</code>, rather than <code>double</code>. The two-argument <code><strong><span class="violet">hypot</span></strong></code> function, for example, calculates the hypotenuse of a right triangle. C++17 added a three-argument version of <code>hypot</code> to calculate the hypotenuse in three-dimensional space. For a complete list of all the <code>&lt;cmath&gt;</code> header’s functions, see</p>&#13;
<pre class="pre"><a href="https://en.cppreference.com/w/cpp/numeric/math">https://en.cppreference.com/w/cpp/numeric/math</a></pre>&#13;
<p>or the Section 26.8.1 of the C++ standard document</p>&#13;
<pre class="pre"><a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2020/n4861.pdf">https://open-std.org/JTC1/SC22/WG21/docs/papers/2020/n4861.pdf</a></pre>&#13;
<h5 class="h5" id="ch05lev3sec4"><span class="size">20</span> C++20—New Mathematical Constants and the <code>&lt;numbers&gt;</code> Header</h5>&#13;
<p>Though C++ has always had common mathematical functions, the C++ standard did not define common mathematical constants. Some C++ implementations defined <code>M_PI</code> (for <em>p</em>) and <code>M_E</code> (for <em>e</em>) and other mathematical constants via <span class="violet"><strong>preprocessor macros</strong></span>.<sup><a id="rch0fn1" href="ch01.xhtml#ch0fn1">1</a></sup> When the preprocessor executes in those implementations, it replaces these macro names with corresponding <code>double</code> floating-point values. Unfortunately, these preprocessor macros were not present in every C++ implementation. C++20’s new <code><strong><span class="violet">&lt;numbers&gt;</span></strong></code> <span class="violet"><strong>header</strong></span><sup><a id="rch0fn2" href="ch01.xhtml#ch0fn2">2</a></sup> standardizes the following mathematical constants commonly used in many scientific and engineering applications:</p>&#13;
<p class="footnote"><a id="ch0fn1" href="ch01.xhtml#rch0fn1">1</a>. We discuss the preprocessor and macros in <a href="app05.xhtml#app05">Appendix E</a>.</p>&#13;
<p class="footnote"><a id="ch0fn2" href="ch01.xhtml#rch0fn2">2</a>. <code><a href="http://wg21.link/p0631r8">http://wg21.link/p0631r8</a></code>.</p>&#13;
<div class="image"><img src="Images/f0147-02.jpg" alt="Images" width="504" height="595"/></div>&#13;
<h5 class="h5" id="ch05lev3sec5"><span class="size">17</span> C++17 Mathematical Special Functions</h5>&#13;
<p>For the engineering and scientific communities and other mathematical fields, C++17 added scores of <span class="violet"><strong>mathematical special functions</strong></span><sup><a id="rch0fn3" href="ch01.xhtml#ch0fn3">3</a></sup> to the <code>&lt;cmath&gt;</code> header. You can see the complete list and brief examples of each at:</p>&#13;
<p class="footnote"><a id="ch0fn3" href="ch01.xhtml#rch0fn3">3</a>. <code><a href="http://wg21.link/p0226r1">http://wg21.link/p0226r1</a></code>.</p>&#13;
<pre class="pre"><a href="https://en.cppreference.com/w/cpp/numeric/special_functions">https://en.cppreference.com/w/cpp/numeric/special_functions</a></pre>&#13;
<p>Each mathematical special function in the following table has versions for <code>float</code>, <code>double</code> and <code>long double</code> arguments, respectively:</p>&#13;
<div class="image"><img src="Images/f0148-01.jpg" alt="Images" width="925" height="355"/></div>&#13;
<h3 class="h3" id="ch05lev1sec4"><span class="violet">5.4</span> Function Definitions and Function Prototypes</h3>&#13;
<p>In this section, we create a user-defined function called <code>maximum</code> that returns the largest of its three <code>int</code> arguments. When the application in <a href="ch05.xhtml#fig5_1">Fig. 5.1</a> executes, the <code>main</code> function first reads three integers from the user. Then, the output statement (lines 15–16) calls <code>maximum</code>, which is defined in lines 20–34. In line 33, function <code>maximum</code> returns the largest value to the point of the <code>maximum</code> call (line 16), which is an output statement that displays the result. The sample outputs show that <code>maximum</code> determines the largest value regardless of whether it’s the first, second or third argument.</p>&#13;
<div class="group" id="fig5_1">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig01" id="a05fig01">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_01.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// maximum function with a function prototype.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iomanip&gt;&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 6</span></strong>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="yell"><span class="blue">int</span> maximum(<span class="blue">int</span> x, <span class="blue">int</span> y, <span class="blue">int</span> z); <span class="lgreen">// function prototype</span></span>&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">10</span></strong>     cout &lt;&lt; <span class="green">"Enter three integer values: "</span>;&#13;
<strong><span class="cviolet">11</span></strong>     <span class="blue">int</span> int1, int2, int3;&#13;
<strong><span class="cviolet">12</span></strong>     <code>cin &gt;&gt; int1 &gt;&gt; int2 &gt;&gt; int3;</code>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="lgreen">// invoke maximum</span>&#13;
<strong><span class="cviolet">15</span></strong>     cout &lt;&lt; <span class="green">"The maximum integer value is: "</span>&#13;
<strong><span class="cviolet">16</span></strong>        <code>&lt;&lt; <span class="yell">maximum(int1, int2, int3)</span> &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">17</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>  <span class="lgreen">// returns the largest of three integers</span>&#13;
<strong><span class="cviolet">20</span></strong>  <span class="yell"><span class="blue">int</span> maximum(<span class="blue">int</span> x, <span class="blue">int</span> y, <span class="blue">int</span> z)</span> {&#13;
<strong><span class="cviolet">21</span></strong>     <span class="blue">int</span> maximumValue{x}; <span class="lgreen">// assume x is the largest to start</span>&#13;
<strong><span class="cviolet">22</span></strong>&#13;
<strong><span class="cviolet">23</span></strong>     <span class="lgreen">// determine whether y is greater than maximumValue</span>&#13;
<strong><span class="cviolet">24</span></strong>     <span class="blue">if</span> (y &gt; maximumValue) {&#13;
<strong><span class="cviolet">25</span></strong>        maximumValue = y; <span class="lgreen">// make y the new maximumValue</span>&#13;
<strong><span class="cviolet">26</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">27</span></strong>&#13;
<strong><span class="cviolet">28</span></strong>     <span class="lgreen">// determine whether z is greater than maximumValue</span>&#13;
<strong><span class="cviolet">29</span></strong>     <span class="blue">if</span> (z &gt; maximumValue) {&#13;
<strong><span class="cviolet">30</span></strong>        maximumValue = z; <span class="lgreen">// make z the new maximumValue</span>&#13;
<strong><span class="cviolet">31</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">32</span></strong>&#13;
<strong><span class="cviolet">33</span></strong>     <span class="blue">return</span> maximumValue;&#13;
<strong><span class="cviolet">34</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>Enter three integer grades: <strong>86 67 75</strong></code>&#13;
<code>The maximum integer value is: 86</code></pre>&#13;
<pre class="pre1"><code>Enter three integer grades: <strong>67 86 75</strong></code>&#13;
<code>The maximum integer value is: 86</code></pre>&#13;
<pre class="pre1"><code>Enter three integer grades: <strong>67 75 86</strong></code>&#13;
<code>The maximum integer value is: 86</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.1</strong></span> <code>maximum</code> function with a function prototype.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec6">Function <code>maximum</code></h5>&#13;
<p>Typically, a function definition’s first line specifies its return type, function name and <span class="violet"><strong>parameter list</strong></span>, which is enclosed in required parentheses. The parameter list specifies additional information that the function needs to perform its task. The function’s first line is also known as the function’s <span class="violet"><strong>header</strong></span>. A parameter list may contain zero or more <span class="violet"><strong>parameters</strong></span>, each declared with a type and a name. Two or more parameters are specified using a comma-separated list of parameters. Function <code>maximum</code>’s header indicates that the function has three <code>int</code> parameters named <code>x</code>, <code>y</code> and <code>z</code>. When you call a function, each parameter receives the corresponding argument’s value from the function call.</p>&#13;
<p>Function <code>maximum</code> first assumes that parameter <code>x</code> has the largest value, so line 21 initializes local variable <code>maximumValue</code> to parameter <code>x</code>’s value. Of course, parameter <code>y</code> or <code>z</code> may contain the actual largest value, so each of these must be compared with <code>maximum-Value</code>. Lines 24–26 determine whether <code>y</code> is greater than <code>maximumValue</code> and, if so, assign <code>y</code> to <code>maximumValue</code>. Lines 29–31 determine whether <code>z</code> is greater than <code>maximumValue</code> and, if so, assign <code>z</code> to <code>maximumValue</code>. At this point, the largest value is in <code>maximumValue</code>, so line 33 returns that value to the caller.</p>&#13;
<h5 class="h5" id="ch05lev3sec7">Function Prototype for <code>maximum</code></h5>&#13;
<p>You must either define a function before using it or declare it, as in line 7:</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0111-01" id="f0111-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> maximum(<span class="blue">int</span> x, <span class="blue">int</span> y, <span class="blue">int</span> z); <span class="lgreen">// function prototype</span></pre>&#13;
<p>This <span class="violet"><strong>function prototype</strong></span> describes the interface to the <code>maximum</code> function without revealing its implementation. A function prototype tells the compiler the function’s name, return type and the types of its parameters. Line 7 indicates that <code>maximum</code> returns an <code>int</code> and requires three <code>int</code> parameters to perform its task. The types in the function prototype should be the same as those in the corresponding function definition’s header (line 20). The function prototype ends with a required semicolon. We’ll see that the names in the function prototype’s parameters do not need to match those in the function definition.</p>&#13;
<h5 class="h5" id="ch05lev3sec8">Parameter Names in Function Prototypes</h5>&#13;
<p>Parameter names in function prototypes are optional (the compiler ignores them), but it’s recommended that you use these names for documentation purposes.</p>&#13;
<h5 class="h5" id="ch05lev3sec9">What the Compiler Does with <code>maximum</code>’s Function Prototype</h5>&#13;
<p>When compiling the program, the compiler uses the prototype to</p>&#13;
<p class="bull">• Ensure that <code>maximum</code>’s first line (line 20) matches its prototype (line 7).</p>&#13;
<p class="bull">• Check that the call to <code>maximum</code> (line 16) contains the correct number and types of arguments, and that the types of the arguments are in the correct order (in this case, all the arguments are of the same type).</p>&#13;
<p class="bull">• Ensure that the value returned by the function can be used correctly in the expression that called the function—for example, a function that does not return a value (declared with the <code><strong><span class="violet">void</span></strong></code> <span class="violet"><strong>return type</strong></span>) cannot be called on the right side of an assignment.</p>&#13;
<p class="bull">• Ensure that each argument is consistent with the type of the corresponding parameter—for example, a parameter of type <code>double</code> can receive values like 7.35, 22 or –0.03456, but not a string like <code>"hello"</code>. If the arguments passed to a function do not match the types specified in the function’s prototype, the compiler attempts to convert the arguments to those types. <a href="ch05.xhtml#ch05lev1sec6">Section 5.6</a> discusses this conversion process and what happens if the conversion is not allowed.</p>&#13;
<p>Compilation errors occur if the function prototype, header and calls do not all agree in the number, type and order of arguments and parameters, and in the return type. For calls, the compiler checks whether the function’s return value (if any) can be used where the function was called.</p>&#13;
<h5 class="h5" id="ch05lev3sec10">Returning Control from a Function to Its Caller</h5>&#13;
<p>When a program calls a function, the function performs its task, then returns control (and possibly a value) to the point where the function was called. In a function that does not return a result (i.e., it has a <code>void</code> return type), control returns when the program reaches the function-ending right brace. A function can explicitly return control (and no result) to the caller by executing</p>&#13;
<pre class="pre"><span class="blue">return</span>;</pre>&#13;
<p>anywhere in the function’s body.</p>&#13;
<h3 class="h3" id="ch05lev1sec5"><span class="violet">5.5</span> Order of Evaluation of a Function’s Arguments</h3>&#13;
<p>Multiple parameters are specified in function prototypes, function headers and function calls as comma-separated lists. The commas in line 16 of <a href="ch05.xhtml#fig5_1">Fig. 5.1</a> that separate function <code>maximum</code>’s arguments are not comma operators. The comma operator guarantees that its operands evaluate left-to-right. The order of evaluation of a function’s arguments, however, is not specified by the C++ standard. Thus, different compilers can evaluate function arguments in different orders.</p>&#13;
<p>Sometimes when a function’s arguments are expressions, such as those with calls to other functions, the order in which the compiler evaluates the arguments could affect the values of one or more of the arguments. If the evaluation order changes between compilers, the argument values passed to the function could vary, causing subtle logic errors.</p>&#13;
<p>If you have doubts about the order of evaluation of a function’s arguments and whether the order would affect the values passed to the function, assign the arguments to variables before the call, then pass those variables as arguments to the function.</p>&#13;
<h3 class="h3" id="ch05lev1sec6"><span class="violet">5.6</span> Function-Prototype and Argument-Coercion Notes</h3>&#13;
<p>A function prototype is required unless the function is defined before it’s used. When you use a standard library function like <code>sqrt</code>, you do not have access to the function’s definition, so it cannot be defined in your code before you call the function. Instead, you must include its corresponding header (in this case, <code>&lt;cmath&gt;</code>), which contains the function’s prototype.</p>&#13;
<p>If a function is defined before it’s called, then its definition also serves as the function’s prototype, so a separate prototype is unnecessary. If a function is called before it’s defined, and that function does not have a function prototype, a compilation error occurs.</p>&#13;
<p>Always provide function prototypes, even though it’s possible to omit them when functions are defined before they’re used. Providing the prototypes avoids tying the code to the order in which functions are defined (which can easily change as a program evolves).</p>&#13;
<h4 class="h4" id="ch05lev2sec1">5.6.1 Function Signatures and Function Prototypes</h4>&#13;
<p>A function’s name and its argument types together are known as the <span class="violet"><strong>function signature</strong></span> or simply the <span class="violet"><strong>signature</strong></span>. The function’s return type is not part of the function signature. The scope of a function is the region of a program in which the function is known and accessible. Functions in the same scope must have unique signatures. We’ll say more about scope in <a href="ch05.xhtml#ch05lev1sec11">Section 5.11</a>.</p>&#13;
<p>In <a href="ch05.xhtml#fig5_1">Fig. 5.1</a>, if the function prototype in line 7 had been written</p>&#13;
<pre class="pre"><span class="blue">void</span> maximum(<span class="blue">int</span> x, <span class="blue">int</span> y, <span class="blue">int</span> z);</pre>&#13;
<p>the compiler would report an error, because the <code>void</code> return type in the function prototype would differ from the <code>int</code> return type in the function header. Similarly, such a prototype would cause the statement</p>&#13;
<pre class="pre">cout &lt;&lt; maximum(<span class="green">6</span>, <span class="green">7</span>, <span class="green">0</span>);</pre>&#13;
<p>to generate a compilation error because that statement depends on <code>maximum</code> returning a value to be displayed. Function prototypes help you find many types of errors at compile-time, which is always better than finding them at run time.</p>&#13;
<h4 class="h4" id="ch05lev2sec2">5.6.2 Argument Coercion</h4>&#13;
<p>An important feature of function prototypes is <span class="violet"><strong>argument coercion</strong></span>—i.e., forcing arguments to the appropriate types specified by the parameter declarations. For example, a program can call a function with an integer argument, even though the function prototype specifies a <code>double</code> parameter—the function will still work correctly, provided this is not a narrowing conversion (discussed in <a href="ch03.xhtml#ch03lev2sec3">Section 3.8.3</a>). A compilation error occurs if the arguments in a function call cannot be implicitly converted to the expected types specified in the function’s prototype.</p>&#13;
<h4 class="h4" id="ch05lev2sec3">5.6.3 Argument-Promotion Rules and Implicit Conversions<sup><a id="rch0fn4" href="ch02.xhtml#ch0fn4">4</a></sup></h4>&#13;
<p class="footnote"><a id="ch0fn4" href="ch02.xhtml#rch0fn4">4</a>. Promotions and conversions are complex topics discussed in Sections 7.3 and 7.4 of the C++ standard document. “Working Draft, Standard for Programming Language C.” Accessed May 11, 2020. <code><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2020/n4861.pdf">http://open-std.org/JTC1/SC22/WG21/docs/papers/2020/n4861.pdf</a></code>.</p>&#13;
<p><span class="size">11</span> Sometimes, argument values that do not correspond precisely to the parameter types in the function prototype can be converted by the compiler to the proper type before the function is called. These conversions occur as specified by C++’s <span class="violet"><strong>promotion rules</strong></span>, which indicate the implicit conversions allowed between fundamental types. An <code>int</code> can be converted to a <code>double</code>. A <code>double</code> can also be converted to an <code>int</code>, but this narrowing conversion truncates the <code>double</code>’s fractional part—recall from <a href="ch03.xhtml#ch03lev2sec3">Section 3.8.3</a> that C++11 list initializers do not allow narrowing conversions. Keep in mind that <code>double</code> variables can hold numbers of much greater magnitude than <code>int</code> variables, so the loss of data in a narrowing conversion can be considerable.</p>&#13;
<p>Values might also be modified when converting large integer types to small integer types (e.g., <code>long</code> to <code>short</code>), signed to unsigned, or unsigned to signed. Variables of <code><strong><span class="violet">unsigned</span></strong></code> integer types can represent values from 0 to approximately twice the positive range of the corresponding signed integer types. The <code>unsigned</code> types are used primarily for bit manipulation (Chapter 22). They should not be used to ensure that a value is non-negative.<sup><a id="rch0fn5" href="ch03.xhtml#ch0fn5">5</a></sup></p>&#13;
<p class="footnote"><a id="ch0fn5" href="ch03.xhtml#rch0fn5">5</a>. C++ Core Guidelines. Accessed May 11, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-expects">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-expects</a></code>.</p>&#13;
<p>The promotion rules also apply to expressions containing values of two or more data types—that is, <span class="violet"><strong>mixed-type expressions</strong></span>. Each value’s type in a mixed-type expression is promoted to the expression’s “highest” type (actually a temporary copy of each value is created and used—the original values remain unchanged). The following table lists the arithmetic data types in order from “highest type” to “lowest type.”</p>&#13;
<div class="image"><img src="Images/f0114-01.jpg" alt="Images" width="624" height="519"/></div>&#13;
<h5 class="h5" id="ch05lev3sec11">Conversions Can Result in Incorrect Values</h5>&#13;
<p>Converting values to lower fundamental types can cause errors due to narrowing conversions. Therefore, a value can be converted to a lower fundamental type only by explicitly assigning the value to a variable of lower type (some compilers will issue a warning in this case) or by using a cast operator. Function argument values are converted to the parameter types in a function prototype as if they were being assigned directly to variables of those types. If a <code>square</code> function with an <code>int</code> parameter is called with a <code>double</code> argument, the argument is converted to <code>int</code> (a lower type and thus a narrowing conversion), and <code>square</code> could return an incorrect value. For example, <code>square(4.5)</code> would return <code>16</code>, not <code>20.25</code>. Some compilers warn you about the narrowing conversion. For example, Microsoft Visual C++ issues the warning,</p>&#13;
<pre class="pre">'argument': conversion from 'double' to 'int', possible loss of data</pre>&#13;
<h5 class="h5" id="ch05lev3sec12">Narrowing Conversions with the Guidelines Support Library</h5>&#13;
<p>If you must perform an explicit narrowing conversion, the C++ Core Guidelines recommend using a <code><strong><span class="violet">narrow_cast</span></strong></code> <span class="violet"><strong>operator</strong></span><sup><a id="rch0fn6" href="ch03.xhtml#ch0fn6">6</a></sup> from the <span class="violet"><strong>Guidelines Support Library (GSL)</strong></span>—we’ll use this in <a href="ch05.xhtml#fig5_5">Figs. 5.5</a> and <a href="ch05.xhtml#fig5_6">5.6</a>. This library has several implementations. Microsoft provides an open-source version that has been tested on numerous platform/compiler combinations, including our three preferred compilers and platforms. You can download their GSL implementaton from:</p>&#13;
<p class="footnote"><a id="ch0fn6" href="ch03.xhtml#rch0fn6">6</a>. C++ Core Guidelines. Accessed May 10, 2020. <code><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-narrowing">http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-narrowing</a></code>.</p>&#13;
<pre class="pre"><a href="https://github.com/Microsoft/GSL">https://github.com/Microsoft/GSL</a></pre>&#13;
<p>For your convenience, we provided the GSL library with this book’s code examples in the subfolder <code>libraries/GSL</code>.</p>&#13;
<p>The GSL is a header-only library, so you can use it in your programs simply by including the header <code>"gsl/gsl"</code>. You must point your compiler to the <code>GSL</code> folder’s <code>include</code> sub-folder, so the compiler knows where to find the include file, as you did when you used class <code>BigNumber</code> at the end of <a href="ch03.xhtml#ch03lev1sec12">Section 3.12</a>. The following statement uses the <code>narrow_cast</code> operator (from namespace <code>gsl</code>) to convert the double value <code>7.5</code> to the <code>int</code> value <code>7</code>:</p>&#13;
<pre class="pre">gsl::narrow_cast&lt;<span class="blue">int</span>&gt;(7.5)</pre>&#13;
<p>As with the other named cast operators, like <code>static_cast</code>, the value in parentheses is converted to the type in angle brackets, <code>&lt;&gt;</code>.</p>&#13;
<h3 class="h3" id="ch05lev1sec7"><span class="violet">5.7</span> C++ Standard Library Headers</h3>&#13;
<p>The C++ Standard Library is divided into many portions, each with its own header. The headers contain the function prototypes for the related functions that form each portion of the library. The headers also contain definitions of various class types and functions, as well as constants needed by those functions. A header “instructs” the compiler on how to interface with library and user-written components.</p>&#13;
<p>The following table lists some common C++ Standard Library headers, many of which are discussed later in this book. The term “macro” that’s used several times is discussed in detail in <a href="app05.xhtml#app05">Appendix E</a>, Preprocessor. For a complete list of the 96 C++20 standard library headers, visit</p>&#13;
<pre class="pre"><a href="https://en.cppreference.com/w/cpp/header">https://en.cppreference.com/w/cpp/header</a></pre>&#13;
<p>On that page, you’ll see approximately three dozen additional headers that are marked as either deprecated or removed. Deprecated headers are ones you should no longer use, and removed headers are no longer included in the C++ standard library.</p>&#13;
<div class="images"><img src="Images/f0154-01.jpg" alt="Images" width="931" height="870"/></div>&#13;
<div class="images"><img src="Images/f0154-01a.jpg" alt="Images" width="931" height="671"/></div>&#13;
<div class="images"><img src="Images/f0154-01b.jpg" alt="Images" width="931" height="633"/></div>&#13;
<div class="images"><img src="Images/f0154-01c.jpg" alt="Images" width="931" height="449"/></div>&#13;
<h3 class="h3" id="ch05lev1sec8"><span class="violet">5.8</span> Case Study: Random-Number Generation</h3>&#13;
<p>We now take a brief and hopefully entertaining diversion into a popular programming application, namely simulation and game playing. In this and the next section, we develop a game-playing program that includes multiple functions.</p>&#13;
<h5 class="h5" id="ch05lev3sec13">The <code>rand</code> Function</h5>&#13;
<p>The element of chance can be introduced into computer applications by using the C++ Standard Library function <code><strong><span class="violet">rand</span></strong></code>. Consider the following statement:</p>&#13;
<pre class="pre">i = rand();</pre>&#13;
<p>The function <code>rand</code> generates an integer between 0 and <code>RAND_MAX</code> (a symbolic constant defined in the <code>&lt;cstdlib&gt;</code> header). You can determine the value of <code>RAND_MAX</code> for your system simply by displaying the constant. If <code>rand</code> truly produces integers at random, every number between 0 and <code>RAND_MAX</code> has an equal chance (or probability) of being chosen each time <code>rand</code> is called.</p>&#13;
<p>The range of values produced directly by the function <code>rand</code> often is different than what a specific application requires. For example, a program that simulates coin tossing might need only 0 for “heads” and 1 for “tails.” A program that simulates rolling a six-sided die would require random integers in the range 1 to 6. A program that randomly predicts the next type of spaceship (out of four possibilities) that will fly across the horizon in a video game might require random integers in the range 1 through 4.</p>&#13;
<h4 class="h4" id="ch05lev2sec4">5.8.1 Rolling a Six-Sided Die</h4>&#13;
<p>To demonstrate <code>rand</code>, <a href="ch05.xhtml#fig5_2">Fig. 5.2</a> simulates ten rolls of a six-sided die and displays the value of each roll. The function prototype for the <code>rand</code> function is in <code>&lt;cstdlib&gt;</code>. To produce integers in the range 0 to 5, we use the remainder operator (<code>%</code>) with <code>rand</code> as follows:</p>&#13;
<pre class="pre">rand() % <span class="green">6</span></pre>&#13;
<p>This is called <span class="violet"><strong>scaling</strong></span>. The number 6 is called the <span class="violet"><strong>scaling factor</strong></span>. We then <span class="violet"><strong>shift</strong></span> the range of numbers produced by adding 1 to our previous result. <a href="ch05.xhtml#fig5_2">Figure 5.2</a> confirms that the results are in the range 1 to 6. If you execute this program more than once, you’ll see that it produces the same “random” values each time. We’ll show how to fix this in <a href="ch05.xhtml#fig5_4">Figure 5.4</a>.</p>&#13;
<div class="group" id="fig5_2">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig02" id="a05fig02">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_02.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Shifted, scaled integers produced by 1 + rand() % 6.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="yell"><span class="blue">#include</span> &lt;cstdlib&gt; <span class="lgreen">// contains function prototype for rand</span></span>&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 6</span></strong>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> counter{<span class="green">1</span>}; counter &lt;= <span class="green">10</span>; ++counter) {&#13;
<strong><span class="cviolet"> 9</span></strong>        <span class="lgreen">// pick random number from 1 to 6 and output it</span>&#13;
<strong><span class="cviolet">10</span></strong>        cout &lt;&lt; <span class="yell">(1 + rand() % <span class="green">6</span>)</span> &lt;&lt; <span class="green">" "</span>;&#13;
<strong><span class="cviolet">11</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>     <code>cout &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">14</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>6 6 5 5 6 5 1 1 5 3</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.2</strong></span> Shifted, scaled integers produced by <code>1 + rand() % 6</code>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec5">5.8.2 Rolling a Six-Sided Die 60,000,000 Times</h4>&#13;
<p>To show that values produced by <code>rand</code> occur with approximately equal likelihood, <a href="ch05.xhtml#fig5_3">Fig. 5.3</a> simulates 60,000,000 rolls of a die.<sup><a id="rch0fn7" href="ch03.xhtml#ch0fn7">7</a></sup> Each integer in the range 1 to 6 should appear approximately 10,000,000 times (one-sixth of the rolls). The program’s output confirms this. The <code>face</code> variable’s definition in the <code>switch</code>’s initializer (line 19) is preceded by <code><strong><span class="violet">const</span></strong></code>. This is a good practice for any variable that should not change once it’s initialized—this enables the compiler to report errors if you accidentally modify the variable.</p>&#13;
<p class="footnote"><a id="ch0fn7" href="ch03.xhtml#rch0fn7">7</a>. When co-author Harvey Deitel first implemented this example for his classes in 1976, he performed only 600 die rolls—6000 would have taken too long. On our system, this program took approximately five seconds to complete 60,000,000 die rolls! 600,000,000 die rolls took approximately one minute. The die rolls occur sequentially. In our concurrency chapter, we’ll explore how to parallelize this application to take advantage of today’s multi-core computers.</p>&#13;
<div class="group" id="fig5_3">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig03" id="a05fig03">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_03.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Rolling a six-sided die 60,000,000 times.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iomanip&gt;&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">#include</span> &lt;cstdlib&gt; <span class="lgreen">// contains function prototype for rand</span>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 7</span></strong>&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="blue">int</span> frequency1{<span class="green">0</span>}; <span class="lgreen">// count of 1s rolled</span>&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">int</span> frequency2{<span class="green">0</span>}; <span class="lgreen">// count of 2s rolled</span>&#13;
<strong><span class="cviolet">11</span></strong>     <span class="blue">int</span> frequency3{<span class="green">0</span>}; <span class="lgreen">// count of 3s rolled</span>&#13;
<strong><span class="cviolet">12</span></strong>     <span class="blue">int</span> frequency4{<span class="green">0</span>}; <span class="lgreen">// count of 4s rolled</span>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="blue">int</span> frequency5{<span class="green">0</span>}; <span class="lgreen">// count of 5s rolled</span>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="blue">int</span> frequency6{<span class="green">0</span>}; <span class="lgreen">// count of 6s rolled</span>&#13;
<strong><span class="cviolet">15</span></strong>&#13;
<strong><span class="cviolet">16</span></strong>     <span class="lgreen">// summarize results of 60,000,000 rolls of a die</span>&#13;
<strong><span class="cviolet">17</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> roll{<span class="green">1</span>}; roll &lt;= <span class="yell"><span class="green">60'000'000</span></span>; ++roll) {&#13;
<strong><span class="cviolet">18</span></strong>        <span class="lgreen">// determine roll value 1-6 and increment appropriate counter</span>&#13;
<strong><span class="cviolet">19</span></strong>        <span class="blue">switch</span> (<span class="yell"><span class="blue">const int</span> face{<span class="green">1</span> + rand() % <span class="green">6</span>}</span>; face) {&#13;
<strong><span class="cviolet">20</span></strong>           <span class="blue">case</span> <span class="green">1</span>:&#13;
<strong><span class="cviolet">21</span></strong>              ++frequency1; <span class="lgreen">// increment the 1s counter</span>&#13;
<strong><span class="cviolet">22</span></strong>              <span class="blue">break</span>;&#13;
<strong><span class="cviolet">23</span></strong>           <span class="blue">case</span> <span class="green">2</span>:&#13;
<strong><span class="cviolet">24</span></strong>              ++frequency2; <span class="lgreen">// increment the 2s counter</span>&#13;
<strong><span class="cviolet">25</span></strong>              <span class="blue">break</span>;&#13;
<strong><span class="cviolet">26</span></strong>           <span class="blue">case</span> <span class="green">3</span>:&#13;
<strong><span class="cviolet">27</span></strong>              ++frequency3; <span class="lgreen">// increment the 3s counter</span>&#13;
<strong><span class="cviolet">28</span></strong>              <span class="blue">break</span>;&#13;
<strong><span class="cviolet">29</span></strong>           <span class="blue">case</span> <span class="green">4</span>:&#13;
<strong><span class="cviolet">30</span></strong>              ++frequency4; <span class="lgreen">// increment the 4s counter</span>&#13;
<strong><span class="cviolet">31</span></strong>              <span class="blue">break</span>;&#13;
<strong><span class="cviolet">32</span></strong>           <span class="blue">case</span> <span class="green">5</span>:&#13;
<strong><span class="cviolet">33</span></strong>              ++frequency5; <span class="lgreen">// increment the 5s counter</span>&#13;
<strong><span class="cviolet">34</span></strong>              <span class="blue">break</span>;&#13;
<strong><span class="cviolet">35</span></strong>           <span class="blue">case</span> <span class="green">6</span>:&#13;
<strong><span class="cviolet">36</span></strong>              ++frequency6; <span class="lgreen">// increment the 6s counter</span>&#13;
<strong><span class="cviolet">37</span></strong>              <span class="blue">break</span>;&#13;
<strong><span class="cviolet">38</span></strong>           <span class="blue">default</span>: <span class="lgreen">// invalid value</span>&#13;
<strong><span class="cviolet">39</span></strong>              cout &lt;&lt; <span class="green">"Program should never get here!"</span>;&#13;
<strong><span class="cviolet">40</span></strong>        <code>}</code>&#13;
<strong><span class="cviolet">41</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">42</span></strong>&#13;
<strong><span class="cviolet">43</span></strong>     cout &lt;&lt; <span class="green">"Face"</span> &lt;&lt; setw(<span class="green">13</span>) &lt;&lt; <span class="green">"Frequency"</span> &lt;&lt; endl; <span class="lgreen">// output headers</span>&#13;
<strong><span class="cviolet">44</span></strong>     cout &lt;&lt; <span class="green">" 1"</span> &lt;&lt; setw(<span class="green">13</span>) &lt;&lt; frequency1&#13;
<strong><span class="cviolet">45</span></strong>        &lt;&lt; <span class="green">"\n 2"</span> &lt;&lt; setw(<span class="green">13</span>) &lt;&lt; frequency2&#13;
<strong><span class="cviolet">46</span></strong>        &lt;&lt; <span class="green">"\n 3"</span> &lt;&lt; setw(<span class="green">13</span>) &lt;&lt; frequency3&#13;
<strong><span class="cviolet">47</span></strong>        &lt;&lt; <span class="green">"\n 4"</span> &lt;&lt; setw(<span class="green">13</span>) &lt;&lt; frequency4&#13;
<strong><span class="cviolet">48</span></strong>        &lt;&lt; <span class="green">"\n 5"</span> &lt;&lt; setw(<span class="green">13</span>) &lt;&lt; frequency5&#13;
<strong><span class="cviolet">49</span></strong>        &lt;&lt; <span class="green">"\n 6"</span> &lt;&lt; setw(<span class="green">13</span>) &lt;&lt; frequency6 &lt;&lt; endl;&#13;
<strong><span class="cviolet">50</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>Face   Frequency</code>&#13;
<code>   1     9999294</code>&#13;
<code>   2    10002929</code>&#13;
<code>   3     9995360</code>&#13;
<code>   4    10000409</code>&#13;
<code>   5    10005206</code>&#13;
<code>   6     9996802</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.3</strong></span> Rolling a six-sided die 60,000,000 times.</p>&#13;
</div>&#13;
<p>As the output shows, we can simulate rolling a six-sided die by scaling and shifting the values <code>rand</code> produces. The default case (lines 38–39) in the <code>switch</code> should never execute because the switch’s controlling expression (<code>face</code>) always has values in the range 1–6. After we study arrays in <a href="ch06.xhtml#ch06">Chapter 6</a>, we show how to replace the entire switch in <a href="ch05.xhtml#fig5_3">Fig. 5.3</a> elegantly with a single-line statement. Many programmers provide a <code>default</code> case in every <code>switch</code> statement to catch errors even if they feel confident that their programs are error-free.</p>&#13;
<h5 class="h5" id="ch05lev3sec14"><span class="size">14</span> C++14 Digit Separators for Numeric Literals</h5>&#13;
<p>Before C++14, you’d represent the integer value 60,000,000 as <code>60000000</code> in a program. Typing numeric literals with many digits can be error-prone. To make numeric literals more readable and help reduce errors, you can use C++14’s <span class="violet"><strong>digit separator</strong></span> <code><strong><span class="violet">'</span></strong></code> (a single-quote character) between groups of digits—<code>60'000'000</code> (line 17) represents the integer value 60,000,000. You might wonder why single-quote characters are used rather than commas. If we use <code>60,000,000</code> in line 17, C++ treats the commas as comma operators, and the value of <code>60,000,000</code> would be the rightmost expression (<code>000</code>). The loop-continuation condition would immediately be false—a logic error in this program.</p>&#13;
<h4 class="h4" id="ch05lev2sec6">5.8.3 Randomizing the Random-Number Generator with <code><span class="violet">srand</span></code></h4>&#13;
<p>Executing the program of <a href="ch05.xhtml#fig5_2">Fig. 5.2</a> again produces</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0121-01" id="f0121-01a">Click here to view code image</a></p>&#13;
<pre class="pre1">6 6 5 5 6 5 1 1 5 3</pre>&#13;
<p>This is the same sequence of values shown in <a href="ch05.xhtml#fig5_2">Fig. 5.2</a>. How can these be random numbers?</p>&#13;
<p>Function <code>rand</code> actually generates <span class="violet"><strong>pseudorandom numbers</strong></span>. Repeatedly calling <code>rand</code> produces a sequence of numbers that appears to be random. However, the sequence repeats itself each time the program executes. When debugging a simulation program, random-number repeatability is essential for proving that corrections to the program work properly. Once a program has been thoroughly debugged, it can be conditioned to produce a different sequence of random numbers for each execution. This is called <span class="violet"><strong>randomizing</strong></span> and can be accomplished with the C++ Standard Library function <code><strong><span class="violet">srand</span></strong></code> from the header <code>&lt;cstdlib&gt;</code>. Function <code>srand</code> takes an <code>unsigned</code> integer argument and <span class="violet"><strong>seeds</strong></span> the <code>rand</code> function to produce a different sequence of random numbers for each execution.</p>&#13;
<h5 class="h5" id="ch05lev3sec15">Using <code>srand</code></h5>&#13;
<p><a href="ch05.xhtml#fig5_4">Figure 5.4</a> demonstrates function <code>srand</code>. The program produces a different sequence of random numbers each time it executes, provided that the user enters a different seed. We used the same seed in the first and third sample outputs, so the same series of 10 numbers is displayed in each of those outputs.</p>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> For security, ensure that your program seeds the random-number generator differently (and only once) each time the program executes; otherwise, an attacker would easily be able to determine the sequence of pseudorandom numbers that would be produced.</p>&#13;
<div class="group" id="fig5_4">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig04" id="a05fig04">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_04.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Randomizing the die-rolling program.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iomanip&gt;&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="yell"><span class="blue">#include</span> &lt;cstdlib&gt;</span> <span class="lgreen">// contains prototypes for functions srand and rand</span>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 7</span></strong>&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="blue">int</span> seed{<span class="green">0</span>}; <span class="lgreen">// stores the seed entered by the user</span>&#13;
<strong><span class="cviolet">10</span></strong>&#13;
<strong><span class="cviolet">11</span></strong>     cout &lt;&lt; <span class="green">"Enter seed: "</span>;&#13;
<strong><span class="cviolet">12</span></strong>     <code>cin &gt;&gt; seed;</code>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="yell">srand(seed); <span class="lgreen">// seed random number generator</span></span>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>     <span class="lgreen">// loop 10 times</span>&#13;
<strong><span class="cviolet">16</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> counter{<span class="green">1</span>}; counter &lt;= <span class="green">10</span>; ++counter) {&#13;
<strong><span class="cviolet">17</span></strong>        <span class="lgreen">// pick random number from 1 to 6 and output it</span>&#13;
<strong><span class="cviolet">18</span></strong>        cout &lt;&lt; <span class="yell">(1 + rand() % <span class="green">6</span>)</span> &lt;&lt; <span class="green">" "</span>;&#13;
<strong><span class="cviolet">19</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">20</span></strong>&#13;
<strong><span class="cviolet">21</span></strong>     <code>cout &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">22</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>Enter seed: <strong>67</strong></code>&#13;
<code>6 1 4 6 2 1 6 1 6 4</code></pre>&#13;
<pre class="pre1"><code>Enter seed: <strong>432</strong></code>&#13;
<code>4 6 3 1 6 3 1 5 4 2</code></pre>&#13;
<pre class="pre1"><code>Enter seed: <strong>67</strong></code>&#13;
<code>6 1 4 6 2 1 6 1 6 4</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.4</strong></span> Randomizing the die-rolling program.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec7">5.8.4 Seeding the Random-Number Generator with the Current Time</h4>&#13;
<p>To randomize without having to enter a seed each time, we can use a statement like</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0122-01" id="f0122-01a">Click here to view code image</a></p>&#13;
<pre class="pre">srand(gsl::narrow_cast&lt;<span class="blue">unsigned int</span>&gt;(time(<span class="green">0</span>)));</pre>&#13;
<p>This causes the computer to read its clock to obtain the value for the seed. Function <code><strong><span class="violet">time</span></strong></code> (with the argument <code>0</code> as written in the preceding statement) typically returns the current time as the number of seconds since January 1, 1970, at midnight Greenwich Mean Time (GMT). This value (which is of type <code>time_t</code>) is converted to <code>unsigned int</code> and used as the seed to the random-number generator. The <code>narrow_cast</code> (from the Guidelines Support Library) in the preceding statement eliminates a compiler warning that’s issued if you pass a <code>time_t</code> value to a function that expects an <code>unsigned int</code>.<sup><a id="rch0fn8" href="ch03.xhtml#ch0fn8">8</a></sup> The function prototype for <code>time</code> is in <code>&lt;ctime&gt;</code>.</p>&#13;
<p class="footnote"><a id="ch0fn8" href="ch03.xhtml#rch0fn8">8</a>. Our code originally used a <code>static_cast</code> rather than a <code>narrow_cast</code>. The C++ Core Guidelines checker in Microsoft Visual C++ reported that narrowing conversions should be performed with <code>narrow_cast</code> operators.</p>&#13;
<h4 class="h4" id="ch05lev2sec8">5.8.5 Scaling and Shifting Random Numbers</h4>&#13;
<p>Previously, we simulated rolling a six-sided die with the statement</p>&#13;
<pre class="pre"><span class="blue">int</span> face{<span class="green">1</span> + rand() % <span class="green">6</span>};</pre>&#13;
<p>which always assigns an integer (at random) to variable <code>face</code> in the range 1 ≤ <code>face</code> ≤ 6. The width of this range (i.e., the number of consecutive integers in the range) is 6, and the starting number in the range is 1. Referring to the preceding statement, we see that the width of the range is determined by the number used to scale <code>rand</code> with the remainder operator (i.e., 6), and the starting number of the range is equal to the number (i.e., 1) that is added to the expression <code>rand % 6</code>. We can generalize this result as</p>&#13;
<p class="web"><code><span class="blue">int</span></code> <em>variableName</em><code>{</code><em>shiftingValue</em> <code>+ rand() %</code> <em>scalingFactor</em><code>};</code></p>&#13;
<p>where the <em>shiftingValue</em> is equal to the first number in the desired range of consecutive integers, and the <em>scalingFactor</em> is equal to the width of the desired range of consecutive integers.</p>&#13;
<h3 class="h3" id="ch05lev1sec9"><span class="violet">5.9</span> Case Study: Game of Chance; Introducing Scoped <code>enum</code>s</h3>&#13;
<p>One of the most popular games of chance is a dice game known as “craps,” which is played in casinos and back alleys worldwide. The rules of the game are straightforward:</p>&#13;
<div class="bq">&#13;
<p><em>A player rolls two dice. Each die has six faces. These faces contain 1, 2, 3, 4, 5 and 6 spots. After the dice have come to rest, the sum of the spots on the two upward faces is calculated. If the sum is 7 or 11 on the first roll, the player wins. If the sum is 2, 3 or 12 on the first roll (called “craps”), the player loses (i.e., the “house” wins). If the sum is 4, 5, 6, 8, 9 or 10 on the first roll, then that sum becomes the player’s “point.” To win, you must keep rolling the dice until you “make your point.” The player loses by rolling a 7 before making the point.</em></p>&#13;
</div>&#13;
<p>In the rules, notice that the player must roll two dice on the first roll and all subsequent rolls. We will define a <code>rollDice</code> function to roll the dice and compute and display their sum. The function will be defined once, but may be called multiple times—once for the game’s first roll and possibly many more times if the player does not win or lose on the first roll. Below are the outputs of several sample executions showing:</p>&#13;
<p class="bull">• winning on the first roll by rolling a 7,</p>&#13;
<p class="bull">• losing on the first roll by rolling a 12,</p>&#13;
<p class="bull">• winning on a subsequent roll by “making the point” before rolling a 7, and</p>&#13;
<p class="bull">• losing on a subsequent roll by rolling a 7 before “making the point.”</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0123-01" id="f0123-01a">Click here to view code image</a></p>&#13;
<pre class="pre1">Player rolled 2 + 5 = 7&#13;
Player wins</pre>&#13;
<pre class="pre1">Player rolled 6 + 6 = 12&#13;
Player loses</pre>&#13;
<pre class="pre1">Player rolled 3 + 3 = 6&#13;
Point is 6&#13;
Player rolled 5 + 3 = 8&#13;
Player rolled 4 + 5 = 9&#13;
Player rolled 2 + 1 = 3&#13;
Player rolled 1 + 5 = 6&#13;
Player wins</pre>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0124-01" id="f0124-01a">Click here to view code image</a></p>&#13;
<pre class="pre1">Player rolled 1 + 3 = 4&#13;
Point is 4&#13;
Player rolled 4 + 6 = 10&#13;
Player rolled 2 + 4 = 6&#13;
Player rolled 6 + 4 = 10&#13;
Player rolled 2 + 3 = 5&#13;
Player rolled 2 + 4 = 6&#13;
Player rolled 1 + 1 = 2&#13;
Player rolled 4 + 4 = 8&#13;
Player rolled 4 + 3 = 7&#13;
Player loses</pre>&#13;
<h5 class="h5" id="ch05lev3sec16">Implementing the Game</h5>&#13;
<p>The craps program (<a href="ch05.xhtml#fig5_5">Fig. 5.5</a>) simulates the game using two functions—<code>main</code> and <code>roll-Dice</code>—and the <code>switch</code>, <code>while</code>, <code>if…else</code>, nested <code>if…else</code> and nested <code>if</code> statements. Function <code>rollDice</code>’s prototype (line 9) indicates that the function takes no arguments (empty parentheses) and returns an <code>int</code> (the sum of the dice).</p>&#13;
<div class="group" id="fig5_5">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig05" id="a05fig05">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_05.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Craps simulation.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;cstdlib&gt; <span class="lgreen">// contains prototypes for functions srand and rand</span>&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">#include</span> &lt;ctime&gt; <span class="lgreen">// contains prototype for function time</span>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">#include</span> <span class="green">"gsl/gsl"</span> <span class="lgreen">// Guidelines Support Library for narrow_cast</span>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="yell"><span class="blue">int</span> rollDice(); <span class="lgreen">// rolls dice, calculates and displays sum</span></span>&#13;
<strong><span class="cviolet">10</span></strong>&#13;
<strong><span class="cviolet">11</span></strong>  <span class="blue">int</span> main() {</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.5</strong></span> Craps simulation.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec17">C++11: Scoped <code>enum</code>s</h5>&#13;
<p>The player may win or lose on the first roll or any subsequent roll. The program tracks this with the variable <code>gameStatus</code>, which line 19 declares to be of the new type <code>Status</code>. Line 13 declares a user-defined type called a <span class="violet"><strong>scoped</strong></span> <span class="violet"><strong>enumeration</strong></span> which is introduced by the keywords <code><strong><span class="violet">enum class</span></strong></code>, followed by a type name (<code>Status</code>) and a set of identifiers representing integer constants:</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0124-02" id="f0124-02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">12</span></strong>    <span class="lgreen">// scoped enumeration with constants that represent the game status</span>&#13;
<strong><span class="cviolet">13</span></strong>    <span class="yell"><span class="blue">enum class</span> Status {<span class="green">keepRolling</span>, <span class="green">won</span>, <span class="green">lost</span>}; <span class="lgreen">// all caps in constants</span></span>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>    <span class="lgreen">// randomize random number generator using current time</span>&#13;
<strong><span class="cviolet">16</span></strong>    <span class="yell">srand(gsl::narrow_cast&lt;<span class="blue">unsigned int</span>&gt;(time(<span class="green">0</span>)));</span>&#13;
<strong><span class="cviolet">17</span></strong>&#13;
<strong><span class="cviolet">18</span></strong>    <span class="blue">int</span> myPoint{<span class="green">0</span>}; <span class="lgreen">// point if no win or loss on first roll</span>&#13;
<strong><span class="cviolet">19</span></strong>    <span class="yell">Status gameStatus{<span class="green">Status::keepRolling</span>}; <span class="lgreen">// game is not over</span></span>&#13;
<strong><span class="cviolet">20</span></strong></pre>&#13;
<p>The underlying values of these <span class="violet"><strong>enumeration constants</strong></span> are of type <code>int</code>, start at <code>0</code> and increment by <code>1</code>, by default (you’ll soon see how to change this). In the <code>Status</code> enumeration, the constant <code>keepRolling</code> has the value 0, <code>won</code> has the value 1, and <code>lost</code> has the value 2. The identifiers in an <code>enum class</code> must be unique, but separate enumeration constants can have the same value. Variables of user-defined type <code>Status</code> can be assigned only the constants declared in the enumeration.</p>&#13;
<p>By convention, you should capitalize the first letter of an <code>enum class</code>’s name and the first letter of each subsequent word in a multi-word <code>enum class</code> name (e.g., <code>ProductCode</code>). The constants in an <code>enum class</code> should use the same naming conventions as variables.<sup><a id="rch0fn9" href="ch03.xhtml#ch0fn9">9</a>,<a id="rch0fn10" href="ch03.xhtml#ch0fn10">10</a></sup></p>&#13;
<p class="footnote"><a id="ch0fn9" href="ch03.xhtml#rch0fn9">9</a>. C++ Core Guidelines. Accessed May 11, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Renum-caps">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Renum-caps</a></code>.</p>&#13;
<p class="footnote"><a id="ch0fn10" href="ch03.xhtml#rch0fn10">10</a>. In legacy C++ code, you’ll commonly see <code>enum</code> constants in all uppercase letters—that practice is now deprecated.</p>&#13;
<p>To reference a scoped <code>enum</code> constant, qualify the constant with the scoped <code>enum</code>’s type name (in this example, <code>Status</code>) and the scope-resolution operator (<code>::</code>), as shown in line 19, which initializes <code>gameStatus</code> to <code>Status::keepRolling</code>. For a win, the program sets <code>gameStatus</code> to <code>Status::won</code>. For a loss, the program sets <code>gameStatus</code> to <code>Status::lost</code>.</p>&#13;
<h5 class="h5" id="ch05lev3sec18">Winning or Losing on the First Roll</h5>&#13;
<p>The following <code>switch</code> determines whether the player wins or loses on the first roll:</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0125-01" id="f0125-01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">21</span></strong>    <span class="lgreen">// determine game status and point (if needed) based on first roll</span>&#13;
<strong><span class="cviolet">22</span></strong>    <span class="blue">switch</span> (<span class="yell"><span class="blue">const int</span> sumOfDice{rollDice()}</span>; sumOfDice) {&#13;
<strong><span class="cviolet">23</span></strong>       <span class="blue">case</span> <span class="green">7</span>: <span class="lgreen">// win with 7 on first roll</span>&#13;
<strong><span class="cviolet">24</span></strong>       <span class="blue">case</span> <span class="green">11</span>: <span class="lgreen">// win with 11 on first roll</span>&#13;
<strong><span class="cviolet">25</span></strong>          <span class="yell">gameStatus = <span class="green">Status::won</span>;</span>&#13;
<strong><span class="cviolet">26</span></strong>          <span class="blue">break</span>;&#13;
<strong><span class="cviolet">27</span></strong>       <span class="blue">case</span> <span class="green">2</span>: <span class="green">// lose with 2 on first roll</span>&#13;
<strong><span class="cviolet">28</span></strong>       <span class="blue">case</span> <span class="green">3</span>: <span class="green">// lose with 3 on first roll</span>&#13;
<strong><span class="cviolet">29</span></strong>       <span class="blue">case</span> <span class="green">12</span>: <span class="green">// lose with 12 on first roll</span>&#13;
<strong><span class="cviolet">30</span></strong>          <span class="yell">gameStatus = <span class="green">Status::lost</span>;</span>&#13;
<strong><span class="cviolet">31</span></strong>          <span class="blue">break</span>;&#13;
<strong><span class="cviolet">32</span></strong>       <span class="blue">default</span>: <span class="lgreen">// did not win or lose, so remember point</span>&#13;
<strong><span class="cviolet">33</span></strong>          myPoint = sumOfDice; <span class="lgreen">// remember the point</span>&#13;
<strong><span class="cviolet">34</span></strong>          cout &lt;&lt; <span class="green">"Point is "</span> &lt;&lt; myPoint &lt;&lt; endl;&#13;
<strong><span class="cviolet">35</span></strong>          <span class="blue">break</span>; <span class="lgreen">// optional at end of switch</span>&#13;
<strong><span class="cviolet">36</span></strong>    }&#13;
<strong><span class="cviolet">37</span></strong></pre>&#13;
<p><span class="size">17</span> The <code>switch</code>’s initializer (line 22) creates the variable <code>sumOfDice</code> and initializes it by calling function <code>rollDice</code>. If the roll is <code>7</code> or <code>11</code>, line 25 sets <code>gameStatus</code> to <code>Status::won</code>. If the roll is <code>2</code>, <code>3</code>, or <code>12</code>, line 30 sets <code>gameStatus</code> to <code>Status::lost</code>. For other values, <code>gameStatus</code> remains unchanged (<code>Status::keepRolling</code>), line 33 saves <code>sumOfDice</code> in <code>myPoint</code>, and line 34 displays the <code>myPoint</code>.</p>&#13;
<h5 class="h5" id="ch05lev3sec19">Continuing to Roll</h5>&#13;
<p>After the first roll, if <code>gameStatus</code> is <code>Status::keepRolling</code>, execution proceeds with the following <code>while</code> statement:</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0126-01" id="f0126-01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">38</span></strong>     <span class="lgreen">// while game is not complete</span>&#13;
<strong><span class="cviolet">39</span></strong>     <span class="blue">while</span> (<span class="yell"><span class="green">Status::keepRolling</span> == gameStatus</span>) { <span class="lgreen">// not won or lost</span>&#13;
<strong><span class="cviolet">40</span></strong>        <span class="lgreen">// roll dice again and determine game status</span>&#13;
<strong><span class="cviolet">41</span></strong>        <span class="blue">if</span> (<span class="yell"><span class="blue">const int</span> sumOfDice{rollDice()}</span>; sumOfDice == myPoint) {&#13;
<strong><span class="cviolet">42</span></strong>           <span class="yell">gameStatus = <span class="green">Status::won</span>;</span>&#13;
<strong><span class="cviolet">43</span></strong>        }&#13;
<strong><span class="cviolet">44</span></strong>        <span class="blue">else</span> {&#13;
<strong><span class="cviolet">45</span></strong>           <span class="blue">if</span> (sumOfDice == <span class="green">7</span>) { <span class="lgreen">// lose by rolling 7 before point</span>&#13;
<strong><span class="cviolet">46</span></strong>              <span class="yell">gameStatus = <span class="green">Status::lost</span>;</span>&#13;
<strong><span class="cviolet">47</span></strong>           }&#13;
<strong><span class="cviolet">48</span></strong>        }&#13;
<strong><span class="cviolet">49</span></strong>     }&#13;
<strong><span class="cviolet">50</span></strong></pre>&#13;
<p><span class="size">17</span> In each iteration of the <code>while</code>, the <code>if</code> statement’s initializer (line 41) calls <code>rollDice</code> to produce a new <code>sumOfDice</code>. If <code>sumOfDice</code> matches <code>myPoint</code>, the program sets <code>gameStatus</code> to <code>Status::won</code> (line 42), and the loop terminates. If <code>sumOfDice</code> is <code>7</code>, the program sets <code>gameStatus</code> to <code>Status::lost</code> (line 46), and the loop terminates. Otherwise, the loop continues executing.</p>&#13;
<h5 class="h5" id="ch05lev3sec20">Displaying Whether the Player Won or Lost</h5>&#13;
<p>When the preceding loop terminates, the program proceeds to the following <code>if…else</code> statement, which prints <code>"Player wins"</code> if <code>gameStatus</code> is <code>Status::won</code> or <code>"Player loses"</code> if <code>gameStatus</code> is <code>Status::lost</code>:</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0126-02" id="f0126-02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">51</span></strong>      <span class="lgreen">// display won or lost message</span>&#13;
<strong><span class="cviolet">52</span></strong>      <span class="blue">if</span> (<span class="yell"><span class="green">Status::won</span> == gameStatus</span>) {&#13;
<strong><span class="cviolet">53</span></strong>         cout &lt;&lt; <span class="green">"Player wins"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">54</span></strong>      }&#13;
<strong><span class="cviolet">55</span></strong>      <span class="blue">else</span> {&#13;
<strong><span class="cviolet">56</span></strong>         cout &lt;&lt; <span class="green">"Player loses"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">57</span></strong>      }&#13;
<strong><span class="cviolet">58</span></strong>   }&#13;
<strong><span class="cviolet">59</span></strong></pre>&#13;
<h5 class="h5" id="ch05lev3sec21">Function <code>rollDice</code></h5>&#13;
<p>To roll the dice, function <code>rollDice</code> uses the die-rolling calculation shown previously to initialize variables <code>die1</code> and <code>die2</code>, then calculates their <code>sum</code>. Lines 67–68 display <code>die1</code>’s, <code>die2</code>’s and <code>sum</code>’s values before line 69 returns <code>sum</code>.</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0126-03" id="f0126-03a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">60</span></strong>  <span class="lgreen">// roll dice, calculate sum and display results</span>&#13;
<strong><span class="cviolet">61</span></strong>  <span class="lgreen">int</span> rollDice() {&#13;
<strong><span class="cviolet">62</span></strong>     <span class="blue">const int</span> die1{<span class="green">1</span> + rand() % <span class="green">6</span>}; <span class="lgreen">// first die roll</span>&#13;
<strong><span class="cviolet">63</span></strong>     <span class="blue">const int</span> die2{<span class="green">1</span> + rand() % <span class="green">6</span>}; <span class="lgreen">// second die roll</span>&#13;
<strong><span class="cviolet">64</span></strong>     <span class="blue">const int</span> sum{die1 + die2}; <span class="lgreen">// compute sum of die values</span>&#13;
<strong><span class="cviolet">65</span></strong>&#13;
<strong><span class="cviolet">66</span></strong>  <span class="lgreen">// display results of this roll</span>&#13;
<strong><span class="cviolet">67</span></strong>       cout &lt;&lt; <span class="green">"Player rolled "</span> &lt;&lt; die1 &lt;&lt; <span class="green">" + "</span> &lt;&lt; die2&#13;
<strong><span class="cviolet">68</span></strong>          &lt;&lt; <span class="green">" = "</span> &lt;&lt; sum &lt;&lt; endl;&#13;
<strong><span class="cviolet">69</span></strong>       <span class="blue">return</span> sum;&#13;
<strong><span class="cviolet">70</span></strong>    }</pre>&#13;
<h5 class="h5" id="ch05lev3sec22">Additional Notes Regarding Scoped <code>enum</code>s</h5>&#13;
<p>Qualifying an <code>enum class</code>’s constant with its type name and <code>::</code> explicitly identifies the constant as being in the scope of the specified <code>enum class</code>. If another <code>enum class</code> contains the same identifier, it’s always clear which constant is being used because the type name and <code>::</code> are required. In general, you should use unique values for an <code>enum</code>’s constants to help prevent hard-to-find logic errors.</p>&#13;
<p>Another popular scoped enumeration is</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0127-02" id="f0127-02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">enum class</span> Months {<span class="green">jan</span> = <span class="green">1</span>, <span class="green">feb</span>, <span class="green">mar</span>, <span class="green">apr</span>, <span class="green">may</span>, <span class="green">jun</span>, <span class="green">jul</span>, <span class="green">aug</span>,&#13;
   <span class="green">sep</span>, <span class="green">oct</span>, <span class="green">nov</span>, <span class="green">dec</span>};</pre>&#13;
<p>which creates user-defined <code>enum class</code> type <code>Months</code> with enumeration constants representing the months of the year. The first value in the preceding enumeration is explicitly set to <code>1</code>, so the remaining values increment from <code>1</code>, resulting in the values <code>1</code> through <code>12</code>. Any enumeration constant can be assigned an integer value in the enumeration definition. Subsequent enumeration constants each have a value 1 higher than the preceding constant until the next explicit setting.</p>&#13;
<h5 class="h5" id="ch05lev3sec23">Enumeration Types Before C++11</h5>&#13;
<p>Enumerations also can be defined with the keyword <code><strong><span class="violet">enum</span></strong></code> followed by a type name and a set of integer constants represented by identifiers, as in</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0127-03" id="f0127-03a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">enum</span> Status {<span class="green">keepRolling</span>, <span class="green">won</span>, <span class="green">lost</span>};</pre>&#13;
<p>The constants in such an <code>enum</code> are unscoped—you can refer to them simply by their names <code>keepRolling</code>, <code>won</code> and <code>lost</code>. If two or more unscoped <code>enum</code>s contain constants with the same names, this can lead to naming conflicts and compilation errors.</p>&#13;
<h5 class="h5" id="ch05lev3sec24"><span class="size">11</span> C++11—Specifying the Type of an <code>enum</code>’s Constants</h5>&#13;
<p>An enumeration’s constants have integer values. An unscoped <code>enum</code>’s underlying type depends on its constants’ values and is guaranteed to be large enough to store its constants’ values. A scoped <code>enum</code>’s underlying integral type is <code>int</code>, but you can specify a different type by following the type name with a colon (<code>:</code>) and the integral type. For example, we can specify that the constants in the <code>enum class Status</code> should have type <code>long</code>, as in</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0127-04" id="f0127-04a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">enum class</span> Status : <span class="blue">long</span> {<span class="green">keepRolling</span>, <span class="green">won</span>, <span class="green">lost</span>};</pre>&#13;
<h5 class="h5" id="ch05lev3sec25"><span class="size">20</span> C++20—<code>using enum</code> Declaration</h5>&#13;
<p>If the type of an <code>enum class</code>’s constants is obvious, based on the context in which they’re used—such as in our craps example—C++20’s <code><strong><span class="violet">using enum</span></strong></code> <span class="violet"><strong>declaration</strong></span><sup><a id="rch0fn11" href="ch03.xhtml#ch0fn11">11</a>,<a id="rch0fn12" href="ch03.xhtml#ch0fn12">12</a></sup> allows you to reference an <code>enum class</code>’s constants without the type name and scope-resolution operator (<code>::</code>). For example, adding the following statement after the <code>enum class</code> declaration:</p>&#13;
<p class="footnote"><a id="ch0fn11" href="ch03.xhtml#rch0fn11">11</a>. <code><a href="http://wg21.link/p1099r5">http://wg21.link/p1099r5</a></code>.</p>&#13;
<p class="footnote"><a id="ch0fn12" href="ch03.xhtml#rch0fn12">12</a>. At the time of this writing, this feature works only in Microsoft’s Visual C++ compiler.</p>&#13;
<pre class="pre"><span class="blue">using</span> <span class="blue">enum</span> Status;</pre>&#13;
<p>would allow the rest of the program to use <code>keepRolling</code>, <code>won</code> and <code>lost</code>, rather than <code>Status::keepRolling</code>, <code>Status::won</code> and <code>Status::lost</code>, respectively. You also may use an individual <code>enum class</code> constant with a declaration of the form</p>&#13;
<pre class="pre"><span class="blue">using</span> <span class="blue">enum</span> Status::keepRolling;</pre>&#13;
<p>This would allow your code to use <code>keepRolling</code> without the <code>Status::</code> qualifier.</p>&#13;
<h3 class="h3" id="ch05lev1sec10"><span class="size">11</span> <span class="violet">5.10</span> C++11’s More Secure Nondeterministic Random Numbers</h3>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> Function <code>rand</code>—which was inherited into C++ from the C Standard Library—does not have “good statistical properties” and can be predictable.<sup><a id="rch0fn13" href="ch03.xhtml#ch0fn13">13</a></sup> This makes programs that use <code>rand</code> less secure. C++11 provides a more secure library of random-number capabilities that can produce <span class="violet"><strong>nondeterministic random numbers</strong></span>—a set of random numbers that can’t be predicted. Such random-number generators are used in simulations and security scenarios where predictability is undesirable. These capabilities are located in the C++ Standard Library’s <code>&lt;random&gt;</code> header.</p>&#13;
<p class="footnote"><a id="ch0fn13" href="ch03.xhtml#rch0fn13">13</a>. “Do not use the <code>rand()</code> function for generating pseudorandom numbers.” Accessed May 9, 2020. <code><a href="https://wiki.sei.cmu.edu/confluence/display/c/MSC30-C.+Do+not+use+the+rand%28%29+function+for+generating+pseudorandom+numbers">https://wiki.sei.cmu.edu/confluence/display/c/MSC30-C.+Do+not+use+the+rand%28%29+function+for+generating+pseudorandom+numbers</a></code>.</p>&#13;
<p>Random-number generation is a sophisticated topic for which mathematicians have developed many algorithms with different statistical properties. For flexibility based on how random numbers are used in programs, C++11 provides many classes that represent various <span class="violet"><strong>random-number generation engines and distributions</strong></span>. An engine implements a random-number generation algorithm that produces pseudorandom numbers. A distribution controls the range of values produced by an engine, the value’s types (e.g., <code>int</code>, <code>double</code>, etc.) and the value’s statistical properties. We’ll use the default random-number generation engine—<code><strong><span class="violet">default_random_engine</span></strong></code>—and a <code><strong><span class="violet">uniform_int_distribution</span></strong></code>, which evenly distributes pseudorandom integers over a specified value range. The default range is from 0 to the maximum value of an <code>int</code> on your platform.</p>&#13;
<h5 class="h5" id="ch05lev3sec26">Rolling a Six-Sided Die</h5>&#13;
<p><a href="ch05.xhtml#fig5_6">Figure 5.6</a> uses the <code>default_random_engine</code> and the <code>uniform_int_distribution</code> to roll a six-sided die. Line 14 creates a <code>default_random_engine</code> object named <code>engine</code>. Its constructor argument seeds the random-number generation engine with the current time. If you don’t pass a value to the constructor, the default seed will be used, and the program will produce the same sequence of numbers each time it executes—this is useful for testing purposes. Line 15 creates <code>randomInt</code>—a <code>uniform_int_distribution</code> object that produces <code>int</code> values (specified by <code>&lt;int&gt;</code>) in the range 1 to 6 (specified by the initializer <code>{1, 6}</code>). The expression <code>randomInt(engine)</code> (line 20) returns one <code>int</code> in the range 1 to 6.</p>&#13;
<div class="group" id="fig5_6">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig06" id="a05fig06">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_06.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Using a C++11 random-number generation engine and distribution</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="lgreen">// to roll a six-sided die more securely.</span>&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">#include</span> &lt;iomanip&gt;&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="yell"><span class="blue">#include</span> &lt;random&gt; <span class="lgreen">// contains C++11 random number generation features</span></span>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">#include</span> &lt;ctime&gt;&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="blue">#include</span> <span class="green">"gsl/gsl"</span>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet">10</span></strong>&#13;
<strong><span class="cviolet">11</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">12</span></strong>     <span class="yell"><span class="lgreen">// use the default random-number generation engine to</span>                 </span>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="yell"><span class="lgreen">// produce uniformly distributed pseudorandom int values from 1 to 6</span>  </span>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="yell">default_random_engine engine{gsl::narrow_cast&lt;<span class="blue">unsigned int</span>&gt;(time(<span class="green">0</span>))};</span>&#13;
<strong><span class="cviolet">15</span></strong>     <span class="yell"><span class="blue">const</span> uniform_int_distribution&lt;<span class="blue">int</span>&gt; randomInt{<span class="green">1</span>, <span class="green">6</span>};                  </span>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>     <span class="lgreen">// loop 10 times</span>&#13;
<strong><span class="cviolet">18</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> counter{<span class="green">1</span>}; counter &lt;= <span class="green">10</span>; ++counter) {&#13;
<strong><span class="cviolet">19</span></strong>        <span class="lgreen">// pick random number from 1 to 6 and output it</span>&#13;
<strong><span class="cviolet">20</span></strong>        cout &lt;&lt; setw(10) <span class="green">&lt;</span>&lt; <span class="yell">randomInt(engine)</span>;&#13;
<strong><span class="cviolet">21</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">22</span></strong>&#13;
<strong><span class="cviolet">23</span></strong>     <code>cout &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">24</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>2 1 2 3 5 6 1 5 6 4</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.6</strong></span> Using a C++11 random-number generation engine and distribution to roll a six-sided die more securely.</p>&#13;
</div>&#13;
<p>The notation <code>&lt;int&gt;</code> in line 15 indicates that <code>uniform_int_distribution</code> is a class template. In this case, any integer type can be specified in the angle brackets (<code>&lt;</code> and <code>&gt;</code>). In <a href="ch19.xhtml#ch19">Chapter 19</a>, we discuss how to create class templates, and various other chapters show how to use existing class templates from the C++ Standard Library. For now, you can use class template <code>uniform_int_distribution</code> by mimicking the syntax shown in the example.</p>&#13;
<h3 class="h3" id="ch05lev1sec11"><span class="violet">5.11</span> Scope Rules</h3>&#13;
<p>The portion of a program where an identifier can be used is known as its scope. For example, when we declare a local variable in a block, it can be referenced only</p>&#13;
<p class="bull">• from the point of its declaration in that block and</p>&#13;
<p class="bull">• in nested blocks that appear within that block after the variable’s declaration.</p>&#13;
<p>This section discusses block scope and global namespace scope. Parameter names in function prototypes have <span class="violet"><strong>function-prototype scope</strong></span>—they’re known only in the prototype in which they appear. Later we’ll see other scopes, including <span class="violet"><strong>class scope</strong></span> in <a href="ch11.xhtml#ch11">Chapter 11</a>, and <span class="violet"><strong>function</strong></span> <span class="violet"><strong>scope</strong></span> and <span class="violet"><strong>namespace scope</strong></span> in Chapter 23.</p>&#13;
<h5 class="h5" id="ch05lev3sec27">Block Scope</h5>&#13;
<p>Identifiers declared inside a block have <span class="violet"><strong>block scope</strong></span>, which begins at the identifier’s declaration and ends at the terminating right brace (<code>}</code>) of the enclosing block. Local variables have block scope, as do function parameters (even though they’re declared outside the block’s braces). Any block can contain variable declarations. When blocks are nested and an identifier in an outer block has the same name as an identifier in an inner block, the one in the outer block is “hidden” until the inner block terminates. The inner block “sees” its own local variable’s value and not that of the enclosing block’s identically named variable.</p>&#13;
<p>Accidentally using the same name for an identifier in an inner block that’s used for an identifier in an outer block when, in fact, you want the identifier in the outer block to be active for the duration of the inner block, is typically a logic error. Avoid variable names in inner scopes that hide names in outer scopes. Most compilers will warn you about this.</p>&#13;
<p>Local variables also may be declared <code><strong><span class="violet">static</span></strong></code>. Such variables also have block scope, but unlike other local variables, a <code>static</code> local variable retains its value when the function returns to its caller. The next time the function is called, the <code>static</code> local variable contains the value it had when the function last completed execution. The following statement declares <code>static</code> local variable <code>count</code> and initializes to 1:</p>&#13;
<pre class="pre"><span class="blue">static int</span> count{<span class="green">1</span>};</pre>&#13;
<p>By default, all <code>static</code> local variables of numeric types are initialized to zero. The following statement declares <code>static</code> local variable <code>count</code> and initializes it to <code>0</code>:</p>&#13;
<pre class="pre"><span class="blue">static int</span> count;</pre>&#13;
<p>Default initialization of non-fundamental-type variables depends on the type—for example, a <code>string</code>’s default value is the empty string (<code>""</code>). We’ll say more about default initialization in later chapters.</p>&#13;
<h5 class="h5" id="ch05lev3sec28">Global Namespace Scope</h5>&#13;
<p>An identifier declared outside any function or class has <span class="violet"><strong>global namespace scope</strong></span>. Such an identifier is “known” to all functions after its declaration in the source-code file. Function definitions, function prototypes placed outside a function, class definitions and global variables all have global namespace scope. <span class="violet"><strong>Global variables</strong></span> are created by placing variable declarations outside any class or function definition. Such variables retain their values throughout a program’s execution.</p>&#13;
<p>Declaring a variable as global rather than local allows unintended side effects to occur when a function that does not need access to the variable accidentally or maliciously modifies it. Except for truly global resources such as <code>cin</code> and <code>cout</code>, you should avoid global variables. This is an example of the <span class="violet"><strong>principle of least privilege</strong></span>, which is fundamental to good software engineering. It states that code should be granted <em>only</em> the amount of privilege and access that it needs to accomplish its designated task, but no more. An example of this is the scope of a local variable, which should not be visible when it’s not needed. A local variable is created when the function is called, used by that function while it executes then goes away when the function returns. The principle of least privilege makes your programs more robust by preventing code from accidentally (or maliciously) modifying variable values that should not be accessible to it.</p>&#13;
<p>In general, variables should be declared in the narrowest scope in which they need to be accessed. Variables used only in a particular function should be declared as local variables in that function rather than as global variables.</p>&#13;
<h5 class="h5" id="ch05lev3sec29">Scope Demonstration</h5>&#13;
<p><a href="ch05.xhtml#fig5_7">Figure 5.7</a> demonstrates scoping issues with global variables, local variables and <code>static</code> local variables. We show portions of the program with their corresponding outputs for discussion purposes. Line 10 declares and initializes global variable <code>x</code> to 1. This global variable is hidden in any block (or function) that declares a variable named <code>x</code>.</p>&#13;
<div class="group" id="fig5_7">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig07" id="a05fig07">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_07.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Scoping example.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">void</span> useLocal(); <span class="lgreen">// function prototype</span>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">void</span> useStaticLocal(); <span class="lgreen">// function prototype</span>&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="blue">void</span> useGlobal(); <span class="lgreen">// function prototype</span>&#13;
<strong><span class="cviolet"> 9</span></strong>&#13;
<strong><span class="cviolet">10</span></strong>  <span class="yell"><span class="blue">int</span> x{<span class="green">1</span>}; <span class="lgreen">// global variable</span></span>&#13;
<strong><span class="cviolet">11</span></strong></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.7</strong></span> Scoping example.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec30">Function <code>main</code></h5>&#13;
<p>In <code>main</code>, line 13 displays the value of global variable <code>x</code>. Line 15 initializes local variable <code>x</code> to <code>5</code>. Line 17 outputs this variable to show that the global <code>x</code> is hidden in <code>main</code>. Next, lines 19–23 define a new block in <code>main</code> in which another local variable <code>x</code> is initialized to <code>7</code> (line 20). Line 22 outputs this variable to show that it hides <code>x</code> in the outer block of <code>main</code> as well as the global <code>x</code>. When the block exits, the variable <code>x</code> with value <code>7</code> is destroyed automatically. Next, line 25 outputs the local variable <code>x</code> in the outer block of <code>main</code> to show that it’s no longer hidden.</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0131-01a" id="f0131-01aa">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">12</span></strong>    <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">13</span></strong>       cout &lt;&lt; <span class="green">"global x in main is "</span> &lt;&lt; <span class="yell">x</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>       <span class="yell"><span class="blue">const int</span> x{<span class="green">5</span>}; <span class="lgreen">// local variable to main</span></span>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>       cout &lt;&lt; <span class="green">"local x in main's outer scope is "</span> &lt;&lt; x &lt;&lt; endl;&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>       <span class="yell">{ <span class="lgreen">// block starts a new scope</span>                                 </span>&#13;
<strong><span class="cviolet">20</span></strong>       <span class="yell">   <span class="blue">const int</span> x{<span class="green">7</span>}; <span class="lgreen">// hides both x in outer scope and global x</span></span>&#13;
<strong><span class="cviolet">21</span></strong>       <span class="yell">                                                              </span>&#13;
<strong><span class="cviolet">22</span></strong>       <span class="yell">   cout &lt;&lt; <span class="green">"local x in main's inner scope is "</span> &lt;&lt; x &lt;&lt; endl;  </span>&#13;
<strong><span class="cviolet">23</span></strong>       }&#13;
<strong><span class="cviolet">24</span></strong>&#13;
<strong><span class="cviolet">25</span></strong>       cout &lt;&lt; <span class="green">"local x in main's outer scope is "</span> &lt;&lt; x &lt;&lt; endl;&#13;
<strong><span class="cviolet">26</span></strong></pre>&#13;
<pre class="pre1">global x in main is 1&#13;
local x in main's outer scope is 5&#13;
local x in main's inner scope is 7&#13;
local x in main's outer scope is 5</pre>&#13;
<p>To demonstrate other scopes, the program defines three functions—<code>useLocal</code>, <code>useStaticLocal</code> and <code>useGlobal</code>—each of which takes no arguments and returns nothing. The rest of <code>main</code> (shown below) calls each function twice in lines 27–32. After executing functions <code>useLocal</code>, <code>useStaticLocal</code> and <code>useGlobal</code> twice each, the program prints the local variable <code>x</code> in <code>main</code> again to show that none of the function calls modified the value of <code>x</code> in <code>main</code>, because the functions all referred to variables in other scopes.</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0132-01" id="f0132-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">27</span></strong>      useLocal(); <span class="lgreen">// useLocal has local x</span>&#13;
<strong><span class="cviolet">28</span></strong>      useStaticLocal(); <span class="lgreen">// useStaticLocal has static local x</span>&#13;
<strong><span class="cviolet">29</span></strong>      useGlobal(); <span class="lgreen">// useGlobal uses global x</span>&#13;
<strong><span class="cviolet">30</span></strong>      useLocal(); <span class="lgreen">// useLocal reinitializes its local x</span>&#13;
<strong><span class="cviolet">31</span></strong>      useStaticLocal(); <span class="lgreen">// static local x retains its prior value</span>&#13;
<strong><span class="cviolet">32</span></strong>      useGlobal(); <span class="lgreen">// global x also retains its prior value</span>&#13;
<strong><span class="cviolet">33</span></strong>&#13;
<strong><span class="cviolet">34</span></strong>      cout &lt;&lt; <span class="green">"\nlocal x in main is "</span> &lt;&lt; x &lt;&lt; endl;&#13;
<strong><span class="cviolet">35</span></strong>   }&#13;
<strong><span class="cviolet">36</span></strong></pre>&#13;
<pre class="pre1">local x is 25 on entering useLocal&#13;
local x is 26 on exiting useLocal&#13;
&#13;
local static x is 50 on entering useStaticLocal&#13;
local static x is 51 on exiting useStaticLocal&#13;
&#13;
global x is 1 on entering useGlobal&#13;
global x is 10 on exiting useGlobal&#13;
&#13;
local x is 25 on entering useLocal&#13;
local x is 26 on exiting useLocal&#13;
&#13;
local static x is 51 on entering useStaticLocal&#13;
local static x is 52 on exiting useStaticLocal&#13;
&#13;
global x is 10 on entering useGlobal&#13;
global x is 100 on exiting useGlobal&#13;
&#13;
local x in main is 5</pre>&#13;
<h5 class="h5" id="ch05lev3sec31">Function <code>useLocal</code></h5>&#13;
<p>Function <code>useLocal</code> initializes local variable <code>x</code> to <code>25</code> (line 39). When <code>main</code> calls <code>useLocal</code> (lines 27 and 30), the function prints the variable <code>x</code>, increments it and prints it again before the function returns program control to its caller. Each time the program calls this function, the function recreates local variable <code>x</code> and reinitializes it to <code>25</code>.</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0132-02" id="f0132-02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">37</span></strong>   <span class="lgreen">// useLocal reinitializes local variable x during each call</span>&#13;
<strong><span class="cviolet">38</span></strong>   <span class="blue">void</span> useLocal() {&#13;
<strong><span class="cviolet">39</span></strong>      <span class="yell"><span class="blue">int</span> x{<span class="green">25</span>}; <span class="lgreen">// initialized each time useLocal is called</span></span>&#13;
<strong><span class="cviolet">40</span></strong>&#13;
<strong><span class="cviolet">41</span></strong>      cout &lt;&lt; <span class="green">"\nlocal x is "</span> &lt;&lt; x &lt;&lt; <span class="green">" on entering useLocal"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">42</span></strong>      ++x;&#13;
<strong><span class="cviolet">43</span></strong>      cout &lt;&lt; <span class="green">"local x is "</span> &lt;&lt; x &lt;&lt; <span class="green">" on exiting useLocal"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">44</span></strong>   }&#13;
<strong><span class="cviolet">45</span></strong></pre>&#13;
<h5 class="h5" id="ch05lev3sec32">Function <code>useStaticLocal</code></h5>&#13;
<p>Function <code>useStaticLocal</code> declares <code>static</code> variable <code>x</code> and initializes it to <code>50</code>. Local variables declared as <code>static</code> retain their values even when they’re out of scope (i.e., the function in which they’re declared is not executing). When line 28 in <code>main</code> calls <code>useStaticLocal</code>, the function prints its local <code>x</code>, increments it and prints it again before the function returns program control to its caller. In the next call to this function (line 31), <code>static</code> local variable <code>x</code> contains the value <code>51</code>. The initialization in line 50 occurs only the first time <code>useStaticLocal</code> is called (line 28).</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0133-02" id="f0133-02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">46</span></strong>   <span class="green">// useStaticLocal initializes static local variable x only the</span>&#13;
<strong><span class="cviolet">47</span></strong>   <span class="green">// first time the function is called; value of x is saved</span>&#13;
<strong><span class="cviolet">48</span></strong>   <span class="green">// between calls to this function</span>&#13;
<strong><span class="cviolet">49</span></strong>   <span class="blue">void</span> useStaticLocal() {&#13;
<strong><span class="cviolet">50</span></strong>      <span class="yell"><span class="blue">static int</span> x{<span class="green">50</span>}; <span class="lgreen">// initialized first time useStaticLocal is called</span></span>&#13;
<strong><span class="cviolet">51</span></strong>&#13;
<strong><span class="cviolet">52</span></strong>      cout &lt;&lt; <span class="green">"\nlocal static x is "</span> &lt;&lt; x &lt;&lt; <span class="green">" on entering useStaticLocal"</span>&#13;
<strong><span class="cviolet">53</span></strong>         &lt;&lt; endl;&#13;
<strong><span class="cviolet">54</span></strong>      ++x;&#13;
<strong><span class="cviolet">55</span></strong>      cout &lt;&lt; <span class="green">"local static x is "</span> &lt;&lt; x &lt;&lt; <span class="green">" on exiting useStaticLocal"</span>&#13;
<strong><span class="cviolet">56</span></strong>         &lt;&lt; endl;&#13;
<strong><span class="cviolet">57</span></strong>   }&#13;
<strong><span class="cviolet">58</span></strong></pre>&#13;
<h5 class="h5" id="ch05lev3sec33">Function <code>useGlobal</code></h5>&#13;
<p>Function <code>useGlobal</code> does not declare any variables. Therefore, when it refers to variable <code>x</code>, the global <code>x</code> (line 10, preceding <code>main</code>) is used. When <code>main</code> calls <code>useGlobal</code> (line 29), the function prints the global variable <code>x</code>, multiplies it by 10 and prints it again before the function returns to its caller. The next time <code>main</code> calls <code>useGlobal</code> (line 32), the global variable has its modified value, <code>10</code>.</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0133-03" id="f0133-03a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">59</span></strong>   <span class="lgreen">// useGlobal modifies global variable x during each call</span>&#13;
<strong><span class="cviolet">60</span></strong>   <span class="blue">void</span> useGlobal() {&#13;
<strong><span class="cviolet">61</span></strong>      cout &lt;&lt; <span class="green">"\nglobal x is "</span> &lt;&lt; x &lt;&lt; <span class="green">" on entering useGlobal"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">62</span></strong>      x *= <span class="green">10</span>;&#13;
<strong><span class="cviolet">63</span></strong>      cout &lt;&lt; <span class="green">"global x is "</span> &lt;&lt; x &lt;&lt; <span class="green">" on exiting useGlobal"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">64</span></strong>   }</pre>&#13;
<h3 class="h3" id="ch05lev1sec12"><span class="violet">5.12</span> Inline Functions</h3>&#13;
<p>Implementing a program as a set of functions is good from a software engineering standpoint, but function calls involve execution-time overhead. C++ provides <span class="violet"><strong>inline functions</strong></span> to help reduce function-call overhead. Placing <code><strong><span class="violet">inline</span></strong></code> before a function’s return type in the function definition advises the compiler to generate a copy of the function’s body code in every place where the function is called (when appropriate) to avoid a function call. This often makes the program larger. The compiler can ignore the <code>inline</code> qualifier. Reusable <code>inline</code> functions are typically placed in headers so that their definitions can be inlined in each source file that uses them.</p>&#13;
<p>If you change an <code>inline</code> function’s definition, you must recompile any code that calls that function. Though compilers can inline code for which you have not explicitly used <code>inline</code>, the ISO’s C++ Core Guidelines indicate that you should declare “small and time-critical” functions <code>inline</code>.<sup><a id="rch0fn14" href="ch04.xhtml#ch0fn14">14</a></sup> ISO also provides an extensive FAQ on the subtleties of using inline functions:</p>&#13;
<p class="footnote"><a id="ch0fn14" href="ch04.xhtml#rch0fn14">14</a>. C++ Core Guidelines. Accessed May 11, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-inline">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-inline</a></code>.</p>&#13;
<pre class="pre"><a href="https://isocpp.org/wiki/faq/inline-functions">https://isocpp.org/wiki/faq/inline-functions</a></pre>&#13;
<p><a href="ch05.xhtml#fig5_8">Figure 5.8</a> uses <code>inline</code> function <code>cube</code> (lines 9–11) to calculate the volume of a cube.)</p>&#13;
<div class="group" id="fig5_8">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig08" id="a05fig08">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_08.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// inline function that calculates the volume of a cube.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;m&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="lgreen">// Definition of inline function cube. Definition of function appears</span>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="lgreen">// before function is called, so a function prototype is not required.</span>&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="lgreen">// First line of function definition also acts as the prototype.</span>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="yell"><span class="blue">inline</span> <span class="blue">double</span> cube(<span class="blue">double</span> side) {              </span>&#13;
<strong><span class="cviolet">10</span></strong>  <span class="yell">   <span class="blue">return</span> side * side * side; <span class="lgreen">// calculate cube</span></span>&#13;
<strong><span class="cviolet">11</span></strong>  <span class="yell"><code>}</code>                                              </span>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">14</span></strong>     <span class="blue">double</span> sideValue; <span class="lgreen">// stores value entered by user</span>&#13;
<strong><span class="cviolet">15</span></strong>     cout &lt;&lt; <span class="green">"Enter the side length of your cube: "</span>;&#13;
<strong><span class="cviolet">16</span></strong>     cin &gt;&gt; sideValue; <span class="lgreen">// read value from user</span>&#13;
<strong><span class="cviolet">17</span></strong>&#13;
<strong><span class="cviolet">18</span></strong>     <span class="lgreen">// calculate cube of sideValue and display result</span>&#13;
<strong><span class="cviolet">19</span></strong>     cout &lt;&lt; <span class="green">"Volume of cube with side "</span>&#13;
<strong><span class="cviolet">20</span></strong>        &lt;&lt; sideValue &lt;&lt; <span class="green">" is "</span> &lt;&lt; <span class="yell">cube(sideValue)</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">21</span></strong>  }</pre>&#13;
<pre class="pre1"><code>Enter the side length of your cube: <strong>3.5</strong></code>&#13;
<code>Volume of cube with side 3.5 is 42.875</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.8</strong></span> <code>inline</code> function that calculates the volume of a cube.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch05lev1sec13"><span class="violet">5.13</span> References and Reference Parameters</h3>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> Two ways to pass arguments to functions in many programming languages are <span class="violet"><strong>pass-by-value</strong></span> and <span class="violet"><strong>pass-by-reference</strong></span>. When an argument is passed by value, a copy of the argument’s value is made and passed to the called function. Changes to the copy do not affect the original variable’s value in the caller. This prevents the accidental side effects that so greatly hinder the development of correct and reliable software systems. So far, each argument in the book has been passed by value. One disadvantage of pass-by-value is that, if a large data item is being passed, copying that data can take a considerable amount of execution time and memory space.</p>&#13;
<h5 class="h5" id="ch05lev3sec34">Reference Parameters</h5>&#13;
<p>This section introduces reference parameters—the first of the two means C++ provides for performing pass-by-reference.<sup><a id="rch0fn15" href="ch05.xhtml#ch0fn15">15</a></sup> When a variable is passed by reference, the caller gives the called function the ability to access that variable in the caller directly and to modify the variable.</p>&#13;
<p class="footnote"><a id="ch0fn15" href="ch05.xhtml#rch0fn15">15</a>. <a href="ch07.xhtml#ch07">Chapter 7</a> discusses pointers, which enable an alternate form of pass-by-reference in which the style of the function call clearly indicates pass-by-reference (and the potential for modifying the caller’s arguments).</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> Pass-by-reference is good for performance reasons because it can eliminate the pass-by-value overhead of copying large amounts of data. But Pass-by-reference can weaken security—the called function can corrupt the caller’s data.</p>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> After this section’s example, we’ll show how to achieve the performance advantage of pass-by-reference while simultaneously achieving the software engineering advantage of protecting the caller’s data from corruption.</p>&#13;
<p>A <span class="violet"><strong>reference parameter</strong></span> is an alias for its corresponding argument in a function call. To indicate that a function parameter is passed by reference, simply follow the parameter’s type in the function prototype by an ampersand (<code>&amp;</code>); use the same convention when listing the parameter’s type in the function header. For example, the parameter declaration</p>&#13;
<pre class="pre"><span class="blue">int</span>&amp; number</pre>&#13;
<p>when reading from right to left is pronounced “<code>number</code> is a reference to an <code>int</code>.” As always, the function prototype and header must agree.</p>&#13;
<p>In the function call, simply mention a variable by name to pass it by reference. In the called function’s body, the reference parameter (e.g., <code>number</code>) refers to the original variable in the caller, which can be modified directly by the called function.</p>&#13;
<h5 class="h5" id="ch05lev3sec35">Passing Arguments by Value and by Reference</h5>&#13;
<p><a href="ch05.xhtml#fig5_9">Figure 5.9</a> compares pass-by-value and pass-by-reference with reference parameters. The “styles” of the arguments in the calls to function <code>squareByValue</code> and function <code>square-ByReference</code> are identical—both variables are simply mentioned by name in the function calls. The compiler checks the function prototypes and definitions to determine whether to use pass-by-value or pass-by-reference.</p>&#13;
<div class="group" id="fig5_9">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig09" id="a05fig09">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_09.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Passing arguments by value and by reference.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="yell"><span class="blue">int</span> squareByValue(<span class="blue">int</span> x); <span class="lgreen">// function prototype (for value pass)</span></span>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="yell"><span class="blue">void</span> squareByReference(<span class="blue">int</span>&amp; z); <span class="lgreen">// function prototype (for reference pass)</span></span>&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">const int</span> x{<span class="green">2</span>}; <span class="lgreen">// value to square using squareByValue</span>&#13;
<strong><span class="cviolet">11</span></strong>     <span class="blue">int</span> z{<span class="green">4</span>}; <span class="lgreen">// value to square using squareByReference</span>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="lgreen">// demonstrate squareByValue</span>&#13;
<strong><span class="cviolet">14</span></strong>     cout &lt;&lt; <span class="green">"x = "</span> &lt;&lt; x &lt;&lt; <span class="green">" before squareByValue\n"</span>;&#13;
<strong><span class="cviolet">15</span></strong>     cout &lt;&lt; <span class="green">"Value returned by squareByValue: "</span>&#13;
<strong><span class="cviolet">16</span></strong>        <code>&lt;&lt; <span class="yell">squareByValue(x)</span> &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">17</span></strong>     cout &lt;&lt; <span class="green">"x = "</span> &lt;&lt; x &lt;&lt; <span class="green">" after squareByValue\n"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>     <span class="lgreen">// demonstrate squareByReference</span>&#13;
<strong><span class="cviolet">20</span></strong>     cout &lt;&lt; <span class="green">"z = "</span> &lt;&lt; z &lt;&lt; <span class="green">" before squareByReference"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">21</span></strong>     <span class="yell"><code>squareByReference(z);</code></span>&#13;
<strong><span class="cviolet">22</span></strong>     cout &lt;&lt; <span class="green">"z = "</span> &lt;&lt; z &lt;&lt; <span class="green">" after squareByReference"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">23</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet">24</span></strong>&#13;
<strong><span class="cviolet">25</span></strong>  <span class="lgreen">// squareByValue multiplies number by itself, stores the</span>&#13;
<strong><span class="cviolet">26</span></strong>  <span class="lgreen">// result in number and returns the new value of number</span>&#13;
<strong><span class="cviolet">27</span></strong>  <span class="yell"><span class="blue">int</span> squareByValue(<span class="blue">int</span> number) {                              </span>&#13;
<strong><span class="cviolet">28</span></strong>  <span class="yell">   <span class="blue">return</span> number *= number; <span class="lgreen">// caller's argument not modified</span></span>&#13;
<strong><span class="cviolet">29</span></strong>  <span class="yell"><code>}</code>                                                            </span>&#13;
<strong><span class="cviolet">30</span></strong>&#13;
<strong><span class="cviolet">31</span></strong>  <span class="lgreen">// squareByReference multiplies numberRef by itself and stores the result</span>&#13;
<strong><span class="cviolet">32</span></strong>  <span class="lgreen">// in the variable to which numberRef refers in function main</span>&#13;
<strong><span class="cviolet">33</span></strong>  <span class="yell"><span class="blue">void</span> squareByReference(<span class="blue">int</span>&amp; numberRef) {                </span>&#13;
<strong><span class="cviolet">34</span></strong>  <span class="yell">   numberRef *= numberRef; <span class="lgreen">// caller's argument modified</span></span>&#13;
<strong><span class="cviolet">35</span></strong>  <span class="yell"><code>}</code>                                                       </span></pre>&#13;
<pre class="pre1"><code>x = 2 before squareByValue</code>&#13;
<code>Value returned by squareByValue: 4&#13;
x = 2 after squareByValue</code>&#13;
&#13;
<code>z = 4 before squareByReference&#13;
z = 16 after squareByReference</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.9</strong></span> Passing arguments by value and by reference.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec36">References as Aliases within a Function</h5>&#13;
<p>References can also be used as aliases for other variables within a function (although they typically are used with functions as shown in <a href="ch05.xhtml#fig5_9">Fig. 5.9</a>). For example, the code</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0136-01" id="f0136-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> count{<span class="green">1</span>}; <span class="lgreen">// declare integer variable count</span>&#13;
<span class="blue">int</span>&amp; cRef{count}; <span class="lgreen">// create cRef as an alias for count</span>&#13;
++cRef; <span class="lgreen">// increment count (using its alias cRef)</span></pre>&#13;
<p>increments variable <code>count</code> by using its alias <code>cRef</code>. Reference variables must be initialized in their declarations and cannot be reassigned as aliases to other variables. In this sense, references are constant. All operations performed on the alias (i.e., the reference) are actually performed on the original variable. The alias is simply another name for the original variable. Unless it’s a reference to a constant (discussed below), a reference’s initializer must be an <em>lvalue</em>—something that can appear on the left side of an assignment, like a variable name. A reference may not be initialized with a constant or <em>rvalue</em> expression—that is, something might appear on the right side of an assignment, such as the result of a calculation.</p>&#13;
<h5 class="h5" id="ch05lev3sec37"><code>const</code> References</h5>&#13;
<p>To specify that a reference parameter should not be allowed to modify the corresponding argument in the caller, place the <code><strong><span class="violet">const</span></strong></code> qualifier before the type name in the parameter’s declaration. For example, consider a <code>displayName</code> function:</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0137-01" id="f0137-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">void</span> displayName(std::string name) {&#13;
   std::cout &lt;&lt; name &lt;&lt; std::endl;&#13;
}</pre>&#13;
<p>When called, it receives a copy of its <code>string</code> argument. Since <code>string</code> objects can be large, this copy operation could degrade an application’s performance. For this reason, <code>string</code> objects (and objects in general) should be passed to functions by reference.</p>&#13;
<p>Also, the <code>displayName</code> function does not need to modify its argument, so following the principle of least privilege, we’d declare the parameter as</p>&#13;
<pre class="pre"><span class="blue">const</span> std::string&amp; name</pre>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> <img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> Reading this from right-to-left, the <code>name</code> parameter is a reference to a <code>string</code> constant. We get the performance of passing the <code>string</code> by reference. Also, <code>displayName</code> treats the argument as a constant, so <code>displayName</code> cannot modify the value in the caller—so we get the security of pass-by-value.</p>&#13;
<h5 class="h5" id="ch05lev3sec38">Returning a Reference to a Local Variable</h5>&#13;
<p>Functions can return references to local variables, but this can be dangerous. When returning a reference to a local non-<code>static</code> variable, the reference refers to a variable that’s discarded when the function terminates. An attempt to access such a variable yields undefined behavior, often crashing the program or corrupting data.<sup><a id="rch0fn16" href="ch05.xhtml#ch0fn16">16</a></sup> References to undefined variables are called <span class="violet"><strong>dangling references</strong></span>. This is a logic error for which compilers typically issue a warning. Software-engineering teams often have policies requiring that before code can be deployed, it must compile without warnings.</p>&#13;
<p class="footnote"><a id="ch0fn16" href="ch05.xhtml#rch0fn16">16</a>. C++ Core Guidelines. Accessed May 11, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-dangle">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-dangle</a></code>.</p>&#13;
<h3 class="h3" id="ch05lev1sec14"><span class="violet">5.14</span> Default Arguments</h3>&#13;
<p>It’s common for a program to invoke a function repeatedly with the same argument value for a particular parameter. In such cases, you can specify that such a parameter has a <span class="violet"><strong>default argument</strong></span>, i.e., a default value to be passed to that parameter. When a program omits an argument for a parameter with a default argument in a function call, the compiler rewrites the function call, inserting the default value of that argument.</p>&#13;
<h5 class="h5" id="ch05lev3sec39"><code>boxVolume</code> Function with Default Arguments</h5>&#13;
<p><a href="ch05.xhtml#fig5_10">Figure 5.10</a> demonstrates using default arguments to calculate a box’s volume. The function prototype for <code>boxVolume</code> (line 7) specifies that all three parameters have default values of <code>1</code> by placing <code>= 1</code> to the right of each parameter.</p>&#13;
<div class="group" id="fig5_10">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig10" id="a05fig10">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_10.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Using default arguments.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="lgreen">// function prototype that specifies default arguments</span>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="yell"><span class="blue">int</span> boxVolume(<span class="blue">int</span> length = <span class="green">1</span>, <span class="blue">int</span> width = <span class="green">1</span>, <span class="blue">int</span> height = <span class="green">1</span>);</span>&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">10</span></strong>     <span class="lgreen">// no arguments--use default values for all dimensions</span>&#13;
<strong><span class="cviolet">11</span></strong>     cout &lt;&lt; <span class="green">"The default box volume is: "</span> &lt;&lt; <span class="yell">boxVolume()</span>;&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="lgreen">// specify length; default width and height</span>&#13;
<strong><span class="cviolet">14</span></strong>     cout &lt;&lt; <span class="green">"\n\nThe volume of a box with length 10,\n"</span>&#13;
<strong><span class="cviolet">15</span></strong>        &lt;&lt; <span class="green">"width 1 and height 1 is: "</span> &lt;&lt; <span class="yell">boxVolume(<span class="green">10</span>)</span>;&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>     <span class="lgreen">// specify length and width; default height</span>&#13;
<strong><span class="cviolet">18</span></strong>     cout &lt;&lt; <span class="green">"\n\nThe volume of a box with length 10,\n"</span>&#13;
<strong><span class="cviolet">19</span></strong>        &lt;&lt; <span class="green">"width 5 and height 1 is: "</span> &lt;&lt; <span class="yell">boxVolume(<span class="green">10</span>, <span class="green">5</span>)</span>;&#13;
<strong><span class="cviolet">20</span></strong>&#13;
<strong><span class="cviolet">21</span></strong>     <span class="lgreen">// specify all arguments</span>&#13;
<strong><span class="cviolet">22</span></strong>     cout &lt;&lt; <span class="green">"\n\nThe volume of a box with length 10,\n"</span>&#13;
<strong><span class="cviolet">23</span></strong>        &lt;&lt; <span class="green">"width 5 and height 2 is: "</span> &lt;&lt; <span class="yell">boxVolume(<span class="green">10</span>, <span class="green">5</span>, <span class="green">2</span>)</span>&#13;
<strong><span class="cviolet">24</span></strong>        <code>&lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">25</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet">26</span></strong>&#13;
<strong><span class="cviolet">27</span></strong>  <span class="lgreen">// function boxVolume calculates the volume of a box</span>&#13;
<strong><span class="cviolet">28</span></strong>  <span class="blue">int</span> boxVolume(<span class="blue">int</span> length, <span class="blue">int</span> width, <span class="blue">int</span> height) {&#13;
<strong><span class="cviolet">29</span></strong>     <span class="blue">return</span> length * width * height;&#13;
<strong><span class="cviolet">30</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>The default box volume is: 1</code>&#13;
&#13;
<code>The volume of a box with length 10,&#13;
width 1 and height 1 is: 10</code>&#13;
&#13;
<code>The volume of a box with length 10,&#13;
width 5 and height 1 is: 50</code>&#13;
&#13;
<code>The volume of a box with length 10,&#13;
width 5 and height 2 is: 100</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.10</strong></span> Using default arguments.</p>&#13;
</div>&#13;
<p>The first call to <code>boxVolume</code> (line 11) specifies no arguments, thus using all three default values of 1. The second call (line 15) passes only a <code>length</code> argument, thus using default values of 1 for the <code>width</code> and <code>height</code> arguments. The third call (line 19) passes arguments for only <code>length</code> and <code>width</code>, thus using a default value of 1 for the <code>height</code> argument. The last call (line 23) passes arguments for <code>length</code>, <code>width</code> and <code>height</code>, thus using no default values. Any arguments passed to the function explicitly are assigned to the function’s parameters from left to right. Therefore, when <code>boxVolume</code> receives one argument, the function assigns the value of that argument to its <code>length</code> parameter (i.e., the leftmost parameter in the parameter list). When <code>boxVolume</code> receives two arguments, the function assigns the values of those arguments to its <code>length</code> and <code>width</code> parameters in that order. Finally, when <code>boxVolume</code> receives all three arguments, the function assigns the values of those arguments to its <code>length</code>, <code>width</code> and <code>height</code> parameters, respectively.</p>&#13;
<h5 class="h5" id="ch05lev3sec40">Notes Regarding Default Arguments</h5>&#13;
<p>Default arguments must be the rightmost (trailing) arguments in a function’s parameter list. When calling a function with two or more default arguments, if an omitted argument is not the rightmost argument, then all arguments to the right of that argument also must be omitted. Default arguments must be specified with the first occurrence of the function name—typically, in the function prototype. If the function prototype is omitted because the function definition also serves as the prototype, then the default arguments should be specified in the function header. Default values can be any expression, including constants, global variables or function calls. Default arguments also can be used with <code>inline</code> functions. Using default arguments can simplify writing function calls, but some programmers feel that explicitly specifying all arguments is clearer.</p>&#13;
<h3 class="h3" id="ch05lev1sec15"><span class="violet">5.15</span> Unary Scope Resolution Operator</h3>&#13;
<p>C++ provides the <span class="violet"><strong>unary</strong></span> <span class="violet"><strong>scope resolution operator (</strong></span><code><strong><span class="violet">::</span></strong></code><span class="violet"><strong>)</strong></span> to access a global variable when a local variable of the same name is in scope. The unary scope resolution operator cannot be used to access a local variable of the same name in an outer block. A global variable can be accessed directly without the unary scope resolution operator if the name of the global variable is not the same as that of a local variable in scope.</p>&#13;
<p><a href="ch05.xhtml#fig5_11">Figure 5.11</a> shows the unary scope resolution operator with local and global variables of the same name (lines 6 and 9). To emphasize that the local and global versions of variable <code>number</code> are distinct, the program declares one variable <code>int</code> and the other <code>double</code>.</p>&#13;
<div class="group" id="fig5_11">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig11" id="a05fig11">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_11.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Unary scope resolution operator.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="yell"><span class="blue">int</span> number{<span class="green">7</span>}; <span class="lgreen">// global variable named number</span></span>&#13;
<strong><span class="cviolet"> 7</span></strong>&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="yell"><span class="blue">double</span> number{<span class="green">10.5</span>}; <span class="lgreen">// local variable named number</span></span>&#13;
<strong><span class="cviolet">10</span></strong>&#13;
<strong><span class="cviolet">11</span></strong>     <span class="lgreen">// display values of local and global variables</span>&#13;
<strong><span class="cviolet">12</span></strong>     cout &lt;&lt; <span class="green">"Local double value of number = "</span> &lt;&lt; <span class="yell">number</span>&#13;
<strong><span class="cviolet">13</span></strong>        &lt;&lt; <span class="green">"\nGlobal int value of number = "</span> &lt;&lt; <span class="yell">::number</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">14</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>Local double value of number = 10.5</code>&#13;
<code>Global int value of number = 7</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.11</strong></span> Unary scope resolution operator.</p>&#13;
</div>&#13;
<p>Always use the unary scope resolution operator (<code>::</code>) to refer to global variables (even if there is no collision with a local-variable name). This makes it clear that you’re accessing a global variable rather than a local variable. It also makes programs easier to modify by reducing the risk of name collisions with nonglobal variables and eliminates logic errors that might occur if a local variable hides the global variable. Avoid using variables of the same name for different purposes in a program. Although this is allowed in various circumstances, it can lead to errors.</p>&#13;
<h3 class="h3" id="ch05lev1sec16"><span class="violet">5.16</span> Function Overloading</h3>&#13;
<p>C++ enables several functions of the same name to be defined, as long as they have different signatures. This is called <span class="violet"><strong>function overloading</strong></span>. The C++ compiler selects the proper function to call by examining the number, types and order of the arguments in the call. Function overloading is used to create several functions of the same name that perform similar tasks but on data of different types. For example, many functions in the math library are overloaded for different numeric types—the C++ standard requires <code>float</code>, <code>double</code> and <code>long double</code> overloaded versions of the math library functions in <a href="ch05.xhtml#ch05lev1sec3">Section 5.3</a>. Overloading functions that perform closely related tasks can make programs clearer.</p>&#13;
<h5 class="h5" id="ch05lev3sec41">Overloaded <code>square</code> Functions</h5>&#13;
<p><a href="ch05.xhtml#fig5_12">Figure 5.12</a> uses overloaded <code>square</code> functions to calculate the square of an <code>int</code> (lines 7–10) and the square of a <code>double</code> (lines 13–16). Line 19 invokes the <code>int</code> version of function <code>square</code> by passing the literal value <code>7</code>. C++ treats whole-number literal values as type <code>int</code>. Similarly, line 21 invokes the <code>double</code> version of function <code>square</code> by passing the literal value <code>7.5</code>, which C++ treats as a <code>double</code>. In each case, the compiler chooses the proper function to call, based on the type of the argument. The output confirms that the proper function was called in each case.</p>&#13;
<div class="group" id="fig5_12">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig12" id="a05fig12">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_12.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Overloaded square functions.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="lgreen">// function square for int values</span>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="yell"><span class="blue">int</span> square(<span class="blue">int</span> x) {</span>&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="yell">cout &lt;&lt; <span class="green">"square of integer "</span> &lt;&lt; x &lt;&lt; <span class="green">" is "</span>;</span>&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="blue">return</span> x * x;&#13;
<strong><span class="cviolet">10</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>  <span class="lgreen">// function square for double values</span>&#13;
<strong><span class="cviolet">13</span></strong>  <span class="yell"><span class="blue">double</span> square(<span class="blue">double</span> y) {</span>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="yell">cout &lt;&lt; <span class="green">"square of double "</span> &lt;&lt; y &lt;&lt; <span class="green">" is "</span>;</span>&#13;
<strong><span class="cviolet">15</span></strong>     <span class="blue">return</span> y * y;&#13;
<strong><span class="cviolet">16</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet">17</span></strong>&#13;
<strong><span class="cviolet">18</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">19</span></strong>     cout &lt;&lt; <span class="yell">square(<span class="green">7</span>)</span>; <span class="lgreen">// calls int version</span>&#13;
<strong><span class="cviolet">20</span></strong>     <code>cout &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">21</span></strong>     cout &lt;&lt; <span class="yell">square(<span class="green">7.5</span>)</span>; <span class="lgreen">// calls double version</span>&#13;
<strong><span class="cviolet">22</span></strong>     <code>cout &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">23</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>square of integer 7 is 49&#13;
square of double 7.5 is 56.25</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.12</strong></span> Overloaded <code>square</code> functions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec42">How the Compiler Differentiates Among Overloaded Functions</h5>&#13;
<p>Overloaded functions are distinguished by their signatures. A signature is a combination of a function’s name and its parameter types (in order). <span class="violet"><strong>Type-safe linkage</strong></span> ensures that the proper function is called and that the types of the arguments conform to the types of the parameters. To enable type-safe linkage, the compiler internally encodes each function identifier with the types of its parameters—a process referred to as <span class="violet"><strong>name mangling</strong></span>. These encodings vary by compiler, so everything that will be linked to create an executable for a given platform must be compiled using the same compiler for that platform. <a href="ch05.xhtml#fig5_13">Figure 5.13</a> was compiled with GNU C++.<sup><a id="rch0fn17" href="ch05.xhtml#ch0fn17">17</a></sup> Rather than showing the execution output of the program as we normally would, we show the mangled function names produced in assembly language by GNU C++. <sup><a id="rch0fn18" href="ch05.xhtml#ch0fn18">18</a></sup></p>&#13;
<p class="footnote"><a id="ch0fn17" href="ch05.xhtml#rch0fn17">17</a>. The empty-bodied <code>main</code> function ensures that we do not get a linker error if we compile this code.</p>&#13;
<p class="footnote"><a id="ch0fn18" href="ch05.xhtml#rch0fn18">18</a>. The command <code>g++ -S fig05_13.cpp</code> produces the assembly language file <code>fig05_14.s</code>.</p>&#13;
<div class="group" id="fig5_13">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig13" id="a05fig13">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_13.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Name mangling to enable type-safe linkage.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="lgreen">// function square for int values</span>&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="yell"><span class="blue">int</span> square(<span class="blue">int</span> x)</span> {&#13;
<strong><span class="cviolet"> 6</span></strong>     <span class="blue">return</span> x * x;&#13;
<strong><span class="cviolet"> 7</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="lgreen">// function square for double values</span>&#13;
<strong><span class="cviolet">10</span></strong>  <span class="yell"><span class="blue">double</span> square(<span class="blue">double</span> y)</span> {&#13;
<strong><span class="cviolet">11</span></strong>     <span class="blue">return</span> y * y;&#13;
<strong><span class="cviolet">12</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>  <span class="lgreen">// function that receives arguments of types</span>&#13;
<strong><span class="cviolet">15</span></strong>  <span class="lgreen">// int, float, char and int&amp;</span>&#13;
<strong><span class="cviolet">16</span></strong>  <span class="yell"><span class="blue">void</span> nothing1(<span class="blue">int</span> a, <span class="blue">float</span> b, <span class="blue">char</span> c, <span class="blue">int</span>&amp; d)</span> { }&#13;
<strong><span class="cviolet">17</span></strong>&#13;
<strong><span class="cviolet">18</span></strong>  <span class="lgreen">// function that receives arguments of types</span>&#13;
<strong><span class="cviolet">19</span></strong>  <span class="lgreen">// char, int, float&amp; and double&amp;</span>&#13;
<strong><span class="cviolet">20</span></strong>  <span class="yell"><span class="blue">int</span> nothing2(<span class="blue">char</span> a, <span class="blue">int</span> b, <span class="blue">float</span>&amp; c, <span class="blue">double</span>&amp; d)</span> {&#13;
<strong><span class="cviolet">21</span></strong>     <span class="blue">return</span> <span class="green">0</span>;&#13;
<strong><span class="cviolet">22</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet">23</span></strong>&#13;
<strong><span class="cviolet">24</span></strong>  <span class="blue">int</span> main() { }</pre>&#13;
<pre class="pre1"><code>_Z6squarei&#13;
_Z6squared&#13;
_Z8nothing1ifcRi&#13;
_Z8nothing2ciRfRd&#13;
main</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.13</strong></span> Name mangling to enable type-safe linkage.</p>&#13;
</div>&#13;
<p>For GNU C++, each mangled name (other than <code>main</code>) begins with an underscore (<code>_</code>) followed by the letter <code>Z</code>, a number and the function name. The number that follows <code>Z</code> specifies how many characters are in the function’s name. For example, function <code>square</code> has 6 characters in its name, so its mangled name is prefixed with <code>_Z6</code>. Following the function name is an encoding of its parameter list:</p>&#13;
<p class="bull">• For function <code>square</code> that receives an <code>int</code> (line 5), <code>i</code> represents <code>int</code>, as shown in the output’s first line.</p>&#13;
<p class="bull">• For function <code>square</code> that receives a <code>double</code> (line 10), <code>d</code> represents <code>double</code>, as shown in the output’s second line.</p>&#13;
<p class="bull">• For function <code>nothing1</code> (line 16), <code>i</code> represents an <code>int</code>, <code>f</code> represents a <code>float</code>, <code>c</code> represents a <code>char</code>, and <code>Ri</code> represents an <code>int&amp;</code> (i.e., a reference to an <code>int</code>), as shown in the output’s third line.</p>&#13;
<p class="bull">• For function <code>nothing2</code> (line 20), <code>c</code> represents a <code>char</code>, <code>i</code> represents an <code>int</code>, <code>Rf</code> rep-resents a <code>float&amp;</code>, and <code>Rd</code> represents a <code>double&amp;</code>.</p>&#13;
<p>The compiler distinguishes the two <code>square</code> functions by their parameter lists—one specifies <code>i</code> for <code>int</code> and the other <code>d</code> for <code>double</code>. The return types of the functions are not specified in the mangled names. Overloaded functions can have different return types, but if they do, they must also have different parameter lists. Function-name mangling is compiler-specific. For example, Visual C++ produces the name <code>square@@YAHH@Z</code> for the square function at line 5. The GNU C++ compiler did not mangle <code>main</code>’s name, but some compilers do. For example, Visual C++ uses <code>_main</code>.</p>&#13;
<p>Creating overloaded functions with identical parameter lists and different return types is a compilation error. The compiler uses only the parameter lists to distinguish between overloaded functions. Such functions need not have the same number of parameters.</p>&#13;
<p>A function with default arguments omitted might be called identically to another overloaded function; this is a compilation error. For example, having a program that contains both a function that explicitly takes no arguments and a function of the same name that contains all default arguments results in a compilation error when an attempt is made to use that function name in a call passing no arguments. The compiler cannot unambiguously determine which version of the function to choose.</p>&#13;
<h5 class="h5" id="ch05lev3sec43">Overloaded Operators</h5>&#13;
<p>In <a href="ch14.xhtml#ch14">Chapter 14</a>, we discuss how to overload operators to define how they should operate on objects of user-defined data types. (In fact, we’ve been using many overloaded operators to this point, including the stream insertion <code>&lt;&lt;</code> and the stream extraction <code>&gt;&gt;</code> operators. These are overloaded for all the fundamental types. We say more about overloading <code>&lt;&lt;</code> and <code>&gt;&gt;</code> to be able to handle objects of user-defined types in <a href="ch14.xhtml#ch14">Chapter 14</a>.)</p>&#13;
<h3 class="h3" id="ch05lev1sec17"><span class="violet">5.17</span> Function Templates</h3>&#13;
<p>Overloaded functions are normally used to perform similar operations that involve different program logic on different data types. If the program logic and operations are identical for each data type, overloading may be performed more compactly and conveniently by using <span class="violet"><strong>function templates</strong></span>. You write a single function template definition. Given the argument types provided in calls to this function, C++ automatically generates separate <span class="violet"><strong>function template specializations</strong></span> to handle each type of call appropriately. Thus, defining a single function template essentially defines a whole family of overloaded functions.</p>&#13;
<h5 class="h5" id="ch05lev3sec44"><code>maximum</code> Function Template</h5>&#13;
<p><a href="ch05.xhtml#fig5_14">Figure 5.14</a> defines a <code>maximum</code> function template that determines the largest of three values. All function template definitions begin with the <code><strong><span class="violet">template</span></strong></code> <span class="violet"><strong>keyword</strong></span> (line 3) followed by a <span class="violet"><strong>template parameter list</strong></span> enclosed in angle brackets (<code>&lt;</code> and <code>&gt;</code>). Every parameter in the template parameter list is preceded by keyword <code><strong><span class="violet">typename</span></strong></code> or keyword <code>class</code> (they are synonyms in this context). The <span class="violet"><strong>type parameters</strong></span> are placeholders for fundamental types or user-defined types. These placeholders—in this case, <code>T</code>—are used to specify the types of the function’s parameters (line 4), to specify the function’s return type (line 4) and to declare variables within the body of the function definition (line 5). A function template is defined like any other function but uses the type parameters as placeholders for actual data types.</p>&#13;
<div class="group" id="fig5_14">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig14" id="a05fig14">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// Fig. 5.14: maximum.h</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Function template maximum header.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="yell"><span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt; <span class="lgreen">// or template&lt;class T&gt;</span></span>&#13;
<strong><span class="cviolet"> 4</span></strong>  <code><span class="yell">T</span> maximum(<span class="yell">T</span> value1, <span class="yell">T</span> value2, <span class="yell">T</span> value3) {</code>&#13;
<strong><span class="cviolet"> 5</span></strong>     <span class="yell">T</span> maximumValue{value1}; <span class="lgreen">// assume value1 is maximum</span>&#13;
<strong><span class="cviolet"> 6</span></strong>&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="lgreen">// determine whether value2 is greater than maximumValue</span>&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="blue">if</span> (value2 &gt; maximumValue) {&#13;
<strong><span class="cviolet"> 9</span></strong>        <code>maximumValue = value2;</code>&#13;
<strong><span class="cviolet">10</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>     <span class="lgreen">// determine whether value3 is greater than maximumValue</span>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="blue">if</span> (value3 &gt; maximumValue) {&#13;
<strong><span class="cviolet">14</span></strong>        <code>maximumValue = value3;</code>&#13;
<strong><span class="cviolet">15</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>     <span class="blue">return</span> maximumValue;&#13;
<strong><span class="cviolet">18</span></strong>  <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.14</strong></span> Function template <code>maximum</code> header.</p>&#13;
</div>&#13;
<p>This function template declares a single type parameter <code>T</code> (line 3) as a placeholder for the type of the data to be tested by function <code>maximum</code>. The name of a type parameter must be unique in the template parameter list for a particular template definition. When the compiler encounters a call to <code>maximum</code> in the program source code, the compiler substitutes the argument types in the <code>maximum</code> call for <code>T</code> throughout the template definition, creating a complete function template specialization that determines the maximum of three values of the specified type. The values must have the same type, since we use only one type parameter in this example. Then the newly created function is compiled—templates are a means of code generation. We’ll use C++ Standard Library templates that require multiple type parameters in <a href="ch16.xhtml#ch16">Chapter 16</a>.</p>&#13;
<h5 class="h5" id="ch05lev3sec45">Using Function Template <code>maximum</code></h5>&#13;
<p><a href="ch05.xhtml#fig5_15">Figure 5.15</a> uses the <code>maximum</code> function template to determine the largest of three <code>int</code> values, three <code>double</code> values and three <code>char</code> values, respectively (lines 15, 24 and 33). Because each call uses arguments of a different type, “behind the scenes” the compiler creates a separate function definition for each—one expecting three <code>int</code> values, one expecting three <code>double</code> values and one expecting three <code>char</code> values, respectively.</p>&#13;
<div class="group" id="fig5_15">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig15" id="a05fig15">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_15.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Function template maximum test program.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="yell"><span class="blue">#include</span> <span class="green">"maximum.h"</span> <span class="lgreen">// include definition of function template maximum</span></span>&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 6</span></strong>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="lgreen">// demonstrate maximum with int values</span>&#13;
<strong><span class="cviolet"> 9</span></strong>     cout &lt;&lt; <span class="green">"Input three integer values: "</span>;&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">int</span> int1, int2, int3;&#13;
<strong><span class="cviolet">11</span></strong>     <code>cin &gt;&gt; int1 &gt;&gt; int2 &gt;&gt; int3;</code>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="lgreen">// invoke int version of maximum</span>&#13;
<strong><span class="cviolet">14</span></strong>     cout &lt;&lt; <span class="green">"The maximum integer value is: "</span>&#13;
<strong><span class="cviolet">15</span></strong>        <code>&lt;&lt; <span class="yell">maximum(int1, int2, int3)</span>;</code>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>     <span class="lgreen">// demonstrate maximum with double values</span>&#13;
<strong><span class="cviolet">18</span></strong>     cout &lt;&lt; <span class="green">"\n\nInput three double values: "</span>;&#13;
<strong><span class="cviolet">19</span></strong>     <span class="blue">double</span> double1, double2, double3;&#13;
<strong><span class="cviolet">20</span></strong>     <code>cin &gt;&gt; double1 &gt;&gt; double2 &gt;&gt; double3;</code>&#13;
<strong><span class="cviolet">21</span></strong>&#13;
<strong><span class="cviolet">22</span></strong>     <span class="lgreen">// invoke double version of maximum</span>&#13;
<strong><span class="cviolet">23</span></strong>     cout &lt;&lt; <span class="green">"The maximum double value is: "</span>&#13;
<strong><span class="cviolet">24</span></strong>        <code>&lt;&lt; <span class="yell">maximum(double1, double2, double3)</span>;</code>&#13;
<strong><span class="cviolet">25</span></strong>&#13;
<strong><span class="cviolet">26</span></strong>     <span class="lgreen">// demonstrate maximum with char values</span>&#13;
<strong><span class="cviolet">27</span></strong>     cout &lt;&lt; <span class="green">"\n\nInput three characters: "</span>;&#13;
<strong><span class="cviolet">28</span></strong>     <span class="blue">char</span> char1, char2, char3;&#13;
<strong><span class="cviolet">29</span></strong>     <code>cin &gt;&gt; char1 &gt;&gt; char2 &gt;&gt; char3;</code>&#13;
<strong><span class="cviolet">30</span></strong>&#13;
<strong><span class="cviolet">31</span></strong>     <span class="lgreen">// invoke char version of maximum</span>&#13;
<strong><span class="cviolet">32</span></strong>     cout &lt;&lt; <span class="green">"The maximum character value is: "</span>&#13;
<strong><span class="cviolet">33</span></strong>        <code>&lt;&lt; <span class="yell">maximum(char1, char2, char3)</span> &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">34</span></strong>  }</pre>&#13;
<pre class="pre1"><code>Input three integer values: <strong>1 2 3</strong></code>&#13;
<code>The maximum integer value is: 3</code>&#13;
&#13;
<code>Input three double values: <strong>3.3 2.2 1.1</strong></code>&#13;
<code>The maximum double value is: 3.3</code>&#13;
&#13;
<code>Input three characters: <strong>A C B</strong></code>&#13;
<code>The maximum character value is: C</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.15</strong></span> Function template <code>maximum</code> test program.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec46"><code>maximum</code> Function Template Specialization for Type <code>int</code></h5>&#13;
<p>The function template specialization created for type <code>int</code> replaces each occurrence of <code>T</code> with <code>int</code> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0145-01" id="f0145-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> maximum(<span class="blue">int</span> value1, <span class="blue">int</span> value2, <span class="blue">int</span> value3) {&#13;
   <span class="blue">int</span> maximumValue{value1}; <span class="lgreen">// assume value1 is maximum</span>&#13;
&#13;
   <span class="lgreen">// determine whether value2 is greater than maximumValue</span>&#13;
   <span class="blue">if</span> (value2 &gt; maximumValue) {&#13;
      maximumValue = value2;&#13;
   }&#13;
&#13;
   <span class="lgreen">// determine whether value3 is greater than maximumValue</span>&#13;
   <span class="blue">if</span> (value3 &gt; maximumValue) {&#13;
      maximumValue = value3;&#13;
   }&#13;
&#13;
   <span class="blue">return</span> maximumValue;&#13;
}</pre>&#13;
<h3 class="h3" id="ch05lev1sec18"><span class="violet">5.18</span> Recursion</h3>&#13;
<p>For some problems, it’s useful to have functions call themselves. A <span class="violet"><strong>recursive function</strong></span> is a function that calls itself, either directly or indirectly (through another function). This section and the next present simple examples of recursion. Recursion is discussed at length in upper-level computer science courses.</p>&#13;
<h5 class="h5" id="ch05lev3sec47">Recursion Concepts</h5>&#13;
<p>We first consider recursion conceptually, then examine programs containing recursive functions. Recursive problem-solving approaches have several elements in common. A recursive function is called to solve a problem. The function knows how to solve only the simplest case(s), or so-called <span class="violet"><strong>base case(s)</strong></span>. If the function is called with a base case, the function simply returns a result. If the function is called with a more complex problem, it typically divides the problem into two conceptual pieces—a piece that the function knows how to do and a piece that it does not know how to do. To make recursion feasible, the latter piece must resemble the original problem, but be a slightly simpler or smaller version. This new problem looks like the original, so the function calls a copy of itself to work on the smaller problem—this is referred to as a <span class="violet"><strong>recursive call</strong></span> and is also called the <span class="violet"><strong>recursion step</strong></span>. The recursion step often includes the keyword <code>return</code>, because its result will be combined with the portion of the problem the function knew how to solve to form the result passed back to the original caller, possibly <code>main</code>.</p>&#13;
<p>Omitting the base case or writing the recursion step incorrectly so that it does not converge on the base case causes an infinite recursion error, typically causing a stack overflow. This is analogous to the problem of an infinite loop in an iterative (nonrecursive) solution. Accidentally having a nonrecursive function call itself, either directly or indirectly through another function, also causes an infinite recursion.</p>&#13;
<p>The recursion step executes while the original call to the function is still “open,” i.e., it has not yet finished executing. The recursion step can result in many more such recursive calls, as the function keeps dividing each new subproblem with which the function is called into two conceptual pieces. For the recursion to eventually terminate, each time the function calls itself with a slightly simpler version of the original problem, this sequence of smaller and smaller problems must eventually converge on the base case. At that point, the function recognizes the base case and returns a result to the previous copy of the function. Then, a sequence of returns ensues up the line until the original call eventually returns the final result to <code>main</code>.<sup><a id="rch0fn19" href="ch05.xhtml#ch0fn19">19</a></sup> This sounds quite exotic compared to the kind of problem-solving we’ve been using to this point. As an example of these concepts at work, let’s write a recursive program to perform a popular mathematical calculation.</p>&#13;
<p class="footnote"><a id="ch0fn19" href="ch05.xhtml#rch0fn19">19</a>. The C++ standard document indicates that <code>main</code> should not be called within a program (Section 6.9.3.1) or recursively (Section 7.6.1.2). Its sole purpose is to be the starting point for program execution.</p>&#13;
<h5 class="h5" id="ch05lev3sec48">Factorial</h5>&#13;
<p>The factorial of a non-negative integer <em>n</em>, written <em>n</em>! (pronounced “<em>n</em> factorial”), is the product</p>&#13;
<p class="web"><em>n</em> <code>·</code> (<em>n</em> – 1) <code>·</code> (<em>n</em> – 2) · … · 1</p>&#13;
<p>with 1! equal to 1, and 0! defined to be 1. For example, 5! is the product 5 · 4 · 3 · 2 · 1, which is equal to 120.</p>&#13;
<h5 class="h5" id="ch05lev3sec49">Iterative Factorial</h5>&#13;
<p>The factorial of an integer, <code>number</code>, greater than or equal to 0, can be calculated <span class="violet"><strong>iteratively</strong></span> (nonrecursively) by using a <code>for</code> statement as follows:</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0146-01" id="f0146-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">int</span> factorial{<span class="green">1</span>};&#13;
&#13;
<span class="blue">for</span> (<span class="blue">int</span> counter{number}; counter &gt;= <span class="green">1</span>; --counter) {&#13;
   factorial *= counter;&#13;
}</pre>&#13;
<h5 class="h5" id="ch05lev3sec50">Recursive Factorial</h5>&#13;
<p>A recursive definition of the factorial function is arrived at by observing the following algebraic relationship:</p>&#13;
<p class="web"><em>n</em>! = <em>n</em> · (<em>n</em> – 1)!</p>&#13;
<p>For example, 5! is clearly equal to 5 * 4! as is shown by the following:</p>&#13;
<p class="web">5! = 5 · 4 · 3 · 2 · 1<br/>5! = 5 · (4 · 3 · 2 · 1)<br/>5! = 5 · (4!)</p>&#13;
<h5 class="h5" id="ch05lev3sec51">Evaluating 5!</h5>&#13;
<p>The evaluation of 5! would proceed as shown in the following diagram, which illustrates how the succession of recursive calls proceeds until 1! is evaluated to be 1, terminating the recursion. Part (b) of the diagram shows the values returned from each recursive call to its caller until the final value is calculated and returned.</p>&#13;
<div class="image"><img src="Images/05unfig01.jpg" alt="Images" width="666" height="446"/></div>&#13;
<h5 class="h5" id="ch05lev3sec52">Using a Recursive <code>factorial</code> Function to Calculate Factorials</h5>&#13;
<p><a href="ch05.xhtml#fig5_16">Figure 5.16</a> uses recursion to calculate and print the factorials of the integers 0–10. The recursive function <code>factorial</code> (lines 18–25) first determines whether the terminating condition <code>number &lt;= 1</code> (i.e., the base case; line 19) is true. If <code>number</code> is less than or equal to 1, the <code>factorial</code> function returns 1 (line 20), no further recursion is necessary and the function terminates. If <code>number</code> is greater than 1, line 23 expresses the problem as the product of <code>number</code> and a recursive call to <code>factorial</code> evaluating the factorial of <code>number - 1</code>, which is a slightly simpler problem than the original calculation <code>factorial(number)</code>.</p>&#13;
<div class="group" id="fig5_16">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig16" id="a05fig16">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_16.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Recursive function factorial.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iomanip&gt;&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 6</span></strong>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="yell"><span class="blue">long</span> factorial(<span class="blue">long</span> number); <span class="lgreen">// function prototype</span></span>&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">10</span></strong>     <span class="lgreen">// calculate the factorials of 0 through 10</span>&#13;
<strong><span class="cviolet">11</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> counter{<span class="green">0</span>}; counter &lt;= <span class="green">10</span>; ++counter) {&#13;
<strong><span class="cviolet">12</span></strong>        cout &lt;&lt; setw(2) <span class="green">&lt;</span>&lt; counter &lt;&lt; <span class="green">"! = "</span> &lt;&lt; <span class="yell">factorial(counter)</span>&#13;
<strong><span class="cviolet">13</span></strong>           <code>&lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">14</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">15</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>  <span class="yell"><span class="lgreen">// recursive definition of function factorial</span>   </span>&#13;
<strong><span class="cviolet">18</span></strong>  <span class="yell"><span class="blue">long</span> factorial(<span class="blue">long</span> number) {                   </span>&#13;
<strong><span class="cviolet">19</span></strong>  <span class="yell">   <span class="blue">if</span> (number &lt;= <span class="green">1</span>) { <span class="lgreen">// test for base case</span>     </span>&#13;
<strong><span class="cviolet">20</span></strong>  <span class="yell">      <span class="blue">return</span> <span class="green">1</span>; <span class="lgreen">// base cases: 0! = 1 and 1! = 1</span></span>&#13;
<strong><span class="cviolet">21</span></strong>  <span class="yell">   <code>}</code>                                            </span>&#13;
<strong><span class="cviolet">22</span></strong>  <span class="yell">   <span class="blue">else</span> { <span class="lgreen">// recursion step</span>                     </span>&#13;
<strong><span class="cviolet">23</span></strong>  <span class="yell">      <span class="blue">return</span> number * factorial(number - <span class="green">1</span>);    </span>&#13;
<strong><span class="cviolet">24</span></strong>  <span class="yell">   <code>}</code>                                            </span>&#13;
<strong><span class="cviolet">25</span></strong>  <span class="yell"><code>}</code>                                               </span></pre>&#13;
<pre class="pre1"><code>0! = 1&#13;
1! = 1&#13;
2! = 2&#13;
3! = 6&#13;
4! = 24&#13;
5! = 120&#13;
6! = 720&#13;
7! = 5040&#13;
8! = 40320&#13;
9! = 362880&#13;
10! = 3628800</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.16</strong></span> Recursive function <code>factorial</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec53">Factorial Values Grow Quickly</h5>&#13;
<p>Function <code>factorial</code> receives a parameter of type <code>long</code> and returns a result of type <code>long</code>. Typically, a <code>long</code> is stored in at least four bytes (32 bits); such a variable can hold a value in the range –2,147,483,647 to 2,147,483,647. Unfortunately, the function <code>factorial</code> produces large values so quickly that type <code>long</code> does not help us compute many factorial values before reaching the maximum value of a <code>long</code>. For larger integer values, we could use type <code>long long</code> (<a href="ch03.xhtml#ch03lev1sec11">Section 3.11</a>) or a class that represents arbitrary sized integers (such as the open-source <code>BigNumber</code> class we introduced in <a href="ch03.xhtml#ch03lev1sec12">Section 3.12</a>).</p>&#13;
<h3 class="h3" id="ch05lev1sec19"><span class="violet">5.19</span> Example Using Recursion: Fibonacci Series</h3>&#13;
<p>The Fibonacci series</p>&#13;
<p class="web">0, 1, 1, 2, 3, 5, 8, 13, 21, …</p>&#13;
<p>begins with 0 and 1 and has the property that each subsequent Fibonacci number is the sum of the previous two Fibonacci numbers.</p>&#13;
<p>The series occurs in nature and, in particular, describes a form of a spiral. The ratio of successive Fibonacci numbers converges on a constant value of 1.618…. This number frequently occurs in nature and has been called the <span class="violet"><strong>golden ratio</strong></span> or the <span class="violet"><strong>golden mean.</strong></span> Humans tend to find the golden mean aesthetically pleasing. Architects often design windows, rooms and buildings whose length and width are in the ratio of the golden mean. Postcards are often designed with a golden mean length/width ratio. A web search for “Fibonacci in nature” reveals many interesting examples, including flower petals, shells, spiral galaxies, hurricanes and more.</p>&#13;
<h5 class="h5" id="ch05lev3sec54">Recursive Fibonacci Definition</h5>&#13;
<p>The Fibonacci series can be defined recursively as follows:</p>&#13;
<p class="web">fibonacci(0) = 0<br/>fibonacci(1) = 1<br/>fibonacci(<em>n</em>) = fibonacci(<em>n</em> – 1) + fibonacci(<em>n</em> – 2)</p>&#13;
<p>The program of <a href="ch05.xhtml#fig5_17">Fig. 5.17</a> calculates the <em>n</em>th Fibonacci number recursively by using function <code>fibonacci</code>. Fibonacci numbers tend to become large quickly, although slower than factorials do. <a href="ch05.xhtml#fig5_17">Figure 5.17</a> shows the execution of the program, which displays the Fibonacci values for several numbers.</p>&#13;
<div class="group" id="fig5_17">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig17" id="a05fig17">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_17.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Recursive function fibonacci.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="yell"><span class="blue">long</span> fibonacci(<span class="blue">long</span> number); <span class="lgreen">// function prototype</span></span>&#13;
<strong><span class="cviolet"> 7</span></strong>&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="lgreen">// calculate the fibonacci values of 0 through 10</span>&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> counter{<span class="green">0</span>}; counter &lt;= <span class="green">10</span>; ++counter)&#13;
<strong><span class="cviolet">11</span></strong>        cout &lt;&lt; <span class="green">"fibonacci("</span> &lt;&lt; counter &lt;&lt; <span class="green">") = "</span>&#13;
<strong><span class="cviolet">12</span></strong>           <code>&lt;&lt; <span class="yell">fibonacci(counter)</span> &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="lgreen">// display higher fibonacci values</span>&#13;
<strong><span class="cviolet">15</span></strong>     cout &lt;&lt; <span class="green">"\nfibonacci(20) = "</span> &lt;&lt; <span class="yell">fibonacci(<span class="green">20</span>)</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">16</span></strong>     cout &lt;&lt; <span class="green">"fibonacci(30) = "</span> &lt;&lt; <span class="yell">fibonacci(<span class="green">30</span>)</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">17</span></strong>     cout &lt;&lt; <span class="green">"fibonacci(35) = "</span> &lt;&lt; <span class="yell">fibonacci(<span class="green">35</span>)</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">18</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>  <span class="lgreen">// recursive function fibonacci</span>&#13;
<strong><span class="cviolet">21</span></strong>  <span class="yell"><span class="blue">long</span> fibonacci(<span class="blue">long</span> number)</span> {&#13;
<strong><span class="cviolet">22</span></strong>     <span class="yell"><span class="blue">if</span> ((<span class="green">0</span> == number) || (<span class="green">1</span> == number)) { <span class="lgreen">// base cases</span></span>&#13;
<strong><span class="cviolet">23</span></strong>        <span class="blue">return</span> number;&#13;
<strong><span class="cviolet">24</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">25</span></strong>     <span class="blue">else</span> { <span class="lgreen">// recursion step</span>&#13;
<strong><span class="cviolet">26</span></strong>        <span class="yell"><span class="blue">return</span> fibonacci(number - <span class="green">1</span>) + fibonacci(number - <span class="green">2</span>);</span>&#13;
<strong><span class="cviolet">27</span></strong>     <code>}</code>&#13;
<strong><span class="cviolet">28</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>fibonacci(0) = 0&#13;
fibonacci(1) = 1&#13;
fibonacci(2) = 1&#13;
fibonacci(3) = 2&#13;
fibonacci(4) = 3&#13;
fibonacci(5) = 5&#13;
fibonacci(6) = 8&#13;
fibonacci(7) = 13&#13;
fibonacci(8) = 21&#13;
fibonacci(9) = 34&#13;
fibonacci(10) = 55</code>&#13;
&#13;
<code>fibonacci(20) = 6765&#13;
fibonacci(30) = 832040&#13;
fibonacci(35) = 9227465</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.17</strong></span> Recursive function <code>fibonacci</code>.</p>&#13;
</div>&#13;
<p>The application begins with a loop that calculates and displays the Fibonacci values for the integers 0–10 and is followed by three calls to calculate the Fibonacci values of the integers 20, 30 and 35 (lines 15–17). The calls to <code>fibonacci</code> in <code>main</code> (lines 12 and 15–17) are not recursive calls, but the calls from line 26 of <code>fibonacci</code> are recursive. Each time the program invokes <code>fibonacci</code> (lines 21–28), the function immediately tests the base case to determine whether <code>number</code> is equal to <code>0</code> or <code>1</code> (line 22). If this is true, line 23 returns <code>number</code>. Interestingly, if <code>number</code> is greater than 1, the recursion step (line 26) generates two recursive calls, each for a slightly smaller problem than the original call to <code>fibonacci</code>.</p>&#13;
<h5 class="h5" id="ch05lev3sec55">Evaluating <code>fibonacci(3)</code></h5>&#13;
<p>The following diagram shows how function <code>fibonacci</code> would evaluate <code>fibonacci(3)</code>. This figure raises some interesting issues about the order in which C++ compilers evaluate the operands of operators. This is a separate issue from the order in which operators are applied to their operands, namely, the order dictated by the rules of operator precedence and grouping. The following diagram shows that evaluating <code>fibonacci(3)</code> causes two recursive calls, namely, <code>fibonacci(2)</code> and <code>fibonacci(1)</code>. In what order are these calls made?</p>&#13;
<div class="image"><img src="Images/05unfig02.jpg" alt="Images" width="649" height="329"/></div>&#13;
<h5 class="h5" id="ch05lev3sec56">Order of Evaluation of Operands</h5>&#13;
<p>Most programmers simply assume that the operands are evaluated left to right, which is the case in some programming languages. C++ does not specify the order in which the operands of many operators (including <code>+</code>) are to be evaluated. Therefore, you must make no assumption about the order in which these calls execute. The calls could, in fact, execute <code>fibonacci(2)</code> first, then <code>fibonacci(1)</code>, or <code>fibonacci(1)</code> first, then <code>fibonacci(2)</code>. In this program and in most others, it turns out that the final result would be the same. However, in some programs, the evaluation of an operand can have <span class="violet"><strong>side effects</strong></span> (changes to data values) that could affect the final result of the expression.</p>&#13;
<h5 class="h5" id="ch05lev3sec57">Operators for which Order Of Evaluation Is Specified</h5>&#13;
<p>Before C++17, C++ specified the order of evaluation of the operands of only the operators <code>&amp;&amp;</code>, <code>||</code>, comma (<code>,</code>) and <code>?:</code>. The first three are binary operators whose two operands are guaranteed to be evaluated left to right. The last operator is C++’s only ternary operator— its leftmost operand is always evaluated first; if it evaluates to true, the middle operand evaluates next and the last operand is ignored; if the leftmost operand evaluates to false, the third operand evaluates next and the middle operand is ignored.</p>&#13;
<p><span class="size">17</span> As of C++17, C++ now also specifies the order of evaluation of the operands for various other operators. For the operators dot (<code>.</code>), <code>[]</code> (<a href="ch06.xhtml#ch06">Chapter 6</a>), <code>-&gt;</code> (<a href="ch07.xhtml#ch07">Chapter 7</a>), parentheses (of a function call), <code>&lt;&lt;</code>, <code>&gt;&gt;</code> and <code>-&gt;*</code>, the compiler evaluates the operands left-to-right. For a function call’s parentheses, this means that the compiler evaluates the function name before the arguments. The compiler evaluates the operands of assignment operators right-to-left.</p>&#13;
<p>Writing programs that depend on the order of evaluation of the operands of other operators can lead to logic errors. For other operators, to ensure that side effects are applied in the correct order, break complex expressions into separate statements. Recall that the <code>&amp;&amp;</code> and <code>||</code> operators use short-circuit evaluation. Placing an expression with a side effect on the right side of the <code>&amp;&amp;</code> or <code>||</code> operator is a logic error if that expression should always be evaluated.</p>&#13;
<h5 class="h5" id="ch05lev3sec58">Exponential Complexity</h5>&#13;
<p>A word of caution is in order about recursive programs like the one we use here to generate Fibonacci numbers. Each level of recursion in function <code>fibonacci</code> has a doubling effect on the number of function calls; i.e., the number of recursive calls that are required to calculate the <em>n</em>th Fibonacci number is on the order of 2<sup><em>n</em></sup>. This rapidly gets out of hand. Calculating only the 20th Fibonacci number would require on the order of 2<sup>20</sup> or about a million calls, calculating the 30th Fibonacci number would require on the order of 2<sup>30</sup> or about a billion calls, and so on. Computer scientists refer to this as <span class="violet"><strong>exponential complexity</strong></span>. Problems of this nature can humble even the world’s most powerful computers as <em>n</em> becomes large. Complexity issues in general, and exponential complexity in particular, are discussed in detail in the upper-level computer science course typically called Algorithms. Avoid Fibonacci-style recursive programs that result in an exponential “explosion” of calls.</p>&#13;
<h3 class="h3" id="ch05lev1sec20"><span class="violet">5.20</span> Recursion vs. Iteration</h3>&#13;
<p>In the two prior sections, we studied two recursive functions that can also be implemented with simple iterative programs. This section compares the two approaches and discusses why you might choose one approach over the other in a particular situation.</p>&#13;
<p class="bull">• Both iteration and recursion are based on a control statement: Iteration uses an iteration statement; recursion uses a selection statement.</p>&#13;
<p class="bull">• Both iteration and recursion involve iteration: Iteration explicitly uses an iteration statement; recursion achieves iteration through repeated function calls.</p>&#13;
<p class="bull">• Iteration and recursion each involve a termination test: Iteration terminates when the loop-continuation condition fails; recursion terminates when a base case is recognized.</p>&#13;
<p class="bull">• Counter-controlled iteration and recursion each gradually approach termination: Iteration modifies a counter until the counter assumes a value that makes the loop-continuation condition fail; recursion produces simpler versions of the original problem until the base case is reached.</p>&#13;
<p class="bull">• Both iteration and recursion can occur infinitely: An infinite loop occurs with iteration if the loop-continuation test never becomes false; infinite recursion occurs if the recursion step does not reduce the problem during each recursive call in a manner that converges on the base case.</p>&#13;
<h5 class="h5" id="ch05lev3sec59">Iterative Factorial Implementation</h5>&#13;
<p>To illustrate the differences between iteration and recursion, let’s examine an iterative solution to the factorial problem (<a href="ch05.xhtml#fig5_18">Fig. 5.18</a>). Lines 22–24 use an iteration statement rather than the selection statement of the recursive solution (lines 19–24 of <a href="ch05.xhtml#fig5_16">Fig. 5.16</a>). Both solutions use a termination test. In the recursive solution, line 19 (<a href="ch05.xhtml#fig5_16">Fig. 5.16</a>) tests for the base case. In the iterative solution, line 22 (<a href="ch05.xhtml#fig5_18">Fig. 5.18</a>) tests the loop-continuation condition— if the test fails, the loop terminates. Finally, instead of producing simpler versions of the original problem, the iterative solution uses a counter that’s modified until the loop-continuation condition becomes false.</p>&#13;
<div class="group" id="fig5_18">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig18" id="a05fig18">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_18.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Iterative function factorial.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iomanip&gt;&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 6</span></strong>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">unsigned long</span> factorial(<span class="blue">int</span> number); <span class="lgreen">// function prototype</span>&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">10</span></strong>     <span class="lgreen">// calculate the factorials of 0 through 10</span>&#13;
<strong><span class="cviolet">11</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> counter{<span class="green">0</span>}; counter &lt;= <span class="green">10</span>; ++counter) {&#13;
<strong><span class="cviolet">12</span></strong>        cout &lt;&lt; setw(2) <span class="green">&lt;</span>&lt; counter &lt;&lt; <span class="green">"! = "</span> &lt;&lt; <span class="yell">factorial(counter)</span>&#13;
<strong><span class="cviolet">13</span></strong>           <code>&lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">14</span></strong>     }&#13;
<strong><span class="cviolet">15</span></strong>  }&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>  <span class="lgreen">// iterative function factorial</span>&#13;
<strong><span class="cviolet">18</span></strong>  <span class="blue">unsigned long</span> factorial(<span class="blue">int</span> number) {&#13;
<strong><span class="cviolet">19</span></strong>     <span class="blue">unsigned long</span> result{<span class="green">1</span>};&#13;
<strong><span class="cviolet">20</span></strong>&#13;
<strong><span class="cviolet">21</span></strong>     <span class="lgreen">// iterative factorial calculation</span>&#13;
<strong><span class="cviolet">22</span></strong>     <span class="yell"><span class="blue">for</span> (<span class="blue">int</span> i{number}; i &gt;= <span class="green">1</span>; --i) {</span>&#13;
<strong><span class="cviolet">23</span></strong>     <span class="yell">   <code>result *= i;</code>                   </span>&#13;
<strong><span class="cviolet">24</span></strong>     <span class="yell"><code>}</code>                                 </span>&#13;
<strong><span class="cviolet">25</span></strong>&#13;
<strong><span class="cviolet">26</span></strong>     <span class="blue">return</span> result;&#13;
<strong><span class="cviolet">27</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>0! = 1&#13;
1! = 1&#13;
2! = 2&#13;
3! = 6&#13;
4! = 24&#13;
5! = 120&#13;
6! = 720&#13;
7! = 5040&#13;
8! = 40320&#13;
9! = 362880&#13;
10! = 3628800</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.18</strong></span> Iterative function <code>factorial</code>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec60">Negatives of Recursion</h5>&#13;
<p>Recursion has negatives. It repeatedly invokes the mechanism, and consequently the overhead, of function calls. This can be expensive in both processor time and memory space. Each recursive call causes another copy of the function variables to be created; this can consume considerable memory. Iteration normally occurs within a function, so the overhead of repeated function calls and extra memory assignment is omitted. So why choose recursion?</p>&#13;
<h5 class="h5" id="ch05lev3sec61">When to Choose Recursion vs. Iteration</h5>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> Any problem that can be solved recursively can also be solved iteratively (nonrecursively). A recursive approach is normally chosen when the recursive approach more naturally mirrors the problem and results in a program that’s easier to understand and debug. Another reason to choose a recursive solution is that an iterative solution may not be apparent when a recursive solution is. If possible, avoid using recursion in performance situations. Recursive calls take time and consume additional memory.</p>&#13;
<h3 class="h3" id="ch05lev1sec21"><span class="size">17</span> <span class="violet">5.21</span> C++17 and C++20: <code>[[nodiscard]]</code> Attribute</h3>&#13;
<p>Some functions return values that you should not ignore. For example, <a href="ch02.xhtml#ch02lev1sec7">Section 2.7</a> introduced the <code>string</code> member function <code>empty</code>. When you want to know whether a <code>string</code> is empty you must not only call <code>empty</code>, but also check its return value in a condition, such as:</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0154-01e" id="f0154-01ea">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">if</span> (s.empty()) {&#13;
   <span class="lgreen">// do something because the string s is empty</span>&#13;
}</pre>&#13;
<p>As of C++17, <code>string</code>’s <code>empty</code> function is declared with the <code><strong><span class="violet">[[nodiscard]]</span></strong></code> <span class="violet"><strong>attribute</strong></span><sup><a id="rch0fn20" href="ch05.xhtml#ch0fn20">20</a></sup> to tell the compiler to issue a warning when the return value is not used by the caller. Since C++17, many C++ Standard Library functions have been enhanced with <code>[[nodiscard]]</code> so the compiler can help you write correct code.</p>&#13;
<p class="footnote"><a id="ch0fn20" href="ch05.xhtml#rch0fn20">20</a>. Section 9.12.8 of the ISO/IEC C++20 standard document. <code><a href="https://wg21.link/n4849">https://wg21.link/n4849</a></code>.</p>&#13;
<p>You may also use this attribute on your own function definitions. <a href="ch05.xhtml#fig5_19">Figure 5.19</a> shows a <code>cube</code> function declared with <code>[[nodiscard]]</code>, which you place before the return type— typically on a line by itself (line 4).</p>&#13;
<div class="group" id="fig5_19">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig19" id="a05fig19">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig05_19.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// C++17 [[nodiscard]] attribute.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="yell"><code>[[nodiscard]]</code></span>&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">int</span> cube(<span class="blue">int</span> x) {&#13;
<strong><span class="cviolet"> 6</span></strong>     <span class="blue">return</span> x * x * x;&#13;
<strong><span class="cviolet"> 7</span></strong>  <code>}</code>&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">10</span></strong>     cube(<span class="green">10</span>); <span class="lgreen">// generates a compiler warning</span>&#13;
<strong><span class="cviolet">11</span></strong>  <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.19</strong></span> C++17 <code>[[nodiscard]]</code> attribute.</p>&#13;
</div>&#13;
<p>Line 10 calls <code>cube</code>, but does not use the returned value. When you compile this program our preferred compilers, they issue the following warnings:</p>&#13;
<p class="bull">• Microsoft Visual C++: <code>"discarding return value of function with 'nodis-card' attribute"</code></p>&#13;
<p class="bull">• Clang in Xcode: <code>"Ignoring return value of function declared with 'nodis-card' attribute</code></p>&#13;
<p class="bull">• GNU C++: <code>"ignoring return value of 'int cube(int)', declared with attribute nodiscard"</code></p>&#13;
<p>However, these are just warnings, so the program still compiles and runs.</p>&#13;
<h5 class="h5" id="ch05lev3sec62"><span class="size">20</span> C++20’s <code>[[nodiscard("with reason")]]</code> Attribute</h5>&#13;
<p>One problem with C++17’s <code>[[nodiscard]]</code> attribute is that it did not provide any insight into why you should not ignore a given function’s return value. So, in C++20, you can now include a message<sup><a id="rch0fn21" href="ch05.xhtml#ch0fn21">21</a></sup> that will be displayed as part of the compiler warning, as in:</p>&#13;
<p class="footnote"><a id="ch0fn21" href="ch05.xhtml#rch0fn21">21</a>. At the time of this writing, this feature is not yet implemented.</p>&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#f0154-01f" id="f0154-01fa">Click here to view code image</a></p>&#13;
<pre class="pre">[[nodiscard(<span class="green">"Insight into why return value should not be ignored"</span>)]]</pre>&#13;
<h3 class="h3" id="ch05lev1sec22"><span class="violet">5.22</span> Lnfylun Lhqtomh Wjtz Qarcv: Qjwazkrplm xzz Xndmwwqhlz</h3>&#13;
<p>No doubt, you’ve noticed that the last Objectives bullet for this chapter, the last section name in the chapter outline, the last sentence in <a href="ch05.xhtml#ch05lev1sec1">Section 5.1</a> and the section title above all look like gibberish. These are not mistakes! In this section, we continue our objects-natural presentation. You’ll conveniently encrypt and decrypt messages with an object you create of a preexisting class <code>that</code> implements a <span class="violet"><strong>Vignère secret key cipher</strong></span>.<sup><a id="rch0fn22" href="ch05.xhtml#ch0fn22">22</a></sup></p>&#13;
<p class="footnote"><a id="ch0fn22" href="ch05.xhtml#rch0fn22">22</a>. <code><a href="https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher">https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher</a></code>.</p>&#13;
<p>In prior objects-natural sections, you created objects of built-in C++ standard library class <code>string</code> and objects of classes from open-source libraries. Sometimes you’ll use classes built by your organization or team members for internal use or for use in a specific project. For this example, we wrote our own class called <code>Cipher</code> (in the header <code>"cipher.h"</code>) and provided it to you. In <a href="ch10.xhtml#ch10">Chapter 10</a>, Introduction to Classes, you’ll start building your own custom classes.</p>&#13;
<h5 class="h5" id="ch05lev3sec63">Cryptography</h5>&#13;
<p><img class="inline" src="Images/common02.jpg" alt="Images" width="22" height="31"/> <span class="size"><small>Security</small></span> Cryptography has been in use for thousands of years<sup><a id="rch0fn23" href="ch05.xhtml#ch0fn23">23</a>,<a id="rch0fn24" href="ch05.xhtml#ch0fn24">24</a></sup> and is critically important in today’s connected world. Every day, cryptography is used behind the scenes to ensure that your Internet-based communications are private and secure. For example, most websites now use the HTTPS protocol to encrypt and decrypt your web interactions.</p>&#13;
<p class="footnote"><a id="ch0fn23" href="ch05.xhtml#rch0fn23">23</a>. <code><a href="https://en.wikipedia.org/wiki/Cryptography#History_of_cryptography_and_cryptanalysis">https://en.wikipedia.org/wiki/Cryptography#History_of_cryptography_and_cryptanalysis</a></code>.</p>&#13;
<p class="footnote"><a id="ch0fn24" href="ch05.xhtml#rch0fn24">24</a>. <code><a href="https://www.binance.vision/security/history-of-cryptography">https://www.binance.vision/security/history-of-cryptography</a></code>.</p>&#13;
<h5 class="h5" id="ch05lev3sec64">Caesar Cipher</h5>&#13;
<p>Julius Caesar used a simple <span class="violet"><strong>substitution cipher</strong></span> to encrypt military communications.<sup><a id="rch0fn25" href="ch05.xhtml#ch0fn25">25</a></sup> His technique—which became known as the <span class="violet"><strong>Caesar cipher</strong></span>—replaces every letter in a communication with the letter three ahead in the alphabet. So, A is replaced with D, B with E, C with F, … X with A, Y with B and Z with C. Thus, the plain text</p>&#13;
<pre class="pre">Caesar Cipher</pre>&#13;
<p class="footnote"><a id="ch0fn25" href="ch05.xhtml#rch0fn25">25</a>. <code><a href="https://en.wikipedia.org/wiki/Caesar_cipher">https://en.wikipedia.org/wiki/Caesar_cipher</a></code>.</p>&#13;
<p>would be encrypted as</p>&#13;
<pre class="pre">Fdhvdu Flskhu</pre>&#13;
<p>The encrypted text is known as the <span class="violet"><strong>ciphertext</strong></span>.</p>&#13;
<p>For a fun way to play with the Caesar cipher and many other cipher techniques, check out the website:</p>&#13;
<pre class="pre"><a href="https://cryptii.com/pipes/caesar-cipher">https://cryptii.com/pipes/caesar-cipher</a></pre>&#13;
<p>which is an online implementation of the open-source <code>cryptii</code> project:</p>&#13;
<pre class="pre"><a href="https://github.com/cryptii/cryptii">https://github.com/cryptii/cryptii</a></pre>&#13;
<h5 class="h5" id="ch05lev3sec65">Vignère Cipher</h5>&#13;
<p>Simple substitution ciphers like the Caesar cipher are relatively easy to decrypt. For example, the letter “e” is the most frequently used letter in English. So, you could study ciphertext and assume with a high likelihood that the character appearing most frequently is probably an “e.”</p>&#13;
<p>In this example, you’ll use a Vignère cipher, which is a secret-key substitution cipher. A Vignère cipher is implemented using 26 Caesar ciphers—one for each letter of the alphabet. A Vignère cipher uses letters from the plain text and secret key to look up replacement characters in the various Caesar ciphers. You can read more about the implementation at</p>&#13;
<pre class="pre"><a href="https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher">https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher</a></pre>&#13;
<p>For this cipher, the secret key must be composed of letters. Like passwords, the secret key should not be something that’s easy to guess. In this example, we used the 11 randomly selected characters</p>&#13;
<pre class="pre">XMWUJBVYHXZ</pre>&#13;
<p>There’s no limit to the number of characters you can use in your secret key. However, the person decrypting the ciphertext must know the secret key that was originally used to create the ciphertext.<sup><a id="rch0fn26" href="ch05.xhtml#ch0fn26">26</a></sup> Presumably, you’d provide that in advance—possibly in a face-to-face meeting.</p>&#13;
<p class="footnote"><a id="ch0fn26" href="ch05.xhtml#rch0fn26">26</a>. There are many websites offering Vignère cipher decoders that attempt to decrypt ciphertext without the original secret key. We tried several, but none restored our original text.</p>&#13;
<h5 class="h5" id="ch05lev3sec66">Using Our <code>Cipher</code> Class</h5>&#13;
<p>For the example in <a href="ch05.xhtml#fig5_20">Fig. 5.20</a>, you’ll use our class <code>Cipher</code>, which implements the Vigenère cipher. The header <code>"cipher.h"</code> (line 3) from this chapter’s <code>ch05</code> examples folder defines the class. You don’t need to read and understand the class’s code to use its encryption and decryption capabilities. As with all our other “Objects Natural” case studies, you can simply create an object of class <code>Cipher</code> and call its <code>encrypt</code> and <code>decrypt</code> member functions to encrypt and decrypt text, respectively. In a later chapter, we’ll present class <code>Cipher</code>’s implementation.</p>&#13;
<div class="group" id="fig5_20">&#13;
<p class="codelink"><a href="Images/ch05_images.xhtml#aa05fig20" id="a05fig20">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig15_20.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Encrypting and decrypting text with a Vigenère cipher.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> <span class="green">"cipher.h"</span>&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">#include</span> &lt;string&gt;&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 7</span></strong>&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 9</span></strong>     <code>string plainText;</code>&#13;
<strong><span class="cviolet">10</span></strong>     cout &lt;&lt; <span class="green">"Enter the text to encrypt:\n"</span>;&#13;
<strong><span class="cviolet">11</span></strong>     <code>getline(cin, plainText);</code>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>     <code>string secretKey;</code>&#13;
<strong><span class="cviolet">14</span></strong>     cout &lt;&lt; <span class="green">"\nEnter the secret key:\n"</span>;&#13;
<strong><span class="cviolet">15</span></strong>     <code>getline(cin, secretKey);</code>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>     <span class="yell"><code>Cipher cipher;</code></span>&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>     <span class="lgreen">// encrypt plainText using secretKey</span>&#13;
<strong><span class="cviolet">20</span></strong>     <code>string cipherText{<span class="yell">cipher.encrypt(plainText, secretKey)</span>};</code>&#13;
<strong><span class="cviolet">21</span></strong>     cout &lt;&lt; <span class="green">"\nEncrypted:\n   "</span> &lt;&lt; cipherText &lt;&lt; endl;&#13;
<strong><span class="cviolet">22</span></strong>&#13;
<strong><span class="cviolet">23</span></strong>     <span class="lgreen">// decrypt cipherText</span>&#13;
<strong><span class="cviolet">24</span></strong>     cout &lt;&lt; <span class="green">"\nDecrypted:\n "</span>&#13;
<strong><span class="cviolet">25</span></strong>        <code>&lt;&lt; <span class="yell">cipher.decrypt(cipherText, secretKey)</span> &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">26</span></strong>&#13;
<strong><span class="cviolet">27</span></strong>     <span class="lgreen">// decrypt ciphertext entered by the user</span>&#13;
<strong><span class="cviolet">28</span></strong>     cout &lt;&lt; <span class="green">"\nEnter the ciphertext to decipher:\n"</span>;&#13;
<strong><span class="cviolet">29</span></strong>     <code>getline(cin, cipherText);</code>&#13;
<strong><span class="cviolet">30</span></strong>     cout &lt;&lt; <span class="green">"\nDecrypted:\n  "</span>&#13;
<strong><span class="cviolet">31</span></strong>        <code>&lt;&lt; <span class="yell">cipher.decrypt(cipherText, secretKey)</span> &lt;&lt; endl;</code>&#13;
<strong><span class="cviolet">32</span></strong>  <code>}</code></pre>&#13;
<pre class="pre1"><code>Enter the text to encrypt:</code>&#13;
<code><strong>Welcome to Modern C++ application development with C++20!</strong></code>&#13;
&#13;
<code>Enter the secret key:</code>&#13;
<code><strong>XMWUJBVYHXZ</strong></code>&#13;
&#13;
<code>Encrypted:</code>&#13;
   <code>Tqhwxnz rv Jnaqnh L++ bknsfbxfeiw eztlinmyahc xdro Z++20!</code>&#13;
&#13;
<code>Decrypted:</code>&#13;
   <code>Welcome to Modern C++ application development with C++20!</code>&#13;
&#13;
<code>Enter the ciphertext to decipher:</code>&#13;
<code><strong>Lnfylun Lhqtomh Wjtz Qarcv: Qjwazkrplm xzz Xndmwwqhlz</strong></code>&#13;
&#13;
<code>Decrypted:</code>&#13;
   <code>Objects Natural Case Study: Encryption and Decryption</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 5.20</strong></span> Encrypting and decrypting text with a Vigenère cipher.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec67">Class <code>Cipher</code>’s Member Functions</h5>&#13;
<p>The class provides two key member functions:</p>&#13;
<p class="bull">• Member function <code>encrypt</code> receives <code>string</code>s representing the plain text to encrypt and the secret key, uses the Vigenère cipher to encrypt the text, then returns a <code>string</code> containing the ciphertext.</p>&#13;
<p class="bull">• Member function <code>decrypt</code> receives <code>string</code>s representing the ciphertext to decrypt, reverses the Vigenère cipher to decrypt the text, then returns a <code>string</code> containing the plain text.</p>&#13;
<p>The program first asks you to enter text to encrypt and a secret key. Line 17 creates the <code>Cipher</code> object. Lines 20–21 encrypt the text you entered and display the encrypted text. Then, lines 24–25 decrypt the text to show you the plain-text string you entered.</p>&#13;
<p>Though the last Objectives bullet in this chapter, the last sentence of <a href="ch05.xhtml#ch05lev1sec1">Section 5.1</a> and this section’s title look like gibberish, they’re each ciphertext that we created with our <code>Cipher</code> class and the secret key</p>&#13;
<pre class="pre">XMWUJBVYHXZ</pre>&#13;
<p>Line 28–29 prompt for and input existing ciphertext, then lines 30–31 decrypt the ciphertext and display the original plain text that we encrypted.</p>&#13;
<h3 class="h3" id="ch05lev1sec23"><span class="violet">5.23</span> Wrap-Up</h3>&#13;
<p>In this chapter, we presented function concepts, including function prototypes, function signatures, function headers and function bodies. We overviewed the math library functions and new math functions and constants added in C++20, C++17 and C++11.</p>&#13;
<p>You learned about argument coercion—forcing arguments to the appropriate types specified by the parameter declarations of a function. We presented an overview of the C++ Standard Library’s headers. We demonstrated how to use functions <code>rand</code> and <code>srand</code> to generate random numbers that can be used for simulations, then presented C++11’s nondeterministic capabilities for producing more secure random numbers. We introduced C++14’s digit separators for more readable large numeric literals. We defined sets of constants with scoped <code>enum</code>s and introduced C++20’s <code>using enum</code> declaration.</p>&#13;
<p>You learned about the scope of variables. We discussed two ways to pass arguments to functions—pass-by-value and pass-by-reference. We showed how to implement inline functions and functions that receive default arguments. You learned that overloaded functions have the same name but different signatures. Such functions can be used to perform the same or similar tasks, using different types or different numbers of parameters. We demonstrated using function templates to conveniently generate families of overloaded functions. You then studied recursion, where a function calls itself to solve a problem.</p>&#13;
<p>We presented C++17’s <code>[[nodiscard]]</code> attribute for indicating that a function’s return value should not be ignored and discussed C++20’s <code>[[nodiscard]]</code> enhancement for specifying a reason why the return value should not be ignored. Finally, our objects-natural case study introduced secret key substitution ciphers for encrypting and decrypting text.</p>&#13;
<p>In <a href="ch06.xhtml#ch06">Chapter 6</a>, you’ll learn how to maintain lists and tables of data in arrays and object-oriented <code>vector</code>s. You’ll see a more elegant array-based implementation of the dice-rolling application.</p>&#13;
</div></body>
</html>