<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch04">Chapter 4. Control Statements, Part 2</h2>&#13;
<div class="image"><img src="Images/ch04.jpg" alt="Images" width="657" height="862"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Use the <code>for</code> and <code>do</code>…<code>while</code> iteration statements.</p>&#13;
<p class="squ"><span class="red">■</span> Perform multiple selection using the <code>switch</code> selection statement.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++17’s <code>[[fallthrough]]</code> attribute in <code>switch</code> statements.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++17’s selection statements with initializers.</p>&#13;
<p class="squ"><span class="red">■</span> Use the <code>break</code> and <code>continue</code> statements to alter the flow of control.</p>&#13;
<p class="squ"><span class="red">■</span> Use the logical operators to form compound conditions in control statements.</p>&#13;
<p class="squ"><span class="red">■</span> Understand the representational errors associated with using floating-point data to hold monetary values.</p>&#13;
<p class="squ"><span class="red">■</span> Use C++20’s <code>[[likely]]</code> and <code>[[unlikely]]</code> attributes to help the compiler optimize selection statements by knowing which paths of execution are likely or unlikely to execute.</p>&#13;
<p class="squ"><span class="red">■</span> Continue our objects-natural approach with a case study that uses an open source ZIP compression/decompression library to create and read ZIP files.</p>&#13;
<p class="squ"><span class="red">■</span> Use more C++20 text-formatting capabilities.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec1"><span class="violet"><strong>4.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec2"><span class="violet"><strong>4.2</strong></span> Essentials of Counter-Controlled Iteration</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec3"><span class="violet"><strong>4.3</strong></span> <code>for</code> Iteration Statement</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec4"><span class="violet"><strong>4.4</strong></span> Examples Using the <code>for</code> Statement</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec5"><span class="violet"><strong>4.5</strong></span> Application: Summing Even Integers</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec6"><span class="violet"><strong>4.6</strong></span> Application: Compound-Interest Calculations</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec7"><span class="violet"><strong>4.7</strong></span> <code>do…while</code> Iteration Statement</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec8"><span class="violet"><strong>4.8</strong></span> <code>switch</code> Multiple-Selection Statement</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec9"><span class="violet"><strong>4.9</strong></span> C++17: Selection Statements with Initializers</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec10"><span class="violet"><strong>4.10</strong></span> <code>break</code> and <code>continue</code> Statements</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec11"><span class="violet"><strong>4.11</strong></span> Logical Operators</a></p>&#13;
<p class="chap-lev2"><a href="ch04.xhtml#ch04lev2sec1">4.11.1 Logical AND (<code>&amp;&amp;</code>) Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch04.xhtml#ch04lev2sec2">4.11.2 Logical OR (<code>||</code>) Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch04.xhtml#ch04lev2sec3">4.11.3 Short-Circuit Evaluation</a></p>&#13;
<p class="chap-lev2"><a href="ch04.xhtml#ch04lev2sec4">4.11.4 Logical Negation (<code>!</code>) Operator</a></p>&#13;
<p class="chap-lev2"><a href="ch04.xhtml#ch04lev2sec5">4.11.5 Logical Operators Example</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec12"><span class="violet"><strong>4.12</strong></span> Confusing the Equality (<code>==</code>) and Assignment (<code>=</code>) Operators</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec13"><span class="violet"><strong>4.13</strong></span> C++20 Feature Mock-Up: <code>[[likely]]</code> and <code>[[unlikely]]</code> Attributes</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec14"><span class="violet"><strong>4.14</strong></span> Objects Natural Case Study: Using the <code>miniz-cpp</code> Library to Write and Read ZIP files</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec15"><span class="violet"><strong>4.15</strong></span> C++20 Feature Mock-Up:</a></p>&#13;
<p class="chap-lev1"><a href="ch04.xhtml#ch04lev1sec16"><span class="violet"><strong>4.16</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec1"><span class="violet">4.1</span> Introduction</h3>&#13;
<p><span class="size">17</span> <span class="size">20</span> This chapter introduces all but one of the remaining control statements—the <code>for</code>, <code>do…while</code>, <code>switch</code>, <code>break</code> and <code>continue</code> statements. We explore the essentials of counter-controlled iteration. We use compound-interest calculations to begin investigating the issues of processing monetary amounts. First, we discuss the representational errors associated with floating-point types. We use a <code>switch</code> statement to count the number of A, B, C, D and F grade equivalents in a set of numeric grades. We show C++17’s enhancements that allow you to initialize one or more variables of the same type in the headers of <code>if</code> and <code>switch</code> statements. We discuss the logical operators, which enable you to combine simple conditions to form compound conditions. We show C++20’s attributes <code>[[likely]]</code> and <code>[[unlikely]]</code>, which can help the compiler optimize selection statements by knowing which paths of execution are likely or unlikely to execute. In our objects-natural case study, we continue using objects of pre-existing classes with the miniz-cpp open-source library for creating and reading compressed ZIP archive files. Finally, we introduce more of C++20’s powerful and expressive text-formatting features.</p>&#13;
<h5 class="h5" id="ch04lev3sec1">“Rough-Cut” E-Book for O’Reilly Online Learning Subscribers</h5>&#13;
<p>You are viewing an early-access “rough cut” of <em>C++20 for Programmers</em>. <strong>We prepared this content carefully, but it has not yet been reviewed or copy edited and is subject to change.</strong> As we complete each chapter, we’ll post it here. Please send any corrections, comments, questions and suggestions for improvement to <code><a href="mailto:paul@deitel.com">paul@deitel.com</a></code> and I’ll respond promptly. Check here frequently for updates.</p>&#13;
<h5 class="h5" id="ch04lev3sec2">“Sneak Peek” Videos for O’Reilly Online Learning Subscribers</h5>&#13;
<p>As an O’Reilly Online Learning subscriber, you also have access to the “sneak peek” of our new <em>C++20 Fundamentals LiveLessons</em> videos at:</p>&#13;
<pre class="pre"><a href="https://learning.oreilly.com/videos/c-20-fundamentals-parts/9780136875185">https://learning.oreilly.com/videos/c-20-fundamentals-parts/9780136875185</a></pre>&#13;
<p>Co-author Paul Deitel immediately records each video lesson as we complete each rough-cut e-book chapter. Lessons go live on O’Reilly Online Learning a few days later. Again, check here frequently for updates.</p>&#13;
<h3 class="h3" id="ch04lev1sec2"><span class="violet">4.2</span> Essentials of Counter-Controlled Iteration</h3>&#13;
<p>This section uses the <code>while</code> iteration statement introduced in <a href="ch03.xhtml#ch03">Chapter 3</a> to formalize the elements of counter-controlled iteration:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> a <span class="violet"><strong>control variable</strong></span> (or loop counter)</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> the control variable’s <span class="violet"><strong>initial value</strong></span></p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> the control variable’s <span class="violet"><strong>increment</strong></span> that’s applied during each iteration of the loop</p>&#13;
<p class="num"><span class="red"><strong>4.</strong></span> the <span class="violet"><strong>loop-continuation condition</strong></span> that determines if looping should continue.</p>&#13;
<p>Consider the application of <a href="ch04.xhtml#fig4_1">Fig. 4.1</a>, which uses a loop to display the numbers from 1 through 10.</p>&#13;
<div class="group" id="fig4_1">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig01" id="a04fig01">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_01.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Counter-controlled iteration with the while iteration statement.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="blue">int</span> counter{<span class="green">1</span>}; <span class="lgreen">// declare and initialize control variable</span>&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="blue">while</span> (counter &lt;= <span class="green">10</span>) { <span class="lgreen">// loop-continuation condition</span>&#13;
<strong><span class="cviolet">10</span></strong>        cout &lt;&lt; counter &lt;&lt; <span class="green">" "</span>;&#13;
<strong><span class="cviolet">11</span></strong>        ++counter; <span class="lgreen">// increment control variable</span>&#13;
<strong><span class="cviolet">12</span></strong>     }&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>     cout &lt;&lt; endl;&#13;
<strong><span class="cviolet">15</span></strong>   }</pre>&#13;
<pre class="pre1">1 2 3 4 5 6 7 8 9 10</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.1</strong></span> Counter-controlled iteration with the <code>while</code> iteration statement.</p>&#13;
</div>&#13;
<p>In <a href="ch04.xhtml#fig4_1">Fig. 4.1</a>, lines 7, 9 and 11 define the elements of counter-controlled iteration. Line 7 declares the control variable (<code>counter</code>) as an <code>int</code>, reserves space for it in memory and sets its initial value to <code>1</code>. Declarations that require initialization are executable statements. In C++, it’s more precise to call a variable declaration that also reserves memory a <span class="violet"><strong>definition</strong></span>. Because definitions are declarations, too, we’ll generally use the term “declaration” except when the distinction is important.</p>&#13;
<p>Line 10 displays <code>counter</code>’s value once per iteration of the loop. Line 11 increments the control variable by 1 for each iteration of the loop. The <code>while</code>’s loop-continuation condition (line 9) tests whether the value of the control variable is less than or equal to <code>10</code> (the final value for which the condition is true). The program performs the <code>while</code>’s body even when the control variable is <code>10</code>. The loop terminates when the control variable exceeds <code>10</code>.</p>&#13;
<p>Floating-point values are approximate, so controlling counting loops with floating-point variables can result in imprecise counter values and inaccurate tests for termination. For that reason, always control counting loops with integer values.</p>&#13;
<h3 class="h3" id="ch04lev1sec3"><span class="violet">4.3</span> <code>for</code> Iteration Statement</h3>&#13;
<p>C++ also provides the <code><strong><span class="violet">for</span></strong></code> <span class="violet"><strong>iteration statement</strong></span>, which specifies the counter-controlled-iteration details in a single line of code. <a href="ch04.xhtml#fig4_2">Figure 4.2</a> reimplements the application of <a href="ch04.xhtml#fig4_1">Fig. 4.1</a> using a <code>for</code> statement.</p>&#13;
<div class="group" id="fig4_2">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig02" id="a04fig02">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_02.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Counter-controlled iteration with the for iteration statement.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="lgreen">// for statement header includes initialization,</span>&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="lgreen">// loop-continuation condition and increment</span>&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> counter{<span class="green">1</span>}; counter &lt;= <span class="green">10</span>; ++counter) {&#13;
<strong><span class="cviolet">10</span></strong>        cout &lt;&lt; counter &lt;&lt; <span class="green">" "</span>;&#13;
<strong><span class="cviolet">11</span></strong>     }&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>     cout &lt;&lt; endl;&#13;
<strong><span class="cviolet">14</span></strong>   }</pre>&#13;
<pre class="pre1">1 2 3 4 5 6 7 8 9 10</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.2</strong></span> Counter-controlled iteration with the <code>for</code> iteration statement.</p>&#13;
</div>&#13;
<p>When the <code>for</code> statement (lines 9–11) begins executing, the control variable <code>counter</code> is declared and initialized to <code>1</code>. Next, the program checks the loop-continuation condition, <code>counter &lt;= 10</code>, which is between the two required semicolons. Because <code>counter</code>’s initial value is <code>1</code>, the condition is true. So, the body statement (line 10) displays <code>counter</code>’s value (<code>1</code>). After executing the loop’s body, the program increments <code>counter</code> in the expression <code>++counter</code>, which appears to the right of the second semicolon. Then the program performs the loop-continuation test again to determine whether to proceed with the loop’s next iteration. At this point, <code>counter</code>’s value is <code>2</code>, so the condition is still true, so the program executes the body statement again. This process continues until the loop has displayed the numbers 1–10 and <code>counter</code>’s value becomes <code>11</code>. At this point, the loop-continuation test fails, iteration terminates, and the program continues executing at the first statement after the <code>for</code> (line 13).</p>&#13;
<h5 class="h5" id="ch04lev3sec3">A Closer Look at the <code>for</code> Statement’s Header</h5>&#13;
<p>The following diagram takes a closer look at the <code>for</code> statement in <a href="ch04.xhtml#fig4_2">Fig. 4.2</a>:</p>&#13;
<div class="image"><img src="Images/04unfig01.jpg" alt="Images" width="526" height="198"/></div>&#13;
<p>The first line—including the keyword <code>for</code> and everything in the parentheses after <code>for</code> (line 9 in <a href="ch04.xhtml#fig4_2">Fig. 4.2</a>)—is sometimes called the <code><strong><span class="violet">for</span></strong></code> <span class="violet"><strong>statement header</strong></span>. The <code>for</code> header “does it all”—it specifies each item needed for counter-controlled iteration with a control variable.</p>&#13;
<h5 class="h5" id="ch04lev3sec4">General Format of a <code>for</code> Statement</h5>&#13;
<p>The general format of the <code>for</code> statement is</p>&#13;
<p class="web"><code><span class="blue">for</span> (</code><em>initialization</em><code>;</code> <em>loopContinuationCondition</em><code>;</code> <em>increment</em><code>) {</code><br/>     <em>statement</em><br/><code>}</code></p>&#13;
<p>where</p>&#13;
<p class="bull">• the <em>initialization</em> expression names the loop’s control variable and provides its initial value,</p>&#13;
<p class="bull">• the <em>loopContinuationCondition</em> determines whether the loop should continue executing and</p>&#13;
<p class="bull">• the <em>increment</em> modifies the control variable’s value so that the loop-continuation condition eventually becomes false.</p>&#13;
<p>The two semicolons in the <code>for</code> header are required. If the loop-continuation condition is initially false, the program does not execute the <code>for</code> statement’s body. Instead, execution proceeds with the statement following the <code>for</code>.</p>&#13;
<h5 class="h5" id="ch04lev3sec5">Scope of a <code>for</code> Statement’s Control Variable</h5>&#13;
<p>If the <em>initialization</em> expression in the <code>for</code> header declares the control variable, it can be used only in that <code>for</code> statement—not beyond it. This restricted use is known as the variable’s <span class="violet"><strong>scope</strong></span>, which defines where it can be used in a program. For example, a variable’s scope is from its declaration point to the right brace that closes the block. We discuss scope in detail in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>&#13;
<h5 class="h5" id="ch04lev3sec6">Expressions in a <code>for</code> Statement’s Header Are Optional</h5>&#13;
<p>All three expressions in a <code>for</code> header are optional. If you omit the <em>loopContinuationCondition</em>, the condition is always true, thus creating an infinite loop. You might omit the <em>initialization</em> expression if the program initializes the control variable before the loop. You might omit the <em>increment</em> expression if the program calculates the increment in the loop’s body or if no increment is needed.</p>&#13;
<p>The increment expression in a <code>for</code> acts like a standalone statement at the end of the <code>for</code>’s body. Therefore, the increment expressions</p>&#13;
<pre class="pre">counter = counter + <span class="green">1</span>&#13;
counter += <span class="green">1</span>&#13;
++counter&#13;
counter++</pre>&#13;
<p>are equivalent in a <code>for</code> statement. Many programmers prefer <code>counter++</code> because it’s concise and because a <code>for</code> loop evaluates its increment expression after its body executes, so the postfix increment form seems more natural. In this case, the increment expression does not appear in a larger expression, so preincrementing and postincrementing have the same effect. We prefer preincrement. In <a href="ch14.xhtml#ch14">Chapter 14</a>’s operator overloading discussion, you’ll see that preincrement can have a performance advantage.</p>&#13;
<h5 class="h5" id="ch04lev3sec7">Using a <code>for</code> Statement’s Control Variable in the Statement’s Body</h5>&#13;
<p>Programs frequently display the control-variable value or use it in calculations in the loop body, but this use is not required. The control variable is commonly used to control iteration without being mentioned in the body of the <code>for</code>.</p>&#13;
<p>Although the value of the control variable can be changed in a <code>for</code> loop’s body, avoid doing so, because this practice can lead to subtle errors. If a program must modify the control variable’s value in the loop’s body, use <code>while</code> rather than <code>for</code>.</p>&#13;
<h5 class="h5" id="ch04lev3sec8">UML Activity Diagram of the <code>for</code> Statement</h5>&#13;
<p>Below is the UML activity diagram of the <code>for</code> statement in <a href="ch04.xhtml#fig4_2">Fig. 4.2</a>:</p>&#13;
<div class="image"><img src="Images/04unfig02.jpg" alt="Images" width="704" height="323"/></div>&#13;
<p>The diagram makes it clear that initialization occurs only once—before testing the loop-continuation condition the first time. Incrementing occurs each time through the loop after the body statement executes.</p>&#13;
<h3 class="h3" id="ch04lev1sec4"><span class="violet">4.4</span> Examples Using the <code>for</code> Statement</h3>&#13;
<p>The following examples show techniques for varying the control variable in a <code>for</code> statement. In each case, we write only the appropriate <code>for</code> header. Note the change in the relational operator for the loops that decrement the control variable.</p>&#13;
<p class="alpha">a) Vary the control variable from <code>1</code> to <code>100</code> in increments of <code>1</code>.</p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">1</span>}; i &lt;= <span class="green">100</span>; ++i)</pre>&#13;
<p class="alpha">b) Vary the control variable from <code>100</code> <em>down</em> to <code>1</code> in <em>decrements</em> of <code>1</code>.</p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">100</span>}; i &gt;= <span class="green">1</span>; --i)</pre>&#13;
<p class="alpha">c) Vary the control variable from <code>7</code> to <code>77</code> in increments of <code>7</code>.</p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">7</span>}; i &lt;= <span class="green">77</span>; i += <span class="green">7</span>)</pre>&#13;
<p class="alpha">d) Vary the control variable from <code>20</code> <em>down</em> to <code>2</code> in <em>decrements</em> of <code>2</code>.</p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">20</span>}; i &gt;= <span class="green">2</span>; i -= <span class="green">2</span>)</pre>&#13;
<p class="alpha">e) Vary the control variable over the values <code>2</code>, <code>5</code>, <code>8</code>, <code>11</code>, <code>14</code>, <code>17</code>, <code>20</code>.</p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">2</span>}; i &lt;= <span class="green">20</span>; i += <span class="green">3</span>)</pre>&#13;
<p class="alpha">f) Vary the control variable over the values <code>99</code>, <code>88</code>, <code>77</code>, <code>66</code>, <code>55</code>, <code>44</code>, <code>33</code>, <code>22</code>, <code>11</code>, <code>0</code>.</p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">int</span> i{<span class="green">99</span>}; i &gt;= <span class="green">0</span>; i -= <span class="green">11</span>)</pre>&#13;
<p>Do not use equality operators (<code>!=</code> or <code>==</code>) in a loop-continuation condition if the loop’s control variable increments or decrements by more than <code>1</code>. For example, in the <code>for</code> statement header</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0075-01a" id="f0075-01aa">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">int</span> counter{<span class="green">1</span>}; counter != <span class="green">10</span>; counter += <span class="green">2</span>)</pre>&#13;
<p><code>counter != 10</code> never becomes false (resulting in an infinite loop) because <code>counter</code> increments by 2 after each iteration, producing only the odd values (3, 5, 7, 9, 11, …).</p>&#13;
<h3 class="h3" id="ch04lev1sec5"><span class="violet">4.5</span> Application: Summing Even Integers</h3>&#13;
<p>The application in <a href="ch04.xhtml#fig4_3">Fig. 4.3</a> uses a <code>for</code> statement to sum the even integers from 2 to 20 and store the result in <code>int</code> variable <code>total</code>. Each iteration of the loop (lines 10–12) adds control variable <code>number</code>’s value to variable <code>total</code>.</p>&#13;
<div class="group" id="fig4_3">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig03" id="a04fig03">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_03.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Summing integers with the for statement.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="blue">int</span> total{<span class="green">0</span>};&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="lgreen">// total even integers from 2 through 20</span>&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> number{<span class="green">2</span>}; number &lt;= <span class="green">20</span>; number += <span class="green">2</span>) {&#13;
<strong><span class="cviolet">11</span></strong>        total += number;&#13;
<strong><span class="cviolet">12</span></strong>     }&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>     cout &lt;&lt; <span class="green">"Sum is "</span> &lt;&lt; total &lt;&lt; endl;&#13;
<strong><span class="cviolet">15</span></strong>   }</pre>&#13;
<pre class="pre1">Sum is 110</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.3</strong></span> Summing integers with the <code>for</code> statement.</p>&#13;
</div>&#13;
<p>A <code>for</code> statement’s initialization and increment expressions can be comma-separated lists containing multiple initialization expressions or multiple increment expressions. Although this is discouraged, you could merge the <code>for</code> statement’s body (line 11) into the increment portion of the <code>for</code> header by using a comma operator as in</p>&#13;
<pre class="pre">total += number, number += <span class="green">2</span></pre>&#13;
<p>The comma between the expressions <code>total += number</code> and <code>number += 2</code> is the <span class="violet"><strong>comma operator</strong></span>, which guarantees that a list of expressions evaluates from left to right. The comma operator has the lowest precedence of all C++ operators. The value and type of a comma-separated list of expressions is the value and type of the rightmost expression. For example, assuming <code>x</code> is an <code>int</code> and <code>y</code> is a <code>double</code>, the value of the comma-separated list of expressions</p>&#13;
<pre class="pre">x = 5, y = 6.4;</pre>&#13;
<p>is <code>6.4</code> and the type is <code>double</code>.</p>&#13;
<p>The comma operator is often used in <code>for</code> statements that require multiple initialization expressions or multiple increment expressions.</p>&#13;
<h3 class="h3" id="ch04lev1sec6"><span class="violet">4.6</span> Application: Compound-Interest Calculations</h3>&#13;
<p>Let’s compute compound interest with a <code>for</code> statement. Consider the following problem:</p>&#13;
<div class="bq">&#13;
<p><em>A person invests $1,000 in a savings account yielding 5% interest. Assuming all interest is left on deposit, calculate and print the amount of money in the account at the end of each year for 10 years. Use the following formula to determine the amounts:</em></p>&#13;
<p class="list-sim"><em>a = p</em> (1 + <em>r</em>)<sup><em>n</em></sup></p>&#13;
<p><em>where</em></p>&#13;
<p class="list-sim"><em>p</em> is the original amount invested (i.e., the principal)</p>&#13;
<p class="list-sim"><em>r</em> is the annual interest rate (e.g., use 0.05 for 5%)</p>&#13;
<p class="list-sim"><em>n</em> is the number of years</p>&#13;
<p class="list-sim"><em>a</em> is the amount on deposit at the end of the <em>n</em>th year.</p>&#13;
</div>&#13;
<p>w (<a href="ch04.xhtml#fig4_4">Fig. 4.4</a>) involves a loop that performs the indicated calculation for each of the 10 years the money remains on deposit. We use <code>double</code> values here for the monetary calculations. Then we discuss the problems with using floating-point types to represent monetary amounts. In <a href="ch10.xhtml#ch10">Chapter 10</a>, we’ll develop a new <code>Dollar-Amount</code> class that uses large integers to precisely represent monetary amounts. As you’ll see, the class performs monetary calculations using only integer arithmetic.</p>&#13;
<div class="group" id="fig4_4">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig04" id="a04fig04">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_04.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Compound-interest calculations with for.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iomanip&gt;&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="yell"><span class="blue">#include</span> &lt;cmath&gt;</span> <span class="lgreen">// for pow function</span>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 7</span></strong>&#13;
<strong><span class="cviolet"> 8</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="lgreen">// set floating-point number format</span>&#13;
<strong><span class="cviolet">10</span></strong>     cout &lt;&lt; fixed &lt;&lt; setprecision(<span class="green">2</span>);&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>     <span class="blue">double</span> principal{<span class="green">1000.00</span>}; <span class="lgreen">// initial amount before interest</span>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="blue">double</span> rate{<span class="green">0.05</span>}; <span class="lgreen">// interest rate</span>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>     cout &lt;&lt; <span class="green">"Initial principal: "</span> &lt;&lt; principal &lt;&lt; endl;&#13;
<strong><span class="cviolet">16</span></strong>     cout &lt;&lt; <span class="green">"    Interest rate: "</span> &lt;&lt; rate &lt;&lt; endl;&#13;
<strong><span class="cviolet">17</span></strong>&#13;
<strong><span class="cviolet">18</span></strong>     <span class="lgreen">// display headers</span>&#13;
<strong><span class="cviolet">19</span></strong>     cout &lt;&lt; <span class="green">"\nYear"</span> &lt;&lt; <span class="yell">setw(<span class="green">20</span>)</span> &lt;&lt; <span class="green">"Amount on deposit"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">20</span></strong>&#13;
<strong><span class="cviolet">21</span></strong>     <span class="yell"><span class="lgreen">// calculate amount on deposit for each of ten years</span>              </span>&#13;
<strong><span class="cviolet">22</span></strong>     <span class="yell"><span class="blue">for</span> (<span class="blue">int</span> year{<span class="green">1</span>}; year &lt;= <span class="green">10</span>; ++year) {                           </span>&#13;
<strong><span class="cviolet">23</span></strong>     <span class="yell">   <span class="lgreen">// calculate amount on deposit at the end of the specified year</span></span>&#13;
<strong><span class="cviolet">24</span></strong>     <span class="yell">   <span class="blue">double</span> amount = principal * pow(<span class="green">1.0</span> + rate, year);             </span>&#13;
<strong><span class="cviolet">25</span></strong>     <span class="yell">                                                                  </span>&#13;
<strong><span class="cviolet">26</span></strong>     <span class="yell">   <span class="lgreen">// display the year and the amount</span>                             </span>&#13;
<strong><span class="cviolet">27</span></strong>     <span class="yell">   cout &lt;&lt; setw(<span class="green">4</span>) &lt;&lt; year &lt;&lt; setw(<span class="green">20</span>) &lt;&lt; amount &lt;&lt; endl;         </span>&#13;
<strong><span class="cviolet">28</span></strong>     <span class="yell">}                                                                 </span>&#13;
<strong><span class="cviolet">29</span></strong>   }</pre>&#13;
<pre class="pre1">Initial principal: 1000.00&#13;
    Interest rate: 0.05&#13;
&#13;
Year   Amount on deposit&#13;
  1             1050.00&#13;
  2             1102.50&#13;
  3             1157.63&#13;
  4             1215.51&#13;
  5             1276.28&#13;
  6             1340.10&#13;
  7             1407.10&#13;
  8             1477.46&#13;
  9             1551.33&#13;
 10             1628.89</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.4</strong></span> Compound-interest calculations with <code>for</code>.</p>&#13;
</div>&#13;
<p>Lines 12–13 declare <code>double</code> variables <code>principal</code> and <code>rate</code>, and initialize <code>principal</code> to <code>1000.00</code> and <code>rate</code> to <code>0.05</code>. C++ treats floating-point literals like <code>1000.00</code> and <code>0.05</code> as type <code>double</code>. Similarly, C++ treats whole-number literals like <code>7</code> and <code>-22</code> as type <code>int</code>.<sup><a id="rch0fn1" href="ch01.xhtml#ch0fn1">1</a></sup> Lines 15–16 display the initial principal and the interest rate.</p>&#13;
<p class="footnote"><a id="ch0fn1" href="ch01.xhtml#rch0fn1">1</a>. <a href="ch03.xhtml#ch03lev1sec12">Section 3.12</a> showed that C++’s integer types cannot represent all integer values. Choose the correct type for the range of values you need to represent. You may designate that an integer literal has type <code>long</code> or <code>long long</code> by appending <code>L</code> or <code>LL</code>, respectively, to the literal value.</p>&#13;
<h5 class="h5" id="ch04lev3sec9">Formatting with Field Widths and Justification</h5>&#13;
<p>Line 10 before the loop and line 27 in the loop combine to print the <code>year</code> and <code>amount</code> values. We specify the formatting with the parameterized stream manipulators <code>setprecision</code> and <code><strong><span class="violet">setw</span></strong></code> and the nonparameterized stream manipulator <code>fixed</code>. The stream manipulator <code>setw(4)</code> specifies that the next value output should appear in a <span class="violet"><strong>field width</strong></span> of 4— i.e., <code>cout &lt;&lt;</code> prints the value with at least four character positions. If the value to be output is fewer than four character positions, the value is right-aligned in the field by default. If the value to be output is more than four character positions, C++ extends the field width to the right to accommodate the entire value. To left-align values, output nonparameterized stream manipulator <code><strong><span class="violet">left</span></strong></code> (found in header <code>&lt;iostream&gt;</code>). You can restore right-alignment by outputting nonparameterized stream manipulator <code><strong><span class="violet">right</span></strong></code>.</p>&#13;
<p>The other formatting in the output statements displays variable <code>amount</code> as a fixed-point value with a decimal point (<code>fixed</code> in line 10) right-aligned in a field of 20 character positions (<code>setw(20)</code> in line 27) and two digits of precision to the right of the decimal point (<code>setprecision(2)</code> in line 10). We applied the stream manipulators <code>fixed</code> and <code>setprecision</code> to the output stream <code>cout</code> before the <code>for</code> loop because these format settings remain in effect until they’re changed—such settings are called <span class="violet"><strong>sticky settings</strong></span>, and they do not need to be applied during each iteration of the loop. However, the field width specified with <code>setw</code> applies only to the next value output. <a href="ch15.xhtml#ch15">Chapter 15</a> discusses <code>cin</code>’s and <code>cout</code>’s formatting capabilities in detail. We continue discussing C++20’s powerful new text-formatting capabilities in <a href="ch04.xhtml#ch04lev1sec15">Section 4.15</a>.</p>&#13;
<h5 class="h5" id="ch04lev3sec10">Performing the Interest Calculations with Standard Library Function <code>pow</code></h5>&#13;
<p>The <code>for</code> statement (lines 22–28) iterates 10 times, varying the <code>int</code> control variable <code>year</code> from 1 to 10 in increments of 1. Variable <code>year</code> represents <em>n</em> in the problem statement.</p>&#13;
<p>C++ does not include an exponentiation operator, so we use the <span class="violet"><strong>standard library function</strong></span> <code><strong><span class="violet">pow</span></strong></code> (line 24) from the header <code>&lt;cmath&gt;</code> (line 5). The call <code>pow(x, y)</code> calculates the value of <em>x</em> raised to the <em>y</em>th power. The function receives two <code>double</code> arguments and returns a <code>double</code> value. Line 24 performs the calculation <em>a</em> = <em>p</em>(1 + <em>r</em>)<sup><em>n</em></sup>, where <em>a</em> is <code>amount</code>, <em>p</em> is <code>principal</code>, <em>r</em> is <code>rate</code> and <em>n</em> is <code>year</code>.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> The body of the <code>for</code> statement contains the calculation <code>1.0 + rate</code> as <code>pow</code>’s first argument. This calculation produces the same result each time through the loop, so repeating it in every iteration of the loop is wasteful. In loops, avoid calculations for which the result never changes. Instead, place such calculations before the loop. To improve program performance, many of today’s optimizing compilers place such calculations before loops in the compiled code.</p>&#13;
<h5 class="h5" id="ch04lev3sec11">Floating-Point Number Precision and Memory Requirements</h5>&#13;
<p>Variables of type <code>float</code> represent <span class="violet"><strong>single-precision floating-point numbers</strong></span>. Most of today’s systems store these in four bytes of memory with approximately seven significant digits. Variables of type <code>double</code> represent <span class="violet"><strong>double-precision floating-point numbers</strong></span>. Most of today’s systems store these in eight bytes of memory with approximately 15 significant digits—approximately double the precision of <code>float</code> variables. Most programmers represent floating-point numbers with type <code>double</code>. C++ treats floating-point numbers like 3.14159 in a program’s source code as <code>double</code> values by default. Such values in the source code are known as <span class="violet"><strong>floating-point literals</strong></span>.</p>&#13;
<p>Though most systems store <code>float</code>s in four bytes and <code>double</code>s in eight bytes, the C++ standard indicates that type <code>double</code> provides at least as much precision as <code>float</code>. There is also type <code>long double</code>, which provides at least as much precision as <code>double</code>. For a complete list of C++ fundamental types and their typical ranges, see</p>&#13;
<pre class="pre"><a href="https://en.cppreference.com/w/cpp/language/types">https://en.cppreference.com/w/cpp/language/types</a></pre>&#13;
<h5 class="h5" id="ch04lev3sec12">Floating-Point Numbers Are Approximations</h5>&#13;
<p>In conventional arithmetic, floating-point numbers often arise as a result of division— when we divide 10 by 3, the result is 3.3333333…, with the sequence of 3s repeating infinitely. The computer allocates only a fixed amount of space to hold such a value, so the stored floating-point value can be only an approximation. As you can see, <code>double</code> suffers from what is referred to as <span class="violet"><strong>representational error</strong></span>. Assuming that floating-point numbers are represented exactly (e.g., using them in comparisons for equality) can lead to incorrect results.</p>&#13;
<p>Floating-point numbers have numerous applications, especially for measured values. For example, when we speak of a “normal” body temperature of 98.6 degrees Fahrenheit, we do not need to be precise to a large number of digits. When we read the temperature on a thermometer as 98.6, it actually might be 98.5999473210643. Calling this number 98.6 is fine for most applications involving body temperatures. Generally, type <code>double</code> is preferred over type <code>float</code>, because <code>double</code> variables can represent floating-point numbers more precisely. We use <code>double</code> throughout the book.</p>&#13;
<h5 class="h5" id="ch04lev3sec13">A Warning about Displaying Rounded Values</h5>&#13;
<p>We declared variables <code>amount</code>, <code>principal</code> and <code>rate</code> to be of type <code>double</code> in this example. We’re dealing with fractional parts of dollars and thus need a type that allows decimal points in its values. Unfortunately, floating-point numbers can cause trouble. Here’s a simple explanation of what can go wrong when using floating-point numbers to represent dollar amounts that are displayed with two digits to the right of the decimal point. Two calculated dollar amounts stored in the machine could be 14.234 (rounded to 14.23 for display purposes) and 18.673 (rounded to 18.67 for display purposes). When these amounts are added, they produce the internal sum 32.907, which would typically be rounded to 32.91 for display purposes. Thus, your output could appear as</p>&#13;
<pre class="pre">  14.23&#13;
<span class="underline">+ 18.67</span>&#13;
  32.91</pre>&#13;
<p>but a person adding the individual numbers as displayed would expect the sum to be 32.90. You’ve been warned!</p>&#13;
<h5 class="h5" id="ch04lev3sec14">Even Common Dollar Amounts Can Have Representational Error in Floating Point</h5>&#13;
<p>Even simple dollar amounts, such as those you might see on a grocery or restaurant bill, can have representational errors when they’re stored as <code>double</code>s. To see this, we created a simple program with the declaration</p>&#13;
<pre class="pre"><span class="blue">double</span> d = <span class="green">123.02</span>;</pre>&#13;
<p>then displayed variable <code>d</code>’s value with many digits of precision to the right of the decimal point. The resulting output showed 123.02 as 123.0199999…, which is another example of a representational error. Though some dollar amounts can be represented precisely as <code>double</code>, many cannot. This is a common problem in many programming languages. Later in the book, we create and use classes that handle monetary amounts precisely.</p>&#13;
<h3 class="h3" id="ch04lev1sec7"><span class="violet">4.7</span> <code>do…while</code> Iteration Statement</h3>&#13;
<p>The <code><strong><span class="violet">do…while</span></strong></code> <span class="violet"><strong>iteration statement</strong></span> is similar to the <code>while</code> statement. In a <code>while</code> statement, the program tests the loop-continuation condition at the beginning of the loop, before executing the loop’s body. If the condition is false, the body never executes. The <code>do…while</code> statement tests the loop-continuation condition after executing the loop’s body; therefore, the body always executes at least once. When a <code>do…while</code> statement terminates, execution continues with the next statement in sequence. <a href="ch04.xhtml#fig4_5">Figure 4.5</a> uses a <code>do…while</code> to output the numbers 1–10.</p>&#13;
<div class="group" id="fig4_5">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig05" id="a04fig05">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_05.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// do...while iteration statement.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="blue">int</span> counter{<span class="green">1</span>};&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="yell"><span class="blue">do</span> {                                      </span>&#13;
<strong><span class="cviolet">10</span></strong>     <span class="yell">   cout &lt;&lt; counter &lt;&lt; <span class="green">" "</span>;                </span>&#13;
<strong><span class="cviolet">11</span></strong>     <span class="yell">   ++counter;                             </span>&#13;
<strong><span class="cviolet">12</span></strong>     <span class="yell">} <span class="blue">while</span> (counter &lt;= <span class="green">10</span>); <span class="lgreen">// end do...while</span></span>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>     cout &lt;&lt; endl;&#13;
<strong><span class="cviolet">15</span></strong>   }</pre>&#13;
<pre class="pre1">1 2 3 4 5 6 7 8 9 10</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.5</strong></span> <code>do…while</code> iteration statement.</p>&#13;
</div>&#13;
<p>Line 7 declares and initializes control variable <code>counter</code>. Upon entering the <code>do…while</code> statement, line 10 outputs <code>counter</code>’s value and line 11 increments <code>counter</code>. Then the program evaluates the loop-continuation test at the bottom of the loop (line 12). If the condition is true, the loop continues at the first body statement (line 10). If the condition is false, the loop terminates, and the program continues at the next statement after the loop.</p>&#13;
<h5 class="h5" id="ch04lev3sec15">UML Activity Diagram for the <code>do…while</code> Iteration Statement</h5>&#13;
<p>The UML activity diagram for the <code>do…while</code> statement in <a href="ch04.xhtml#fig4_5">Fig. 4.5</a> makes it clear that the loop-continuation condition is not evaluated until after the loop performs the action state at least once:</p>&#13;
<div class="image"><img src="Images/04unfig03.jpg" alt="Images" width="520" height="473"/></div>&#13;
<h3 class="h3" id="ch04lev1sec8"><span class="violet">4.8</span> <code>switch</code> Multiple-Selection Statement</h3>&#13;
<p>C++ provides the <code><strong><span class="violet">switch</span></strong></code> <span class="violet"><strong>multiple-selection</strong></span> statement to choose among many different actions based on the possible values of a variable or expression. Each action is associated with the value of an <span class="violet"><strong>integral constant expression</strong></span> (i.e., any combination of character and integer constants that evaluates to a constant integer value).</p>&#13;
<h5 class="h5" id="ch04lev3sec16">Using a <code>switch</code> Statement to Count A, B, C, D and F Grades</h5>&#13;
<p><a href="ch04.xhtml#fig4_6">Figure 4.6</a> calculates the class average of a set of numeric grades entered by the user. The <code>switch</code> statement determines each grade’s letter equivalent (A, B, C, D or F) and increments the appropriate grade counter. The program also displays a summary of the number of students who received each grade.</p>&#13;
<div class="group" id="fig4_6">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig06" id="a04fig06">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_06.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Using a switch statement to count letter grades.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;iomanip&gt;&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 6</span></strong>&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 8</span></strong>     <span class="blue">int</span> total{<span class="green">0</span>}; <span class="lgreen">// sum of grades</span>&#13;
<strong><span class="cviolet"> 9</span></strong>     <span class="blue">int</span> gradeCounter{<span class="green">0</span>}; <span class="lgreen">// number of grades entered</span>&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">int</span> aCount{<span class="green">0</span>}; <span class="lgreen">// count of A grades</span>&#13;
<strong><span class="cviolet">11</span></strong>     <span class="blue">int</span> bCount{<span class="green">0</span>}; <span class="lgreen">// count of B grades</span>&#13;
<strong><span class="cviolet">12</span></strong>     <span class="blue">int</span> cCount{<span class="green">0</span>}; <span class="lgreen">// count of C grades</span>&#13;
<strong><span class="cviolet">13</span></strong>     <span class="blue">int</span> dCount{<span class="green">0</span>}; <span class="lgreen">// count of D grades</span>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="blue">int</span> fCount{<span class="green">0</span>}; <span class="lgreen">// count of F grades</span>&#13;
<strong><span class="cviolet">15</span></strong>&#13;
<strong><span class="cviolet">16</span></strong>     cout &lt;&lt; <span class="green">"Enter the integer grades in the range 0-100.\n"</span>&#13;
<strong><span class="cviolet">17</span></strong>        &lt;&lt; <span class="green">"Type the end-of-file indicator to terminate input:\n"</span>&#13;
<strong><span class="cviolet">18</span></strong>        &lt;&lt; <span class="green">"   On UNIX/Linux/macOS type &lt;Ctrl&gt; d then press Enter\n"</span>&#13;
<strong><span class="cviolet">19</span></strong>        &lt;&lt; <span class="green">"   On Windows type &lt;Ctrl&gt; z then press Enter\n";</span>&#13;
<strong><span class="cviolet">20</span></strong>&#13;
<strong><span class="cviolet">21</span></strong>     <span class="blue">int</span> grade;&#13;
<strong><span class="cviolet">22</span></strong>&#13;
<strong><span class="cviolet">23</span></strong>     <span class="lgreen">// loop until user enters the end-of-file indicator</span>&#13;
<strong><span class="cviolet">24</span></strong>     <span class="yell"><span class="blue">while</span> (cin &gt;&gt; grade) {</span>&#13;
<strong><span class="cviolet">25</span></strong>        total += grade; <span class="lgreen">// add grade to total</span>&#13;
<strong><span class="cviolet">26</span></strong>        ++gradeCounter; <span class="lgreen">// increment number of grades</span>&#13;
<strong><span class="cviolet">27</span></strong>&#13;
<strong><span class="cviolet">28</span></strong>        <span class="lgreen">// increment appropriate letter-grade counter</span>&#13;
<strong><span class="cviolet">29</span></strong>        <span class="yell"><span class="blue">switch</span> (grade / <span class="green">10</span>) {                         </span>&#13;
<strong><span class="cviolet">30</span></strong>        <span class="yell">   <span class="blue">case</span> <span class="green">9</span>: <span class="lgreen">// grade was between 90</span>            </span>&#13;
<strong><span class="cviolet">31</span></strong>        <span class="yell">   <span class="blue">case</span> <span class="green">10</span>: <span class="lgreen">// and 100, inclusive</span>             </span>&#13;
<strong><span class="cviolet">32</span></strong>        <span class="yell">      ++aCount;                               </span>&#13;
<strong><span class="cviolet">33</span></strong>        <span class="yell">      <span class="blue">break</span>; <span class="lgreen">// exits switch</span>                  </span>&#13;
<strong><span class="cviolet">34</span></strong>        <span class="yell">                                              </span>&#13;
<strong><span class="cviolet">35</span></strong>        <span class="yell">   <span class="blue">case</span> <span class="green">8</span>: <span class="lgreen">// grade was between 80 and 89</span>     </span>&#13;
<strong><span class="cviolet">36</span></strong>        <span class="yell">      ++bCount;                               </span>&#13;
<strong><span class="cviolet">37</span></strong>        <span class="yell">      <span class="blue">break</span>; <span class="lgreen">// exits switch</span>                  </span>&#13;
<strong><span class="cviolet">38</span></strong>        <span class="yell">                                              </span>&#13;
<strong><span class="cviolet">39</span></strong>        <span class="yell">   <span class="blue">case</span> <span class="green">7</span>: <span class="lgreen">// grade was between 70 and 79</span>     </span>&#13;
<strong><span class="cviolet">40</span></strong>        <span class="yell">      ++cCount;                               </span>&#13;
<strong><span class="cviolet">41</span></strong>        <span class="yell">      <span class="blue">break</span>; <span class="lgreen">// exits switch</span>                  </span>&#13;
<strong><span class="cviolet">42</span></strong>        <span class="yell">                                              </span>&#13;
<strong><span class="cviolet">43</span></strong>        <span class="yell">   <span class="blue">case</span> <span class="green">6</span>: <span class="lgreen">// grade was between 60 and 69</span>     </span>&#13;
<strong><span class="cviolet">44</span></strong>        <span class="yell">      ++dCount;                               </span>&#13;
<strong><span class="cviolet">45</span></strong>        <span class="yell">      <span class="blue">break</span>; <span class="lgreen">// exits switch</span>                  </span>&#13;
<strong><span class="cviolet">46</span></strong>        <span class="yell">                                              </span>&#13;
<strong><span class="cviolet">47</span></strong>        <span class="yell">   <span class="blue">default</span>: <span class="lgreen">// grade was less than 60</span>         </span>&#13;
<strong><span class="cviolet">48</span></strong>        <span class="yell">      ++fCount;                               </span>&#13;
<strong><span class="cviolet">49</span></strong>        <span class="yell">      <span class="blue">break</span>; <span class="lgreen">// optional; exits switch anyway</span> </span>&#13;
<strong><span class="cviolet">50</span></strong>        <span class="yell">} <span class="lgreen">// end switch</span>                               </span>&#13;
<strong><span class="cviolet">51</span></strong>     } <span class="lgreen">// end while</span>&#13;
<strong><span class="cviolet">52</span></strong>&#13;
<strong><span class="cviolet">53</span></strong>     <span class="lgreen">// set floating-point number format</span>&#13;
<strong><span class="cviolet">54</span></strong>     cout &lt;&lt; fixed &lt;&lt; setprecision(<span class="green">2</span>);&#13;
<strong><span class="cviolet">55</span></strong>&#13;
<strong><span class="cviolet">56</span></strong>     <span class="lgreen">// display grade report</span>&#13;
<strong><span class="cviolet">57</span></strong>     cout &lt;&lt; <span class="green">"\nGrade Report:\n"</span>;&#13;
<strong><span class="cviolet">58</span></strong>&#13;
<strong><span class="cviolet">59</span></strong>     <span class="lgreen">// if user entered at least one grade...</span>&#13;
<strong><span class="cviolet">60</span></strong>     <span class="blue">if</span> (gradeCounter != <span class="green">0</span>) {&#13;
<strong><span class="cviolet">61</span></strong>        <span class="lgreen">// calculate average of all grades entered</span>&#13;
<strong><span class="cviolet">62</span></strong>        <span class="blue">double</span> average = <span class="blue">static_cast</span>&lt;<span class="blue">double</span>&gt;(total) / gradeCounter;&#13;
<strong><span class="cviolet">63</span></strong>&#13;
<strong><span class="cviolet">64</span></strong>        <span class="lgreen">// output summary of results</span>&#13;
<strong><span class="cviolet">65</span></strong>        cout &lt;&lt; <span class="green">"Total of the "</span> &lt;&lt; gradeCounter &lt;&lt; <span class="green">" grades entered is "</span>&#13;
<strong><span class="cviolet">66</span></strong>           &lt;&lt; total &lt;&lt; <span class="green">"\nClass average is "</span> &lt;&lt; average&#13;
<strong><span class="cviolet">67</span></strong>           &lt;&lt; <span class="green">"\nNumber of students who received each grade:"</span>&#13;
<strong><span class="cviolet">68</span></strong>           &lt;&lt; <span class="green">"\nA: "</span> &lt;&lt; aCount &lt;&lt; <span class="green">"\nB: "</span> &lt;&lt; bCount &lt;&lt; <span class="green">"\nC: "</span> &lt;&lt; cCount&#13;
<strong><span class="cviolet">69</span></strong>           &lt;&lt; <span class="green">"\nD: "</span> &lt;&lt; dCount &lt;&lt; <span class="green">"\nF: "</span> &lt;&lt; fCount &lt;&lt; endl;&#13;
<strong><span class="cviolet">70</span></strong>     }&#13;
<strong><span class="cviolet">71</span></strong>     <span class="blue">else</span> { <span class="lgreen">// no grades were entered, so output appropriate message</span>&#13;
<strong><span class="cviolet">72</span></strong>        cout &lt;&lt; <span class="green">"No grades were entered"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">73</span></strong>     }&#13;
<strong><span class="cviolet">74</span></strong>   }</pre>&#13;
<pre class="pre1">Enter the integer grades in the range 0-100.&#13;
Type the end-of-file indicator to terminate input:&#13;
   On UNIX/Linux/macOS type &lt;Ctrl&gt; d then press Enter&#13;
   On Windows type &lt;Ctrl&gt; z then press Enter&#13;
<strong>99</strong>&#13;
<strong>92</strong>&#13;
<strong>45</strong>&#13;
<strong>57</strong>&#13;
<strong>63</strong>&#13;
<strong>71</strong>&#13;
<strong>76</strong>&#13;
<strong>85</strong>&#13;
<strong>90</strong>&#13;
<strong>100</strong>&#13;
<strong>^Z</strong>&#13;
&#13;
Grade Report:&#13;
Total of the 10 grades entered is 778&#13;
Class average is 77.80&#13;
&#13;
Number of students who received each grade:&#13;
A: 4&#13;
B: 1&#13;
C: 2&#13;
D: 1&#13;
F: 2</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.6</strong></span> Using a <code>switch</code> statement to count letter grades.</p>&#13;
</div>&#13;
<p>The <code>main</code> function (<a href="ch04.xhtml#fig4_6">Fig. 4.6</a>) declares local variables <code>total</code> (line 8) and <code>gradeCounter</code> (line 9) to keep track of the sum of the grades entered by the user and the number of grades entered, respectively. Lines 10–14 declare and initialize to 0 counter variables for each grade category. The <code>main</code> function has two key parts. Lines 24–51 input an arbitrary number of integer grades using sentinel-controlled iteration, update variables <code>total</code> and <code>gradeCounter</code>, and increment an appropriate letter-grade counter for each grade entered. Lines 54–73 output a report containing the total of all grades entered, the average grade and the number of students who received each letter grade.</p>&#13;
<h5 class="h5" id="ch04lev3sec17">Reading Grades from the User</h5>&#13;
<p>Lines 16–19 prompt the user to enter integer grades or type the end-of-file indicator to terminate the input. The <span class="violet"><strong>end-of-file indicator</strong></span> is a system-dependent keystroke combination used to indicate that there’s no more data to input. In <a href="ch09.xhtml#ch09">Chapter 9</a>, File Processing, you’ll see how the end-of-file indicator is used when a program reads its input from a file.</p>&#13;
<p>The keystroke combinations for entering end-of-file are system dependent. On UNIX/Linux/macOS systems, type the sequence</p>&#13;
<p class="web"><em>&lt;Ctrl&gt; d</em></p>&#13;
<p>on a line by itself. This notation means to press both the <em>Ctrl</em> key and the <em>d</em> key simultaneously. On Windows systems, type</p>&#13;
<p class="web"><em>&lt;Ctrl&gt; z</em></p>&#13;
<p>On some systems, you must press <em>Enter</em> after typing the end-of-file key sequence. Also, Windows typically displays the characters <code>^Z</code> on the screen when you type the end-of-file indicator, as shown in the output of <a href="ch04.xhtml#fig4_6">Fig. 4.6</a>.</p>&#13;
<p>The <code>while</code> statement (lines 24–51) obtains the user input. Line 24</p>&#13;
<pre class="pre"><span class="blue">while</span> (cin &gt;&gt; grade) {</pre>&#13;
<p>performs the input in the <code>while</code> statement’s condition. In this case, the loop-continuation condition evaluates to true if <code>cin</code> successfully reads an <code>int</code> value. If the user enters the endof-file indicator, the condition evaluates to false.</p>&#13;
<p>If the condition evaluates to true, line 25 adds <code>grade</code> to <code>total</code> and line 26 increments <code>gradeCounter</code>. These variables are used to compute the average of the grades. Next, lines 29–50 use a <code>switch</code> statement to increment the appropriate letter-grade counter based on the numeric grade entered.</p>&#13;
<h5 class="h5" id="ch04lev3sec18">Processing the Grades</h5>&#13;
<p>The <code>switch</code> statement (lines 29–50) determines which counter to increment. We assume that the user enters a valid grade in the range 0–100. A grade in the range 90–100 represents A, 80–89 represents B, 70–79 represents C, 60–69 represents D and 0–59 represents F. The <code>switch</code> statement’s block contains a sequence of <code><strong><span class="violet">case</span></strong></code> <span class="violet"><strong>labels</strong></span> and an optional <code><strong><span class="violet">default</span></strong></code> <span class="violet"><strong>case</strong></span>, which can appear anywhere in the <code>switch</code>, but normally appears last. These are used in this example to determine which counter to increment based on the grade.</p>&#13;
<p><span class="size">11</span> When the flow of control reaches the <code>switch</code>, the program evaluates the <span class="violet"><strong>controlling expression</strong></span> in the parentheses (<code>grade / 10</code>) following keyword <code>switch</code>. The program compares this expression’s value with each <code>case</code> label. The expression must have a signed or unsigned integral type—<code>bool</code>, <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, <code>int</code>, <code>long</code> or <code>long long</code>. The expression can also use the C++11 signed or unsigned integral types, such as <code>int64_t</code> and <code>uint64_t</code>—see the <code>&lt;cstdint&gt;</code> header for a complete list of these type names.</p>&#13;
<p>The controlling expression in line 29 performs integer division, which truncates the fractional part of the result. When we divide a value from 0 to 100 by 10, the result is always a value from 0 to 10. We use several of these values in our <code>case</code> labels. If the user enters the integer <code>85</code>, the controlling expression evaluates to 8. The <code>switch</code> compares <code>8</code> with each <code>case</code> label. If a match occurs (<code>case 8:</code> at line 35), that <code>case</code>’s statements execute. For <code>8</code>, line 36 increments <code>bCount</code>, because a grade in the 80s is a B. The <code><strong><span class="violet">break</span></strong></code> <span class="violet"><strong>statement</strong></span> (line 37) exists the <code>switch</code>. In this program, we reach the end of the <code>while</code> loop, so control returns to the loop-continuation condition in line 24 to determine whether the loop should continue executing.</p>&#13;
<p>The <code>case</code>s in our <code>switch</code> explicitly test for the values <code>10</code>, <code>9</code>, <code>8</code>, <code>7</code> and <code>6</code>. Note the cases at lines 30–31 that test for the values <code>9</code> and <code>10</code> (both of which represent the grade A). Listing cases consecutively in this manner with no statements between them enables the cases to perform the same set of statements—when the controlling expression evaluates to <code>9</code> or <code>10</code>, the statements in lines 32–33 execute. The <code>switch</code> statement does not provide a mechanism for testing ranges of values, so every value you need to test must be listed in a separate <code>case</code> label. Each <code>case</code> can have multiple statements. The <code>switch</code> statement differs from other control statements in that it does not require braces around multiple statements in a <code>case</code>.</p>&#13;
<h5 class="h5" id="ch04lev3sec19"><code>case</code> without a <code>break</code> Statement</h5>&#13;
<p>Without <code>break</code> statements, each time a match occurs in the <code>switch</code>, the statements for that case and subsequent cases execute until a <code>break</code> statement or the end of the <code>switch</code> is encountered. This is often referred to as “falling through” to the statements in subsequent <code>case</code>s.<sup><a id="rch0fn2" href="ch01.xhtml#ch0fn2">2</a></sup></p>&#13;
<p class="footnote"><a id="ch0fn2" href="ch01.xhtml#rch0fn2">2</a>. This feature is perfect for writing a concise program that displays the iterative song “The Twelve Days of Christmas.” As an exercise, you might write the program, then use one of the many free, open-source text-to-speech programs to speak the song. You might also tie your program to a free, open-source MIDI (“Musical Instrument Digital Interface”) program to create a singing version of your program accompanied by music.</p>&#13;
<h5 class="h5" id="ch04lev3sec20">C++17: <code>[[fallthrough]]</code> Attribute</h5>&#13;
<p><span class="size">17</span> Forgetting a <code>break</code> statement when one is needed is a logic error. To call your attention to this possible problem, many compilers issuing a warning when a <code>case</code> does not contain a <code>break</code> statement. For instances in which “falling through” is the desired behavior, C++17 introduced the <code><strong><span class="violet">[[fallthrough]]</span></strong></code> <span class="violet"><strong>attribute</strong></span>. This enables you to tell the compiler when “falling through” is correct so that warning will not be generated.</p>&#13;
<p>In <a href="ch04.xhtml#fig4_6">Fig. 4.6</a>, for <code>case 9:</code> (line 30), we want the <code>switch</code> to fall through (without a compiler warning) and execute the statements for <code>case 10:</code>—this allows both <code>case</code>s to execute the same statements. We can indicate the desired behavior by writing line 30 as:</p>&#13;
<pre class="pre"><span class="blue">case</span> <span class="green">9</span>: [[fallthrough]];</pre>&#13;
<h5 class="h5" id="ch04lev3sec21">The <code>default</code> Case</h5>&#13;
<p>If no match occurs between the controlling expression’s value and any of the <code>case</code> labels, the <code>default</code> case (lines 47–49) executes. We use the <code>default</code> case in this example to process all controlling-expression values that are less than <code>6</code>—that is, all failing grades. If no match occurs and the <code>switch</code> does not contain a <code>default</code> case, program control simply continues with the first statement after the <code>switch</code>. In a <code>switch</code>, it’s good practice to test for all possible values of the controlling expression.</p>&#13;
<h5 class="h5" id="ch04lev3sec22">Displaying the Grade Report</h5>&#13;
<p>Lines 54–73 output a report based on the grades entered. Line 60 determines whether the user entered at least one grade—this helps us avoid dividing by zero, which for integer division causes the program to fail and for floating-point division produces the value <code>nan</code>—for “not a number”. If so, line 62 calculates the average of the grades. Lines 65–69 then output the total of all the grades, the class average and the number of students who received each letter grade. If no grades were entered, line 72 outputs an appropriate message. The output in <a href="ch04.xhtml#fig4_6">Fig. 4.6</a> shows a sample grade report based on 10 grades.</p>&#13;
<h5 class="h5" id="ch04lev3sec23"><code>switch</code> Statement UML Activity Diagram</h5>&#13;
<p>The following is the UML activity diagram for the general <code>switch</code> statement:</p>&#13;
<div class="image"><img src="Images/04unfig04.jpg" alt="Images" width="630" height="467"/></div>&#13;
<p>Most <code>switch</code> statements use a <code>break</code> in each <code>case</code> to terminate the <code>switch</code> statement after processing the <code>case</code>. The diagram emphasizes this by including <code>break</code> statements and showing that the <code>break</code> at the end of a <code>case</code> causes control to exit the <code>switch</code> statement immediately.</p>&#13;
<p>The <code>break</code> statement is not required for the <code>switch</code>’s last case (or the optional <code>default</code> case, when it appears last), because execution continues with the next statement after the <code>switch</code>. Provide a <code>default</code> case in every <code>switch</code> statement to focus you on processing exceptional conditions.</p>&#13;
<h5 class="h5" id="ch04lev3sec24">Notes on <code>case</code>s</h5>&#13;
<p>Each <code>case</code> in a <code>switch</code> statement must contain a constant integral expression—that is, any combination of integer constants that evaluates to a constant integer value. An integer constant is simply an integer value. You also can use <code>enum</code> constants (introduced in <a href="ch05.xhtml#ch05lev1sec8">Section 5.8</a>) and <span class="violet"><strong>character constants</strong></span>—specific characters in single quotes, such as <code>'A'</code>, <code>'7'</code> or <code>'$'</code>, which represent the integer values of characters. (<a href="app02.xhtml#app02">Appendix B</a> shows the integer values of the characters in the ASCII character set, which is a subset of the Unicode<sup>®</sup> character set.)</p>&#13;
<p>The expression in each <code>case</code> also can be a <span class="violet"><strong>constant variable</strong></span>—a variable containing a value that does not change for the entire program. Such a variable is declared with keyword <code>const</code> (discussed in <a href="ch05.xhtml#ch05">Chapter 5</a>).</p>&#13;
<p>In <a href="ch13.xhtml#ch13">Chapter 13</a>, Object-Oriented Programming: Polymorphism, we present a more elegant way to implement <code>switch</code> logic. We use a technique called polymorphism to create programs that are often clearer, easier to maintain and easier to extend than programs using <code>switch</code> logic.</p>&#13;
<h3 class="h3" id="ch04lev1sec9"><span class="size">17</span> <span class="violet">4.9</span> C++17: Selection Statements with Initializers</h3>&#13;
<p>Earlier, we introduced the <code>for</code> iteration statement. In the <code>for</code> header’s initialization section, we declared and initialized a control variable, which limited that variable’s scope to the <code>for</code> statement. C++17’s <span class="violet"><strong>selection statements with initializers</strong></span> enable you to include variable initializers before the condition in an <code>if</code> or <code>if…else</code> statement and before the controlling expression of a <code>switch</code> statement. As with the <code>for</code> statement, these variables are known only in the statements where they’re declared. <a href="ch04.xhtml#fig4_7">Figure 4.7</a> shows <code>if…else</code> statements with initializers. We’ll use both <code>if…else</code> and <code>switch</code> statements with initializers in <a href="ch05.xhtml#fig5_5">Fig. 5.5</a>, which implements a popular casino dice game.</p>&#13;
<div class="group" id="fig4_7">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig07" id="a04fig07">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_07.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// C++17 if statements with initializers.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="blue">if</span> (<span class="blue">int</span> value{<span class="green">7</span>}; value == <span class="green">7</span>) {&#13;
<strong><span class="cviolet"> 8</span></strong>        cout &lt;&lt; <span class="green">"value is "</span> &lt;&lt; value &lt;&lt; endl;&#13;
<strong><span class="cviolet"> 9</span></strong>     }&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">else</span> {&#13;
<strong><span class="cviolet">11</span></strong>        cout &lt;&lt; <span class="green">"value is not 7; it is "</span> &lt;&lt; value &lt;&lt; endl;&#13;
<strong><span class="cviolet">12</span></strong>     }&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="blue">if</span> (<span class="blue">int</span> value{<span class="green">13</span>}; value == <span class="green">9</span>) {&#13;
<strong><span class="cviolet">15</span></strong>        cout &lt;&lt; <span class="green">"value is "</span> &lt;&lt; value &lt;&lt; endl;&#13;
<strong><span class="cviolet">16</span></strong>     }&#13;
<strong><span class="cviolet">17</span></strong>     <span class="blue">else</span> {&#13;
<strong><span class="cviolet">18</span></strong>        cout &lt;&lt; <span class="green">"value is not 9; it is "</span> &lt;&lt; value &lt;&lt; endl;&#13;
<strong><span class="cviolet">19</span></strong>     }&#13;
<strong><span class="cviolet">20</span></strong>   }</pre>&#13;
<pre class="pre1">value is 7&#13;
value is not 9; it is 13</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.7</strong></span> C++17 <code>if</code> statements with initializers.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch04lev3sec25">Syntax of Selection Statements with Initializers</h5>&#13;
<p>For an <code>if</code> or <code>if…else</code> statement, you place the initializer first in the condition’s parentheses. For a <code>switch</code> statement, you place the initializer first in the controlling expression’s parentheses. The initializer must end with a semicolon (<code>;</code>), as in lines 7 and 14. The initializer can declare multiple variables of the same type in a comma-separated list.</p>&#13;
<h5 class="h5" id="ch04lev3sec26">Scope of Variables Declared in the Initializer</h5>&#13;
<p>Any variable declared in the initializer of an <code>if</code>, <code>if…else</code> or <code>switch</code> statement may be used throughout the remainder of the statement. In lines 7–12, we use the variable <code>value</code> to determine which branch of the <code>if…else</code> statement to execute, then use <code>value</code> in the output statements of both branches. When the <code>if…else</code> statement terminates, <code>value</code> no longer exists, so we can use that identifier again in the second <code>if…else</code> statement to declare a new variable known only in that statement.</p>&#13;
<p>To prove that value is not accessible outside the <code>if…else</code> statements, we provided a second version of this program (<code>fig04_07_with_error.cpp</code>) that attempts to access variable <code>value</code> after (and thus outside the scope of) the second <code>if…else</code> statement. This produces the following compilation errors in our three compilers:</p>&#13;
<p class="bull">• Visual Studio: <code>'value': undeclared identifier</code></p>&#13;
<p class="bull">• Xcode: <code>error: use of undeclared identifier 'value'</code></p>&#13;
<p class="bull">• GNU g++: <code>error: 'value' was not declared in this scope</code></p>&#13;
<h3 class="h3" id="ch04lev1sec10"><span class="violet">4.10</span> <code>break</code> and <code>continue</code> Statements</h3>&#13;
<p>In addition to selection and iteration statements, C++ provides statements <code>break</code> and <code><strong><span class="violet">continue</span></strong></code> to alter the flow of control. The preceding section showed how <code>break</code> could be used to terminate a <code>switch</code> statement’s execution. This section discusses how to use <code>break</code> in iteration statements.</p>&#13;
<h5 class="h5" id="ch04lev3sec27"><code>break</code> Statement</h5>&#13;
<p>The <code>break</code> statement, when executed in a <code>while</code>, <code>for</code>, <code>do…while</code> or <code>switch</code>, causes immediate exit from that statement—execution continues with the first statement after the control statement. Common uses of <code>break</code> include escaping early from a loop or exiting a <code>switch</code> (as in <a href="ch04.xhtml#fig4_6">Fig. 4.6</a>). <a href="ch04.xhtml#fig4_8">Figure 4.8</a> demonstrates a <code>break</code> statement exiting a <code>for</code> early.</p>&#13;
<div class="group" id="fig4_8">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig08" id="a04fig08">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">1</span></strong>  <span class="lgreen">// fig04_08.cpp</span>&#13;
<strong><span class="cviolet">2</span></strong>  <span class="lgreen">// break statement exiting a for statement.</span>&#13;
<strong><span class="cviolet">3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet">4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet">5</span></strong>&#13;
<strong><span class="cviolet">6</span></strong>  <span class="blue">int mai</span>n() {&#13;
<strong><span class="cviolet">7</span></strong>     <span class="blue">int</span> count; <span class="lgreen">// control variable also used after loop</span>&#13;
<strong><span class="cviolet">8</span></strong>&#13;
<strong><span class="cviolet">9</span></strong>     <span class="blue">for</span> (count = <span class="green">1</span>; count &lt;= <span class="green">10</span>; ++count) { <span class="lgreen">// loop 10 times</span>&#13;
<strong><span class="cviolet">10</span></strong>       <span class="blue">if</span> (count == <span class="green">5</span>) {&#13;
<strong><span class="cviolet">11</span></strong>          <span class="yell"><span class="blue">break</span>; <span class="lgreen">// terminates for loop if count is 5</span></span>&#13;
<strong><span class="cviolet">12</span></strong>       }&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>       cout &lt;&lt; count &lt;&lt; <span class="green">" "</span>;&#13;
<strong><span class="cviolet">15</span></strong>    }&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>    cout &lt;&lt; <span class="green">"\nBroke out of loop at count = "</span> &lt;&lt; count &lt;&lt; endl;&#13;
<strong><span class="cviolet">18</span></strong>  }</pre>&#13;
<pre class="pre1">1 2 3 4&#13;
Broke out of loop at count = 5</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.8</strong></span> <code>break</code> statement exiting a <code>for</code> statement.</p>&#13;
</div>&#13;
<p>When the <code>if</code> statement nested at lines 10–12 in the <code>for</code> statement (lines 9–15) detects that <code>count</code> is <code>5</code>, the <code>break</code> statement at line 11 executes. This terminates the <code>for</code> statement, and the program proceeds to line 17 (immediately after the <code>for</code> statement), which displays a message indicating the value of the control variable when the loop terminated. The loop fully executes its body only four times instead of 10.</p>&#13;
<h5 class="h5" id="ch04lev3sec28"><code>continue</code> Statement</h5>&#13;
<p>The <code>continue</code> statement, when executed in a <code>while</code>, <code>for</code> or <code>do…while</code>, skips the remaining statements in the loop body and proceeds with the next iteration of the loop. In <code>while</code> and <code>do…while</code> statements, the program evaluates the loop-continuation test immediately after the <code>continue</code> statement executes. In a <code>for</code> statement, the increment expression executes, then the program evaluates the loop-continuation test.</p>&#13;
<div class="group" id="fig4_9">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig09" id="a04fig09">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_09.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// continue statement terminating an iteration of a for statement.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> count{<span class="green">1</span>}; count &lt;= <span class="green">10</span>; ++count) { <span class="lgreen">// loop 10 times</span>&#13;
<strong><span class="cviolet"> 8</span></strong>        <span class="blue">if</span> (count == <span class="green">5</span>) {&#13;
<strong><span class="cviolet"> 9</span></strong>           <span class="yell">continue; <span class="lgreen">// skip remaining code in loop body if count is 5</span></span>&#13;
<strong><span class="cviolet">10</span></strong>        }&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>        cout &lt;&lt; count &lt;&lt; " ";&#13;
<strong><span class="cviolet">13</span></strong>     }&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>     cout &lt;&lt; <span class="green">"\nUsed continue to skip printing 5"</span> &lt;&lt; endl;&#13;
<strong><span class="cviolet">16</span></strong>   }</pre>&#13;
<pre class="pre1">1 2 3 4 6 7 8 9 10&#13;
Used continue to skip printing 5</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.9</strong></span> <code>continue</code> statement terminating an iteration of a <code>for</code> statement.</p>&#13;
</div>&#13;
<p><a href="ch04.xhtml#fig4_9">Figure 4.9</a> uses <code>continue</code> (line 9) to skip the statement at line 12 when the nested <code>if</code> determines that <code>count</code>’s value is <code>5</code>. When the <code>continue</code> statement executes, program control continues with the increment of the control variable in the <code>for</code> statement (line 7).</p>&#13;
<p>Some programmers feel that <code>break</code> and <code>continue</code> violate structured programming. Since the same effects are achievable with structured-programming techniques, these programmers do not use <code>break</code> or <code>continue</code>.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> There’s a tension between achieving quality software engineering and achieving the best-performing software. Sometimes one of these goals is achieved at the expense of the other. For all but the most performance-intensive situations, you should first make your code simple and correct, then make it fast and small—but only if necessary.</p>&#13;
<h3 class="h3" id="ch04lev1sec11"><span class="violet">4.11</span> Logical Operators</h3>&#13;
<p>The <code>if</code>, <code>if…else</code>, <code>while</code>, <code>do…while</code> and <code>for</code> statements each require a condition to determine how to continue a program’s flow of control. So far, we’ve studied only simple conditions, such as <code>count &lt;= 10</code>, <code>number != sentinelValue</code> and <code>total &gt; 1000</code>. Simple conditions are expressed in terms of the relational operators <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> and <code>&lt;=</code> and the equality operators <code>==</code> and <code>!=</code>, and each expression tests only one condition. To test multiple conditions in the process of making a decision, we performed these tests in separate statements or in nested <code>if</code> or <code>if…else</code> statements. Sometimes control statements require more complex conditions to determine a program’s flow of control.</p>&#13;
<p>C++’s <span class="violet"><strong>logical operators</strong></span> enable you to combine simple conditions. The logical operators are <code>&amp;&amp;</code> (logical AND), <code>||</code> (logical OR) and <code>!</code> (logical negation).</p>&#13;
<h4 class="h4" id="ch04lev2sec1">4.11.1 Logical AND (<code><strong><span class="violet">&amp;&amp;</span></strong></code>) Operator</h4>&#13;
<p>Suppose we wish to ensure at some point in a program that two conditions are both true before we choose a certain path of execution. In this case, we can use the <code><strong><span class="violet">&amp;&amp;</span></strong></code> (<span class="violet"><strong>logical AND</strong></span>) operator, as follows:</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0090-01" id="f0090-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">if</span> (gender == <span class="green">FEMALE</span> &amp;&amp; age &gt;= <span class="green">65</span>) {&#13;
   ++seniorFemales;&#13;
}</pre>&#13;
<p>This <code>if</code> statement contains two simple conditions. The condition <code>gender == FEMALE</code> com-pares variable <code>gender</code> to the constant <code>FEMALE</code> to determine whether a person is female. The condition <code>age &gt;= 65</code> might be evaluated to determine whether a person is a senior citizen. The <code>if</code> statement considers the combined condition</p>&#13;
<pre class="pre">gender == <span class="green">FEMALE</span> &amp;&amp; age &gt;= <span class="green">65</span></pre>&#13;
<p>which is true if and only if both simple conditions are true. In this case, the <code>if</code> statement’s body increments <code>seniorFemales</code> by <code>1</code>. If either or both of the simple conditions are false, the program skips the increment. Some programmers find that the preceding combined condition is more readable when redundant parentheses are added, as in</p>&#13;
<pre class="pre">(gender == <span class="green">FEMALE</span>) &amp;&amp; (age &gt;= <span class="green">65</span>)</pre>&#13;
<p>The following table summarizes the <code>&amp;&amp;</code> operator, showing all four possible combinations of the <code>bool</code> values <code>false</code> and <code>true</code> values for expression1 and expression2<em>:</em></p>&#13;
<div class="image"><img src="Images/f0128-01.jpg" alt="Images" width="580" height="204"/></div>&#13;
<p>Such tables are called <span class="violet"><strong>truth tables</strong></span>. C++ evaluates to zero (false) or nonzero (true) all expressions that include relational operators, equality operators or logical operators.</p>&#13;
<h4 class="h4" id="ch04lev2sec2">4.11.2 Logical OR (<code><strong><span class="violet">||</span></strong></code>) Operator</h4>&#13;
<p>Now suppose we wish to ensure that either or both of two conditions are true before we choose a certain path of execution. In this case, we use the <code><strong><span class="violet">||</span></strong></code> (<span class="violet"><strong>logical OR</strong></span>) operator, as in the following program segment:</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0091-01a" id="f0091-01aa">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">if</span> ((semesterAverage &gt;= <span class="green">90</span>) || (finalExam &gt;= <span class="green">90</span>)) {&#13;
   cout &lt;&lt; <span class="green">"Student grade is A\n"</span>;&#13;
}</pre>&#13;
<p>This statement also contains two simple conditions. The condition <code>semesterAverage &gt;= 90</code> determines whether the student deserves an A in the course for a solid performance throughout the semester. The condition <code>finalExam &gt;= 90</code> determines whether the student deserves an A in the course for an outstanding performance on the final exam. The <code>if</code> statement then considers the combined condition</p>&#13;
<pre class="pre">(semesterAverage &gt;= <span class="green">90</span>) || (finalExam &gt;= <span class="green">90</span>)</pre>&#13;
<p>and awards the student an A if either or both of the simple conditions are true. The only time the message <code>"Student grade is A"</code> is not printed is when both of the simple conditions are false. The following is the truth table for the operator logical OR (<code>||</code>):</p>&#13;
<div class="image"><img src="Images/f0128-02.jpg" alt="Images" width="580" height="209"/></div>&#13;
<p>Operator <code>&amp;&amp;</code> has higher precedence than operator <code>||</code>. Both operators group left-to-right.</p>&#13;
<h4 class="h4" id="ch04lev2sec3">4.11.3 Short-Circuit Evaluation</h4>&#13;
<p>The parts of an expression containing <code>&amp;&amp;</code> or <code>||</code> operators are evaluated only until it’s known whether the condition is true or false. Thus, evaluation of the expression</p>&#13;
<pre class="pre">(gender == <span class="green">FEMALE</span>) &amp;&amp; (age &gt;= <span class="green">65</span>)</pre>&#13;
<p>stops immediately if <code>gender</code> is not equal to <code>FEMALE</code> (i.e., the entire expression is false) and continues if <code>gender</code> is equal to <code>FEMALE</code> (i.e., the entire expression could still be true if the condition <code>age &gt;= 65</code> is true). This feature of logical AND and logical OR expressions is called <span class="violet"><strong>short-circuit evaluation</strong></span>.</p>&#13;
<p>In expressions using operator <code>&amp;&amp;</code>, a condition—we’ll call this the dependent condition—may require another condition to be true for the evaluation of the dependent condition to be meaningful. In this case, the dependent condition should be placed after the <code>&amp;&amp;</code> operator to prevent errors. Consider the expression <code>(i != 0) &amp;&amp; (10 / i == 2)</code>. The dependent condition <code>(10 / i == 2)</code> must appear after the <code>&amp;&amp;</code> operator to prevent the possibility of division by zero.</p>&#13;
<h4 class="h4" id="ch04lev2sec4">4.11.4 Logical Negation (<code><strong><span class="violet">!</span></strong></code>) Operator</h4>&#13;
<p>The <code><strong><span class="violet">!</span></strong></code> (<span class="violet"><strong>logical negation</strong></span>, also called <span class="violet"><strong>logical NOT</strong></span> or <span class="violet"><strong>logical complement</strong></span>) operator “reverses” the meaning of a condition. Unlike the logical operators <code>&amp;&amp;</code> and <code>||</code>, which are binary operators that combine two conditions, the logical negation operator is a unary operator that has only one condition as an operand. To execute code only when a condition is false, place the logical negation operator <em>before</em> the original condition, as in the program segment</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0092-01" id="f0092-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">if</span> (!(grade == sentinelValue)) {&#13;
   cout &lt;&lt; <span class="green">"The next grade is "</span> &lt;&lt; grade &lt;&lt; <span class="green">"\n"</span>;&#13;
}</pre>&#13;
<p>which executes the body statement only if <code>grade</code> is <em>not</em> equal to <code>sentinelValue</code>. The parentheses around the condition <code>grade == sentinelValue</code> are needed because the logical negation operator has higher precedence than the equality operator.</p>&#13;
<p>In most cases, you can avoid using logical negation by expressing the condition differently with an appropriate relational or equality operator. For example, the previous statement may also be written as follows:</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0092-02" id="f0092-02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">if</span> (grade != sentinelValue) {&#13;
   cout &lt;&lt; <span class="green">"The next grade is "</span> &lt;&lt; grade &lt;&lt; <span class="green">"\n"</span>;&#13;
}</pre>&#13;
<p>This flexibility can help you express a condition more conveniently. The following is the truth table for the logical negation operator:</p>&#13;
<div class="image"><img src="Images/f0129-01.jpg" alt="Images" width="480" height="147"/></div>&#13;
<h4 class="h4" id="ch04lev2sec5">4.11.5 Example: Using the Logical Operators to Produce Their Truth Tables</h4>&#13;
<p><a href="ch04.xhtml#fig4_10">Figure 4.10</a> uses logical operators to produce the truth tables discussed in this section. The output shows each expression that’s evaluated and its <code>bool</code> result. By default, <code>bool</code> values <code>true</code> and <code>false</code> are displayed by <code>cout</code> and the stream insertion operator as <code>1</code> and <code>0</code>, respectively. The sticky <span class="violet"><strong>stream manipulator</strong></span> <code><strong><span class="violet">boolalpha</span></strong></code> (line 8) specifies that each <code>bool</code> expression’s value should be displayed as the word “true” or the word “false.” Lines 8–12, 15–19 and 22–24 produce the truth tables for <code>&amp;&amp;</code>, <code>||</code> and <code>!</code>, respectively.</p>&#13;
<div class="group" id="fig4_10">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig10" id="a04fig10">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_10.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Logical operators.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 5</span></strong>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet"> 7</span></strong>     <span class="lgreen">// create truth table for &amp;&amp; (logical AND) operator</span>&#13;
<strong><span class="cviolet"> 8</span></strong>     cout &lt;&lt; boolalpha &lt;&lt; <span class="green">"Logical AND (&amp;&amp;)"</span>&#13;
<strong><span class="cviolet"> 9</span></strong>        &lt;&lt; <span class="green">"\nfalse &amp;&amp; false: "</span> &lt;&lt; (<span class="blue">false</span> &amp;&amp; <span class="blue">false</span>)&#13;
<strong><span class="cviolet">10</span></strong>        &lt;&lt; <span class="green">"\nfalse &amp;&amp; true: "</span> &lt;&lt; (<span class="blue">false</span> &amp;&amp; <span class="blue">true</span>)&#13;
<strong><span class="cviolet">11</span></strong>        &lt;&lt; <span class="green">"\ntrue &amp;&amp; false: "</span> &lt;&lt; (<span class="blue">true</span> &amp;&amp; <span class="blue">false</span>)&#13;
<strong><span class="cviolet">12</span></strong>        &lt;&lt; <span class="green">"\ntrue &amp;&amp; true: "</span> &lt;&lt; (<span class="blue">true</span> &amp;&amp; <span class="blue">true</span>) &lt;&lt; <span class="green">"\n\n"</span>;&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>     <span class="lgreen">// create truth table for || (logical OR) operator</span>&#13;
<strong><span class="cviolet">15</span></strong>     cout &lt;&lt; <span class="green">"Logical OR (||)"</span>&#13;
<strong><span class="cviolet">16</span></strong>        &lt;&lt; <span class="green">"\nfalse || false: "</span> &lt;&lt; (<span class="blue">false</span> || <span class="blue">false</span>)&#13;
<strong><span class="cviolet">17</span></strong>        &lt;&lt; <span class="green">"\nfalse || true: "</span> &lt;&lt; (<span class="blue">false</span> || <span class="blue">true</span>)&#13;
<strong><span class="cviolet">18</span></strong>        &lt;&lt; <span class="green">"\ntrue || false: "</span> &lt;&lt; (<span class="blue">true</span> || <span class="blue">false</span>)&#13;
<strong><span class="cviolet">19</span></strong>        &lt;&lt; <span class="green">"\ntrue || true: "</span> &lt;&lt; (<span class="blue">true</span> || <span class="blue">true</span>) &lt;&lt; <span class="green">"\n\n"</span>;&#13;
<strong><span class="cviolet">20</span></strong>&#13;
<strong><span class="cviolet">21</span></strong>     <span class="lgreen">// create truth table for ! (logical negation) operator</span>&#13;
<strong><span class="cviolet">22</span></strong>     cout &lt;&lt; <span class="green">"Logical negation (!)"</span>&#13;
<strong><span class="cviolet">23</span></strong>        &lt;&lt; <span class="green">"\n!false: "</span> &lt;&lt; (!<span class="blue">false</span>)&#13;
<strong><span class="cviolet">24</span></strong>        &lt;&lt; <span class="green">"\n!true: "</span> &lt;&lt; (!<span class="blue">true</span>) &lt;&lt; endl;&#13;
<strong><span class="cviolet">25</span></strong>   }</pre>&#13;
<pre class="pre1">Logical AND (&amp;&amp;)&#13;
false &amp;&amp; false: false&#13;
false &amp;&amp; true: false&#13;
true &amp;&amp; false: false&#13;
true &amp;&amp; true: true&#13;
&#13;
Logical OR (||)&#13;
false || false: false&#13;
false || true: true&#13;
true || false: true&#13;
true || true: true&#13;
&#13;
Logical negation (!)&#13;
!false: true&#13;
!true: false</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.10</strong></span> Logical operators.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch04lev3sec29">Precedence and Grouping of the Operators Presented So Far</h5>&#13;
<p>The following table shows the precedence and grouping of the C++ operators introduced so far—from top to bottom in decreasing order of precedence:</p>&#13;
<div class="image"><img src="Images/f0131-01.jpg" alt="Images" width="830" height="536"/></div>&#13;
<h3 class="h3" id="ch04lev1sec12"><span class="violet">4.12</span> Confusing the Equality (<code>==</code>) and Assignment (<code>=</code>) Operators</h3>&#13;
<p>There’s one error that C++ programmers, no matter how experienced, tend to make so frequently that we feel it requires a separate section. That error is accidentally swapping the operators <code>==</code> (equality) and <code>=</code> (assignment). What makes this so damaging is that it ordinarily does not cause syntax errors. Statements with these errors tend to compile correctly and run to completion, often generating incorrect results through runtime logic errors. Some compilers issue a warning when <code>=</code> is used in a context where <code>==</code> is expected.</p>&#13;
<p>Two aspects of C++ contribute to these problems. One is that any expression that produces a value can be used in the decision portion of any control statement. If the expression’s value is zero, it’s treated as <code>false</code>. If the value is nonzero, it’s treated as <code>true</code>. The second is that assignments produce a value—namely, the value assigned to the variable on the left side of the assignment operator. For example, suppose we intend to write</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0094-01" id="f0094-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">if</span> (payCode == <span class="green">4</span>) { <span class="lgreen">// good</span>&#13;
   cout &lt;&lt; <span class="green">"You get a bonus!"</span> &lt;&lt; endl;&#13;
}</pre>&#13;
<p>but we accidentally write</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0094-02" id="f0094-02a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">if</span> (payCode = <span class="green">4</span>) { <span class="lgreen">// bad</span>&#13;
   cout &lt;&lt; <span class="green">"You get a bonus!"</span> &lt;&lt; endl;&#13;
}</pre>&#13;
<p>The first <code>if</code> statement properly awards a bonus to the person whose <code>payCode</code> is equal to 4. The second one—which contains the error—evaluates the assignment expression in the <code>if</code> condition to the constant 4. Any nonzero value is <code>true</code>, so this condition always evaluates as <code>true</code> and the person always receives a bonus regardless of the pay code! Even worse, the pay code has been modified when it was only supposed to be examined!</p>&#13;
<h5 class="h5" id="ch04lev3sec30">lvalues and rvalues</h5>&#13;
<p>You can prevent the preceding problem with a simple trick. First, it’s helpful to know what’s allowed to the left of an assignment operator. Variable names are said to be <span class="violet"><strong><em>lvalues</em></strong></span> (for “left values”) because they can be used on an assignment operator’s left side. Literals are said to be <span class="violet"><strong><em>rvalues</em></strong></span> (for “right values”) because they can be used on only an assignment operator’s right side. <em>Lvalues</em> also can be used as <em>rvalues</em> on the right side of an assignment, but not vice versa.</p>&#13;
<p>Programmers normally write conditions such as <code>x == 7</code> with the variable name (an <em>lvalue</em>) on the left and the literal (an <em>rvalue</em>) on the right. Placing the literal on the left, as in <code>7== x</code> (which is syntactically correct), enables the compiler to issue an error if you accidentally replace the <code>==</code> operator with <code>=</code>. The compiler treats this as a compilation error because you can’t change a literal’s value.</p>&#13;
<h5 class="h5" id="ch04lev3sec31">Using <code>==</code> in Place of <code>=</code></h5>&#13;
<p>There’s another equally unpleasant situation. Suppose you want to assign a value to a variable with a simple statement like</p>&#13;
<pre class="pre">x = <span class="green">1</span>;</pre>&#13;
<p>but instead write</p>&#13;
<pre class="pre">x == <span class="green">1</span>;</pre>&#13;
<p>Here, too, this is not a syntax error. Rather, the compiler simply evaluates the expression. If <code>x</code> is equal to <code>1</code>, the condition is true, and the expression evaluates to a nonzero (true) value. If <code>x</code> is not equal to <code>1</code>, the condition is false and the expression evaluates to 0. Regardless of the expression’s value, there’s no assignment operator, so the value is lost. The value of <code>x</code> remains unaltered, probably causing an execution-time logic error. Using operator <code>==</code> for assignment and using operator <code>=</code> for equality are logic errors. Use your text editor to search for all occurrences of <code>=</code> in your program and check that you have the correct assignment. relational or equality operator in each place.</p>&#13;
<h3 class="h3" id="ch04lev1sec13"><span class="size">20</span> <span class="violet">4.13</span> C++20 Feature Mock-Up: <code>[[likely]]</code> and <code>[[unlikely]]</code> Attributes</h3>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> Today’s compilers use sophisticated optimization techniques<sup><a id="rch0fn3" href="ch01.xhtml#ch0fn3">3</a></sup> to tune your code’s performance. C++20 introduces the attributes <code><strong><span class="violet">[[likely]]</span></strong></code> and <code><strong><span class="violet">[[unlikely]]</span></strong></code> that enable you to provide additional hints to help compilers optimize <code>if</code>, <code>if…else</code> and <code>switch</code> statement code for better performance.<sup><a id="rch0fn4" href="ch02.xhtml#ch0fn4">4</a></sup> These attributes indicate paths of execution that are likely or unlikely to be taken. Many of today’s compilers already provide mechanisms like this, so <code>[[likely]]</code> and <code>[[unlikely]]</code> standardize these features across compilers.<sup><a id="rch0fn5" href="ch03.xhtml#ch0fn5">5</a></sup></p>&#13;
<p class="footnote"><a id="ch0fn3" href="ch01.xhtml#rch0fn3">3</a>. “Optimizing Compiler.” Wikipedia. Wikimedia Foundation, April 7, 2020. <code><a href="https://en.wikipedia.org/wiki/Optimizing_compiler#Specific_techniques">https://en.wikipedia.org/wiki/Optimizing_compiler#Specific_techniques</a></code>.</p>&#13;
<p class="footnote"><a id="ch0fn4" href="ch02.xhtml#rch0fn4">4</a>. Note to reviewers: At the time of this writing, these attributes were not implemented by our preferred compilers. We searched for insights as to why and how you’d use this feature to produce better optimized code. Even though the standard is about to be accepted in May, there is little information at this point other than the proposal document “Attributes for Likely and Unlikely Statements (Revision 2)” (<code><a href="https://wg21.link/p0479r2">https://wg21.link/p0479r2</a></code>). Section 3, Motivation and Scope, suggests who should use these features and what they should be used for.</p>&#13;
<p class="footnote"><a id="ch0fn5" href="ch03.xhtml#rch0fn5">5</a>. Sutter, Herb. “Trip Report: Winter ISO C Standards Meeting (Jacksonville).” Sutter's Mill, April 3, 2018. <code><a href="https://herbsutter.com/2018/04/">https://herbsutter.com/2018/04/</a></code>. Herb Sutter is the Convener of the ISO C++ committee and a Software Architect at Microsoft.</p>&#13;
<p>To use these attributes, place <code>[[likely]]</code> or <code>[[unlikely]]</code> before the body of an <code>if</code> or <code>else</code>, as in</p>&#13;
<pre class="pre"><span class="blue">if</span> (<em>condition</em>) [[likely]] {&#13;
   <span class="lgreen">// statements</span>&#13;
}&#13;
<span class="blue">else</span> {&#13;
   <span class="lgreen">// statements</span>&#13;
}</pre>&#13;
<p>or before a <code>case</code> label in a <code>switch</code>, as in</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0096-01" id="f0096-01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">switch</span> (<em>controllingExpression</em>) {&#13;
   <span class="blue">case</span> <span class="green">7</span>:&#13;
      <span class="lgreen">// statements</span>&#13;
      <span class="blue">break</span>;&#13;
   [[likely]] <span class="blue">case</span> <span class="green">11</span>:&#13;
      <span class="lgreen">// statements</span>&#13;
      <span class="blue">break</span>;&#13;
   <span class="blue">default</span>:&#13;
      <span class="lgreen">// statements</span>&#13;
      <span class="blue">break</span>;&#13;
}</pre>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> There are subtle issues when using these attributes. Using too many <code>[[likely]]</code> and <code>[[unlikely]]</code> attributes in your code could actually reduce performance.<sup><a id="rch0fn6" href="ch03.xhtml#ch0fn6">6</a></sup> The document that proposed adding these to the language says for each, “This attribute is intended for specialized optimizations which are implementation specific. General usage of this attribute is discouraged.”<sup><a id="rch0fn7" href="ch03.xhtml#ch0fn7">7</a></sup> For a discussion of other subtleties, see the proposal document at:</p>&#13;
<p class="footnote"><a id="ch0fn6" href="ch03.xhtml#rch0fn6">6</a>. Section 9.12.6, “Working Draft, Standard for Programming Language C.” ISO/IEC, April 3, 2020. <code><a href="https://github.com/cplusplus/draft/releases/download/n4861/n4861.pdf">https://github.com/cplusplus/draft/releases/download/n4861/n4861.pdf</a></code>.</p>&#13;
<p class="footnote"><a id="ch0fn7" href="ch03.xhtml#rch0fn7">7</a>. “Attributes for Likely and Unlikely Statements (Revision 2).” <code><a href="https://wg21.link/p0479r2">https://wg21.link/p0479r2</a></code>. Section VIII, Technical Specifications.</p>&#13;
<pre class="pre"><a href="https://wg21.link/p0479r2">https://wg21.link/p0479r2</a></pre>&#13;
<p>If you’re working on systems with strict performance requirements you may want to investigate these attributes further.</p>&#13;
<h3 class="h3" id="ch04lev1sec14"><span class="violet">4.14</span> Objects Natural Case Study: Using the <code>miniz-cpp</code> Library to Write and Read ZIP files<sup><a id="rch0fn8" href="ch03.xhtml#ch0fn8">8</a></sup></h3>&#13;
<p class="footnote"><a id="ch0fn8" href="ch03.xhtml#rch0fn8">8</a>. This example does not compile in GNU C++.</p>&#13;
<p><img class="inline" src="Images/common01.jpg" alt="Images" width="34" height="29"/> <span class="size"><small>PERF</small></span> <span class="violet"><strong>Data compression</strong></span> reduces the size of data—typically to save memory, to save secondary storage space or to transmit data over the Internet faster by reducing the number of bytes. <span class="violet"><strong>Lossless data-compression algorithms</strong></span> compress data in a manner that does not lose information—the data can be uncompressed and restored to its original form. <span class="violet"><strong>Lossy data-compression algorithms</strong></span> permanently discard information. Such algorithms are often used to compress audio and video. For example, when you watch streaming video online, the video is often compressed using a lossy algorithm to minimize the total bytes transferred over the Internet. Though some of the video data is discarded, a lossy algorithm compresses the data in a manner such that most people do not notice the removed information as they watch the video. The video quality is still “pretty good.”</p>&#13;
<h5 class="h5" id="ch04lev3sec32">ZIP Files</h5>&#13;
<p>You’ve probably used ZIP files—if not, you almost certainly will. The <span class="violet"><strong>ZIP file format</strong></span><sup><a id="rch0fn9" href="ch03.xhtml#ch0fn9">9</a></sup> is a lossless compression<sup><a id="rch0fn10" href="ch03.xhtml#ch0fn10">10</a></sup> format that has been in use for over 30 years. Lossless compression algorithms use various techniques for compressing data—such as</p>&#13;
<p class="footnote"><a id="ch0fn9" href="ch03.xhtml#rch0fn9">9</a>. “Zip (File Format).” Wikipedia. Wikimedia Foundation, April 23, 2020. <code><a href="https://en.wikipedia.org/wiki/Zip_(file_format)">https://en.wikipedia.org/wiki/Zip_(file_format)</a></code>.</p>&#13;
<p class="footnote"><a id="ch0fn10" href="ch03.xhtml#rch0fn10">10</a>. “Data Compression.” Wikipedia. Wikimedia Foundation, April 16, 2020. <code><a href="https://en.wikipedia.org/wiki/Data_compression#Lossless">https://en.wikipedia.org/wiki/Data_compression#Lossless</a></code>.</p>&#13;
<p class="bull">• replacing duplicate patterns, such as text strings in a document or pixels in an image, with references to a single copy, and</p>&#13;
<p class="bull">• replacing a group of image pixels that have the same color with one pixel of that color and a count.</p>&#13;
<p>ZIP is used to compress files and directories into a single file, known as an <span class="violet"><strong>archive file</strong></span>. ZIP files are often used to distribute software faster over the Internet. Today’s operating systems typically have built-in support for creating ZIP files and extracting their contents.</p>&#13;
<h5 class="h5" id="ch04lev3sec33">Open-Source <code>miniz-cpp</code> Library</h5>&#13;
<p>Many open-source libraries support programmatic manipulation of ZIP archive files and other popular archive-file formats, such as TAR, RAR and 7-Zip.<sup><a id="rch0fn11" href="ch03.xhtml#ch0fn11">11</a></sup> <a href="ch04.xhtml#fig4_11">Figure 4.11</a> continues our objects natural presentation by using objects of the open-source <code>miniz-cpp</code><sup><a id="rch0fn12" href="ch03.xhtml#ch0fn12">12</a>,<a id="rch0fn13" href="ch03.xhtml#ch0fn13">13</a></sup> library’s class <code>zip_file</code> to create and read ZIP files. The <code>miniz-cpp</code> library is a “header-only library”—it’s defined in header file <code>zip_file.hpp</code> that you can simply include in your project (line 5). We provide the library in the <code>examples</code> folder’s <code>libraries/minizcpp</code> subfolder. Header files are discussed in depth in <a href="ch10.xhtml#ch10">Chapter 10</a>.</p>&#13;
<p class="footnote"><a id="ch0fn11" href="ch03.xhtml#rch0fn11">11</a>. “List of Archive Formats.” Wikipedia. Wikimedia Foundation, March 19, 2020. <code><a href="https://en.wikipedia.org/wiki/List_of_archive_formats">https://en.wikipedia.org/wiki/List_of_archive_formats</a></code>.</p>&#13;
<p class="footnote"><a id="ch0fn12" href="ch03.xhtml#rch0fn12">12</a>. <code><a href="https://github.com/tfussell/miniz-cpp">https://github.com/tfussell/miniz-cpp</a></code>.</p>&#13;
<p class="footnote"><a id="ch0fn13" href="ch03.xhtml#rch0fn13">13</a>. The miniz-cpp library provides nearly identical capabilities to the Python standard library’s <code>zipfile</code> module (<code><a href="https://docs.python.org/3/library/zipfile.html">https://docs.python.org/3/library/zipfile.html</a></code>), so the miniz-cpp GitHub repository refers you to that documentation page for the list of features.</p>&#13;
<div class="group" id="fig4_11">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig11" id="a04fig11">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet"> 1</span></strong>   <span class="lgreen">// fig04_11.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Using the miniz-cpp header-only library to write and read a ZIP file.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;string&gt;&#13;
<strong><span class="cviolet"> <span class="yell">5</span></span></strong>  <span class="yell"><span class="blue">#include</span> <span class="green">"zip_file.hpp"</span></span>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 7</span></strong></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.11</strong></span> Using the miniz-cpp header-only library to write and read a ZIP file.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch04lev3sec34">Inputting a Line of Text from the User with <code>getline</code></h5>&#13;
<p>The <code><strong><span class="violet">getline</span></strong></code> function call reads all the characters you type until you press <em>Enter</em>:</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0097-01" id="f0097-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"> <span class="cviolet"><strong>8</strong></span> <span class="blue">int</span> main() {&#13;
 <span class="cviolet"><strong>9</strong></span>    cout &lt;&lt; <span class="green">"Enter a ZIP file name: "</span>;&#13;
<span class="cviolet"><strong>10</strong></span>    string zipFileName;&#13;
<span class="cviolet"><strong>11</strong></span>    <span class="yell">getline(cin, zipFileName);</span> <span class="lgreen">// inputs a line of text</span>&#13;
<span class="cviolet"><strong>12</strong></span></pre>&#13;
<pre class="pre1">Enter a ZIP file name: c:\users\useraccount\Documents\test.zip</pre>&#13;
<p>Here we use <code>getline</code> to read from the user a the location and name of a file, and store it in the <code>string</code> variable <code>zipFileName</code>. Like class <code>string</code>, <code>getline</code> requires the <code>&lt;string&gt;</code> header and belongs to namespace <code>std</code>.</p>&#13;
<h5 class="h5" id="ch04lev3sec35">Creating Sample Content to Write into Individual Files in the ZIP File</h5>&#13;
<p>The following statement creates a lengthy string named <code>content</code> consisting of sentences from this chapter’s introduction:</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0098-01" id="f0098-01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">13</span></strong>    <span class="lgreen">// strings literals separated only by whitespace are combined</span>&#13;
<strong><span class="cviolet">14</span></strong>    <span class="lgreen">// into a single string by the compiler</span>&#13;
<strong><span class="cviolet">15</span></strong>    string content{&#13;
<strong><span class="cviolet">16</span></strong>       <span class="green">"This chapter introduces all but one of the remaining control "</span>&#13;
<strong><span class="cviolet">17</span></strong>       <span class="green">"statements--the for, do...while, switch, break and continue "</span>&#13;
<strong><span class="cviolet">18</span></strong>       <span class="green">"statements. We explore the essentials of counter-controlled "</span>&#13;
<strong><span class="cviolet">19</span></strong>       <span class="green">"iteration. We use compound-interest calculations to begin "</span>&#13;
<strong><span class="cviolet">20</span></strong>       <span class="green">"investigating the issues of processing monetary amounts. First, "</span>&#13;
<strong><span class="cviolet">21</span></strong>       <span class="green">"we discuss the representational errors associated with "</span>&#13;
<strong><span class="cviolet">22</span></strong>       <span class="green">"floating-point types. We use a switch statement to count the "</span>&#13;
<strong><span class="cviolet">23</span></strong>       <span class="green">"number of A, B, C, D and F grade equivalents in a set of "</span>&#13;
<strong><span class="cviolet">24</span></strong>       <span class="green">"numeric grades. We show C++17's enhancements that allow you to "</span>&#13;
<strong><span class="cviolet">25</span></strong>       <span class="green">"initialize one or more variables of the same type in the "</span>&#13;
<strong><span class="cviolet">26</span></strong>       <span class="green">"headers of if and switch statements."</span>};&#13;
<strong><span class="cviolet">27</span></strong></pre>&#13;
<p>We’ll use the <code>miniz-cpp</code> library to write this string as a text file that will be compressed into a ZIP file. Each string literal in the preceding statement is separated from the next only by whitespace. The C++ compiler automatically assembles such string literals into a single string literal, which we use to initialize the <code>string</code> variable <code>content</code>. The following statement outputs the length of <code>content</code> (632 bytes).</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0098-02" id="f0098-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">28</span></strong>    cout &lt;&lt; <span class="green">"\ncontent.length(): "</span> &lt;&lt; content.length();&#13;
<strong><span class="cviolet">29</span></strong></pre>&#13;
<pre class="pre1">content.length(): 632</pre>&#13;
<h5 class="h5" id="ch04lev3sec36">Creating a <code>zip_file</code> Object</h5>&#13;
<p>The <code>miniz-cpp</code> library’s <code>zip_file</code> class—located in the library’s <code>miniz_cpp</code> namespace— is used to create a ZIP file. The statement</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0098-03" id="f0098-03a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">30</span></strong>    <span class="yell">miniz_cpp::zip_file output;</span> <span class="lgreen">// create zip_file object</span>&#13;
<strong><span class="cviolet">31</span></strong></pre>&#13;
<p>creates the <code>zip_file</code> object <code>output</code>, which will perform the ZIP operations to create the archive file.</p>&#13;
<h5 class="h5" id="ch04lev3sec37">Creating a File in the <code>zip_file</code> Object and Saving That Object to Disk</h5>&#13;
<p>Line 33 calls <code>output</code>’s <code>writestr</code> member function, which creates one file (<code>"intro.txt"</code>) in the ZIP archive containing the text in <code>content</code>. Line 34 calls <code>output</code>’s <code>save</code> member function to store the <code>output</code> object’s contents in the file specified by <code>zipFileName</code>:</p>&#13;
<div class="group" id="fig4_11a">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig11a" id="a04fig11a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">32</span></strong>     <span class="lgreen">// write content into a text file in output</span>&#13;
<strong><span class="cviolet">33</span></strong>     <span class="yell">output.writestr(<span class="green">"intro.txt"</span>, content);</span> <span class="lgreen">// create file in ZIP</span>&#13;
<strong><span class="cviolet">34</span></strong>     <span class="yell">output.save(zipFileName);</span> <span class="lgreen">// save output to zipFileName</span>&#13;
<strong><span class="cviolet">35</span></strong></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.11</strong></span> Using the miniz-cpp header-only library to write and read a ZIP file.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch04lev3sec38">ZIP Appear to Contain Random Symbols</h5>&#13;
<p>ZIP is a binary format, so if you open the compressed file in a text editor, you’ll see mostly gibberish. Below is what the file looks like in the Windows Notepad text editor:</p>&#13;
<div class="image"><img src="Images/04unfig05.jpg" alt="Images" width="1132" height="218"/></div>&#13;
<h5 class="h5" id="ch04lev3sec39">Reading the Contents of the ZIP File</h5>&#13;
<p>You can locate the ZIP file on your system and extract (decompress) its contents to confirm that the ZIP file was written correctly. The <code>miniz-cpp</code> library also supports reading and processing a ZIP file’s contents programmatically. The following statement creates a <code>zip_file</code> object named <code>input</code> and initializes it with the name of a ZIP file:</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0099-01" id="f0099-01a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">36</span></strong>    <span class="yell">miniz_cpp::zip_file input{zipFileName};</span> <span class="lgreen">// load zipFileName</span>&#13;
<strong><span class="cviolet">37</span></strong></pre>&#13;
<p>This reads the corresponding ZIP archive’s contents. We can then use the <code>zip_file</code> object’s member functions to interact with the archived files.</p>&#13;
<h5 class="h5" id="ch04lev3sec40">Displaying the Name and Contents of the ZIP File</h5>&#13;
<p>The following statements call <code>input</code>’s <code>get_filename</code> and <code>printdir</code> member functions to display the ZIP’s file name and a directory listing of the ZIP file’s contents, respectively.</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0099-02" id="f0099-02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">38</span></strong>    <span class="lgreen">// display input's file name and directory listing</span>&#13;
<strong><span class="cviolet">39</span></strong>    cout &lt;&lt; <span class="green">"\n\nZIP file's name: "</span> &lt;&lt; <span class="yell">input.get_filename()</span>&#13;
<strong><span class="cviolet">40</span></strong>       &lt;&lt; <span class="green">"\n\nZIP file's directory listing:\n"</span>;&#13;
<strong><span class="cviolet">41</span></strong>    <span class="yell">input.printdir();</span>&#13;
<strong><span class="cviolet">42</span></strong></pre>&#13;
<pre class="pre1">ZIP file's name: c:\users\useraccount\Documents\test.zip&#13;
&#13;
ZIP file's directory listing:&#13;
  Length      Date    Time    Name&#13;
---------  ---------- -----   ----&#13;
      632  04/23/2020 16:48   intro.txt&#13;
---------                     -------&#13;
      632                     1 file</pre>&#13;
<p>The output shows that the ZIP archive contains the file <code>intro.txt</code> and that the file’s length is <code>632</code>, which matches that of the string <code>content</code> we wrote to the file earlier.</p>&#13;
<h5 class="h5" id="ch04lev3sec41">Getting and Displaying Information About a Specific File in the ZIP Archive</h5>&#13;
<p>Line 44 declares and initializes the <code>zip_info</code> object <code>info</code>:</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0100-02" id="f0100-02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">43</span></strong>    <span class="lgreen">// display info about the compressed intro.txt file</span>&#13;
<strong><span class="cviolet">44</span></strong>    <span class="yell">miniz_cpp::zip_info info{input.getinfo(<span class="green">"intro.txt"</span>)};</span>&#13;
<strong><span class="cviolet">45</span></strong></pre>&#13;
<p>Calling <code>input</code>’s <code>getinfo</code> member function returns a <code>zip_info</code> object (from namespace <code>miniz_cpp</code>) for the specified filen in the archive. The object <code>info</code> contains information about the archive’s <code>intro.txt</code> file, including the file’s name (<code>info.filename</code>), its uncom-pressed size (<code>info.file_size</code>) and its compressed size (<code>info.compress_size</code>):</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0100-03" id="f0100-03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">46</span></strong>    cout &lt;&lt; <span class="green">"\nFile name: "</span> &lt;&lt; <span class="yell">info.filename</span>&#13;
<strong><span class="cviolet">47</span></strong>       &lt;&lt; <span class="green">"\nOriginal size: "</span> &lt;&lt; <span class="yell">info.file_size</span>&#13;
<strong><span class="cviolet">48</span></strong>       &lt;&lt; <span class="green">"\nCompressed size: "</span> &lt;&lt; <span class="yell">info.compress_size</span>;&#13;
<strong><span class="cviolet">49</span></strong></pre>&#13;
<pre class="pre1">File name: intro.txt&#13;
Original size: 632&#13;
Compressed size: 360</pre>&#13;
<p>Note that <code>intro.txt</code>’s compressed size is only 360 bytes—43% smaller than the original file. Compression amounts vary considerably, based on the type of content being compressed.</p>&#13;
<h5 class="h5" id="ch04lev3sec42">Extracting <code>"intro.txt"</code> and Displaying Its Original Contents</h5>&#13;
<p>You can extract a compressed file from the ZIP archive to restore the original. Here we use the <code>input</code> object’s <code>read</code> member function, passing the <code>zip_info</code> object (<code>info</code>) as an argument. This returns as a <code>string</code> the contents of the file represented by the object <code>info</code>:</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0100-04" id="f0100-04a">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">50</span></strong>    <span class="lgreen">// original file contents</span>&#13;
<strong><span class="cviolet">51</span></strong>    string extractedContent{<span class="yell">input.read(info)</span>};&#13;
<strong><span class="cviolet">52</span></strong></pre>&#13;
<p>We output <code>extractedContent</code> to show that it matches the original string <code>content</code> that we “zipped up”. This was indeed a lossless compression:</p>&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#f0101-01" id="f0101-01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">53</span></strong>    cout &lt;&lt; <span class="green">"\n\nOriginal contents of intro.txt:\n"</span> &lt;&lt;&#13;
<strong><span class="cviolet">54</span></strong>       extractedContent &lt;&lt; endl;&#13;
<strong><span class="cviolet">55</span></strong>  }</pre>&#13;
<pre class="pre1">Original contents of intro.txt:&#13;
This chapter introduces all but one of the remaining control statements--the&#13;
for, do...while, switch, break and continue statements. We explore the&#13;
essentials of counter-controlled iteration. We use compound-interest&#13;
calculations to begin investigating the issues of processing monetary&#13;
amounts. First, we discuss the representational errors associated with&#13;
floating-point types. We use a switch statement to count the number of A, B,&#13;
C, D and F grade equivalents in a set of numeric grades. We show C++17's&#13;
enhancements that allow you to initialize one or more variables of the same&#13;
type in the headers of if and switch statements.</pre>&#13;
<h3 class="h3" id="ch04lev1sec15"><span class="size">20</span> <span class="violet">4.15</span> C++20 Feature Mock-Up: Text Formatting with Field Widths and Precisions</h3>&#13;
<p>In <a href="ch03.xhtml#ch03lev1sec13">Section 3.13</a>, we introduced C++20’s <code>format</code> function (in header <code>&lt;format&gt;</code>), which provides powerful new text formatting capabilities. <a href="ch04.xhtml#fig4_12">Figure 4.12</a> shows how <code>format</code> strings can concisely specify what each value’s format should be.<sup><a id="rch0fn14" href="ch04.xhtml#ch0fn14">14</a></sup> We reimplement the formatting introduced in <a href="ch04.xhtml#fig4_4">Fig. 4.4</a>’s compound interest problem. <a href="ch04.xhtml#fig4_12">Figure 4.12</a> produces the same output as <a href="ch04.xhtml#fig4_4">Fig. 4.4</a>, so we’ll focus exclusively on the format strings in lines 13, 14, 17 and 22.</p>&#13;
<p class="footnote"><a id="ch0fn14" href="ch04.xhtml#rch0fn14">14</a>. Some of our C++20 Feature Mock-Up sections present code that does not compile or run. Once the compilers implement those features, we’ll retest the code, update our digital products and post updates for our print products at <code><a href="https://deitel.com/c-plus-plus-20-for-programmers">https://deitel.com/c-plus-plus-20-for-programmers</a></code>. The code in this example runs, but uses the <code>{fmt}</code> open-source library to demonstrate features that C++20 compilers will support eventually.</p>&#13;
<div class="group" id="fig4_12">&#13;
<p class="codelink"><a href="Images/ch04_images.xhtml#aa04fig12" id="a04fig12">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet"> 1</span></strong>  <span class="lgreen">// fig04_12.cpp</span>&#13;
<strong><span class="cviolet"> 2</span></strong>  <span class="lgreen">// Compound-interest example with C++20 text formatting.</span>&#13;
<strong><span class="cviolet"> 3</span></strong>  <span class="blue">#include</span> &lt;iostream&gt;&#13;
<strong><span class="cviolet"> 4</span></strong>  <span class="blue">#include</span> &lt;cmath&gt; <span class="lgreen">// for pow function</span>&#13;
<strong><span class="cviolet"> 5</span></strong>  <span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// in C++20, this will be #include &lt;format&gt;</span>&#13;
<strong><span class="cviolet"> 6</span></strong>  <span class="blue">using namespace</span> std;&#13;
<strong><span class="cviolet"> 7</span></strong>  <span class="blue">using namespace</span> fmt; <span class="lgreen">// not needed in C++20</span>&#13;
<strong><span class="cviolet"> 8</span></strong>&#13;
<strong><span class="cviolet"> 9</span></strong>  <span class="blue">int</span> main() {&#13;
<strong><span class="cviolet">10</span></strong>     <span class="blue">double</span> principal{<span class="green">1000.00</span>}; <span class="lgreen">// initial amount before interest</span>&#13;
<strong><span class="cviolet">11</span></strong>     <span class="blue">double</span> rate{<span class="green">0.05</span>}; <span class="lgreen">// interest rate</span>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>     cout &lt;&lt; <span class="yell">format(<span class="green">"Initial principal: {:&gt;7.2f}\n"</span>, principal)</span>&#13;
<strong><span class="cviolet">14</span></strong>          &lt;&lt; <span class="yell">format(" In<span class="green">terest rate: {:&gt;7.2f}\n", rate)</span>;       </span>&#13;
<strong><span class="cviolet">15</span></strong>&#13;
<strong><span class="cviolet">16</span></strong>     <span class="lgreen">// display headers</span>&#13;
<strong><span class="cviolet">17</span></strong>     cout &lt;&lt; <span class="yell">format(<span class="green">"\n{}{:&gt;20}\n"</span>, <span class="green">"Year"</span>, <span class="green">"Amount on deposit"</span>)</span>;&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>     <span class="lgreen">// calculate amount on deposit for each of ten years</span>&#13;
<strong><span class="cviolet">20</span></strong>     <span class="blue">for</span> (<span class="blue">int</span> year{<span class="green">1</span>}; year &lt;= <span class="green">10</span>; ++year) {&#13;
<strong><span class="cviolet">21</span></strong>        double amount = principal * pow(1.0 + rate, year);&#13;
<strong><span class="cviolet">22</span></strong>        cout &lt;&lt; format("{:<span class="green">&gt;4d}{:&gt;20.2f}\n", y</span>ear, amount);&#13;
<strong><span class="cviolet">23</span></strong>     }&#13;
<strong><span class="cviolet">24</span></strong>   }</pre>&#13;
<pre class="pre1">Initial principal: 1000.00&#13;
    Interest rate:    0.05&#13;
&#13;
Year    Amount on deposit&#13;
   1             1050.00&#13;
   2             1102.50&#13;
   3             1157.63&#13;
   4             1215.51&#13;
   5             1276.28&#13;
   6             1340.10&#13;
   7             1407.10&#13;
   8             1477.46&#13;
   9             1551.33&#13;
  10             1628.89</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 4.12</strong></span> Compound-interest example with C++20 string formatting.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch04lev3sec43">Formatting the Principal and Interest Rate</h5>&#13;
<p>The <code>format</code> calls in lines 13 and 14 each use the placeholder <code>{:&gt;7.2f}</code> to format the values of <code>principal</code> and <code>rate</code>. A colon (<code>:</code>) in a placeholder introduces a <span class="violet"><strong>format specifier</strong></span> that indicates how a corresponding value should be formatted. The format specifier <code>&gt;7.2f</code> is for a floating-point number (<code>f</code>) that should be <span class="violet"><strong>right-aligned (</strong></span><code><strong><span class="violet">&gt;</span></strong></code><span class="violet"><strong>)</strong></span> in a field width of <code>7</code> position with two digits of precision (<code>.2</code>)—that is, two positions to the right of the decimal point. Unlike <code>setprecision</code> and <code>fixed</code> shown earlier, format settings specified in placeholders are not “sticky”—they apply only to the value that’s inserted into that placeholder.</p>&#13;
<p>The value of <code>principal</code> (<code>1000.00</code>) requires exactly seven characters to display, so no spaces are required to fill out the field width. The value of <code>rate</code> (<code>0.05</code>) requires only four total character positions, so it will be right-aligned in the field of seven characters and filled from the left with leading spaces, as in</p>&#13;
<div class="image"><img src="Images/04unfig06.jpg" alt="Images" width="249" height="89"/></div>&#13;
<p>Numeric values are right aligned by default, so the &gt; is not required here. You can <span class="violet"><strong>left-align</strong></span> numeric values in a field width via &lt;.</p>&#13;
<h5 class="h5" id="ch04lev3sec44">Formatting the Year and Amount on Deposit Column Heads</h5>&#13;
<p>In line 17’s format string</p>&#13;
<pre class="pre">"\n{}{:&gt;20}\n"</pre>&#13;
<p><code>"Year"</code> is simply placed at the position of the first placeholder, which does not contain a format specifier. The second placeholder indicates that <code>"Amount on Deposit"</code> (17 characters) should be right-aligned (<code>&gt;</code>) in a field of <code>20</code> characters—<code>format</code> inserts three leading spaces to right-align the string. Strings are left-aligned by default, so the &gt; is required here to force right-alignment.</p>&#13;
<h5 class="h5" id="ch04lev3sec45">Formatting the Year and Amount on Deposit Values in the <code>for</code> Loop</h5>&#13;
<p>The format string in line 22</p>&#13;
<pre class="pre">"{:&gt;4d}{:&gt;20.2f}\n"</pre>&#13;
<p>uses two placeholders to format the loop’s output. The placeholder <code>{:&gt;4d}</code> indicates that <code>year</code>’s value should be formatted as an integer (<code>d</code>) right-aligned (<code>&gt;</code>) in a field of width <code>4</code>. This right-aligns all the year values under the <code>"Year"</code> column.</p>&#13;
<p>The placeholder <code>{:&gt;20.2f}</code> formats <code>amount</code>’s value as a floating-point number (<code>f</code>) right-aligned (<code>&gt;</code>) in a field width of <code>20</code> with a decimal point and two digits to the right of the decimal point (<code>.2</code>). Formatting the <code>amount</code>s this way <em>aligns their decimal points vertically</em>, as is typical with monetary amounts. The field width of 20 right-aligns the <code>amount</code>s under <code>"Amount on Deposit"</code>.</p>&#13;
<h3 class="h3" id="ch04lev1sec16"><span class="violet">4.16</span> Wrap-Up</h3>&#13;
<p>In this chapter, we completed our introduction to all but one of C++’s control statements, which enable you to control the flow of execution in member functions. <a href="ch03.xhtml#ch03">Chapter 3</a> discussed <code>if</code>, <code>if…else</code> and <code>while</code>. <a href="ch04.xhtml#ch04">Chapter 4</a> demonstrated <code>for</code>, <code>do…while</code> and <code>switch</code>. We showed C++17’s enhancements that allow you to initialize a variable in the header of an <code>if</code> and <code>switch</code> statement. You used the <code>break</code> statement to exit a <code>switch</code> statement and to terminate a loop immediately. You used a <code>continue</code> statement to terminate a loop’s current iteration and proceed with the loop’s next iteration. We introduced C++’s logical operators, which enable you to use more complex conditional expressions in control statements. We showed C++20’s attributes <code>[[likely]]</code> and <code>[[unlikely]]</code> for hinting to the compiler which paths of execution are likely or unlikely to execute in selection statements. In our objects-natural case study, we used the miniz-cpp open-source library to create and read compressed ZIP archive files. Finally, we introduced more of C++20’s powerful and expressive text-formatting features. In <a href="ch05.xhtml#ch05">Chapter 5</a>, you’ll create your own custom functions.</p>&#13;
</div></body>
</html>