<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch09">Chapter 9. Custom Classes</h2>&#13;
<div class="image"><img src="Images/p0379-01.jpg" alt="Images" width="370" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Define a custom class and use it to create objects.</p>&#13;
<p class="squ"><span class="red">■</span> Implement a class’s behaviors as member functions and attributes as data members.</p>&#13;
<p class="squ"><span class="red">■</span> Access and manipulate <code>private</code> data members through <code>public</code> <em>get</em> and <em>set</em> functions to enforce data encapsulation.</p>&#13;
<p class="squ"><span class="red">■</span> Use a constructor to initialize an object’s data.</p>&#13;
<p class="squ"><span class="red">■</span> Separate a class’s interface from its implementation for reuse.</p>&#13;
<p class="squ"><span class="red">■</span> Access class members via the dot (<code>.</code>) and arrow (<code>-&gt;</code>) operators.</p>&#13;
<p class="squ"><span class="red">■</span> Use destructors to perform “termination housekeeping.”</p>&#13;
<p class="squ"><span class="red">■</span> Learn why returning a reference or a pointer to <code>private</code> data is dangerous.</p>&#13;
<p class="squ"><span class="red">■</span> Assign the data members of one object to those of another.</p>&#13;
<p class="squ"><span class="red">■</span> Create objects composed of other objects.</p>&#13;
<p class="squ"><span class="red">■</span> Use <code>friend</code> functions and declare <code>friend</code> classes.</p>&#13;
<p class="squ"><span class="red">■</span> Access non-<code>static</code> class members via the <code>this</code> pointer.</p>&#13;
<p class="squ"><span class="red">■</span> Use <code>static</code> data members and member functions.</p>&#13;
<p class="squ"><span class="red">■</span> Use <code>struct</code>s to create aggregate types, and use C++20 designated initializers to initialize aggregate members.</p>&#13;
<p class="squ"><span class="red">■</span> Do an objects-natural case study that serializes objects using JavaScript Object Notation (JSON) and the <code>cereal</code> library.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec1"><span class="violet"><strong>9.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec2"><span class="violet"><strong>9.2</strong></span> Test-Driving an <code>Account</code> Object</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec3"><span class="violet"><strong>9.3</strong></span> <code>Account</code> Class with a Data Member and <em>Set</em> and <em>Get</em> Member Functions</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec1">9.3.1 Class Definition</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec2">9.3.2 Access Specifiers <code>private</code> and <code>public</code></a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec4"><span class="violet"><strong>9.4</strong></span> <code>Account</code> Class: Custom Constructors</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec5"><span class="violet"><strong>9.5</strong></span> Software Engineering with <em>Set</em> and <em>Get</em> Member Functions</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec6"><span class="violet"><strong>9.6</strong></span> <code>Account</code> Class with a Balance</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec7"><span class="violet"><strong>9.7</strong></span> <code>Time</code> Class Case Study: Separating Interface from Implementation</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec3">9.7.1 Interface of a Class</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec4">9.7.2 Separating the Interface from the Implementation</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec5">9.7.3 Class Definition</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec6">9.7.4 Member Functions</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec7">9.7.5 Including the Class Header in the Source-Code File</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec8">9.7.6 Scope Resolution Operator (<code>::</code>)</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec9">9.7.7 Member Function <code>setTime</code> and Throwing Exceptions</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec10">9.7.8 Member Function <code>to24HourString</code></a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec11">9.7.9 Member Function <code>to12HourString</code></a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec12">9.7.10 Implicitly Inlining Member Functions</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec13">9.7.11 Member Functions vs. Global Functions</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec14">9.7.12 Using Class <code>Time</code></a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec15">9.7.13 Object Size</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec8"><span class="violet"><strong>9.8</strong></span> Compilation and Linking Process</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec9"><span class="violet"><strong>9.9</strong></span> Class Scope and Accessing Class Members</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec10"><span class="violet"><strong>9.10</strong></span> Access Functions and Utility Functions</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec11"><span class="violet"><strong>9.11</strong></span> <code>Time</code> Class Case Study: Constructors with Default Arguments</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec16">9.11.1 Class <code>Time</code></a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec17">9.11.2 Overloaded Constructors and C++11 Delegating Constructors</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec12"><span class="violet"><strong>9.12</strong></span> Destructors</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec13"><span class="violet"><strong>9.13</strong></span> When Constructors and Destructors Are Called</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec14"><span class="violet"><strong>9.14</strong></span> <code>Time</code> Class Case Study: A Subtle Trap—Returning a Reference or a Pointer to a <code>private</code> Data Member</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec15"><span class="violet"><strong>9.15</strong></span> Default Assignment Operator</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec16"><span class="violet"><strong>9.16</strong></span> <code>const</code> Objects and <code>const</code> Member Functions</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec17"><span class="violet"><strong>9.17</strong></span> Composition: Objects as Members of Classes</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec18"><span class="violet"><strong>9.18</strong></span> <code>friend</code> Functions and <code>friend</code> Classes</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec19"><span class="violet"><strong>9.19</strong></span> The <code>this</code> Pointer</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec18">9.19.1 Implicitly and Explicitly Using the <code>this</code> Pointer to Access an Object’s Data Members</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec19">9.19.2 Using the <code>this</code> Pointer to Enable Cascaded Function Calls</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec20"><span class="violet"><strong>9.20</strong></span> <code>static</code> Class Members—Classwide Data and Member Functions</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec21"><span class="violet"><strong>9.21</strong></span> Aggregates in C++20</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec20">9.21.1 Initializing an Aggregate</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec21">9.21.2 C++20: Designated Initializers</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec22"><span class="violet"><strong>9.22</strong></span> Objects Natural Case Study: Serialization with JSON</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec22">9.22.1 Serializing a <code>vector</code> of Objects containing <code>public</code> Data</a></p>&#13;
<p class="chap-lev2"><a href="#ch09lev2sec23">9.22.2 Serializing a <code>vector</code> of Objects containing <code>private</code> Data</a></p>&#13;
<p class="chap-lev1"><a href="#ch09lev1sec23"><span class="violet"><strong>9.23</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="ch09lev1sec1"><span class="violet">9.1</span> Introduction<sup><a id="rch09fn1" href="ch09.xhtml#ch09fn1">1</a></sup></h3>&#13;
<p class="footnote"><a id="ch09fn1" href="ch09.xhtml#rch09fn1">1</a>. This chapter depends on the terminology and concepts introduced in Section 1.16, Introduction to Object Orientation and “Objects Natural.”</p>&#13;
<p>Section 1.16 presented a friendly introduction to object orientation, discussing classes, objects, data members (attributes) and member functions (behaviors). In our objects-natural case studies, you’ve created objects of existing classes and called their member functions to make the objects perform powerful tasks without having to know how these classes worked internally.</p>&#13;
<p>This chapter begins our deeper treatment of object-oriented programming as we craft valuable custom classes. C++ is an <strong><span class="violet">extensible programming language</span></strong>—each class you create becomes a new type you can use to create objects. Some development teams in industry work on applications that contain hundreds, or even thousands, of custom classes.</p>&#13;
<h3 class="h3" id="ch09lev1sec2"><span class="violet">9.2</span> Test-Driving an <code>Account</code> Object</h3>&#13;
<p>We begin our introduction to custom classes with three examples that create an <code>Account</code> class representing a simple bank account. First, let’s look at the <code>main</code> program and output, so you can see an object of our initial <code>Account</code> class in action. To help you prepare for the larger programs you’ll encounter later in this book and in industry, we define the <code>Account</code> class and <code>main</code> in separate files—<code>main</code> in <code>AccountTest.cpp</code> (<a href="#fig9_1">Fig. 9.1</a>) and class <code>Account</code> in <code>Account.h</code>, which we’ll show in <a href="#fig9_2">Fig. 9.2</a>.</p>&#13;
<div class="group" id="fig9_1">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig01" id="aa09fig01">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.1: AccountTest.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Creating and manipulating an Account object.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> <span class="green">"Account.h"</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">9</span></strong>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>Account myAccount{}; <span class="lgreen">// create Account object myAccount</span></code>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="lgreen">// show that the initial value of myAccount's name is the empty string</span></code>&#13;
<strong><span class="cviolet">14</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Initial account name: {}\n"</span>, myAccount.getName());</code>&#13;
<strong><span class="cviolet">15</span></strong>&#13;
<strong><span class="cviolet">16</span></strong>      <code><span class="lgreen">// prompt for and read the name</span></code>&#13;
<strong><span class="cviolet">17</span></strong>      <code>cout &lt;&lt; <span class="green">"Enter the account name: "</span>;</code>&#13;
<strong><span class="cviolet">18</span></strong>      <code>string name{};</code>&#13;
<strong><span class="cviolet">19</span></strong>      <code>getline(cin, name); <span class="lgreen">// read a line of text</span></code>&#13;
<strong><span class="cviolet">20</span></strong>      <code>myAccount.setName(name); <span class="lgreen">// put name in the myAccount object</span></code>&#13;
<strong><span class="cviolet">21</span></strong>&#13;
<strong><span class="cviolet">22</span></strong>      <code><span class="lgreen">// display the name stored in object myAccount</span></code>&#13;
<strong><span class="cviolet">23</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Updated account name: {}\n"</span>, myAccount.getName());</code>&#13;
<strong><span class="cviolet">24</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Initial account name:</code>&#13;
<code>Enter the account name:</code> <strong>Jane Green</strong>&#13;
<code>Updated account name: Jane Green</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.1</strong></span> Creating and manipulating an <code>Account</code> object.</p>&#13;
</div>&#13;
<div class="group" id="fig9_2">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig02" id="aa09fig02">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.2: Account.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Account class with a data member and</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// member functions to set and get its value.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;string_view&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">class</span> Account {</code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">public</span>:</code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="lgreen">// member function that sets m_name in the object</span></code>&#13;
<strong><span class="cviolet">10</span></strong>      <code><span class="blue">void</span> setName(std::string_view name) {</code>&#13;
<strong><span class="cviolet">11</span></strong>         <code>m_name = name; <span class="lgreen">// replace m_name's value with name</span></code>&#13;
<strong><span class="cviolet">12</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="lgreen">// member function that retrieves the account name from the object</span></code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="blue">const</span> std::string&amp; getName() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">16</span></strong>         <code><span class="blue">return</span> m_name; <span class="lgreen">// return m_name's value to this function's caller</span></code>&#13;
<strong><span class="cviolet">17</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">18</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">19</span></strong>      <code>std::string m_name; <span class="lgreen">// data member containing account holder's name</span></code>&#13;
<strong><span class="cviolet">20</span></strong>   <code>}; <span class="lgreen">// end class Account</span></code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.2</strong></span> <code>Account</code> class with a data member and member functions to <em>set</em> and <em>get</em> its value.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec1">Instantiating an Object</h5>&#13;
<p>Typically, you cannot call a class’s member functions until you create an object of that class.<sup><a id="rch09fn2" href="ch09.xhtml#ch09fn2">2</a></sup> Line 11</p>&#13;
<p class="footnote"><a id="ch09fn2" href="ch09.xhtml#rch09fn2">2</a>. In <a href="#ch09lev1sec20">Section 9.20</a>, you’ll see that <code>static</code> member functions are an exception.</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig01" id="aa09unfig01">Click here to view code image</a></p>&#13;
<pre class="pre">Account myAccount{}; <span class="lgreen">// create Account object myAccount</span></pre>&#13;
<p>creates an object called <code>myAccount</code>. The variable’s type is <code>Account</code>—the class we’ll define in <a href="#fig9_2">Fig. 9.2</a>.</p>&#13;
<h5 class="h5" id="ch09lev3sec2">Headers and Source-Code Files</h5>&#13;
<p>When we declare <code>int</code> variables, the compiler knows what <code>int</code> is—it’s a fundamental type that’s built into C++. In line 11, however, the compiler does not know in advance what type <code>Account</code> is—it’s a <strong><span class="violet">user-defined type</span></strong>.</p>&#13;
<p>When packaged properly, new classes can be reused by other programmers. It’s customary to place a reusable class definition in a file known as a <strong><span class="violet">header</span></strong> with a <code>.h</code> filename extension.<sup><a id="rch09fn3" href="ch09.xhtml#ch09fn3">3</a></sup> You include that header wherever you need to use the class, as you’ve been doing throughout this book with C++ Standard Library and third-party library classes.</p>&#13;
<p class="footnote"><a id="ch09fn3" href="ch09.xhtml#rch09fn3">3</a>. C++ Standard Library headers, like <code>&lt;iostream&gt;</code>, do not use the <code>.h</code> filename extension and some C++ programmers prefer the <code>.hpp</code> extension.</p>&#13;
<p>We tell the compiler what an <code>Account</code> is by including its header, as in line 6:</p>&#13;
<pre class="pre"><code><span class="blue">#include</span> <span class="green">"Account.h"</span></code></pre>&#13;
<p>If we omit this, the compiler issues error messages wherever we use class <code>Account</code> and any of its capabilities. A header that you define in your program is placed in double quotes (<code>""</code>), rather than the angle brackets (<code>&lt;&gt;</code>). The double quotes tell the compiler to check the folder containing <code>AccountTest.cpp</code> (<a href="#fig9_1">Fig. 9.1</a>) before the compiler’s header search path.</p>&#13;
<h5 class="h5" id="ch09lev3sec3">Calling Class <code>Account</code>’s <code>getName</code> Member Function</h5>&#13;
<p>Class <code>Account</code>’s <code>getName</code> member function returns the name stored in a particular <code>Account</code> object. Line 14 calls <code>myAccount.getName()</code> to get the <code>myAccount</code> object’s initial name, which is the empty <code>string</code>. We’ll say more about this shortly.</p>&#13;
<h5 class="h5" id="ch09lev3sec4">Calling Class <code>Account</code>’s <code>setName</code> Member Function</h5>&#13;
<p>The <code>setName</code> member function stores a name in a particular <code>Account</code> object. Line 20 calls</p>&#13;
<p><code>myAccount</code>’s <code>setName</code> member function to store <code>name</code>’s value in the object <code>myAccount</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec5">Displaying the Name That Was Entered by the User</h5>&#13;
<p>To confirm that <code>myAccount</code> now contains the name you entered, line 23 calls member function <code>getName</code> again and displays its result.</p>&#13;
<h3 class="h3" id="ch09lev1sec3"><span class="violet">9.3</span> <code>Account</code> Class with a Data Member and <em>Set</em> and <em>Get</em> Member Functions</h3>&#13;
<p>Now that we’ve seen class <code>Account</code> in action (<a href="#fig9_1">Fig. 9.1</a>), we present its internal details.</p>&#13;
<h4 class="h4" id="ch09lev2sec1">9.3.1 Class Definition</h4>&#13;
<p>Class <code>Account</code> (<a href="#fig9_2">Fig. 9.2</a>) contains an <code>m_name</code> data member (line 19) that stores the account holder’s name. Each object of the class has its own copy of the class’s data members.<sup><a id="rch09fn4" href="ch09.xhtml#ch09fn4">4</a></sup> Later, we’ll add a <code>balance</code> data member to keep track of the money in each <code>Account</code>. Class <code>Account</code> also contains:</p>&#13;
<p class="footnote"><a id="ch09fn4" href="ch09.xhtml#rch09fn4">4</a>. In <a href="#ch09lev1sec20">Section 9.20</a>, you’ll see that <code>static</code> data members are an exception.</p>&#13;
<p class="bull">• member function <code>setName</code> (lines 10–12) that stores a name in an <code>Account</code>, and</p>&#13;
<p class="bull">• member function <code>getName</code> (lines 15–17) that retrieves a name from an <code>Account</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec6">Keyword <code>class</code> and the Class Body</h5>&#13;
<p>The class definition begins with the keyword <code><strong><span class="violet">class</span></strong></code> (line 7) followed immediately by the class’s name—in this case, <code>Account</code>. By convention:</p>&#13;
<p class="bull">• each word in a class name starts with a capital first letter, and</p>&#13;
<p class="bull">• data-member and member-function names begin with a lowercase first letter.</p>&#13;
<p>Every class’s body is enclosed in braces <code>{}</code> (lines 7 and 20). The class definition terminates with a required semicolon (line 20).</p>&#13;
<h5 class="h5" id="ch09lev3sec7">Data Member <code>m_name</code> of Type <code>std::string</code></h5>&#13;
<p>Recall from Section 1.16 that an object has attributes, implemented as data members. Each object maintains its own copy of these throughout its lifetime. Usually, a class also contains member functions that manipulate the data members of particular objects of the class. The data members exist:</p>&#13;
<p class="bull">• before a program calls member functions on a specific object,</p>&#13;
<p class="bull">• while the member functions are executing and</p>&#13;
<p class="bull">• after the member functions finish executing.</p>&#13;
<p>Data members are declared inside a class definition but outside the class’s member functions. Line 19</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig02" id="aa09unfig02">Click here to view code image</a></p>&#13;
<pre class="pre"><code>std::string m_name; <span class="lgreen">// data member containing account holder's name</span></code></pre>&#13;
<p>declares a <code>string</code> data member called <code>m_name</code>. The <code>"m_"</code> prefix is a common naming convention to indicate that a variable represents a data member. If there are many <code>Account</code> objects, each has its own <code>m_name</code>. Because <code>m_name</code> is a data member, it can be manipulated by the class’s member functions. Recall that the default <code>string</code> value is the empty <code>string</code> (<code>""</code>), which is why line 14 in <code>main</code> (<a href="#fig9_1">Fig. 9.1</a>) did not display a name.</p>&#13;
<p>By convention, C++ programmers typically place a class’s data members last in the class’s body. You can declare the data members anywhere in the class outside its member-function definitions, but scattering the data members can lead to hard-to-read code.</p>&#13;
<h5 class="h5" id="ch09lev3sec8">Use <code>std::</code> with Standard Library Components in Headers</h5>&#13;
<p>Throughout the <code>Account.h</code> header (<a href="#fig9_2">Fig. 9.2</a>), we use <code>std::</code> when referring to <code>string</code> (lines 10, 15 and 19). For subtle reasons that we explain in Section 19.4, headers should not contain <code>using</code> directives or <code>using</code> declarations.</p>&#13;
<h5 class="h5" id="ch09lev3sec9"><code>setName</code> Member Function</h5>&#13;
<p>Member function <code>setName</code> (lines 10–12):</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig03" id="aa09unfig03">Click here to view code image</a></p>&#13;
<pre class="pre"><code><span class="blue">void</span> setName(std::string_view name) {</code>&#13;
   <code>m_name = name; <span class="lgreen">// replace m_name's value with name</span>&#13;
}</code></pre>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> receives a <code>string_view</code> representing the <code>Account</code>’s name and assigns the <code>name</code> argument to data member <code>m_name</code>. Recall that a <code>string_view</code> is a read-only view into a character sequence, such as a <code>std::string</code> or a C-string. This copies <code>name</code>’s characters into <code>m_name</code>. The <code>"m_"</code> in <code>m_name</code> makes it easy to distinguish the parameter <code>name</code> from the data member <code>m_name</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec10"><code>getName</code> Member Function</h5>&#13;
<p>Member function <code>getName</code> (lines 15–17):</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig04" id="aa09unfig04">Click here to view code image</a></p>&#13;
<pre class="pre"><code><span class="blue">const</span> std::string&amp; getName() <span class="blue">const</span> {</code>&#13;
   <code><span class="blue">return</span> m_name; <span class="lgreen">// return m_name's value to this function's caller</span></code>&#13;
   <code>}</code></pre>&#13;
<p>has no parameters and returns a particular <code>Account</code> object’s <code>m_name</code> to the caller as a <code>const std::string&amp;</code>. Declaring the returned reference <code>const</code> ensures that the caller cannot modify the object’s data via that reference.</p>&#13;
<h5 class="h5" id="ch09lev3sec11"><code>const</code> Member Functions</h5>&#13;
<p>Note the <code><strong><span class="violet">const</span></strong></code> to the right of the parameter list in <code>getName</code>’s header (line 15). When returning <code>m_name</code>, member function <code>getName</code> does not, and should not, modify the <code>Account</code> object on which it’s called. Declaring a member function <code>const</code> tells the compiler, “this function should not modify the object on which it’s called—if it does, please issue a compilation error.” This can help you locate errors if you accidentally insert code that would modify the object. It also tells the compiler that <code>getName</code> may be called on a <code>const Account</code> object, or called via a reference or pointer to a <code>const Account</code>.</p>&#13;
<h4 class="h4" id="ch09lev2sec2">9.3.2 Access Specifiers <code>private</code> and <code>public</code></h4>&#13;
<p><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> The keyword <code><strong><span class="violet">private</span></strong></code> (line 18) is an <strong><span class="violet">access specifier</span></strong>. Each access specifier is followed by a required colon (<code>:</code>). Data member <code>m_name</code>’s declaration (line 19) appears after <code>private:</code> to indicate that <code>m_name</code> is accessible only to class <code>Account</code>’s member functions.<sup><a id="rch09fn5" href="ch09.xhtml#ch09fn5">5</a></sup> This is known as <strong><span class="violet">information hiding</span></strong> (or, more generally, as hiding implementation details) and is a recommended practice of the C++ Core Guidelines<sup><a id="rch09fn6" href="ch09.xhtml#ch09fn6">6</a></sup> and object-oriented programming in general. The data member <code>m_name</code> is encapsulated (hidden) and can be used only in class <code>Account</code>’s <code>setName</code> and <code>getName</code> member functions. Most data-member declarations appear after the <code>private:</code> access specifier. We generally omit the colon when we refer to the <code>private</code> and <code>public</code> access specifiers in the text, as we did in this sentence.</p>&#13;
<p class="footnote"><a id="ch09fn5" href="ch09.xhtml#rch09fn5">5</a>. Or to “friends” of the class, as you’ll see in <a href="#ch09lev1sec18">Section 9.18</a>.</p>&#13;
<p class="footnote"><a id="ch09fn6" href="ch09.xhtml#rch09fn6">6</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-private">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-private</a></code>.</p>&#13;
<p>This class also contains the <code><strong><span class="violet">public</span></strong></code> access specifier (line 8):</p>&#13;
<pre class="pre"><code><span class="blue">public</span>:</code></pre>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Data members or member functions listed after access specifier <code>public</code>—and before the next access specifier if there is one—are “available to the public.” They can be used anywhere an object of the class is in scope. Making a class’s data members <code>private</code> facilitates debugging because problems with data manipulations are localized to the class’s member functions. In <a href="ch10.xhtml#ch10">Chapter 10</a>, we’ll introduce the <code>protected</code> access specifier.</p>&#13;
<h5 class="h5" id="ch09lev3sec12">Default Access for Class Members</h5>&#13;
<p>By default, everything in a class is <code>private</code>, unless you specify otherwise. Once you list an access specifier, everything has that level of access until you list another access specifier. The access specifiers <code>public</code> and <code>private</code> may be repeated, but this is unnecessary and can be confusing. We prefer to list <code>public</code> only once, grouping everything that’s <code>public</code>. We prefer to list <code>private</code> only once, grouping everything that’s <code>private</code>.</p>&#13;
<h3 class="h3" id="ch09lev1sec4"><span class="violet">9.4</span> <code>Account</code> Class: Custom Constructors</h3>&#13;
<p>As you saw in the preceding example, when an <code>Account</code> object is created, its <code>string</code> data member <code>m_name</code> is initialized to the empty <code>string</code> by default. But what if you want to provide a name when you first create an <code>Account</code> object? Each class can define <strong><span class="violet">constructors</span></strong> that specify custom initialization for objects of that class. A constructor is a special member function that must have the same name as the class. Constructors cannot return values, so they do not specify a return type (not even <code>void</code>). C++ guarantees that a constructor is called when each object is created, so this is the ideal point to initialize an object’s data members. Every time you created an object so far in this book, the corresponding class’s constructor was called to initialize the object. As you’ll soon see, classes may have overloaded constructors.</p>&#13;
<p>Like member functions, constructors can have parameters—the corresponding argument values help initialize the object’s data members. For example, you can specify an <code>Account</code> object’s name when the object is created, as you’ll do in line 12 of <a href="#fig9_4">Fig. 9.4</a>:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig04a" id="aa09unfig04a">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Account account1{<span class="green">"Jane Green"</span>};</code></pre>&#13;
<p>In the preceding statement, the string <code>"Jane Green"</code> is passed to the <code>Account</code> class’s constructor and used to initialize the <code>account1</code> object’s data. The preceding statement assumes that class <code>Account</code> has a constructor that can receive a string argument.</p>&#13;
<h5 class="h5" id="ch09lev3sec13"><code>Account</code> Class Definition</h5>&#13;
<p><a href="#fig9_3">Figure 9.3</a> shows class <code>Account</code> with a constructor that receives an <code>accountName</code> parameter and uses it to initialize the data member <code>m_name</code> when an <code>Account</code> object is created.</p>&#13;
<div class="group" id="fig9_3">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig03" id="aa09fig03">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.3: Account.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Account class with a constructor that initializes the account name.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;string_view&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">class</span> Account {</code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">public</span>:</code>&#13;
 <strong><span class="cviolet">8</span></strong>      <code><span class="lgreen">// constructor initializes data member m_name with the parameter name</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="blue">explicit</span> Account(std::string_view name)</code>&#13;
<strong><span class="cviolet">10</span></strong>         <code>: m_name{name} { <span class="lgreen">// member initializer</span></code>&#13;
<strong><span class="cviolet">11</span></strong>        <code><span class="lgreen">// empty body</span></code>&#13;
<strong><span class="cviolet">12</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="lgreen">// function to set the account name</span></code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="blue">void</span> setName(std::string_view name) {</code>&#13;
<strong><span class="cviolet">16</span></strong>         <code>m_name = name; <span class="lgreen">// replace m_name's value with name</span></code>&#13;
<strong><span class="cviolet">17</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>      <code><span class="lgreen">// function to retrieve the account name</span></code>&#13;
<strong><span class="cviolet">20</span></strong>      <code><span class="blue">const</span> std::string&amp; getName() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">21</span></strong>         <code><span class="blue">return</span> m_name;</code>&#13;
<strong><span class="cviolet">22</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">23</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">24</span></strong>      <code>std::string m_name; <span class="lgreen">// account name data member</span></code>&#13;
<strong><span class="cviolet">25</span></strong>   <code>}; <span class="lgreen">// end class Account</span></code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.3</strong></span> <code>Account</code> class with a constructor that initializes the account name.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec14"><code>Account</code> Class’s Custom Constructor Definition</h5>&#13;
<p>Lines 9–12 of <a href="#fig9_3">Fig. 9.3</a> define <code>Account</code>’s constructor:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig05" id="aa09unfig05">Click here to view code image</a></p>&#13;
<pre class="pre"><code><span class="blue">explicit</span> Account(std::string_view name)</code>&#13;
  <code>: m_name{name} { <span class="lgreen">// member initializer</span></code>&#13;
  <code><span class="lgreen">// empty body</span> }</code></pre>&#13;
<p>Usually, constructors are <code>public</code>, so any code with access to the class definition can create and initialize objects of that class.<sup><a id="rch09fn7" href="ch09.xhtml#ch09fn7">7</a></sup> Line 9 indicates that the constructor has a <code>name</code> parameter of type <code>string_view</code>. When you create a new <code>Account</code> object, you must pass a person’s name to the constructor, which then initializes the data member <code>m_name</code> with the contents of the <code>string_view</code> parameter.</p>&#13;
<p class="footnote"><a id="ch09fn7" href="ch09.xhtml#rch09fn7">7</a>. Section 11.10.2 discusses why you might use a <code>private</code> constructor.</p>&#13;
<p>The constructor’s <strong><span class="violet">member-initializer list</span></strong> (line 10)<code>:</code></p>&#13;
<pre class="pre"><code>: m_name{name}</code></pre>&#13;
<p>initializes the <code>m_name</code> data member. Member initializers appear between a constructor’s parameter list and the left brace that begins the constructor’s body. You separate the member initializer list from the parameter list with a colon (<code>:</code>).</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Each member initializer consists of a data member’s variable name followed by braces containing its initial value.<sup><a id="rch09fn8" href="ch09.xhtml#ch09fn8">8</a></sup> This member initializer calls the <code>std::string</code> class’s constructor that receives a <code>string_view</code>. If a class has more than one data member, each member initializer is separated from the next by a comma. Member initializers execute in the order you declare the data members in the class so, for clarity, list the member initializers in the same order. The member initializer list executes before the constructor’s body executes.</p>&#13;
<p class="footnote"><a id="ch09fn8" href="ch09.xhtml#rch09fn8">8</a>. Occasionally, parentheses rather than braces may be required, such as when initializing a <code>vector</code> of a specified size, as we did in <a href="ch06.xhtml#fig6_14">Fig. 6.14</a>.</p>&#13;
<p><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> <img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size"><small>PERF</small></span> Though you can perform initialization with assignment statements in the constructor’s body, the C++ Core Guidelines recommend using member initializers.<sup><a id="rch09fn9" href="ch09.xhtml#ch09fn9">9</a></sup> You’ll see later that member initializers can be more efficient. Also, you’ll see that certain data members must be initialized using the member-initializer syntax, because you cannot assign to them in the constructor’s body.</p>&#13;
<p class="footnote"><a id="ch09fn9" href="ch09.xhtml#rch09fn9">9</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-initialize">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-initialize</a></code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec15"><code>explicit</code> Keyword</h5>&#13;
<p><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> A constructor with only one parameter should be declared <code><strong><span class="violet">explicit</span></strong></code> to prevent the compiler from using the constructor to perform implicit type conversions.<sup><a id="rch09fn10" href="ch09.xhtml#ch09fn10">10</a></sup> The keyword <code>explicit</code> means that <code>Account</code>’s constructor must be called explicitly, as in:</p>&#13;
<p class="footnote"><a id="ch09fn10" href="ch09.xhtml#rch09fn10">10</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-explicit">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-explicit</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig06" id="aa09unfig06">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Account account1{<span class="green">"Jane Green"</span>};</code></pre>&#13;
<p><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> For now, simply declare all single-parameter constructors <code>explicit</code>. In Section 11.13, you’ll see that single-parameter constructors without <code>explicit</code> can be called implicitly to perform type conversions. Such implicit constructor calls can lead to subtle errors and are generally discouraged. Line 9 of <a href="#fig9_3">Fig. 9.3</a> does not specify a return type (not even <code>void</code>) because, again, constructors cannot return values. Also, constructors cannot be declared <code>const</code> (simply because initializing an object modifies it).</p>&#13;
<h5 class="h5" id="ch09lev3sec16">Initializing <code>Account</code> Objects When They’re Created</h5>&#13;
<p>The <code>AccountTest</code> program (<a href="#fig9_4">Fig. 9.4</a>) initializes two <code>Account</code> objects using the constructor. Line 12 creates the <code>Account</code> object <code>account1</code>:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig07" id="aa09unfig07">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Account account1{<span class="green">"Jane Green"</span>};</code></pre>&#13;
<div class="group" id="fig9_4">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig04" id="aa09fig04">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.4: AccountTest.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Using the Account constructor to initialize the m_name data</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// member at the time each Account object is created.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> <span class="green">"Account.h"</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">9</span></strong>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code><span class="lgreen">// create two Account objects</span></code>&#13;
<strong><span class="cviolet">12</span></strong>      <code>Account account1{<span class="green">"Jane Green"</span>};</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>Account account2{<span class="green">"John Blue"</span>};</code>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="lgreen">// display initial each Account's corresponding name</span></code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"account1 name is: {}\naccount2 name is: {}\n"</span>,</code>&#13;
<strong><span class="cviolet">17</span></strong>                 <code>account1.getName(), account2.getName());</code>&#13;
<strong><span class="cviolet">18</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>account1 name is: Jane Green</code>&#13;
<code>account2 name is: John Blue</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.4</strong></span> Using the <code>Account</code> constructor to initialize the <code>m_name</code> data member at the time each <code>Account</code> object is created.</p>&#13;
</div>&#13;
<p>When you create an object, C++ calls the class’s constructor to initialize that object. In line 12, the argument <code>"Jane Green"</code> is used by the constructor to initialize the new object’s <code>m_name</code> data member, as specified in lines 9–12 of <a href="#fig9_3">Fig. 9.3</a>. Line 13 of <a href="#fig9_4">Fig. 9.4</a> repeats this process, passing the argument <code>"John Blue"</code> to initialize <code>m_name</code> for <code>account2</code>:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig08" id="aa09unfig08">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Account account2{<span class="green">"John Blue"</span>};</code></pre>&#13;
<p>To confirm the objects were initialized properly, lines 16–17 call the <code>getName</code> member function to get each object’s name. The output shows different names, confirming that each <code>Account</code> maintains its own copy of the class’s data member <code>m_name</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec17">Default Constructor</h5>&#13;
<p>Recall that line 11 of <a href="#fig9_1">Fig. 9.1</a> created an <code>Account</code> object with empty braces to the right of the object’s variable name:</p>&#13;
<pre class="pre"><code>Account myAccount{};</code></pre>&#13;
<p>which, for an object of a class, is equivalent to:</p>&#13;
<pre class="pre"><code>Account myAccount;</code></pre>&#13;
<p>In the preceding statements, C++ implicitly calls <code>Account</code>’s <strong><span class="violet">default constructor</span></strong>. In any class that does not define a constructor, the compiler generates a default constructor with no parameters. The default constructor does not initialize the class’s fundamental-type data members but does call the default constructor for each data member that’s an object of another class. For example, though you do not see this in the first <code>Account</code> class’s code (<a href="#fig9_2">Fig. 9.2</a>), <code>Account</code>’s default constructor calls class <code>std::string</code>’s default constructor to initialize the data member <code>m_name</code> to the empty string (<code>""</code>). An uninitialized fundamental-type variable contains an undefined (“garbage”) value.</p>&#13;
<h5 class="h5" id="ch09lev3sec18">There’s No Default Constructor in a Class That Defines a Constructor</h5>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> If you define a custom constructor for a class, the compiler will not create a default constructor for that class. In that case, you will not be able to create an <code>Account</code> object by calling the constructor with no arguments unless the custom constructor you define has an empty parameter list or has default arguments for all its parameters. We’ll show later that you can force the compiler to create the default constructor even if you’ve defined non-default constructors. Unless default initialization of your class’s data members is acceptable, provide a custom constructor that initializes each new object’s data members with meaningful values.</p>&#13;
<h5 class="h5" id="ch09lev3sec19">C++’s Special Member Functions</h5>&#13;
<p>In addition to the default constructor, the compiler can generate default versions of five other <strong><span class="violet">special member functions</span></strong>—a copy constructor, a move constructor, a copy assignment operator, a move assignment operator and a destructor. We’ll briefly introduce copy construction, copy assignment and destructors in this chapter. In <a href="ch11.xhtml#ch11">Chapter 11</a>, we’ll discuss the details of all six special member functions, including:</p>&#13;
<p class="bull">• when they’re auto-generated,</p>&#13;
<p class="bull">• when you might need to define custom versions of each, and</p>&#13;
<p class="bull">• the various C++ Core Guidelines for these special member functions.</p>&#13;
<p>You’ll see that you should try to construct your custom classes such that the compiler can auto-generate these special member functions for you—this is called the “Rule of Zero.”</p>&#13;
<h3 class="h3" id="ch09lev1sec5"><span class="violet">9.5</span> Software Engineering with <em>Set</em> and <em>Get</em> Member Functions</h3>&#13;
<p>As you’ll see in the next section, <em>set</em> and <em>get</em> member functions can validate attempts to modify <code>private</code> data and control how that data is presented to the caller, respectively. These are compelling software engineering benefits.</p>&#13;
<p>A <strong><span class="violet">client</span></strong> of the class is any other code that calls the class’s member functions. If a data member were <code>public</code>, any client could see the data and do whatever it wanted with it, including setting it to an invalid value.</p>&#13;
<p>You might think that even though a client cannot directly access a <code>private</code> data member, the client can nevertheless do whatever it wants with the variable through <code>public</code> <em>set</em> and <em>get</em> functions. You’d think that you could peek at the <code>private</code> data (and see exactly how it’s stored in the object) anytime with the <code>public</code> <em>get</em> function and that you could modify the <code>private</code> data at will through the <code>public</code> <em>set</em> function.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Actually, <em>set</em> functions can be written to validate their arguments and reject any attempts to <em>set</em> the data to incorrect values, such as</p>&#13;
<p class="bull">• a negative body temperature</p>&#13;
<p class="bull">• a day in March outside the range 1 through 31, or</p>&#13;
<p class="bull">• a product code not in the company’s product catalog.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> <img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> A <em>get</em> function can present the data in a different form, keeping the object’s actual data representation hidden from the user. For example, a <code>Grade</code> class might store a numeric grade as an <code>int</code> between 0 and 100, but a <code>getGrade</code> member function might return a letter grade as a <code>string</code>, such as <code>"A"</code> for grades between 90 and 100, <code>"B"</code> for grades between 80 and 89, etc. Tightly controlling the access to and presentation of <code>private</code> data can reduce errors while increasing your programs’ robustness, security and usability.</p>&#13;
<h5 class="h5" id="ch09lev3sec20">Conceptual View of an <code>Account</code> Object with Encapsulated Data</h5>&#13;
<p>You can think of an <code>Account</code> object, as shown in the following diagram. The <code>private</code> data member <code>m_name</code>, represented by the inner circle, is hidden inside the object and accessible only via an outer layer of <code>public</code> member functions, represented by the outer ring containing <code>getName</code> and <code>setName</code>. Any client that needs to interact with the <code>Account</code> object can do so only by calling the <code>public</code> member functions of the outer layer.</p>&#13;
<div class="group">&#13;
<div class="images"><img src="Images/09unfig09.jpg" alt="Images" width="245" height="247"/></div>&#13;
</div>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Generally, data members are <code>private</code>, and the member functions that a class’s clients need to use are <code>public</code>. Later, we’ll discuss why you might use a <code>public</code> data member or a <code>private</code> member function<strong>.</strong> Using <code>public</code> <em>set</em> and <em>get</em> functions to control access to <code>private</code> data makes programs clearer and easier to maintain. Change is the rule rather than the exception. You should anticipate that your code will be modified, and possibly often.</p>&#13;
<h3 class="h3" id="ch09lev1sec6"><span class="violet">9.6</span> <code>Account</code> Class with a Balance</h3>&#13;
<p><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> <a href="#fig9_5">Figure 9.5</a> defines an <code>Account</code> class that maintains two related pieces of data—a bank account’s balance and the account holder’s name. The C++ Core Guidelines recommend defining related data items in a class (or, as you’ll see in <a href="#ch09lev1sec21">Section 9.21</a>, a <code>struct</code>).<sup><a id="rch09fn11" href="ch09.xhtml#ch09fn11">11</a></sup></p>&#13;
<p class="footnote"><a id="ch09fn11" href="ch09.xhtml#rch09fn11">11</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-org">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-org</a></code>.</p>&#13;
<div class="group" id="fig9_5">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig05" id="aa09fig05">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.5: Account.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Account class with m_name and m_balance data members, and a</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// constructor and deposit function that each perform validation.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;string_view&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">class</span> Account {</code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">public</span>:</code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="lgreen">// Account constructor with two parameters</span></code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>Account(std::string_view name, <span class="blue">double</span> balance)</code>&#13;
<strong><span class="cviolet">11</span></strong>         <code>: m_name{name} { <span class="lgreen">// member initializer for m_name</span></code>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>         <code><span class="lgreen">// validate that balance is greater than 0.0; if not,</span></code>&#13;
<strong><span class="cviolet">14</span></strong>         <code><span class="lgreen">// data member m_balance keeps its default initial value of 0.0</span></code>&#13;
<strong><span class="cviolet">15</span></strong>         <code><span class="blue">if</span> (balance &gt; <span class="green">0.0</span>) { <span class="lgreen">// if the balance is valid</span></code>&#13;
<strong><span class="cviolet">16</span></strong>            <code>m_balance = balance; <span class="lgreen">// assign it to data member m_balance</span></code>&#13;
<strong><span class="cviolet">17</span></strong>         <code>}</code>&#13;
<strong><span class="cviolet">18</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>      <code><span class="lgreen">// function that deposits (adds) only a valid amount to the balance</span></code>&#13;
<strong><span class="cviolet">21</span></strong>      <code><span class="blue">void</span> deposit(<span class="blue">double</span> amount) {</code>&#13;
<strong><span class="cviolet">22</span></strong>         <code><span class="blue">if</span> (amount &gt; <span class="green">0.0</span>) { <span class="lgreen">// if the amount is valid</span></code>&#13;
<strong><span class="cviolet">23</span></strong>            <code>m_balance += amount; <span class="lgreen">// add it to m_balance</span></code>&#13;
<strong><span class="cviolet">24</span></strong>         <code>}</code>&#13;
<strong><span class="cviolet">25</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">26</span></strong>&#13;
<strong><span class="cviolet">27</span></strong>      <code><span class="lgreen">// function returns the account balance</span></code>&#13;
<strong><span class="cviolet">28</span></strong>      <code><span class="blue">double</span> getBalance() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">29</span></strong>         <code><span class="blue">return</span> m_balance;</code>&#13;
<strong><span class="cviolet">30</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">31</span></strong>&#13;
<strong><span class="cviolet">32</span></strong>      <code><span class="lgreen">// function that sets the account name</span></code>&#13;
<strong><span class="cviolet">33</span></strong>      <code><span class="blue">void</span> setName(std::string_view name) {</code>&#13;
<strong><span class="cviolet">34</span></strong>         <code>m_name = name; <span class="lgreen">// replace m_name's value with name</span></code>&#13;
<strong><span class="cviolet">35</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">36</span></strong>&#13;
<strong><span class="cviolet">37</span></strong>      <code><span class="lgreen">// function that returns the account name</span></code>&#13;
<strong><span class="cviolet">38</span></strong>      <code><span class="blue">const</span> std::string&amp; getName() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">39</span></strong>         <code><span class="blue">return</span> m_name;</code>&#13;
<strong><span class="cviolet">40</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">41</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">42</span></strong>      <code>std::string m_name; <span class="lgreen">// account name data member</span></code>&#13;
<strong><span class="cviolet">43</span></strong>      <code><span class="blue">double</span> m_balance{<span class="green">0.0</span>}; <span class="lgreen">// data member with default initial value</span></code>&#13;
<strong><span class="cviolet">44</span></strong>   <code>}; <span class="lgreen">// end class Account</span></code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.5</strong></span> <code>Account</code> class with <code>m_name</code> and <code>m_balance</code> data members, and a constructor and <code>deposit</code> function that each perform validation.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec21">Data Member <code>balance</code></h5>&#13;
<p>A typical bank services many accounts, each with its own balance. Every object of this updated <code>Account</code> class contains its own copies of data members <code>m_name</code> and <code>m_balance</code>. Line 43 declares a <code>double</code> data member <code>m_balance</code> and initializes its value to <code>0.0</code>:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig10" id="aa09unfig10">Click here to view code image</a></p>&#13;
<pre class="pre"><code><span class="blue">double</span> m_balance{<span class="green">0.0</span>}; <span class="lgreen">// data member with default initial value</span></code></pre>&#13;
<p><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> <img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> <img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size"><small>PERF</small></span> This is an <strong><span class="violet">in-class initializer</span></strong>. The C++ Core Guidelines recommend using in-class initializers when a data member should be initialized with a constant.<sup><a id="rch09fn12" href="ch09.xhtml#ch09fn12">12</a></sup> The Core Guidelines also recommend when possible that you initialize all your data members with in-class initializers and let the compiler generate a default constructor for your class. A compiler-generated default constructor can be more efficient than one you define.<sup><a id="rch09fn13" href="ch09.xhtml#ch09fn13">13</a></sup> Like <code>m_name</code>, we can use <code>m_balance</code> in the class’s member functions (lines 16, 23 and 29) because it’s a data member of the class.</p>&#13;
<p class="footnote"><a id="ch09fn12" href="ch09.xhtml#rch09fn12">12</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-in-class-initializer">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-in-class-initializer</a></code>.</p>&#13;
<p class="footnote"><a id="ch09fn13" href="ch09.xhtml#rch09fn13">13</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default</a></code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec22">Two-Parameter Constructor</h5>&#13;
<p>The class has a constructor and four member functions. It’s common for someone opening an account to deposit money immediately, so the constructor (lines 10–18) receives a second parameter <code>balance</code> of type <code>double</code> that represents the starting balance. We did not declare this constructor <code>explicit</code>, because it cannot be called with only one parameter.</p>&#13;
<p>Lines 15–17 ensure that data member <code>m_balance</code> is assigned the <code>balance</code> parameter’s value only if that value is greater than <code>0.0:</code></p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig11" id="aa09unfig11">Click here to view code image</a></p>&#13;
<pre class="pre"><code><span class="blue">if</span> (balance &gt; <span class="green">0.0</span>) { <span class="lgreen">// if the balance is valid</span></code>&#13;
   <code>m_balance = balance; <span class="lgreen">// assign it to data member m_balance</span></code>&#13;
<code>}</code></pre>&#13;
<p>Otherwise, <code>m_balance</code> will still have its default initial value <code>0.0</code> that was set at line 43 in class <code>Account</code>’s definition.</p>&#13;
<h5 class="h5" id="ch09lev3sec23"><code>deposit</code> Member Function</h5>&#13;
<p>Member function <code>deposit</code> (lines 21–25) receives a <code>double</code> parameter <code>amount</code> and does not return a value. Lines 22–24 ensure that parameter <code>amount</code>’s value is added to <code>m_balance</code> only if <code>amount</code> is greater than zero (that is, it’s a valid deposit amount).</p>&#13;
<h5 class="h5" id="ch09lev3sec24"><code>getBalance</code> Member Function</h5>&#13;
<p>Member function <code>getBalance</code> (lines 28–30) allows the class’s clients to obtain a particular <code>Account</code> object’s <code>m_balance</code> value. The member function specifies return type <code>double</code> and an empty parameter list. Like member function <code>getName</code>, <code>getBalance</code> is declared <code>const</code> because, in the process of returning <code>m_balance</code>, the function does not, and should not, modify the <code>Account</code> object on which it’s called.</p>&#13;
<h5 class="h5" id="ch09lev3sec25">Manipulating <code>Account</code> Objects with Balances</h5>&#13;
<p>The <code>main</code> function in <a href="#fig9_6">Fig. 9.6</a> creates two <code>Account</code> objects (lines 10–11) and attempts to initialize them with a valid balance of <code>50.00</code> and an invalid balance of <code>-7.00</code>, respectively. For our examples, we assume that balances must be greater than or equal to zero. Lines 14–17 output both <code>Account</code>s’ names and balances by calling each objects’ <code>getName</code> and <code>getBalance</code> member functions. The <code>account2</code> object’s balance is initially <code>0.0</code> because the constructor rejected the attempt to start <code>account2</code> with a negative balance, so <code>account2</code>’s <code>m_balance</code> data member retains its default initial value.</p>&#13;
<div class="group" id="fig9_6">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig06" id="aa09fig06">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.6: AccountTest.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Displaying and updating Account balances.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"Account.h"</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">8</span></strong>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>Account account1{<span class="green">"Jane Green"</span>, <span class="green">50.00</span>};</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>Account account2{<span class="green">"John Blue"</span>, <span class="green">-7.00</span>};</code>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="lgreen">// display initial balance of each object</span></code>&#13;
<strong><span class="cviolet">14</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"account1: {} balance is ${:.2f}\n"</span>,</code>&#13;
<strong><span class="cviolet">15</span></strong>                 <code>account1.getName(), account1.getBalance());</code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"account2: {} balance is ${:.2f}\n\n"</span>,</code>&#13;
<strong><span class="cviolet">17</span></strong>                 <code>account2.getName(), account2.getBalance());</code>&#13;
<strong><span class="cviolet">18</span></strong></pre>&#13;
<pre class="pre1"><code>account1: Jane Green balance is $50.00</code>&#13;
<code>account2: John Blue balance is $0.00</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.6</strong></span> Displaying and updating <code>Account</code> balances.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec26">Reading a Deposit Amount from the User and Making a Deposit</h5>&#13;
<p>Lines 19–22 prompt for, input and display the <code>account1</code> deposit amount. Line 23 calls object <code>account1</code>’s <code>deposit</code> member function with variable <code>amount</code> as the argument to add that value to <code>account1</code>’s balance. Lines 26–29 (<a href="#fig9_6">Fig. 9.6</a>) output both <code>Account</code>s’ names and balances again to show that only <code>account1</code>’s balance has changed.</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig12" id="aa09unfig12">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">19</span></strong>      <code>cout &lt;&lt; <span class="green">"Enter deposit amount for account1: "</span>; <span class="lgreen">// prompt</span></code>&#13;
<strong><span class="cviolet">20</span></strong>      <code><span class="blue">double</span> amount;</code>&#13;
<strong><span class="cviolet">21</span></strong>      <code>cin &gt;&gt; amount; <span class="lgreen">// obtain user input</span></code>&#13;
<strong><span class="cviolet">22</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"adding ${:.2f} to account1 balance\n\n"</span>, amount);</code>&#13;
<strong><span class="cviolet">23</span></strong>      <code>account1.deposit(amount); <span class="lgreen">// add to account1's balance</span></code>&#13;
<strong><span class="cviolet">24</span></strong>&#13;
<strong><span class="cviolet">25</span></strong>      <code><span class="lgreen">// display balances</span></code>&#13;
<strong><span class="cviolet">26</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"account1: {} balance is ${:.2f}\n"</span>,</code>&#13;
<strong><span class="cviolet">27</span></strong>                 <code>account1.getName(), account1.getBalance());</code>&#13;
<strong><span class="cviolet">28</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"account2: {} balance is ${:.2f}\n\n"</span>,</code>&#13;
<strong><span class="cviolet">29</span></strong>                 <code>account2.getName(), account2.getBalance());</code>&#13;
<strong><span class="cviolet">30</span></strong></pre>&#13;
<pre class="pre1"><code>Enter deposit amount for account1: <strong>25.37</strong></code>&#13;
<code>adding $25.37 to account1 balance</code>&#13;
&#13;
<code>account1: Jane Green balance is $75.37</code>&#13;
<code>account2: John Blue balance is $0.00</code></pre>&#13;
<p>Lines 31–33 prompt for, input and display <code>account2</code>’s deposit amount. Line 34 calls object <code>account2</code>’s <code>deposit</code> member function with variable <code>amount</code> as the argument to add that value to <code>account2</code>’s balance. Finally, lines 37–40 output both <code>Account</code>s’ names and balances again to show that only <code>account2</code>’s balance has changed.</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig13" id="aa09unfig13">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">31</span></strong>      <code>cout &lt;&lt; <span class="green">"Enter deposit amount for account2: "</span>; <span class="lgreen">// prompt</span></code>&#13;
<strong><span class="cviolet">32</span></strong>      <code>cin &gt;&gt; amount; <span class="lgreen">// obtain user input</span></code>&#13;
<strong><span class="cviolet">33</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"adding ${:.2f} to account2 balance\n\n"</span>, amount);</code>&#13;
<strong><span class="cviolet">34</span></strong>      <code>account2.deposit(amount); <span class="lgreen">// add to account2 balance</span></code>&#13;
<strong><span class="cviolet">35</span></strong>&#13;
<strong><span class="cviolet">36</span></strong>      <code><span class="lgreen">// display balances</span></code>&#13;
<strong><span class="cviolet">37</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"account1: {} balance is ${:.2f}\n"</span>,</code>&#13;
<strong><span class="cviolet">38</span></strong>                 <code>account1.getName(), account1.getBalance());</code>&#13;
<strong><span class="cviolet">39</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"account2: {} balance is ${:.2f}\n"</span>,</code>&#13;
<strong><span class="cviolet">40</span></strong>                 <code>account2.getName(), account2.getBalance());</code>&#13;
<strong><span class="cviolet">41</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Enter deposit amount for account2: <strong>123.45</strong></code>&#13;
<code>adding $123.45 to account2 balance</code>&#13;
&#13;
<code>account1: Jane Green balance is $75.37</code>&#13;
<code>account2: John Blue balance is $123.45</code></pre>&#13;
<h3 class="h3" id="ch09lev1sec7"><span class="violet">9.7</span> <code><strong>Time</strong></code> Class Case Study: Separating Interface from Implementation</h3>&#13;
<p>Each of our prior custom class definitions placed a class in a header for reuse, then included the header into a source-code file containing <code>main</code>, so we could create and manipulate objects of the class. Unfortunately, placing a complete class definition in a header reveals the class’s entire implementation to its clients. A header is simply a text file that anyone can open and read.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Conventional software-engineering wisdom says that to use an object of a class, the client code (e.g., <code>main</code>) needs to know only</p>&#13;
<p class="bull">• what member functions to call,</p>&#13;
<p class="bull">• what arguments to provide to each member function and</p>&#13;
<p class="bull">• what return type to expect from each member function.</p>&#13;
<p>The client code does not need to know how those functions are implemented. This is another example of the principle of least privilege.</p>&#13;
<p>If the client-code programmer knows how a class is implemented, the programmer might write client code based on the class’s implementation details. Ideally, if that implementation changes, the class’s clients should not have to change. Hiding the class’s implementation details makes it easier to change the implementation while minimizing, and hopefully eliminating, changes to client code.</p>&#13;
<p>Our next example creates and manipulates an object of class <code>Time</code>.<sup><a id="rch09fn14" href="ch09.xhtml#ch09fn14">14</a></sup> We demonstrate two important C++ software engineering concepts:</p>&#13;
<p class="footnote"><a id="ch09fn14" href="ch09.xhtml#rch09fn14">14</a>. In professional C++ development, rather than building your own classes to represent times and dates, you’ll typically use the header <code>&lt;chrono&gt;</code> (<code><a href="https://en.cppreference.com/w/cpp/chrono">https://en.cppreference.com/w/cpp/chrono</a></code>) from the C++ Standard Library.</p>&#13;
<p class="bull">• <strong><span class="violet">Separating interface from implementation</span></strong>.</p>&#13;
<p class="bull">• Using the preprocessor directive “<code>#pragma once</code>” in a header to prevent the header code from being included into the same source code file more than once. Since a class can be defined only once, using such a preprocessing directive prevents multiple-definition errors.</p>&#13;
<h5 class="h5" id="ch09lev3sec27"><span class="size"><small>20</small></span> C++20 Modules Change How You Separate Interface from Implementation</h5>&#13;
<p><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>MOD</small></span> As you’ll see in <a href="ch15.xhtml#ch15">Chapter 15</a>, C++20 modules<sup><a id="rch09fn15" href="ch09.xhtml#ch09fn15">15</a></sup> eliminate the need for preprocessor <code>#pragma once</code>. You’ll also see that modules enable you to separate interface from implementation in a single source-code file or by using multiple source-code files.</p>&#13;
<p class="footnote"><a id="ch09fn15" href="ch09.xhtml#rch09fn15">15</a>. At the time of this writing, the C++20 modules features were not fully implemented by the three compilers we use, so we cover them in a separate chapter.</p>&#13;
<h4 class="h4" id="ch09lev2sec3">9.7.1 Interface of a Class</h4>&#13;
<p><strong><span class="violet">Interfaces</span></strong> define and standardize how things such as people and systems interact with one another. For example, a radio’s controls serve as an interface between the radio’s users and its internal components. The controls allow users to perform a limited set of operations (such as changing the station, adjusting the volume, and choosing between AM and FM stations). Various radios may implement these operations differently—some provide push buttons, some provide dials and some support voice commands. The interface specifies <em>what</em> operations a radio permits users to perform but does not specify <em>how</em> the operations are implemented inside the radio.</p>&#13;
<p>Similarly, the <strong><span class="violet">interface of a class</span></strong> describes <em>what</em> services a class’s clients can use and how to request those services, but not <em>how</em> the class implements them. A class’s <code>public</code> interface consists of the class’s <code>public</code> member functions (also known as the class’s <strong><span class="violet"><code>public</code> services</span></strong>). As you’ll soon see, you can specify a class’s interface by writing a class definition that lists only the class’s member-function prototypes in the class’s <code>public</code> section.</p>&#13;
<h4 class="h4" id="ch09lev2sec4">9.7.2 Separating the Interface from the Implementation</h4>&#13;
<p>To separate the class’s interface from its implementation, we break up class <code>Time</code> into two files—<code>Time.h</code> (<a href="#fig9_7">Fig. 9.7</a>) in which class <code>Time</code> is defined and <code>Time.cpp</code> (<a href="#fig9_8">Fig. 9.8</a>) in which <code>Time</code>’s member functions are defined. This split:</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> helps make the class reusable,</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> ensures that the clients of the class know what member functions the class provides, how to call them and what return types to expect, and</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> enables the clients to ignore how the class’s member functions are implemented.</p>&#13;
<div class="group" id="fig9_7">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig07" id="aa09fig07">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.7: Time.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Time class definition.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// Member functions are defined in Time.cpp</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="lgreen">// Time class definition</span></code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">class</span> Time {</code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">public</span>:</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code><span class="blue">void</span> setTime(<span class="blue">int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second);</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>std::string to24HourString() <span class="blue">const</span>; <span class="lgreen">// 24-hour string format</span></code>&#13;
<strong><span class="cviolet">12</span></strong>      <code>std::string to12HourString() <span class="blue">const</span>; <span class="lgreen">// 12-hour string format</span></code>&#13;
<strong><span class="cviolet">13</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="blue">int</span> m_hour{<span class="green">0</span>}; <span class="lgreen">// 0 - 23 (24-hour clock format)</span></code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="blue">int</span> m_minute{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span></code>&#13;
<strong><span class="cviolet">16</span></strong>      <code><span class="blue">int</span> m_second{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span></code>&#13;
<strong><span class="cviolet">17</span></strong>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.7</strong></span> <code>Time</code> class definition.</p>&#13;
</div>&#13;
<div class="group" id="fig9_8">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig08" id="aa09fig08">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.8: Time.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Time class member-function definitions.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;stdexcept&gt; <span class="lgreen">// for invalid_argument exception class</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> <span class="green">"Time.h"</span> <span class="lgreen">// include definition of class Time from Time.h</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">9</span></strong>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="lgreen">// set new Time value using 24-hour time</span></code>&#13;
<strong><span class="cviolet">11</span></strong>   <code><span class="blue">void</span> Time::setTime(<span class="blue">int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second) {</code>&#13;
<strong><span class="cviolet">12</span></strong>      <code><span class="lgreen">// validate hour, minute and second</span></code>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="blue">if</span> ((hour &lt; <span class="green">0</span> || hour &gt;= <span class="green">24</span>) || (minute &lt; <span class="green">0</span> || minute &gt;= <span class="green">60</span>) ||</code>&#13;
<strong><span class="cviolet">14</span></strong>         <code>(second &lt; <span class="green">0</span> || second &gt;= <span class="green">60</span>)) {</code>&#13;
<strong><span class="cviolet">15</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"hour, minute or second was out of range"</span>};</code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">17</span></strong>&#13;
<strong><span class="cviolet">18</span></strong>      <code>m_hour = hour;</code>&#13;
<strong><span class="cviolet">19</span></strong>      <code>m_minute = minute;</code>&#13;
<strong><span class="cviolet">20</span></strong>      <code>m_second = second;</code>&#13;
<strong><span class="cviolet">21</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">22</span></strong>&#13;
<strong><span class="cviolet">23</span></strong>   <code><span class="lgreen">// return Time as a string in 24-hour format (HH:MM:SS)</span></code>&#13;
<strong><span class="cviolet">24</span></strong>   <code>string Time::to24HourString() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">25</span></strong>      <code><span class="blue">return</span> fmt::format(<span class="green">"{:02d}:{:02d}:{:02d}"</span>, m_hour, m_minute, m_second);</code>&#13;
<strong><span class="cviolet">26</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">27</span></strong>&#13;
<strong><span class="cviolet">28</span></strong>   <code><span class="lgreen">// return Time as string in 12-hour format (HH:MM:SS AM or PM)</span></code>&#13;
<strong><span class="cviolet">29</span></strong>   <code>string Time::to12HourString() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">30</span></strong>      <code><span class="blue">return</span> fmt::format(<span class="green">"{}:{:02d}:{:02d} {}"</span>,</code>&#13;
<strong><span class="cviolet">31</span></strong>                <code>((</code><strong>m_</strong><code>hour % <span class="green">12</span> == <span class="green">0</span>) ? <span class="green">12</span> : m_hour % <span class="green">12</span>), m_minute, m_second,</code>&#13;
<strong><span class="cviolet">32</span></strong>                <code>(m_hour &lt; <span class="green">12</span> ? <span class="green">"AM"</span> : <span class="green">"PM"</span>));</code>&#13;
<strong><span class="cviolet">33</span></strong>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.8</strong></span> <code>Time</code> class member-function definitions.</p>&#13;
</div>&#13;
<p><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size"><small>PERF</small></span> In addition, this split can reduce compilation time because the implementation file can be compiled, then does not need to be recompiled unless the implementation changes.</p>&#13;
<p>By convention, member-function definitions are placed in a <code>.cpp</code> file with the same base name (e.g., <code>Time</code>) as the class’s header. Some compilers support other filename extensions as well. <a href="#fig9_9">Figure 9.9</a> defines function <code>main</code>, which is the client of our <code>Time</code> class.</p>&#13;
<div class="group" id="fig9_9">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig09" id="aa09fig09">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_09.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Program to test class Time.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// NOTE: This file must be compiled with Time.cpp.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;stdexcept&gt; <span class="lgreen">// invalid_argument exception class</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> &lt;string_view&gt;</code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">#include</span> <span class="green">"Time.h"</span> <span class="lgreen">// definition of class Time from Time.h</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
<strong><span class="cviolet">10</span></strong>&#13;
<strong><span class="cviolet">11</span></strong>   <code><span class="lgreen">// displays a Time in 24-hour and 12-hour formats</span></code>&#13;
<strong><span class="cviolet">12</span></strong>   <code><span class="blue">void</span> displayTime(string_view message, <span class="blue">const</span> Time&amp; time) {</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"{}\n24-hour time: {}\n12-hour time: {}\n\n"</span>,</code>&#13;
<strong><span class="cviolet">14</span></strong>                 <code>message, time.to24HourString(), time.to12HourString());</code>&#13;
<strong><span class="cviolet">15</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">18</span></strong>      <code>Time t{}; <span class="lgreen">// instantiate object t of class Time</span></code>&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>      <code>displayTime(<span class="green">"Initial time:"</span>, t); <span class="lgreen">// display t's initial value</span></code>&#13;
<strong><span class="cviolet">21</span></strong>      <code>t.setTime(<span class="green">13</span>, <span class="green">27</span>, <span class="green">6</span>); <span class="lgreen">// change time</span></code>&#13;
<strong><span class="cviolet">22</span></strong>      <code>displayTime(<span class="green">"After setTime:"</span>, t); <span class="lgreen">// display t's new value</span></code>&#13;
<strong><span class="cviolet">23</span></strong>&#13;
<strong><span class="cviolet">24</span></strong>      <code><span class="lgreen">// attempt to set the time with invalid values</span></code>&#13;
<strong><span class="cviolet">25</span></strong>      <code><span class="blue">try</span> {</code>&#13;
<strong><span class="cviolet">26</span></strong>         <code>t.setTime(99, <span class="green"/><span class="green">99</span>, <span class="green">99</span>); <span class="lgreen">// all values out of range</span></code>&#13;
<strong><span class="cviolet">27</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">28</span></strong>      <code><span class="blue">catch</span> (<span class="blue">const</span> invalid_argument&amp; e) {</code>&#13;
<strong><span class="cviolet">29</span></strong>         <code>cout &lt;&lt; fmt::format(<span class="green">"Exception: {}\n\n"</span>, e.what());</code>&#13;
<strong><span class="cviolet">30</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">31</span></strong>&#13;
<strong><span class="cviolet">32</span></strong>      <code><span class="lgreen">// display t's value after attempting to set an invalid time</span></code>&#13;
<strong><span class="cviolet">33</span></strong>      <code>displayTime(<span class="green">"After attempting to set an invalid time:"</span>, t);</code>&#13;
<strong><span class="cviolet">34</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Initial time:</code>&#13;
<code>24-hour time: 00:00:00</code>&#13;
<code>12-hour time: 12:00:00 AM</code>&#13;
&#13;
<code>After setTime:</code>&#13;
<code>24-hour time: 13:27:06</code>&#13;
<code>12-hour time: 1:27:06 PM</code>&#13;
&#13;
<code>Exception: hour, minute and/or second was out of range</code>&#13;
&#13;
<code>After attempting to set an invalid time:</code>&#13;
<code>24-hour time: 13:27:06</code>&#13;
<code>12-hour time: 1:27:06 PM</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.9</strong></span> Program to test class <code>Time</code>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch09lev2sec5">9.7.3 Class Definition</h4>&#13;
<p>The header <code>Time.h</code> (<a href="#fig9_7">Fig. 9.7</a>) contains <code>Time</code>’s class definition (lines 8–17). Rather than function definitions, the class contains function prototypes (lines 10–12) that describe the class’s <code>public</code> interface without revealing the member-function implementations<em>.</em> The function prototype in line 10 indicates that <code>setTime</code> requires three <code>int</code> parameters and returns <code>void</code>. The prototypes for <code>to24HourString</code> and <code>to12HourString</code> (lines 11–12) specify that they take no arguments and return a <code>string</code>. Classes with one or more constructors would also declare them in the header, as we’ll do in subsequent examples.</p>&#13;
<p><span class="size"><small>11</small></span> The header still specifies the class’s <code>private</code> data members (lines 14–16). Each uses a C++11 in-class initializer to set the data member to <code>0</code>. The compiler must know the class’s data members to determine how much memory to reserve for each object of the class. Including the header <code>Time.h</code> in the client code provides the compiler with the information it needs to ensure that the client code calls class <code>Time</code>’s member functions correctly.</p>&#13;
<h5 class="h5" id="ch09lev3sec28"><code>#pragma once</code></h5>&#13;
<p><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> <img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>MOD</small></span> In larger programs, headers also will contain other definitions and declarations. Attempts to include a header multiple times (inadvertently) often occur in programs with many headers that may themselves include other headers. This could lead to compilation errors if the same definition appears more than once in a preprocessed file. The <code><strong><span class="violet">#pragma</span> <span class="violet">once</span></strong></code> directive (line 4) prevents <code>time.h</code>’s contents from being included into the same source-code file more than once. In <a href="ch15.xhtml#ch15">Chapter 15</a>, we’ll discuss how C++20 modules help prevent such problems.</p>&#13;
<h4 class="h4" id="ch09lev2sec6">9.7.4 Member Functions</h4>&#13;
<p><code>Time.cpp</code> (<a href="#fig9_8">Fig. 9.8</a>) defines class <code>Time</code>’s member functions, which were declared in lines 10–12 of <a href="#fig9_7">Fig. 9.7</a>. For member functions <code>to24HourString</code> and <code>to12HourString</code>, the <code>const</code> keyword must appear in both the function prototypes (<a href="#fig9_7">Fig. 9.7</a>, lines 11–12) and the function definitions (<a href="#fig9_8">Fig. 9.8</a>, lines 24 and 29).</p>&#13;
<h4 class="h4" id="ch09lev2sec7">9.7.5 Including the Class Header in the Source-Code File</h4>&#13;
<p>To indicate that the member functions in <code>Time.cpp</code> are part of class <code>Time</code>, we must first include the <code>Time.h</code> header (<a href="#fig9_8">Fig. 9.8</a>, line 6). This allows us to use the class name <code>Time</code> in the <code>Time.cpp</code> file (lines 11, 24 and 29). When compiling <code>Time.cpp</code>, the compiler uses the information in <code>Time.h</code> to ensure that</p>&#13;
<p class="bull">• the first line of each member function matches its prototype in <code>Time.h</code>, and</p>&#13;
<p class="bull">• each member function knows about the class’s data members and other member functions.</p>&#13;
<h4 class="h4" id="ch09lev2sec8">9.7.6 Scope Resolution Operator (<code>::</code>)</h4>&#13;
<p>Each member function’s name (lines 11, 24 and 29) is preceded by the class name and the scope resolution operator (<code>::</code>). This “ties” them to the (now separate) <code>Time</code> class definition (<a href="#fig9_7">Fig. 9.7</a>), which declares the class’s members. The <code>Time::</code> tells the compiler that each member function is in that <strong><span class="violet">class’s scope</span></strong>, and its name is known to other class members.</p>&#13;
<p>Without “<code>Time::</code>” preceding each function name, the compiler would treat these as global functions with no relationship to class time. Such functions, also called “<strong><span class="violet">free</span></strong>” functions, cannot access <code>Time</code>’s <code>private</code> data and cannot call the class’s member functions without specifying an object. So, the compiler would not be able to compile these functions because it would not know that class <code>Time</code> declares variables <code>m_hour</code>, <code>m_minute</code> and <code>m_second</code>. In <a href="#fig9_8">Fig. 9.8</a>, lines 18–20, 25 and 31–32 would cause compilation errors because <code>m_hour</code>, <code>m_minute</code> and <code>m_second</code> are not declared as local variables in each function nor are they declared as global variables.</p>&#13;
<h4 class="h4" id="ch09lev2sec9">9.7.7 Member Function <code>setTime</code> and Throwing Exceptions</h4>&#13;
<p>Function <code>setTime</code> (lines 11–21) is a <code>public</code> function that declares three <code>int</code> parameters and uses them to set the time. Lines 13–14 test each argument to determine whether the value is in range. If so, lines 18–20 assign the values to the <code>m_hour</code>, <code>m_minute</code> and <code>m_second</code> data members, respectively. The <code>hour</code> argument must be greater than or equal to <code>0</code> and less than <code>24</code> because the 24-hour time format represents hours as integers from 0 to 23. Similarly, the <code>minute</code> and <code>second</code> arguments must be greater than or equal to <code>0</code> and less than <code>60</code>.</p>&#13;
<p>If any of the values is outside its range, <code>setTime</code> throws an exception (lines 15) of type <code><strong><span class="violet">invalid_argument</span></strong></code> (header <code>&lt;stdexcept&gt;</code>), which notifies the client code that an invalid argument was received. As you saw in <a href="ch06.xhtml#ch06lev1sec15">Section 6.15</a>, you can use <code>try</code>…<code>catch</code> to catch exceptions and attempt to recover from them, which we’ll do in <a href="#fig9_9">Fig. 9.9</a>. The <code><strong><span class="violet">throw</span></strong></code> <strong><span class="violet">statement</span></strong> creates a new <code>invalid_argument</code> object. That object’s constructor receives a custom error-message string. After the exception object is created, the <code>throw</code> statement terminates function <code>setTime</code>. Then, the exception is returned to the code that called <code>setTime</code>.</p>&#13;
<p>Invalid values cannot be stored in a <code>Time</code> object, because:</p>&#13;
<p class="bull">• when a <code>Time</code> object is created, its default constructor is called and each data member is initialized to 0, as specified in lines 14–16 of <a href="#fig9_7">Fig. 9.7</a>—setting <code>m_hour</code>, <code>m_minute</code> and <code>m_second</code> to 0 is the equivalent of 12 AM (midnight)—and</p>&#13;
<p class="bull">• all subsequent attempts by a client to modify the data members are scrutinized by function <code>setTime</code>.</p>&#13;
<h4 class="h4" id="ch09lev2sec10">9.7.8 Member Function <code>to24HourString</code></h4>&#13;
<p>Member function <code>to24HourString</code> (lines 24–26 of <a href="#fig9_8">Fig. 9.8</a>) takes no arguments and returns a formatted 24-hour <code>string</code> with three colon-separated digit pairs. So, if the time is 1:30:07 PM, the function returns <code>"13:30:07"</code>. Each <code>{:02d}</code> placeholder in line 25 formats an integer (<code>d</code>) in a field width of two. The <code>0</code> before the field width indicates that values with fewer than two digits should be formatted with leading zeros.</p>&#13;
<h4 class="h4" id="ch09lev2sec11">9.7.9 Member Function <code>to12HourString</code></h4>&#13;
<p>Function <code>to12HourString</code> (lines 29–33) takes no arguments and returns a formatted 12-hour time <code>string</code> containing the <code>m_hour</code>, <code>m_minute</code> and <code>m_second</code> values separated by colons and followed by an AM or PM indicator (e.g., <code>10:54:27 AM</code> and <code>1:27:06 PM</code>). The function uses the placeholder <code>{:02d}</code> to format <code>m_minute</code> and <code>m_second</code> as two-digit values with leading zeros, if necessary. Line 31 uses the conditional operator (<code>?:</code>) to determine how <code>m_hour</code> should be formatted. If <code>m_hour</code> is <code>0</code> or <code>12</code> (AM or PM, respectively), it appears as 12; otherwise, we use the remainder operator (<code>%</code>) to get a value from 1 to 11. The conditional operator in line 32 determines whether to include AM or PM.</p>&#13;
<h4 class="h4" id="ch09lev2sec12">9.7.10 Implicitly Inlining Member Functions</h4>&#13;
<p><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size"><small>PERF</small></span> If a member function is fully defined in a class’s body (as we did in our <code>Account</code> class examples), the member function is implicitly declared <code>inline</code> (<a href="ch05.xhtml#ch05lev1sec12">Section 5.12</a>). This can improve performance. Remember that the compiler reserves the right not to inline any function. Similarly, optimizing compilers also reserve the right to inline functions even if they are not declared with the <code>inline</code> keyword.</p>&#13;
<p>Only the simplest, most stable member functions (i.e., whose implementations are unlikely to change) should be defined in the class header. Every change to the header requires you to recompile every source-code file dependent on that header—a time-consuming task in large systems.</p>&#13;
<h4 class="h4" id="ch09lev2sec13">9.7.11 Member Functions vs. Global Functions</h4>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Member functions <code>to24HourString</code> and <code>to12HourString</code> take no arguments. They implicitly know about and are able to access the data members for the <code>Time</code> object on which they’re invoked. This is a nice benefit of object-oriented programming. In general, member-function calls receive either no arguments or fewer arguments than function calls in non-object-oriented programs. This reduces the likelihood of passing wrong arguments, the wrong number of arguments or arguments in the wrong order.</p>&#13;
<h4 class="h4" id="ch09lev2sec14">9.7.12 Using Class <code>Time</code></h4>&#13;
<p>Once class <code>Time</code> is defined, it can be used as a type in declarations, such as:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig14" id="aa09unfig14">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Time sunset{}; <span class="lgreen">// object of type Time</span></code>&#13;
<code>array&lt;Time, <span class="green">5</span>&gt; arrayOfTimes{}; <span class="lgreen">// std::array of 5 Time objects</span></code>&#13;
<code>Time&amp; dinnerTimeRef{sunset}; <span class="lgreen">// reference to a Time object</span></code>&#13;
<code>Time* timePtr{&amp;sunset}; <span class="lgreen">// pointer to a Time object</span></code></pre>&#13;
<p><a href="#fig9_9">Figure 9.9</a> creates and manipulates a <code>Time</code> object. Separating <code>Time</code>’s interface from the implementation of its member functions does not affect the way that this client code uses the class. Line 8 includes <code>Time.h</code> so the compiler knows how much space to reserve for the <code>Time</code> object <code>t</code> (line 18) and can ensure that <code>Time</code> objects are created and manipulated correctly in the client code.</p>&#13;
<p>Throughout the program, we display <code>string</code> representations of the <code>Time</code> object using function <code>displayTime</code> (lines 12–15), which calls <code>Time</code> member functions <code>to24HourString</code> and <code>to12HourString</code>. Line 18 creates the <code>Time</code> object <code>t</code>. Recall that class <code>Time</code> does not define a constructor, so this statement calls the compiler-generated default constructor. Thus, <code>t</code>’s <code>m_hour</code>, <code>m_minute</code> and <code>m_second</code> are set to <code>0</code> via their initializers in class <code>Time</code>’s definition. Then, line 20 displays the time in 24-hour and 12-hour formats, respectively, to confirm that the members were correctly initialized. Line 21 sets a new valid time by calling member function <code>setTime</code>, and line 22 again shows the time in both formats.</p>&#13;
<h5 class="h5" id="ch09lev3sec29">Calling <code>setTime</code> with Invalid Values</h5>&#13;
<p>To show that <code>setTime</code> validates its arguments, line 26 calls <code>setTime</code> with invalid arguments of <code>99</code> for the <code>hour</code>, <code>minute</code> and <code>second</code> parameters. We placed this statement in a <code>try</code> block (lines 25–27) in case <code>setTime</code> throws an <code>invalid_argument</code> exception, which it will do in this example. When the exception occurs, it’s caught at lines 28–30, and line 29 displays the exception’s error message by calling its <code>what</code> member function. Line 33 shows the time to confirm that <code>setTime</code> did not change the time when invalid arguments were supplied.</p>&#13;
<h4 class="h4" id="ch09lev2sec15">9.7.13 Object Size</h4>&#13;
<p>People new to object-oriented programming often suppose that objects must be quite large because they contain data members and member functions. Logically, this is true. You may think of objects as containing data and functions physically (and our discussion has certainly encouraged this view). However, this is not the case.</p>&#13;
<p><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size"><small>PERF</small></span> Objects contain only data, so they’re much smaller than if they also contained member functions. The member functions’ code is maintained separately from all objects of the class. Each object needs its own data because the data usually varies among the objects. The function code is the same for all objects of the class and can be shared among them.</p>&#13;
<h3 class="h3" id="ch09lev1sec8"><span class="violet">9.8</span> Compilation and Linking Process</h3>&#13;
<p>Often a class’s interface and implementation will be created by one programmer and used by a separate programmer who implements the client code. A <strong><span class="violet">class-implementation programmer</span></strong> responsible for creating a reusable <code>Time</code> class creates the header <code>Time.h</code> and the source-code file <code>Time.cpp</code> that <code>#include</code>s the header, then provides these files to the client-code programmer. A reusable class’s source code often is available to client-code programmers as a library they can download from a website, like <code><a href="http://GitHub.com">GitHub.com</a></code>.</p>&#13;
<p>The client-code programmer needs to know only <code>Time</code>’s interface to use the class and must be able to compile <code>Time.cpp</code> and link its object code. Since the class’s interface is part of the class definition in the <code>Time.h</code> header, the client-code programmer must <code>#include</code> this file in the client’s source-code file. The compiler uses the class definition in <code>Time.h</code> to ensure that the client code creates and manipulates <code>Time</code> objects correctly.</p>&#13;
<p>To create the executable <code>Time</code> application, the last step is to link</p>&#13;
<p class="num"><span class="red"><strong>1.</strong></span> the object code for the <code>main</code> function (that is, the client code),</p>&#13;
<p class="num"><span class="red"><strong>2.</strong></span> the object code for class <code>Time</code>’s member-function implementations, and</p>&#13;
<p class="num"><span class="red"><strong>3.</strong></span> the C++ Standard Library object code for the C++ classes (such as <code>std::string</code>) used by the class-implementation programmer and the client-code programmer.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> The linker’s output for the program of <a href="#ch09lev1sec7">Section 9.7</a> is the executable application that users can run to create and manipulate a <code>Time</code> object. Compilers and IDEs typically invoke the linker for you after compiling your code.</p>&#13;
<h5 class="h5" id="ch09lev3sec30">Compiling Programs Containing Two or More Source-Code Files</h5>&#13;
<p>In Section 1.9, we showed how to compile and run C++ applications that contained one source-code (<code>.cpp</code>) file. To compile and link multiple source-code files:<sup><a id="rch09fn16" href="ch09.xhtml#ch09fn16">16</a></sup></p>&#13;
<p class="footnote"><img class="inline" src="Images/mod.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>MOD</small></span> <a id="ch09fn16" href="ch09.xhtml#rch09fn16">16</a>. This process changes with C++20 modules, as we’ll discuss in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>&#13;
<p class="bull">• In Microsoft Visual Studio, add to your project (as shown in Section 1.9.1) all the custom headers and source-code files that make up the program, then build and run the project. You can place the headers in the project’s <strong>Header Files</strong> folder and the source-code files in the project’s <strong>Source Files</strong> folder, but these are mainly for organizing files in large projects. The programs will compile if you place all the files in the <strong>Source Files</strong> folder.</p>&#13;
<p class="bull">• For GNU C++, open a shell and change to the directory containing all the files for a given program. Then in your compilation command, either list each <code>.cpp</code> file by name or use <code>*.cpp</code> to compile all the <code>.cpp</code> files in the current folder. The preprocessor automatically locates the program-specific headers in that folder.</p>&#13;
<p class="bull">• For Apple Xcode, add to your project (as shown in Section 1.9.2) all the headers and source-code files that make up a program, then build and run the project.</p>&#13;
<h3 class="h3" id="ch09lev1sec9"><span class="violet">9.9</span> Class Scope and Accessing Class Members</h3>&#13;
<p>A class’s data members and member functions belong to that class’s scope. Non-member functions are defined at global namespace scope, by default. (We discuss namespaces in more detail in Section 19.4.) Within a class’s scope, class members are immediately accessible by all of that class’s member functions and can be referenced by name. Outside a class’s scope, <code>public</code> class members are referenced through</p>&#13;
<p class="bull">• an object name,</p>&#13;
<p class="bull">• a reference to an object, or</p>&#13;
<p class="bull">• a pointer to an object.</p>&#13;
<p>We refer to these as <strong><span class="violet">handles</span></strong> on an object. The handle’s type helps the compiler determine the interface (that is, the member functions) accessible to the client via that handle. We’ll see in <a href="#ch09lev1sec19">Section 9.19</a> that an implicit handle (called the <code>this</code> pointer) is inserted by the compiler each time you refer to a data member or member function from within an object.</p>&#13;
<h5 class="h5" id="ch09lev3sec31">Dot (<code>.</code>) and Arrow (<code>-&gt;</code>) Member-Selection Operators</h5>&#13;
<p>As you know, you can use an object’s name or a reference to an object followed by the dot member-selection operator (<code>.</code>) to access the object’s members. To reference an object’s members via a pointer to an object, follow the pointer name by the <strong><span class="violet">arrow member-selection operator (</span></strong><code><strong><span class="violet">-&gt;</span></strong></code><strong><span class="violet">)</span></strong> and the member name, as in <em>pointerName</em><code>-&gt;</code><em>memberName</em>.</p>&#13;
<h5 class="h5" id="ch09lev3sec32">Accessing <code>public</code> Class Members Through Objects, References and Pointers</h5>&#13;
<p>Consider an <code>Account</code> class that has a <code>public deposit</code> member function. Given the following declarations:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig15" id="aa09unfig15">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Account account{}; <span class="lgreen">// an Account object</span></code>&#13;
<code>Account&amp; ref{account}; <span class="lgreen">// ref refers to an Account object</span></code>&#13;
<code>Account* ptr{&amp;account}; <span class="lgreen">// ptr points to an Account object</span></code></pre>&#13;
<p>You can invoke member function <code>deposit</code> using the dot (<code>.</code>) and arrow (<code>-&gt;</code>) member selection operators as follows:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig16" id="aa09unfig16">Click here to view code image</a></p>&#13;
<pre class="pre"><code>account.deposit(<span class="green">123.45</span>); <span class="lgreen">// call deposit via account object</span></code>&#13;
<code>ref.deposit(<span class="green">123.45</span>); <span class="lgreen">// call deposit via reference to account</span></code>&#13;
<code>ptr-&gt;deposit(<span class="green">123.45</span>); <span class="lgreen">// call deposit via pointer to account</span></code></pre>&#13;
<p>Again, you should use references over pointers whenever possible. We’ll continue to show pointers when they are required and to prepare you to work with them in the legacy code you’ll encounter in industry.</p>&#13;
<h3 class="h3" id="ch09lev1sec10"><span class="violet">9.10</span> Access Functions and Utility Functions</h3>&#13;
<h5 class="h5" id="ch09lev3sec33">Access Functions</h5>&#13;
<p><strong><span class="violet">Access functions</span></strong> can read or display data, not modify it. Another use of access functions is to test whether a condition is true or false. Such functions are often called <strong><span class="violet">predicate functions.</span></strong> An example would be a <code>std::array</code>’s or a <code>std::vector</code>’s <code>empty</code> function. A program might test <code>empty</code> before attempting to read an item from the container object.<sup><a id="rch09fn17" href="ch09.xhtml#ch09fn17">17</a></sup></p>&#13;
<p class="footnote"><a id="ch09fn17" href="ch09.xhtml#rch09fn17">17</a>. Many programmers prefer to begin the names of predicate functions with the word “<code>is</code>.” For example, useful predicate functions for our <code>Time</code> class might be <code>isAM</code> and <code>isPM</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec34">Utility Functions</h5>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> A <strong><span class="violet">utility function</span></strong> (also called a <strong><span class="violet">helper function</span></strong>) is a <code>private</code> member function that supports the operation of a class’s other member functions. Utility functions are declared <code>private</code> because they’re not intended for use by the class’s clients. Typically, a utility function contains code that would otherwise be duplicated in several other member functions.</p>&#13;
<h3 class="h3" id="ch09lev1sec11"><span class="violet">9.11</span> <code>Time</code> Class Case Study: Constructors with Default Arguments</h3>&#13;
<p>The program of <a href="#fig9_10">Figs. 9.10</a>–<a href="#fig9_12">9.12</a> enhances class <code>Time</code> to demonstrate a constructor with default arguments.</p>&#13;
<div class="group" id="fig9_10">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig10" id="aa09fig10">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.10: Time.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Time class containing a constructor with default arguments.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// Member functions defined in Time.cpp.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="lgreen">// Time class definition</span></code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">class</span> Time {</code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">public</span>:</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code><span class="lgreen">// default constructor because it can be called with no arguments</span></code>&#13;
<strong><span class="cviolet">11</span></strong>      <code><span class="blue">explicit</span> Time(<span class="blue">int</span> hour = <span class="green">0</span>, <span class="blue">int</span> minute = <span class="green">0</span>, <span class="blue">int</span> second = <span class="green">0</span>);</code>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="lgreen">// set functions</span></code>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="blue">void</span> setTime(<span class="blue">int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second);</code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="blue">void</span> setHour(<span class="blue">int</span> hour); <span class="lgreen">// set hour (after validation)</span></code>&#13;
<strong><span class="cviolet">16</span></strong>      <code><span class="blue">void</span> setMinute(<span class="blue">int</span> minute); <span class="lgreen">// set minute (after validation)</span></code>&#13;
<strong><span class="cviolet">17</span></strong>      <code><span class="blue">void</span> setSecond(<span class="blue">int</span> second); <span class="lgreen">// set second (after validation)</span></code>&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>      <code><span class="lgreen">// get functions</span></code>&#13;
<strong><span class="cviolet">20</span></strong>      <code><span class="blue">int</span> getHour() <span class="blue">const</span>; <span class="lgreen">// return hour</span></code>&#13;
<strong><span class="cviolet">21</span></strong>      <code><span class="blue">int</span> getMinute() <span class="blue">const</span>; <span class="lgreen">// return minute</span></code>&#13;
<strong><span class="cviolet">22</span></strong>      <code><span class="blue">int</span> getSecond() <span class="blue">const</span>; <span class="lgreen">// return second</span></code>&#13;
<strong><span class="cviolet">23</span></strong>&#13;
<strong><span class="cviolet">24</span></strong>      <code>std::string to24HourString() <span class="blue">const</span>; <span class="lgreen">// 24-hour time format string</span></code>&#13;
<strong><span class="cviolet">25</span></strong>      <code>std::string to12HourString() <span class="blue">const</span>; <span class="lgreen">// 12-hour time format string</span></code>&#13;
<strong><span class="cviolet">26</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">27</span></strong>      <code><span class="blue">int</span> m_hour{<span class="green">0</span>}; <span class="lgreen">// 0 - 23 (24-hour clock format)</span></code>&#13;
<strong><span class="cviolet">28</span></strong>      <code><span class="blue">int</span> m_minute{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span></code>&#13;
<strong><span class="cviolet">29</span></strong>      <code><span class="blue">int</span> m_second{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span></code>&#13;
<strong><span class="cviolet">30</span></strong>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.10</strong></span> <code>Time</code> class containing a constructor with default arguments.</p>&#13;
</div>&#13;
<div class="group" id="fig9_11">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig11" id="aa09fig11">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.11: Time.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Member-function definitions for class Time.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;stdexcept&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> <span class="green">"Time.h"</span> <span class="lgreen">// include definition of class Time from Time.h</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">8</span></strong>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="lgreen">// Time constructor initializes each data member</span></code>&#13;
<strong><span class="cviolet">10</span></strong>   <code>Time::Time<span class="blue">(int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second) {</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>setHour(hour); <span class="lgreen">// validate and set private field m_hour</span></code>&#13;
<strong><span class="cviolet">12</span></strong>      <code>setMinute(minute); <span class="lgreen">// validate and set private field m_minute</span></code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>setSecond(second); <span class="lgreen">// validate and set private field m_second</span></code>&#13;
<strong><span class="cviolet">14</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">15</span></strong>&#13;
<strong><span class="cviolet">16</span></strong>   <code><span class="lgreen">// set new Time value using 24-hour time</span></code>&#13;
<strong><span class="cviolet">17</span></strong>   <code><span class="blue">void</span> Time::setTime(<span class="blue">int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second) {</code>&#13;
<strong><span class="cviolet">18</span></strong>      <code><span class="lgreen">// validate hour, minute and second</span></code>&#13;
<strong><span class="cviolet">19</span></strong>      <code><span class="blue">if</span> ((hour &lt; <span class="green">0</span> || hour &gt;= <span class="green">24</span>) || (minute &lt; <span class="green">0</span> || minute &gt;= <span class="green">60</span>) ||</code>&#13;
<strong><span class="cviolet">20</span></strong>         <code>(second &lt; <span class="green">0</span> || second &gt;= <span class="green">60</span>)) {</code>&#13;
<strong><span class="cviolet">21</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"hour, minute or second was out of range"</span>};</code>&#13;
<strong><span class="cviolet">22</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">23</span></strong>&#13;
<strong><span class="cviolet">24</span></strong>      <code>m_hour = hour;</code>&#13;
<strong><span class="cviolet">25</span></strong>      <code>m_minute = minute;</code>&#13;
<strong><span class="cviolet">26</span></strong>      <code>m_second = second;</code>&#13;
<strong><span class="cviolet">27</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">28</span></strong>&#13;
<strong><span class="cviolet">29</span></strong>   <code><span class="lgreen">// set hour value</span></code>&#13;
<strong><span class="cviolet">30</span></strong>   <code><span class="blue">void</span> Time::setHour(<span class="blue">int</span> hour) {</code>&#13;
<strong><span class="cviolet">31</span></strong>      <code><span class="blue">if</span> (hour &lt; <span class="green">0</span> || hour &gt;= <span class="green">24</span>) {</code>&#13;
<strong><span class="cviolet">32</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"hour must be 0-23"</span>};</code>&#13;
<strong><span class="cviolet">33</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">34</span></strong>&#13;
<strong><span class="cviolet">35</span></strong>      <code>m_hour = hour;</code>&#13;
<strong><span class="cviolet">36</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">37</span></strong>&#13;
<strong><span class="cviolet">38</span></strong>   <code><span class="lgreen">// set minute value</span></code>&#13;
<strong><span class="cviolet">39</span></strong>   <code><span class="blue">void</span> Time::setMinute(<span class="blue">int</span> minute) {</code>&#13;
<strong><span class="cviolet">40</span></strong>      <code><span class="blue">if</span> (minute &lt; <span class="green">0</span> || minute &gt;= <span class="green">60</span>) {</code>&#13;
<strong><span class="cviolet">41</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"minute must be 0-59"</span>};</code>&#13;
<strong><span class="cviolet">42</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">43</span></strong>&#13;
<strong><span class="cviolet">44</span></strong>      <code>m_minute = minute;</code>&#13;
<strong><span class="cviolet">45</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">46</span></strong>&#13;
<strong><span class="cviolet">47</span></strong>   <code><span class="lgreen">// set second value</span></code>&#13;
<strong><span class="cviolet">48</span></strong>   <code><span class="blue">void</span> Time::setSecond(<span class="blue">int</span> second) {</code>&#13;
<strong><span class="cviolet">49</span></strong>      <code><span class="blue">if</span> (second &lt; <span class="green">0</span> &amp;&amp; second &gt;= <span class="green">60</span>) {</code>&#13;
<strong><span class="cviolet">50</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"second must be 0-59"</span>};</code>&#13;
<strong><span class="cviolet">51</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">52</span></strong>&#13;
<strong><span class="cviolet">53</span></strong>      <code>m_second = second;</code>&#13;
<strong><span class="cviolet">54</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">55</span></strong>&#13;
<strong><span class="cviolet">56</span></strong>   <code><span class="lgreen">// return hour value</span></code>&#13;
<strong><span class="cviolet">57</span></strong>   <code><span class="blue">int</span> Time::getHour() <span class="blue">const</span> {<span class="blue">return</span> m_hour;}</code>&#13;
<strong><span class="cviolet">58</span></strong>&#13;
<strong><span class="cviolet">59</span></strong>   <code><span class="lgreen">// return minute value</span></code>&#13;
<strong><span class="cviolet">60</span></strong>   <code><span class="blue">int</span> Time::getMinute() <span class="blue">const</span> {<span class="blue">return</span> m_minute;}</code>&#13;
<strong><span class="cviolet">61</span></strong>&#13;
<strong><span class="cviolet">62</span></strong>   <code><span class="lgreen">// return second value</span></code>&#13;
<strong><span class="cviolet">63</span></strong>   <code><span class="blue">int</span> Time::getSecond() <span class="blue">const</span> {<span class="blue">return</span> m_second;}</code>&#13;
<strong><span class="cviolet">64</span></strong>&#13;
<strong><span class="cviolet">65</span></strong>   <code><span class="lgreen">// return Time as a string in 24-hour format (HH:MM:SS)</span></code>&#13;
<strong><span class="cviolet">66</span></strong>   <code>string Time::to24HourString() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">67</span></strong>      <code><span class="blue">return</span> fmt::format(<span class="green">"{:02d}:{:02d}:{:02d}"</span>,</code>&#13;
<strong><span class="cviolet">68</span></strong>                <code>getHour(), getMinute(), getSecond());</code>&#13;
<strong><span class="cviolet">69</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">70</span></strong>&#13;
<strong><span class="cviolet">71</span></strong>   <code><span class="lgreen">// return Time as string in 12-hour format (HH:MM:SS AM or PM)</span></code>&#13;
<strong><span class="cviolet">72</span></strong>   <code>string Time::to12HourString() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">73</span></strong>      <code><span class="blue">return</span> fmt::format(<span class="green">"{}:{:02d}:{:02d} {}"</span>,</code>&#13;
<strong><span class="cviolet">74</span></strong>         <code>((getHour() % <span class="green">12</span> == <span class="green">0</span>) ? <span class="green">12</span> : getHour() % <span class="green">12</span>),</code>&#13;
<strong><span class="cviolet">75</span></strong>         <code>getMinute(), getSecond(), (getHour() &lt; <span class="green">12</span> ? <span class="green">"AM"</span> : <span class="green">"PM"</span>));</code>&#13;
<strong><span class="cviolet">76</span></strong>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.11</strong></span> Member-function definitions for class <code>Time</code>.</p>&#13;
</div>&#13;
<div class="group" id="fig9_12">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig12" id="aa09fig12">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_12.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Constructor with default arguments.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;stdexcept&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">#include</span> <span class="green">"Time.h"</span> <span class="lgreen">// include definition of class Time from Time.h</span></code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">9</span></strong>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="lgreen">// displays a Time in 24-hour and 12-hour formats</span></code>&#13;
<strong><span class="cviolet">11</span></strong>   <code><span class="blue">void</span> displayTime(string_view message, <span class="blue">const</span> Time&amp; time) {</code>&#13;
<strong><span class="cviolet">12</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"{}\n24-hour time: {}\n12-hour time: {}\n\n"</span>,</code>&#13;
<strong><span class="cviolet">13</span></strong>                 <code>message, time.to24HourString(), time.to12HourString());</code>&#13;
<strong><span class="cviolet">14</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">15</span></strong>&#13;
<strong><span class="cviolet">16</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">17</span></strong>      <code><span class="blue">const</span> Time t1{}; <span class="lgreen">// all arguments defaulted</span></code>&#13;
<strong><span class="cviolet">18</span></strong>      <code><span class="blue">const</span> Time t2{<span class="green">2</span>}; <span class="lgreen">// hour specified; minute and second defaulted</span></code>&#13;
<strong><span class="cviolet">19</span></strong>      <code><span class="blue">const</span> Time t3{<span class="green">21</span>, <span class="green">34</span>}; <span class="lgreen">// hour and minute specified; second defaulted</span></code>&#13;
<strong><span class="cviolet">20</span></strong>      <code><span class="blue">const</span> Time t4{<span class="green">12</span>, <span class="green">25</span>, <span class="green">42</span>}; <span class="lgreen">// hour, minute and second specified</span></code>&#13;
<strong><span class="cviolet">21</span></strong>&#13;
<strong><span class="cviolet">22</span></strong>      <code>cout &lt;&lt; <span class="green">"Constructed with:\n\n"</span>;</code>&#13;
<strong><span class="cviolet">23</span></strong>      <code>displayTime(<span class="green">"t1: all arguments defaulted"</span>, t1);</code>&#13;
<strong><span class="cviolet">24</span></strong>      <code>displayTime(<span class="green">"t2: hour specified; minute and second defaulted"</span>, t2);</code>&#13;
<strong><span class="cviolet">25</span></strong>      <code>displayTime(<span class="green">"t3: hour and minute specified; second defaulted"</span>, t3);</code>&#13;
<strong><span class="cviolet">26</span></strong>      <code>displayTime(<span class="green">"t4: hour, minute and second specified"</span>, t4);</code>&#13;
<strong><span class="cviolet">27</span></strong>&#13;
<strong><span class="cviolet">28</span></strong>      <code><span class="lgreen">// attempt to initialize t5 with invalid values</span></code>&#13;
<strong><span class="cviolet">29</span></strong>      <code><span class="blue">try</span> {</code>&#13;
<strong><span class="cviolet">30</span></strong>         <code><span class="blue">const</span> Time t5{<span class="green">27</span>, <span class="green">74</span>, <span class="green">99</span>}; <span class="lgreen">// all bad values specified</span></code>&#13;
<strong><span class="cviolet">31</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">32</span></strong>      <code><span class="blue">catch</span> (<span class="blue">const</span> invalid_argument&amp; e) {</code>&#13;
<strong><span class="cviolet">33</span></strong>         <code>cerr &lt;&lt; fmt::format("t5 <span class="green">not created: {}\n", e</span>.what());</code>&#13;
<strong><span class="cviolet">34</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">35</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Constructed with:</code>&#13;
&#13;
<code>t1: all arguments defaulted</code>&#13;
<code>24-hour time: 00:00:00</code>&#13;
<code>12-hour time: 12:00:00 AM</code>&#13;
&#13;
<code>t2: hour specified; minute and second defaulted</code>&#13;
<code>24-hour time: 02:00:00</code>&#13;
<code>12-hour time: 2:00:00 AM</code>&#13;
&#13;
<code>t3: hour and minute specified; second defaulted</code>&#13;
<code>24-hour time: 21:34:00</code>&#13;
<code>12-hour time: 9:34:00 PM</code>&#13;
&#13;
<code>t4: hour, minute and second specified</code>&#13;
<code>24-hour time: 12:25:42</code>&#13;
<code>12-hour time: 12:25:42 PM</code>&#13;
&#13;
<code>t5 not created: hour must be 0-23</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.12</strong></span> Constructor with default arguments.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch09lev2sec16">9.11.1 Class <code>Time</code></h4>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Like other functions, constructors can specify default arguments. Line 11 of <a href="#fig9_10">Fig. 9.10</a> declares a <code>Time</code> constructor with default arguments, specifying the default value <code>0</code> for each parameter. A constructor with default arguments for all its parameters is also a default constructor—that is, a constructor that can be invoked with no arguments. There can be at most one default constructor per class. Any change to a function’s default argument values requires the client code to be recompiled (to ensure that the program still functions correctly). Class <code>Time</code>’s constructor is declared <code>explicit</code> because it can be called with one argument. We discuss <code>explicit</code> constructors in detail in Section 11.13. This <code>Time</code> class also provides <em>set</em> and <em>get</em> functions for each data member (lines 15–17 and 20–22).</p>&#13;
<h5 class="h5" id="ch09lev3sec35">Class <code>Time</code>’s Constructor</h5>&#13;
<p>In <a href="#fig9_11">Fig. 9.11</a>, lines 10–14 define the <code>Time</code> constructor. The <code>Time</code> constructor calls the <code>setHour</code>, <code>setMinute</code> and <code>setSecond</code> functions to validate and assign values to the data members.</p>&#13;
<p><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> Lines 11–13 of the constructor call <code>setHour</code> to ensure that <code>hour</code> is in the range 0–23, then calls <code>setMinute</code> and <code>setSecond</code> to ensure that <code>minute</code> and <code>second</code> are each in the range 0–59. Functions <code>setHour</code> (lines 30–36), <code>setMinute</code> (lines 39–45) and <code>setSecond</code> (lines 48–54) each throw an exception if an out-of-range argument is received. If <code>setHour</code>, <code>setMinute</code> or <code>setSecond</code> throws an exception during construction, the <code>Time</code> object will not complete construction and will not exist for use in the program.</p>&#13;
<p><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> <img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> The C++ Core Guidelines provide many constructor recommendations. We’ll see more in the next two chapters. If a class requires data members to have specific values (as in class <code>Time</code>), the class should define a constructor that validates the data and, if invalid, throws an exception.<sup><a id="rch09fn18" href="ch09.xhtml#ch09fn18">18</a>,<a id="rch09fn19" href="ch09.xhtml#ch09fn19">19</a>,<a id="rch09fn20" href="ch09.xhtml#ch09fn20">20</a></sup></p>&#13;
<p class="footnote"><a id="ch09fn18" href="ch09.xhtml#rch09fn18">18</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-ctor">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-ctor</a></code>.</p>&#13;
<p class="footnote"><a id="ch09fn19" href="ch09.xhtml#rch09fn19">19</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-complete">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-complete</a></code>.</p>&#13;
<p class="footnote"><a id="ch09fn20" href="ch09.xhtml#rch09fn20">20</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-throw">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-throw</a></code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec36">Testing the Updated Class Time</h5>&#13;
<p>Function <code>main</code> in <a href="#fig9_12">Fig. 9.12</a> initializes five <code>Time</code> objects:</p>&#13;
<p class="bull">• one with all three arguments defaulted in the implicit constructor call (line 17),</p>&#13;
<p class="bull">• one with one argument specified (line 18),</p>&#13;
<p class="bull">• one with two arguments specified (line 19),</p>&#13;
<p class="bull">• one with three arguments specified (line 20) and</p>&#13;
<p class="bull">• one with three invalid arguments specified (line 30).</p>&#13;
<p><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> The program displays each object in 24-hour and 12-hour time formats. For <code>Time</code> object <code>t5</code> (line 30), the program displays an error message because the constructor arguments are out of range. The variable <code>t5</code> never represents a fully constructed object in this program, because the exception is thrown during construction.</p>&#13;
<h5 class="h5" id="ch09lev3sec37"><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Software Engineering Notes Regarding Class <code>Time</code>’s <em>set</em> and <em>get</em> Functions and Constructor</h5>&#13;
<p><code>Time</code>’s <em>set</em> and <em>get</em> functions are called throughout the class’s body. In particular, the constructor (<a href="#fig9_11">Fig. 9.11</a>, lines 10–14) calls functions <code>setHour</code>, <code>setMinute</code> and <code>setSecond</code>, and functions <code>to24HourString</code> and <code>to12HourString</code> call functions <code>getHour</code>, <code>getMinute</code> and <code>getSecond</code> in lines 68 and lines 74–75. In each case, we could have accessed the class’s <code>private</code> data directly.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Our current internal time representation uses three <code>int</code>s, which require 12 bytes of memory on systems with four-byte <code>int</code>s. Consider changing this to a single <code>int</code> representing the total number of seconds since midnight, which requires only four bytes of memory. If we made this change, only the bodies of functions that directly access the <code>private</code> data would need to change. In this class, we’d modify <code>setTime</code> and the <em>set</em> and <em>get</em> function’s bodies for <code>m_hour</code>, <code>m_minute</code> and <code>m_second</code>. There would be no need to modify the constructor or functions <code>to24HourString</code> or <code>to12HourString</code> because they do not access the data directly.</p>&#13;
<p><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> Duplicating statements in multiple functions or constructors makes changing the class’s internal data representation more difficult. Implementing the <code>Time</code> constructor and functions <code>to24HourString</code> and <code>to12HourString</code> as shown in this example reduces the likelihood of errors when altering the class’s implementation.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> As a general rule: Avoid repeating code. This principle is generally referred to as DRY—“don’t repeat yourself.”<sup><a id="rch09fn21" href="ch09.xhtml#ch09fn21">21</a></sup> Rather than duplicating code, place it in a member function that can be called by the class’s constructor or other member functions. This simplifies code maintenance and reduces the likelihood of an error if the code implementation is modified.</p>&#13;
<p class="footnote"><a id="ch09fn21" href="ch09.xhtml#rch09fn21">21</a>. “Don't Repeat Yourself,” Wikipedia (Wikimedia Foundation, Accessed June 20, 2020), <code><a href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">https://en.wikipedia.org/wiki/Don't_repeat_yourself</a></code>.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> <img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> A constructor can call the class’s other member functions. You must be careful when doing this. The constructor initializes the object, so data members used in the called function may not yet be initialized. Logic errors may occur if you use data members before they have been properly initialized.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Making data members <code>private</code> and controlling access (especially write access) to those data members through <code>public</code> member functions helps ensure data integrity. The benefits of data integrity are not automatic simply because data members are <code>private</code>. You must provide appropriate validity checking.</p>&#13;
<h4 class="h4" id="ch09lev2sec17"><span class="size"><small>11</small></span> 9.11.2 Overloaded Constructors and C++11 Delegating Constructors</h4>&#13;
<p><a href="ch05.xhtml#ch05lev1sec16">Section 5.16</a> showed how to overload functions. A class’s constructors and member functions also can be overloaded. Overloaded constructors allow objects to be initialized with different types and/or numbers of arguments. To overload a constructor, provide a prototype and definition for each overloaded version. This also applies to overloaded member functions.</p>&#13;
<p>In <a href="#fig9_10">Figs. 9.10</a>–<a href="#fig9_12">9.12</a>, class <code>Time</code>’s constructor had a default argument for each parameter. We could have defined that constructor instead as four overloaded constructors with the following prototypes:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig17" id="aa09unfig17">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Time(); <span class="lgreen">// default m_hour, m_minute and m_second to 0</span></code>&#13;
<code><span class="blue">explicit</span> Time(<span class="blue">int</span> hour); <span class="lgreen">// default m_minute &amp; m_second to 0</span></code>&#13;
<code>Time(<span class="blue">int</span> hour, <span class="blue">int</span> minute); <span class="lgreen">// default m_second to 0</span></code>&#13;
<code>Time(<span class="blue">int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second); <span class="lgreen">// no default values</span></code></pre>&#13;
<p><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> Just as a constructor can call a class’s other member functions to perform tasks, constructors can call other constructors in the same class. The calling constructor is known as a <strong><span class="violet">delegating constructor</span></strong>—it delegates its work to another constructor. The C++ Core Guidelines recommend defining common code for overloaded constructors in one constructor, then using delegating constructors to call it.<sup><a id="rch09fn22" href="ch09.xhtml#ch09fn22">22</a></sup> Before C++11, this would have been accomplished via a <code>private</code> utility function called by all the constructors.</p>&#13;
<p class="footnote"><a id="ch09fn22" href="ch09.xhtml#rch09fn22">22</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-delegating">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-delegating</a></code>.</p>&#13;
<p>The first three of the four <code>Time</code> constructors declared above can delegate work to one with three <code>int</code> arguments, passing <code>0</code> as the default value for the extra parameters. To do so, you use a member initializer with the name of the class as follows:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig18" id="aa09unfig18">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Time::Time() : Time{<span class="green">0</span>, <span class="green">0</span>, <span class="green">0</span>} {}</code>&#13;
&#13;
<code>Time::Time(<span class="blue">int</span> hour) : Time{hour, <span class="green">0</span>, <span class="green">0</span>} {}</code>&#13;
&#13;
<code>Time::Time(<span class="blue">int</span> hour, <span class="blue">int</span> minute) : Time{hour, minute, <span class="green">0</span>} {}</code></pre>&#13;
<h3 class="h3" id="ch09lev1sec12"><span class="violet">9.12</span> Destructors</h3>&#13;
<p>A <strong><span class="violet">destructor</span></strong> is a special member function that may not specify parameters or a return type. A class’s destructor name is the <strong><span class="violet">tilde character (</span></strong><code><strong><span class="violet">~</span></strong></code><strong><span class="violet">)</span></strong> followed by the class name, such as <code>~Time</code>. This naming convention has intuitive appeal because, as we’ll see in a later chapter, the tilde is the bitwise complement operator. In a sense, the destructor is the complement of the constructor.</p>&#13;
<p>A class’s destructor is called implicitly when an object is destroyed, typically when program execution leaves the scope in which that object was created. The destructor itself does not actually remove the object from memory. It performs <strong><span class="violet">termination housekeeping</span></strong> (such as closing a file) before the object’s memory is reclaimed for later use.</p>&#13;
<p>Even though destructors have not been defined for the classes presented so far, every class has exactly one destructor. If you do not explicitly define a destructor, the compiler defines a default destructor that invokes any class-type data members’ destructors.<sup><a id="rch09fn23" href="ch09.xhtml#ch09fn23">23</a></sup> In <a href="ch12.xhtml#ch12">Chapter 12</a>, we’ll explain why exceptions should not be thrown from destructors.</p>&#13;
<p class="footnote"><a id="ch09fn23" href="ch09.xhtml#rch09fn23">23</a>. We’ll see that such a default destructor also destroys class objects that are created through inheritance (<a href="ch10.xhtml#ch10">Chapter 10</a>).</p>&#13;
<h3 class="h3" id="ch09lev1sec13"><span class="violet">9.13</span> When Constructors and Destructors Are Called</h3>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Constructors and destructors are called implicitly when objects are created and when they’re about to go out of scope, respectively. The order in which these are called depends on the objects’ scopes. Generally, destructor calls are made in the reverse order of the corresponding constructor calls, but as we’ll see in <a href="#fig9_13">Figs. 9.13</a>–<a href="#fig9_15">9.15</a>, global and <code>static</code> objects can alter the order in which destructors are called.</p>&#13;
<div class="group" id="fig9_13">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig13" id="aa09fig13">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.13: CreateAndDestroy.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// CreateAndDestroy class definition.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// Member functions defined in CreateAndDestroy.cpp.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> &lt;string_view&gt;</code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">class</span> CreateAndDestroy {</code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">public</span>:</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>CreateAndDestroy(<span class="blue">int</span> ID, std::string_view message); <span class="lgreen">// constructor</span></code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>~CreateAndDestroy(); <span class="lgreen">// destructor</span></code>&#13;
<strong><span class="cviolet">12</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="blue">int</span> m_ID; <span class="lgreen">// ID number for object</span></code>&#13;
<strong><span class="cviolet">14</span></strong>      <code>std::string m_message; <span class="lgreen">// message describing object</span></code>&#13;
<strong><span class="cviolet">15</span></strong>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.13</strong></span> <code>CreateAndDestroy</code> class definition.</p>&#13;
</div>&#13;
<div class="group" id="fig9_14">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig14" id="aa09fig14">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.14: CreateAndDestroy.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// CreateAndDestroy class member-function definitions.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"CreateAndDestroy.h"</span><span class="lgreen">// include CreateAndDestroy class definition</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="lgreen">// constructor sets object's ID number and descriptive message</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code>CreateAndDestroy::CreateAndDestroy<span class="blue">(int</span> ID, string_view message)</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>:</code> <strong>m_ID</strong><code>{ID}, m_message{message} {</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Object {}  constructor runs  {}\n",</span></code>&#13;
<strong><span class="cviolet">12</span></strong>                 <code>m_ID, m_message);</code>&#13;
<strong><span class="cviolet">13</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>   <code><span class="lgreen">// destructor</span></code>&#13;
<strong><span class="cviolet">16</span></strong>   <code>CreateAndDestroy::~CreateAndDestroy() {</code>&#13;
<strong><span class="cviolet">17</span></strong>      <code><span class="lgreen">// output newline for certain objects; helps readability</span></code>&#13;
<strong><span class="cviolet">18</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"{}Object {}  destructor runs  {}\n",</span></code>&#13;
<strong><span class="cviolet">19</span></strong>                 <code>(m_ID == <span class="green">1</span> || m_ID == <span class="green">6</span> ? <span class="green">"\n"</span> : <span class="green">""</span>), m_ID, m_message);</code>&#13;
<strong><span class="cviolet">20</span></strong>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.14</strong></span> <code>CreateAndDestroy</code> class member-function definitions.</p>&#13;
</div>&#13;
<div class="group" id="fig9_15">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig15" id="aa09fig15">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_15.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Order in which constructors and</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// destructors are called.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"CreateAndDestroy.h"</span> <span class="lgreen">// include CreateAndDestroy class definition</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">void</span> create(); <span class="lgreen">// prototype</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="blue">const</span> CreateAndDestroy first{<span class="green">1</span>, <span class="green">"(global before main)"</span>}; <span class="lgreen">// global object</span></code>&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>cout &lt;&lt; <span class="green">"\nMAIN FUNCTION: EXECUTION BEGINS\n"</span>;</code>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="blue">const</span> CreateAndDestroy second{<span class="green">2</span>, <span class="green">"(local in main)"</span>};</code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="blue">static const</span> CreateAndDestroy third{<span class="green">3</span>, <span class="green">"(local static in main)"</span>};</code>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>      <code>create(); <span class="lgreen">// call function to create objects</span></code>&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>      <code>cout &lt;&lt; <span class="green">"\nMAIN FUNCTION: EXECUTION RESUMES\n"</span>;</code>&#13;
<strong><span class="cviolet">20</span></strong>      <code><span class="blue">const</span> CreateAndDestroy fourth{<span class="green">4</span>, <span class="green">"(local in main)"</span>};</code>&#13;
<strong><span class="cviolet">21</span></strong>      <code>cout &lt;&lt; <span class="green">"\nMAIN FUNCTION: EXECUTION ENDS\n"</span>;</code>&#13;
<strong><span class="cviolet">22</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">23</span></strong>&#13;
<strong><span class="cviolet">24</span></strong>   <code><span class="lgreen">// function to create objects</span></code>&#13;
<strong><span class="cviolet">25</span></strong>   <code><span class="blue">void</span> create() {</code>&#13;
<strong><span class="cviolet">26</span></strong>      <code>cout &lt;&lt; <span class="green">"\nCREATE FUNCTION: EXECUTION BEGINS\n"</span>;</code>&#13;
<strong><span class="cviolet">27</span></strong>      <code><span class="blue">const</span> CreateAndDestroy fifth{<span class="green">5</span>, <span class="green">"(local in create)"</span>};</code>&#13;
<strong><span class="cviolet">28</span></strong>      <code><span class="blue">static const</span> CreateAndDestroy sixth{<span class="green">6</span>, <span class="green">"(local static in create)"</span>};</code>&#13;
<strong><span class="cviolet">29</span></strong>      <code><span class="blue">const</span> CreateAndDestroy seventh{<span class="green">7</span>, <span class="green">"(local in create)"</span>};</code>&#13;
<strong><span class="cviolet">30</span></strong>      <code>cout &lt;&lt; <span class="green">"\nCREATE FUNCTION: EXECUTION ENDS\n"</span>;</code>&#13;
<strong><span class="cviolet">31</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Object 1   constructor runs   (global before main)</code>&#13;
&#13;
<code>MAIN FUNCTION: EXECUTION BEGINS</code>&#13;
<code>Object 2   constructor runs   (local in main)</code>&#13;
<code>Object 3   constructor runs   (local static in main)</code>&#13;
&#13;
<code>CREATE FUNCTION: EXECUTION BEGINS</code>&#13;
<code>Object 5   constructor runs   (local in create)</code>&#13;
<code>Object 6   constructor runs   (local static in create)</code>&#13;
<code>Object 7   constructor runs   (local in create)</code>&#13;
&#13;
<code>CREATE FUNCTION: EXECUTION ENDS</code>&#13;
<code>Object 7   destructor runs    (local in create)</code>&#13;
<code>Object 5   destructor runs    (local in create)</code>&#13;
&#13;
<code>MAIN FUNCTION: EXECUTION RESUMES</code>&#13;
<code>Object 4   constructor runs   (local in main)</code>&#13;
&#13;
<code>MAIN FUNCTION: EXECUTION ENDS</code>&#13;
<code>Object 4   destructor runs    (local in main)</code>&#13;
<code>Object 2   destructor runs    (local in main)</code>&#13;
&#13;
<code>Object 6   destructor runs    (local static in create)</code>&#13;
<code>Object 3   destructor runs    (local static in main)</code>&#13;
&#13;
<code>Object 1   destructor runs    (global before main)</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.15</strong></span> Order in which constructors and destructors are called.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec38">Constructors and Destructors for Objects in Global Scope</h5>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> <img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> <img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> Constructors are called for objects defined in global scope (also called global namespace scope) before any other function (including <code>main</code>) in that file begins execution. The execution order of global object constructors among multiple files is not guaranteed. When <code>main</code> terminates, the corresponding destructors are called in the reverse order of their construction. The <code>exit</code> function often is used to terminate a program when a fatal unrecoverable error occurs. Function <code><strong><span class="violet">exit</span></strong></code> forces a program to terminate immediately and does not execute the destructors of local objects. Function <code><strong><span class="violet">abort</span></strong></code> performs similarly to function <code>exit</code> but forces the program to terminate immediately, without allowing programmer-defined cleanup code of any kind to be called. Function <code>abort</code> is usually used to indicate abnormal termination of the program. (See <a href="app07.xhtml#app07">Appendix G</a> for more information on functions <code>exit</code> and <code>abort</code>.)</p>&#13;
<h5 class="h5" id="ch09lev3sec39">Constructors and Destructors for Non-<code>static</code> Local Objects</h5>&#13;
<p>A non-<code>static</code> local object’s constructor is called when execution reaches the object’s definition. Its destructor is called when execution leaves the object’s scope—that is, when the block in which that object is defined finishes executing normally or due to an exception. Destructors are not called for local objects if the program terminates with a call to function <code>exit</code> or function <code>abort</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec40">Constructors and Destructors for <code>static</code> Local Objects</h5>&#13;
<p>The constructor for a <code>static</code> local object is called only once when execution first reaches the point where the object is defined. The corresponding destructor is called when <code>main</code> terminates or the program calls function <code>exit</code>. Global and <code>static</code> objects are destroyed in the reverse order of their creation. Destructors are not called for <code>static</code> objects if the program terminates with a call to function <code>abort</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec41">Demonstrating When Constructors and Destructors Are Called</h5>&#13;
<p>The program of <a href="#fig9_13">Figs. 9.13</a>–<a href="#fig9_15">9.15</a> demonstrates the order in which constructors and destructors are called for global, local and local <code>static</code> objects of class <code>CreateAndDestroy</code> (<a href="#fig9_13">Fig. 9.13</a> and <a href="#fig9_14">Fig. 9.14</a>). This mechanical example is purely for pedagogic purposes.</p>&#13;
<p><a href="#fig9_13">Figure 9.13</a> declares class <code>CreateAndDestroy</code>. Lines 13–14 declare the class’s data members—an integer (<code>m_ID</code>) and a <code>string</code> (<code>m_message</code>) that identify each object in the program’s output.</p>&#13;
<p>The constructor and destructor implementations (<a href="#fig9_14">Fig. 9.14</a>) both display lines of output to indicate when they’re called. In the destructor, the conditional expression (line 19) determines whether the object being destroyed has the <code>m_ID</code> value <code>1</code> or <code>6</code> and, if so, outputs a newline character to make the program’s output easier to follow.</p>&#13;
<p><a href="#fig9_15">Figure 9.15</a> defines object <code>first</code> (line 10) in global scope. Its constructor is called before any statements in <code>main</code> execute and its destructor is called at program termination after the destructors for all objects with automatic storage duration have run.</p>&#13;
<p>Function <code>main</code> (lines 12–22) defines three objects. Objects <code>second</code> (line 14) and <code>fourth</code> (line 20) are local objects, and object <code>third</code> (line 15) is a <code>static</code> local object. The constructor for each of these objects is called when execution reaches the point where that object is defined. When execution reaches the end of <code>main</code>, the destructors for objects <code>fourth</code> then <code>second</code> are called in the reverse of their constructors’ order. Object <code>third</code> is <code>static</code>, so it exists until program termination. The destructor for object <code>third</code> is called before the destructor for global object <code>first</code>, but after non-<code>static</code> local objects are destroyed.</p>&#13;
<p>Function <code>create</code> (lines 25–31) defines three objects—<code>fifth</code> (line 27) and <code>seventh</code> (line 29) are local automatic objects, and <code>sixth</code> (line 28) is a <code>static</code> local object. When <code>create</code> terminates, the destructors for objects <code>seventh</code> then <code>fifth</code> are called in the reverse of their constructors’ order. Because <code>sixth</code> is <code>static</code>, it exists until program termination. The destructor for <code>sixth</code> is called before the destructors for <code>third</code> and <code>first</code>, but after all other objects are destroyed.</p>&#13;
<h3 class="h3" id="ch09lev1sec14"><span class="violet">9.14</span> <code>Time</code> Class Case Study: A Subtle Trap — Returning a Reference or a Pointer to a <code>private</code> Data Member</h3>&#13;
<p>A reference to an object is an alias for the object’s name, so it may be used on the left side of an assignment statement. In this context, the reference makes a perfectly acceptable <em>lvalue</em> to which you can assign a value.</p>&#13;
<p>A member function can return a reference to a <code>private</code> data member of that class. If the reference return type is declared <code>const</code>, the reference is a nonmodifiable <em>lvalue</em> and cannot be used to modify the data. However, if the reference return type is not declared <code>const</code>, subtle errors can occur.</p>&#13;
<p>The program of <a href="#fig9_16">Figs. 9.16</a>–<a href="#fig9_18">9.18</a> uses a simplified <code>Time</code> class (<a href="#fig9_16">Fig. 9.16</a> and <a href="#fig9_17">Fig. 9.17</a>) to demonstrate returning a reference to a <code>private</code> data member with member function <code>badSetHour</code> (declared in <a href="#fig9_16">Fig. 9.16</a> in line 12 and defined in <a href="#fig9_17">Fig. 9.17</a> in lines 24–31). Such a reference return makes the result of a call to member function <code>badSetHour</code> an alias for <code>private</code> data member <code>hour</code>! The function call can be used in any way that the <code>private</code> data member can be used, including as an <em>lvalue</em> in an assignment statement, thus enabling clients of the class to overwrite the class’s <code>private</code> data at will! A similar problem would occur if the function returned a pointer to the <code>private</code> data.</p>&#13;
<div class="group" id="fig9_16">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig16" id="aa09fig16">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.16: Time.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Time class definition.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// Member functions defined in Time.cpp</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="lgreen">// prevent multiple inclusions of header</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#pragma</span> <span class="green">once</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">class</span> Time {</code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">public</span>:</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code><span class="blue">void</span> setTime(<span class="blue">int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second);</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code><span class="blue">int</span> getHour() <span class="blue">const</span>;</code>&#13;
<strong><span class="cviolet">12</span></strong>      <code><span class="rred">int&amp; badSetHour(int h); // dangerous reference return</span></code>&#13;
<strong><span class="cviolet">13</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="blue">int</span> m_hour{<span class="green">0</span>};</code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="blue">int</span> m_minute{<span class="green">0</span>};</code>&#13;
<strong><span class="cviolet">16</span></strong>      <code><span class="blue">int</span> m_second{<span class="green">0</span>};</code>&#13;
<strong><span class="cviolet">17</span></strong>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.16</strong></span> <code>Time</code> class declaration.</p>&#13;
</div>&#13;
<div class="group" id="fig9_17">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig17" id="aa09fig17">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.17: Time.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Time class member-function definitions.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;stdexcept&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> <span class="green">"Time.h"</span> <span class="lgreen">// include definition of class Time</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">6</span></strong>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="lgreen">// set values of hour, minute and second</span></code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">void</span> Time::setTime(<span class="blue">int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second) {</code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="lgreen">// validate hour, minute and second</span></code>&#13;
<strong><span class="cviolet">10</span></strong>      <code><span class="blue">if</span> ((hour &lt; <span class="green">0</span> || hour &gt;= <span class="green">24</span>) || (minute &lt; <span class="green">0</span> || minute &gt;= <span class="green">60</span>) ||</code>&#13;
<strong><span class="cviolet">11</span></strong>         <code>(second &lt; <span class="green">0</span> || second &gt;= <span class="green">60</span>)) {</code>&#13;
<strong><span class="cviolet">12</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"hour, minute or second was out of range"</span>};</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>      <code>m_hour = hour;</code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>m_minute = minute;</code>&#13;
<strong><span class="cviolet">17</span></strong>      <code>m_second = second;</code>&#13;
<strong><span class="cviolet">18</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>   <code><span class="lgreen">// return hour value</span></code>&#13;
<strong><span class="cviolet">21</span></strong>   <code><span class="blue">int</span> Time::getHour() <span class="blue">const</span> {<span class="blue">return</span> m_hour;}</code>&#13;
<strong><span class="cviolet">22</span></strong>&#13;
<strong><span class="cviolet">23</span></strong>   <code><span class="lgreen">// poor practice: returning a reference to a private data member.</span></code>&#13;
<strong><span class="cviolet">24</span></strong>   <code><span class="rred">int&amp;</span> Time::badSetHour(<span class="blue">int</span> hour) {</code>&#13;
<strong><span class="cviolet">25</span></strong>      <code><span class="blue">if</span> (hour &lt; <span class="green">0</span> || hour &gt;= <span class="green">24</span>) {</code>&#13;
<strong><span class="cviolet">26</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"hour must be 0-23"</span>};</code>&#13;
<strong><span class="cviolet">27</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">28</span></strong>&#13;
<strong><span class="cviolet">29</span></strong>      <code>m_hour = hour;</code>&#13;
<strong><span class="cviolet">30</span></strong>      <code><span class="blue">return</span> m_hour; <span class="lgreen">// dangerous reference return</span></code>&#13;
<strong><span class="cviolet">31</span></strong>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.17</strong></span> <code>Time</code> class member-function definitions.</p>&#13;
</div>&#13;
<div class="group" id="fig9_18">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig18" id="aa09fig18">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_18.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// public member function that</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// returns a reference to private data.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> <span class="green">"Time.h"</span> <span class="lgreen">// include definition of class Time</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">8</span></strong>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>Time t{}; <span class="lgreen">// create Time object</span></code>&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>      <code><span class="lgreen">// initialize hourRef with the reference returned by badSetHour</span></code>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="rred">int&amp; hourRef{t.badSetHour(20)};</span> <span class="lgreen">// 20 is a valid hour</span></code>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Valid hour before modification: {}\n"</span>, hourRef);</code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>hourRef = <span class="green">30</span>; <span class="lgreen">// use hourRef to set invalid value in Time object t</span></code>&#13;
<strong><span class="cviolet">17</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Invalid hour after modification: {}\n\n"</span>,</code>&#13;
<strong><span class="cviolet">18</span></strong>                 <code>t.getHour());</code>&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>      <code><span class="lgreen">// Dangerous: Function call that returns a reference can be</span></code>&#13;
<strong><span class="cviolet">21</span></strong>      <code><span class="lgreen">// used as an lvalue! POOR PROGRAMMING PRACTICE!!!!!!!!</span></code>&#13;
<strong><span class="cviolet">22</span></strong>      <code><span class="rred">t.badSetHour(12) = 74;</span> <span class="lgreen">// assign another invalid value to hour</span></code>&#13;
<strong><span class="cviolet">23</span></strong>&#13;
<strong><span class="cviolet">24</span></strong>      <code>cout &lt;&lt; <span class="green">"After using t.badSetHour(12) as an lvalue, "</span></code>&#13;
<strong><span class="cviolet">25</span></strong>           <code>&lt;&lt; fmt::format("hour <span class="green">is: {}\n"</span>, t.getHour());</code>&#13;
<strong><span class="cviolet">26</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Valid hour before modification: 20</code>&#13;
<code>Invalid hour after modification: 30</code>&#13;
&#13;
<code>After using t.badSetHour(12) as an lvalue, hour is: 74</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.18</strong></span> <code>public</code> member function that returns a reference to <code>private</code> data.</p>&#13;
</div>&#13;
<p><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> <a href="#fig9_18">Figure 9.18</a> declares <code>Time</code> object <code>t</code> (line 10) and reference <code>hourRef</code> (line 13), which we initialize with the reference returned by <code>t.badSetHour(20)</code>. Line 15 displays <code>hourRef</code>’s value to show how <code>hourRef</code> breaks the class’s encapsulation. Statements in <code>main</code> should not have access to the <code>private</code> data in a <code>Time</code> object. Next, line 16 uses the <code>hourRef</code> to set <code>hour</code>’s value to 30 (an invalid value). Lines 17–18 call <code>getHour</code> to show that assigning to <code>hourRef</code> modifies <code>t</code>’s <code>private</code> data. Line 22 uses the <code>badSetHour</code> function call as an <em>lvalue</em> and assigns 74 (another invalid value) to the reference the function returns. Line 25 calls <code>getHour</code> again to show that line 22 modifies the <code>private</code> data in the <code>Time</code> object <code>t</code>.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Returning a reference or a pointer to a <code>private</code> data member breaks the class’s encapsulation, making the client code dependent on the class’s data representation. There are cases where doing this is appropriate. We’ll show an example of this when we build our custom <code>Array</code> class in Section 11.10.</p>&#13;
<h3 class="h3" id="ch09lev1sec15"><span class="violet">9.15</span> Default Assignment Operator</h3>&#13;
<p>The assignment operator (<code>=</code>) can assign an object to another object of the same type. The <strong><span class="violet">default assignment operator</span></strong> generated by the compiler copies each data member of the right operand into the same data member in the left operand. <a href="#fig9_19">Figures 9.19</a>–<a href="#fig9_20">9.20</a> define a <code>Date</code> class. Line 15 of <a href="#fig9_21">Fig. 9.21</a> uses the default assignment operator to assign <code>Date</code> object <code>date1</code> to <code>Date</code> object <code>date2</code>. In this case, <code>date1</code>’s <code>m_year</code>, <code>m_month</code> and <code>m_day</code> members are assigned to <code>date2</code>’s <code>m_year</code>, <code>m_month</code> and <code>m_day</code> members, respectively.</p>&#13;
<div class="group" id="fig9_19">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig19" id="aa09fig19">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.19: Date.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Date class declaration. Member functions are defined in Date.cpp.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="lgreen">// class Date definition</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">class</span> Date {</code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">public:</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="blue">explicit</span> Date(<span class="blue">int</span> year, <span class="blue">int</span> month, <span class="blue">int</span> day);</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>std::string toString() <span class="blue">const</span>;</code>&#13;
<strong><span class="cviolet">11</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">12</span></strong>      <code><span class="blue">int</span> m_year;</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="blue">int</span> m_month;</code>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="blue">int</span> m_day;</code>&#13;
<strong><span class="cviolet">15</span></strong>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.19</strong></span> <code>Date</code> class declaration.</p>&#13;
</div>&#13;
<div class="group" id="fig9_20">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig20" id="aa09fig20">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.20: Date.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Date class member-function definitions.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"Date.h"</span> <span class="lgreen">// include definition of class Date from Date.h</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="lgreen">// Date constructor (should do range checking)</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code>Date::Date<span class="blue">(int</span> year, <span class="blue">int</span> month, <span class="blue">int</span> day)</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>: m_year{year}, m_month{month}, m_day{day} {}</code>&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>   <code><span class="lgreen">// return string representation of a Date in the format yyyy-mm-dd</span></code>&#13;
<strong><span class="cviolet">13</span></strong>   <code>string Date::toString() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="blue">return</span> fmt::format(<span class="green">"{}-{:02d}-{:02d}"</span>, m_year, m_month, m_day);</code>&#13;
<strong><span class="cviolet">15</span></strong>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.20</strong></span> <code>Date</code> class member-function definitions.</p>&#13;
</div>&#13;
<div class="group" id="fig9_21">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig21" id="aa09fig21">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_21.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Demonstrating that class objects can be assigned</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// to each other using the default assignment operator.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> <span class="green">"Date.h"</span> <span class="lgreen">// include definition of class Date from Date.h</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">8</span></strong>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code><span class="blue">const</span> Date date1{<span class="green">2004, 7</span>, <span class="green">4</span>};</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>Date date2{<span class="green">2020, 1</span>, <span class="green">1</span>};</code>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"date1: {}\ndate2: {}\n\n"</span>,</code>&#13;
<strong><span class="cviolet">14</span></strong>                 <code>date1.toString(), date2.toString());</code>&#13;
<strong><span class="cviolet">15</span></strong>      <code>date2 = date1; <span class="lgreen">// uses the default assignment operator</span></code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"After assignment, date2: {}\n"</span>, date2.toString());</code>&#13;
<strong><span class="cviolet">17</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>date1: 2004-07-04</code>&#13;
<code>date2: 2020-01-01</code>&#13;
&#13;
<code>After assignment, date2: 2004-07-04</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.21</strong></span> Class objects can be assigned to each other using the default assignment operator.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec42">Copy Constructors</h5>&#13;
<p>Objects may be passed as function arguments and may be returned from functions. Such passing and returning are performed using pass-by-value by default—a copy of the object is passed or returned. In such cases, C++ creates a new object and uses a <strong><span class="violet">copy constructor</span></strong> to copy the original object’s data into the new object. For each class we’ve shown so far, the compiler provides a default copy constructor that copies each member of the original object into the corresponding member of the new object.<sup><a id="rch09fn24" href="ch09.xhtml#ch09fn24">24</a></sup></p>&#13;
<p class="footnote"><a id="ch09fn24" href="ch09.xhtml#rch09fn24">24</a>. In <a href="ch11.xhtml#ch11">Chapter 11</a>, we’ll discuss cases in which the compiler uses move constructors, rather than copy constructors.</p>&#13;
<h3 class="h3" id="ch09lev1sec16"><span class="violet">9.16</span> <code>const</code> Objects and <code>const</code> Member Functions</h3>&#13;
<p>Let’s see how the principle of least privilege applies to objects. Some objects do not need to be modifiable, in which case you should declare them <code>const</code>. Any attempt to modify a <code>const</code> object results in a compilation error. The statement</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig19" id="aa09unfig19">Click here to view code image</a></p>&#13;
<pre class="pre"><code><span class="blue">const</span> Time noon{<span class="green">12</span>, <span class="green">0</span>, <span class="green">0</span>};</code></pre>&#13;
<p>declares a <code>const Time</code> object <code>noon</code> and initializes it to 12 noon (12 PM). It’s possible to instantiate <code>const</code> and non-<code>const</code> objects of the same class.</p>&#13;
<p><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size"><small>PERF</small></span> Declaring variables and objects <code>const</code> can improve performance. Compilers can perform optimizations on constants that cannot be performed on non-<code>const</code> variables.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> C++ disallows calling a member function on a <code>const</code> object unless that member functions is declared <code>const</code>. So you should declared as <code>const</code> any member function that does not modify the object on which it’s called.</p>&#13;
<p><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> A constructor must be allowed to modify an object to initialize it. A destructor must be allowed to perform its termination housekeeping before an object’s memory is reclaimed by the system. So, attempting to declare a constructor or destructor <code>const</code> is a compilation error. The “<code>const</code>ness” of a <code>const</code> object is enforced throughout the object’s lifetime, from when the constructor finishes initializing the object until that object’s destructor is called.</p>&#13;
<h5 class="h5" id="ch09lev3sec43">Using <code>const</code> and Non-<code>const</code> Member Functions</h5>&#13;
<p>The program of <a href="#fig9_22">Fig. 9.22</a> uses a copy of class <code>Time</code> from <a href="#fig9_10">Figs. 9.10</a>–<a href="#fig9_11">9.11</a>, but removes <code>const</code> from function <code>to12HourString</code>’s prototype and definition to force a compilation error. We create two <code>Time</code> objects—non-<code>const</code> object <code>wakeUp</code> (line 6) and <code>const</code> object <code>noon</code> (line 7). The program attempts to invoke non-<code>const</code> member functions <code>setHour</code> (line 11) and <code>to12HourString</code> (line 15) on the <code>const</code> object <code>noon</code>. In each case, the compiler generates an error message. The program also illustrates the three other member-function-call combinations on objects:</p>&#13;
<p class="bull">• a non-<code>const</code> member function on a non-<code>const</code> object (line 10),</p>&#13;
<p class="bull">• a <code>const</code> member function on a non-<code>const</code> object (line 12) and</p>&#13;
<p class="bull">• a <code>const</code> member function on a <code>const</code> object (lines 13–14).</p>&#13;
<div class="group" id="fig9_22">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig22" id="aa09fig22">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_22.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// const objects and const member functions.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> <span class="green">"Time.h"</span> <span class="lgreen">// include Time class definition</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
 <strong><span class="cviolet">6</span></strong>      <code>Time wakeUp{<span class="green">6</span>, <span class="green">45</span>, <span class="green">0</span>}; <span class="lgreen">// non-constant object</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>      <code><span class="blue">const</span> Time noon{<span class="green">12</span>, <span class="green">0</span>, <span class="green">0</span>}; <span class="lgreen">// constant object</span></code>&#13;
 <strong><span class="cviolet">8</span></strong>&#13;
 <strong><span class="cviolet">9</span></strong>                                <code><span class="lgreen">// OBJECT      MEMBER FUNCTION</span></code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>wakeUp.setHour(<span class="green">18</span>);       <span class="lgreen">// non-const   non-const</span></code>&#13;
<strong><span class="cviolet">11</span></strong>      <code><span class="rred">noon.setHour(12);         // const       non-const</span></code>&#13;
<strong><span class="cviolet">12</span></strong>      <code>wakeUp.getHour();         <span class="lgreen">// non-const   const</span></code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>noon.getMinute();         <span class="lgreen">// const       const</span></code>&#13;
<strong><span class="cviolet">14</span></strong>      <code>noon.to24HourString();    <span class="lgreen">// const       const</span></code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="rred">noon.to12HourString();    // const       non-const</span></code>&#13;
<strong><span class="cviolet">16</span></strong>   <code>}</code></pre>&#13;
<p class="pren"><em>Microsoft Visual C++ compiler error messages:</em></p>&#13;
<pre class="pre1"><code>C:\Users\PaulDeitel\Documents\examples\ch09\fig09_22\fig09_22.cpp(11,19): error C2662: 'void Time::setHour(int)': cannot convert 'this' pointer from 'const Time' to 'Time &amp;'</code>&#13;
&#13;
<code>C:\Users\PaulDeitel\Documents\examples\ch09\fig09_22\fig09_22.cpp(11,4): message : Conversion loses qualifiers</code>&#13;
&#13;
<code>C:\Users\PaulDeitel\Documents\examples\ch09\fig09_22\Time.h(15,9): message : see declaration of 'Time::setHour'</code>&#13;
&#13;
<code>C:\Users\PaulDeitel\Documents\examples\ch09\fig09_22\fig09_22.cpp(15,26): error C2662: 'std::string Time::to12HourString(void)': cannot convert 'this' pointer from 'const Time' to 'Time &amp;'</code>&#13;
&#13;
<code>C:\Users\PaulDeitel\Documents\examples\ch09\fig09_22fig09_22.cpp(15,4): message : Conversion loses qualifiers</code>&#13;
&#13;
<code>C:\Users\PaulDeitel\Documents\examples\ch09\fig09_22\Time.h(25,16): message : see declaration of 'Time::to12HourString'</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.22</strong></span> <code>const</code> objects and <code>const</code> member functions.</p>&#13;
</div>&#13;
<p>The error messages generated for non-<code>const</code> member functions called on a <code>const</code> object are shown in the output window. We added blank lines for readability.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> A constructor must be a non-<code>const</code> member function, but it can still be used to initialize a <code>const</code> object (<a href="#fig9_22">Fig. 9.22</a>, line 7). Recall from <a href="#fig9_11">Fig. 9.11</a> that the <code>Time</code> constructor’s definition calls another non-<code>const</code> member function—<code>setTime</code>—to perform the initialization of a <code>Time</code> object. Invoking a non-<code>const</code> member function from the constructor call as part of the initialization of a <code>const</code> object is allowed. The object is not <code>const</code> until the constructor finishes initializing the object.</p>&#13;
<p>Line 15 in <a href="#fig9_22">Fig. 9.22</a> generates a compilation error even though <code>Time</code>’s member function <code>to12HourString</code> does not modify the object on which it’s called. The fact that a member function does not modify an object is not sufficient. The function must explicitly be declared <code>const</code> for this call to be allowed by the compiler.</p>&#13;
<h3 class="h3" id="ch09lev1sec17"><span class="violet">9.17</span> Composition: Objects as Members of Classes</h3>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> An <code>AlarmClock</code> object needs to know when it’s supposed to sound its alarm, so why not include a <code>Time</code> object as a member of the <code>AlarmClock</code> class? Such a software-reuse capability is called <strong><span class="violet">composition</span></strong> (or <strong><span class="violet">aggregation</span></strong>) and is sometimes referred to as a <span class="violet"><em><strong>has-a</strong></em></span> <strong><span class="violet">relation-ship</span></strong>—a class can have objects of other classes as members.<sup><a id="rch09fn25" href="ch09.xhtml#ch09fn25">25</a></sup> You’ve already used composition in this chapter’s <code>Account</code> class examples. Class <code>Account</code> contained a <code>string</code> object as a data member.</p>&#13;
<p class="footnote"><a id="ch09fn25" href="ch09.xhtml#rch09fn25">25</a>. As you’ll see in <a href="ch10.xhtml#ch10">Chapter 10</a>, classes also may be derived from other classes that provide attributes and behaviors the new classes can use—this is called inheritance.</p>&#13;
<p>You’ve seen how to pass arguments to the constructor of an object you created. Now we show how a class’s constructor can pass arguments to member-object constructors via member initializers.</p>&#13;
<p>The next program uses classes <code>Date</code> (<a href="#fig9_23">Figs. 9.23</a>–<a href="#fig9_24">9.24</a>) and <code>Employee</code> (<a href="#fig9_25">Figs. 9.25</a>–<a href="#fig9_26">9.26</a>) to demonstrate composition. Class <code>Employee</code>’s definition (<a href="#fig9_25">Fig. 9.25</a>) has <code>private</code> data members <code>m_firstName</code>, <code>m_lastName</code>, <code>m_birthDate</code> and <code>m_hireDate</code>. Members <code>m_birth-Date</code> and <code>m_hireDate</code> are <code>const</code> objects of class <code>Date</code>, which has <code>private</code> data members <code>m_year</code>, <code>m_month</code> and <code>m_day</code>. The <code>Employee</code> constructor’s prototype (<a href="#fig9_25">Fig. 9.25</a>, lines 11–12) specifies that the constructor has four parameters (<code>firstName</code>, <code>lastName</code>, <code>birthDate</code> and <code>hireDate</code>). The first two parameters are passed via member initializers to the <code>string</code> constructor for data members <code>firstName</code> and <code>lastName</code>. The last two are passed via member initializers to class <code>Date</code>’s constructor for data members <code>birthDate</code> and <code>hireDate</code>.</p>&#13;
<div class="group" id="fig9_23">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig23" id="aa09fig23">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.23: Date.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Date class definition; Member functions defined in Date.cpp</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">class</span> Date {</code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">public</span>:</code>&#13;
 <strong><span class="cviolet">8</span></strong>      <code><span class="blue">static const int</span> <span class="green">monthsPerYear</span>{<span class="green">12</span>}; <span class="lgreen">// months in a year</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="blue">explicit</span> Date(<span class="blue">int</span> year, <span class="blue">int</span> month, <span class="blue">int</span> day);</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>std::string toString() <span class="blue">const</span>; <span class="lgreen">// date string in yyyy-mm-dd format</span></code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>~Date(); <span class="lgreen">// provided to show when destruction occurs</span></code>&#13;
<strong><span class="cviolet">12</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="blue">int</span> m_year; <span class="lgreen">// any year</span></code>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="blue">int</span> m_month; <span class="lgreen">// 1-12 (January-December)</span></code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="blue">int</span> m_day; <span class="lgreen">// 1-31 based on month</span></code>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>      <code><span class="lgreen">// utility function to check if day is proper for month and year</span></code>&#13;
<strong><span class="cviolet">18</span></strong>      <code><span class="blue">bool</span> checkDay(<span class="blue">int</span> day) <span class="blue">const</span>;</code>&#13;
<strong><span class="cviolet">19</span></strong>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.23</strong></span> <code>Date</code> class definition.</p>&#13;
</div>&#13;
<div class="group" id="fig9_24">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig24" id="aa09fig24">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.24: Date.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Date class member-function definitions.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;array&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;stdexcept&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">#include</span> <span class="green">"Date.h"</span> <span class="lgreen">// include Date class definition</span></code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">9</span></strong>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="lgreen">// constructor confirms proper value for month; calls</span></code>&#13;
<strong><span class="cviolet">11</span></strong>   <code><span class="lgreen">// utility function checkDay to confirm proper value for day</span></code>&#13;
<strong><span class="cviolet">12</span></strong>   <code>Date::Date<span class="blue">(int</span> year, <span class="blue">int</span> month, <span class="blue">int</span> day)</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>: m_year{year}, m_month{month}, m_day{day} {</code>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="blue">if</span> (m_month &lt; <span class="green">1</span> || m_month &gt; <span class="green">monthsPerYear</span>) { <span class="lgreen">// validate the month</span></code>&#13;
<strong><span class="cviolet">15</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"month must be 1-12"</span>};</code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">17</span></strong>&#13;
<strong><span class="cviolet">18</span></strong>      <code><span class="blue">if</span> (!checkDay(day)) { <span class="lgreen">// validate the day</span></code>&#13;
<strong><span class="cviolet">19</span></strong>           <code><span class="blue">throw</span> invalid_argument{<span class="green">"Invalid day for current month and year"</span>};</code>&#13;
<strong><span class="cviolet">20</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">21</span></strong>&#13;
<strong><span class="cviolet">22</span></strong>      <code><span class="lgreen">// output Date object to show when its constructor is called</span></code>&#13;
<strong><span class="cviolet">23</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Date object constructor: {}\n"</span>, toString());</code>&#13;
<strong><span class="cviolet">24</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">25</span></strong>&#13;
<strong><span class="cviolet">26</span></strong>   <code><span class="lgreen">// gets string representation of a Date in the form yyyy-mm-dd</span></code>&#13;
<strong><span class="cviolet">27</span></strong>   <code>string Date::toString() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">28</span></strong>      <code><span class="blue">return</span> fmt::format(<span class="green">"{}-{:02d}-{:02d}"</span>, m_year, m_month, m_day);</code>&#13;
<strong><span class="cviolet">29</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">30</span></strong>&#13;
<strong><span class="cviolet">31</span></strong>   <code><span class="lgreen">// output Date object to show when its destructor is called</span></code>&#13;
<strong><span class="cviolet">32</span></strong>   <code>Date::~Date() {</code>&#13;
<strong><span class="cviolet">33</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Date object destructor: {}\n"</span>, toString());</code>&#13;
<strong><span class="cviolet">34</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">35</span></strong>&#13;
<strong><span class="cviolet">36</span></strong>   <code><span class="lgreen">// utility function to confirm proper day value based on</span></code>&#13;
<strong><span class="cviolet">37</span></strong>   <code><span class="lgreen">// month and year; handles leap years, too</span></code>&#13;
<strong><span class="cviolet">38</span></strong>   <code><span class="blue">bool</span> Date::checkDay(<span class="blue">int</span> day) <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">39</span></strong>      <code><span class="blue">static const</span> array daysPerMonth{</code>&#13;
<strong><span class="cviolet">40</span></strong>         <code><span class="green">0</span>, <span class="green">31</span>, <span class="green">28</span>, <span class="green">31</span>, <span class="green">30</span>, <span class="green">31</span>, <span class="green">30</span>, <span class="green">31</span>, <span class="green">31</span>, <span class="green">30</span>, <span class="green">31</span>, <span class="green">30</span>, <span class="green">31</span>};</code>&#13;
<strong><span class="cviolet">41</span></strong>&#13;
<strong><span class="cviolet">42</span></strong>      <code><span class="lgreen">// determine whether testDay is valid for specified month</span></code>&#13;
<strong><span class="cviolet">43</span></strong>      <code><span class="blue">if</span> (<span class="green">1</span> &lt;= day &amp;&amp; day &lt;= daysPerMonth.at(m_month)) {</code>&#13;
<strong><span class="cviolet">44</span></strong>         <code><span class="blue">return</span> <span class="blue">true</span>;</code>&#13;
<strong><span class="cviolet">45</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">46</span></strong>&#13;
<strong><span class="cviolet">47</span></strong>      <code><span class="lgreen">// February 29 check for leap year</span></code>&#13;
<strong><span class="cviolet">48</span></strong>      <code><span class="blue">if</span> (m_month == <span class="green">2</span> &amp;&amp; day == <span class="green">29</span> &amp;&amp; (m_year % <span class="green">400</span> == <span class="green">0</span> ||</code>&#13;
<strong><span class="cviolet">49</span></strong>         <code>(m_year % <span class="green">4</span> == <span class="green">0</span> &amp;&amp; m_year % <span class="green">100</span> != <span class="green">0</span>))) {</code>&#13;
<strong><span class="cviolet">50</span></strong>         <code><span class="blue">return</span> <span class="blue">true</span>;</code>&#13;
<strong><span class="cviolet">51</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">52</span></strong>&#13;
<strong><span class="cviolet">53</span></strong>      <code><span class="blue">return</span> <span class="blue">false</span>; <span class="lgreen">// invalid day, based on current m_month and m_year</span></code>&#13;
<strong><span class="cviolet">54</span></strong>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.24</strong></span> <code>Date</code> class member-function definitions.</p>&#13;
</div>&#13;
<div class="group" id="fig9_25">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig25" id="aa09fig25">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.25: Employee.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Employee class definition showing composition.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// Member functions defined in Employee.cpp.</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> &lt;string_view&gt;</code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">#include</span> <span class="green">"Date.h"</span> <span class="lgreen">// include Date class definition</span></code>&#13;
 <strong><span class="cviolet">8</span></strong>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">class</span> Employee {</code>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="blue">public</span>:</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>Employee(std::string_view firstName, std::string_view lastName,</code>&#13;
<strong><span class="cviolet">12</span></strong>         <code><span class="blue">const</span> Date&amp; birthDate, <span class="blue">const</span> Date&amp; hireDate);</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>std::string toString() <span class="blue">const</span>;</code>&#13;
<strong><span class="cviolet">14</span></strong>      <code>~Employee(); <span class="lgreen">// provided to confirm destruction order</span></code>&#13;
<strong><span class="cviolet">15</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>std::string m_firstName; <span class="lgreen">// composition: member object</span></code>&#13;
<strong><span class="cviolet">17</span></strong>      <code>std::string m_lastName; <span class="lgreen">// composition: member object</span></code>&#13;
<strong><span class="cviolet">18</span></strong>      <code>Date m_birthDate; <span class="lgreen">// composition: member object</span></code>&#13;
<strong><span class="cviolet">19</span></strong>      <code>Date m_hireDate; <span class="lgreen">// composition: member object</span></code>&#13;
<strong><span class="cviolet">20</span></strong>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.25</strong></span> <code>Employee</code> class definition showing composition.</p>&#13;
</div>&#13;
<div class="group" id="fig9_26">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig26" id="aa09fig26">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.26: Employee.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Employee class member-function definitions.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"Employee.h"</span> <span class="lgreen">// Employee class definition</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> <span class="green">"Date.h"</span> <span class="lgreen">// Date class definition</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">8</span></strong>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="lgreen">// constructor uses member initializer list to pass initializer</span></code>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="lgreen">// values to constructors of member objects</span></code>&#13;
<strong><span class="cviolet">11</span></strong>   <code>Employee::Employee(string_view firstName, string_view lastName,</code>&#13;
<strong><span class="cviolet">12</span></strong>      <code><span class="blue">const</span> Date &amp;birthDate, <span class="blue">const</span> Date &amp;hireDate)</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>: m_firstName{firstName}, m_lastName{lastName},</code>&#13;
<strong><span class="cviolet">14</span></strong>        <code>m_birthDate{birthDate}, m_hireDate{hireDate} {</code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="lgreen">// output Employee object to show when constructor is called</span></code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Employee object constructor: {} {}\n"</span>,</code>&#13;
<strong><span class="cviolet">17</span></strong>                 <code>m_firstName, m_lastName);</code>&#13;
<strong><span class="cviolet">18</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>   <code><span class="lgreen">// gets string representation of an Employee object</span></code>&#13;
<strong><span class="cviolet">21</span></strong>   <code>string Employee::toString() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">22</span></strong>      <code><span class="blue">return</span> fmt::format(<span class="green">"{}, {}  Hired: {}  Birthday: {}"</span>, m_lastName,</code>&#13;
<strong><span class="cviolet">23</span></strong>                <code>m_firstName, m_hireDate.toString(), m_birthDate.toString());</code>&#13;
<strong><span class="cviolet">24</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">25</span></strong>&#13;
<strong><span class="cviolet">26</span></strong>   <code><span class="lgreen">// output Employee object to show when its destructor is called</span></code>&#13;
<strong><span class="cviolet">27</span></strong>   <code>Employee::~Employee() {</code>&#13;
<strong><span class="cviolet">28</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Employee object destructor: {}, {}\n"</span>,</code>&#13;
<strong><span class="cviolet">29</span></strong>                 <code>m_lastName, m_firstName);</code>&#13;
<strong><span class="cviolet">30</span></strong>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.26</strong></span> <code>Employee</code> class member-function definitions.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec44"><code>Employee</code> Constructor’s Member-Initializer List</h5>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> <img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> The colon (<code>:</code>) following the <code>Employee</code> constructor’s header (<a href="#fig9_26">Fig. 9.26</a>, line 13) begins the member-initializer list. The member initializers pass the constructor’s parameters <code>first-Name</code>, <code>lastName</code>, <code>birthDate</code> and <code>hireDate</code> to the constructors of the composed <code>string</code> and <code>Date</code> data members <code>m_firstName</code>, <code>m_lastName</code>, <code>m_birthDate</code> and <code>m_hireDate</code>, respectively. The order of the member initializers does not matter. Data members are constructed in the order that they’re declared in class <code>Employee</code>, not in the order they appear in the member-initializer list. For clarity, the C++ Core Guidelines recommend listing the member initializers in the order they’re declared in the class.<sup><a id="rch09fn26" href="ch09.xhtml#ch09fn26">26</a></sup></p>&#13;
<p class="footnote"><a id="ch09fn26" href="ch09.xhtml#rch09fn26">26</a>. C++ Core Guidelines. Accessed July 12, 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-order">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-order</a></code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec45"><code>Date</code> Class’s Default Copy Constructor</h5>&#13;
<p>As you study class <code>Date</code> (<a href="#fig9_23">Fig. 9.23</a>), notice it does not provide a constructor with a <code>Date</code> parameter. So, why can the <code>Employee</code> constructor’s member-initializer list initialize the <code>m_birthDate</code> and <code>m_hireDate</code> objects by passing <code>Date</code> objects to their constructors? As we mentioned in <a href="#ch09lev1sec15">Section 9.15</a>, the compiler provides each class with a default copy constructor that copies each data member of the constructor’s argument object into the corresponding member of the object being initialized. <a href="ch11.xhtml#ch11">Chapter 11</a> discusses how to define customized copy constructors.</p>&#13;
<h5 class="h5" id="ch09lev3sec46">Testing Classes <code>Date</code> and <code>Employee</code></h5>&#13;
<p><a href="#fig9_27">Figure 9.27</a> creates two <code>Date</code> objects (lines 10–11) and passes them as arguments to the constructor of the <code>Employee</code> object created in line 12. There are fivetotal constructor calls when an <code>Employee</code> is constructed:</p>&#13;
<p class="bull">• two calls to the <code>string</code> class’s constructor (line 13 of <a href="#fig9_26">Fig. 9.26</a>),</p>&#13;
<p class="bull">• two calls to the <code>Date</code> class’s default copy constructor (line 14 of <a href="#fig9_26">Fig. 9.26</a>),</p>&#13;
<p class="bull">• and the call to the <code>Employee</code> class’s constructor, which calls the other four.</p>&#13;
<p>Line 14 of <a href="#fig9_27">Fig. 9.27</a> outputs the <code>Employee</code> object’s data.</p>&#13;
<div class="group" id="fig9_27">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig27" id="aa09fig27">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_27.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Demonstrating composition--an object with member objects.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"Date.h"</span> <span class="lgreen">// Date class definition</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> <span class="green">"Employee.h"</span> <span class="lgreen">// Employee class definition</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">8</span></strong>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code><span class="blue">const</span> Date birth{<span class="green">1987</span> ,<span class="green">7</span>, <span class="green">24</span>};</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code><span class="blue">const</span> Date hire{<span class="green">2018</span>, <span class="green">3</span>, <span class="green">12</span>};</code>&#13;
<strong><span class="cviolet">12</span></strong>      <code><span class="blue">const</span> Employee manager{<span class="green">"Sue"</span>, <span class="green">"Green"</span>, birth, hire};</code>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"\n{}\n"</span>, manager.toString());</code>&#13;
<strong><span class="cviolet">15</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Date object constructor: 1987-07-24</code>&#13;
<code>Date object constructor: 2018-03-12</code>&#13;
<code>Employee object constructor: Sue Green</code>&#13;
&#13;
<code>Green, Sue  Hired: 2018-03-12  Birthday: 1987-07-24</code>&#13;
<code>Employee object destructor: Green, Sue</code>&#13;
<code>Date object destructor: 2018-03-12</code>&#13;
<code>Date object destructor: 1987-07-24</code>&#13;
<code>Date object destructor: 2018-03-12</code>&#13;
<code>Date object destructor: 1987-07-24</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.27</strong></span> Demonstrating composition—an object with member objects.</p>&#13;
</div>&#13;
<p>When each <code>Date</code> object is created in lines 10–11, the <code>Date</code> constructor (lines 12–24 of <a href="#fig9_24">Fig. 9.24</a>) displays a line of output to show that the constructor was called (see the first two lines of the sample output). However, line 12 of <a href="#fig9_27">Fig. 9.27</a> causes two <code>Date</code> copy-constructor calls (line 14 of <a href="#fig9_26">Fig. 9.26</a>) that do not appear in this program’s output. Since the compiler defines our <code>Date</code> class’s copy constructor, it does not contain any output statements to demonstrate when it’s called.</p>&#13;
<p>Class <code>Date</code> and class <code>Employee</code> each include a destructor (lines 32–34 of <a href="#fig9_24">Fig. 9.24</a> and lines 27–30 of <a href="#fig9_26">Fig. 9.26</a>, respectively) that prints a message when an object of its class is destructed. The destructors help us show that, though objects are constructed from the inside out, they’re destructed from the outside in. That is, the <code>Date</code> member objects are destructed after the enclosing <code>Employee</code> object.</p>&#13;
<p>Notice the last four lines in the output of <a href="#fig9_27">Fig. 9.27</a>. The last two lines are the outputs of the <code>Date</code> destructor running on <code>Date</code> objects <code>hire</code> (<a href="#fig9_27">Fig. 9.27</a>, line 11) and <code>birth</code> (line 10), respectively. The outputs confirm that the three objects created in <code>main</code> are destructed in the reverse of the order from which they were constructed. The <code>Employee</code> destructor output is five lines from the bottom. The fourth and third lines from the bottom of the output show the destructors running for the <code>Employee</code>’s member objects <code>m_hireDate</code> (<a href="#fig9_25">Fig. 9.25</a>, line 19) and <code>m_birthDate</code> (line 18).</p>&#13;
<p>These outputs confirm that the <code>Employee</code> object is destructed from the outside in. The <code>Employee</code> destructor runs first (see the output five lines from the bottom). Then the member objects are destructed in the reverse order from which they were constructed. Class <code>string</code>’s destructor does not contain output statements, so we do not see the <code>first-Name</code> and <code>lastName</code> objects being destructed.</p>&#13;
<h5 class="h5" id="ch09lev3sec47">What Happens When You Do Not Use the Member-Initializer List?</h5>&#13;
<p><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> If you do not initialize a member object explicitly, the member object’s default constructor will be called implicitly to initialize the member object. If there is no default constructor, a compilation error occurs. Values set by the default constructor can be changed later by <em>set</em> functions. However, for complex initialization, this approach may require significant additional work and time.</p>&#13;
<p><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size"><small>PERF</small></span> Initializing member objects explicitly through member initializers eliminates the overhead of “doubly initializing” member objects—once when the member object’s default constructor is called and again when <em>set</em> functions are called in the constructor body (or later) to change values in the member object.</p>&#13;
<h3 class="h3" id="ch09lev1sec18"><span class="violet">9.18</span> <code>friend</code> Functions and <code>friend</code> Classes</h3>&#13;
<p>A <code><strong><span class="violet">friend</span></strong></code> <strong><span class="violet">function</span></strong> is a function with access to a class’s <code>public</code> and non-<code>public</code> class members. A class may have as <code>friend</code>s:</p>&#13;
<p class="bull">• standalone functions,</p>&#13;
<p class="bull">• entire classes (and thus all their functions) or</p>&#13;
<p class="bull">• specific member functions of other classes.</p>&#13;
<p>This section presents a mechanical example of how a <code>friend</code> function works. In <a href="ch11.xhtml#ch11">Chapter 11</a>, Operator Overloading, we’ll show <code>friend</code> functions that overload operators for use with objects of custom classes. You’ll see that sometimes a member function cannot be used to define certain overloaded operators.</p>&#13;
<h5 class="h5" id="ch09lev3sec48">Declaring a <code>friend</code></h5>&#13;
<p>To declare a non-member function as a <code>friend</code> of a class, place the function prototype in the class definition and precede it with the keyword <code>friend</code>. To declare all member functions of class <code>ClassTwo</code> as friends of class <code>ClassOne</code>, place in <code>ClassOne</code>’s definition a declaration of the form:</p>&#13;
<pre class="pre"><code><span class="blue">friend class</span> ClassTwo;</code></pre>&#13;
<h5 class="h5" id="ch09lev3sec49">Friendship Rules</h5>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> These are the basic friendship rules:</p>&#13;
<p class="bull">• Friendship is granted, not taken—For class B to be a <code>friend</code> of class A, class A must declare that class B is its <code>friend</code>.</p>&#13;
<p class="bull">• Friendship is not symmetric—If class A is a <code>friend</code> of class B, you cannot infer that class B is a <code>friend</code> of class A.</p>&#13;
<p class="bull">• Friendship is not transitive—If class A is a <code>friend</code> of class B and class B is a <code>friend</code> of class C, you cannot infer that class A is a <code>friend</code> of class C.</p>&#13;
<h5 class="h5" id="ch09lev3sec50"><code>friend</code>s Are Not Subject to Access Modifiers</h5>&#13;
<p>Member access notions of <code>public</code>, <code>protected</code> (<a href="ch10.xhtml#ch10">Chapter 10</a>) and <code>private</code> do not apply to <code>friend</code> declarations, so <code>friend</code> declarations can be placed anywhere in a class definition. We prefer to place all friendship declarations first inside the class definition’s body and not precede them with any access specifier.</p>&#13;
<h5 class="h5" id="ch09lev3sec51">Modifying a Class’s <code>private</code> Data with a <code>friend</code> Function</h5>&#13;
<p><a href="#fig9_28">Figure 9.28</a> defines <code>friend</code> function <code>setX</code> to set class <code>Count</code>’s <code>private</code> data member <code>m_x</code>. Though a <code>friend</code> declaration can appear anywhere in the class, by convention, place the <code>friend</code> declaration (line 9) first in the class definition, .</p>&#13;
<div class="group" id="fig9_28">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig28" id="aa09fig28">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_28.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Friends can access private members of a class.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">6</span></strong>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="lgreen">// Count class definition</span></code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">class</span> Count {</code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="blue">friend</span> <span class="blue">void</span> setX(Count&amp; c, <span class="blue">int</span> value); <span class="lgreen">// friend declaration</span></code>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="blue">public</span>:</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code><span class="blue">int</span> getX() <span class="blue">const</span> {<span class="blue">return</span> m_x;}</code>&#13;
<strong><span class="cviolet">12</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="blue">int</span> m_x{<span class="green">0</span>};</code>&#13;
<strong><span class="cviolet">14</span></strong>   <code>};</code>&#13;
<strong><span class="cviolet">15</span></strong>&#13;
<strong><span class="cviolet">16</span></strong>   <code><span class="lgreen">// function setX can modify private data of Count</span></code>&#13;
<strong><span class="cviolet">17</span></strong>   <code><span class="lgreen">// because setX is declared as a friend of Count (line 8)</span></code>&#13;
<strong><span class="cviolet">18</span></strong>   <code><span class="blue">void</span> setX(Count&amp; c, <span class="blue">int</span> value) {</code>&#13;
<strong><span class="cviolet">19</span></strong>      <code>c.m_x = value; <span class="lgreen">// allowed because setX is a friend of Count</span></code>&#13;
<strong><span class="cviolet">20</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">21</span></strong>&#13;
<strong><span class="cviolet">22</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">23</span></strong>      <code>Count counter{}; <span class="lgreen">// create Count object</span></code>&#13;
<strong><span class="cviolet">24</span></strong>&#13;
<strong><span class="cviolet">25</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Initial counter.x value: {}\n"</span>, counter.getX());</code>&#13;
<strong><span class="cviolet">26</span></strong>      <code>setX(counter, <span class="green">8</span>); <span class="lgreen">// set x using a friend function</span></code>&#13;
<strong><span class="cviolet">27</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"counter.x after setX call: {}\n"</span>, counter.getX());</code>&#13;
<strong><span class="cviolet">28</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>counter.x after instantiation: 0</code>&#13;
<code>counter.x after call to setX friend function: 8</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.28</strong></span> <code>Friend</code>s can access <code>private</code> members of a class.</p>&#13;
</div>&#13;
<p>Function <code>setX</code> (lines 18–20) is a standalone (free) function, not a <code>Count</code> member function. So, when we call <code>setX</code> to modify <code>counter</code> (line 26), we must pass <code>counter</code> as an argument to <code>setX</code>. Function <code>setX</code> is allowed to access class <code>Count</code>’s <code>private</code> data member <code>m_x</code> (line 19) only because the function was declared as a <code>friend</code> of class <code>Count</code> (line 9). If you remove the <code>friend</code> declaration, you’ll receive error messages indicating that function <code>setX</code> cannot modify class <code>Count</code>’s <code>private</code> data member <code>m_x</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec52">Overloaded <code>friend</code> Functions</h5>&#13;
<p>It’s possible to specify overloaded functions as <code>friend</code>s of a class. Each overload intended to be a <code>friend</code> must be explicitly declared in the class definition as a <code>friend</code>, as you’ll see in <a href="ch11.xhtml#ch11">Chapter 11</a>.</p>&#13;
<h3 class="h3" id="ch09lev1sec19"><span class="violet">9.19</span> The <code>this</code> Pointer</h3>&#13;
<p>There’s only one copy of each class’s functionality, but there can be many objects of a class, so how do member functions know which object’s data members to manipulate? Every object’s member functions access the object through a pointer called <code><strong><span class="violet">this</span></strong></code> (a C++ keyword), which is an implicit argument to each of the object’s non-<code>static</code><sup><a id="rch09fn27" href="ch09.xhtml#ch09fn27">27</a></sup> member functions.</p>&#13;
<p class="footnote"><a id="ch09fn27" href="ch09.xhtml#rch09fn27">27</a>. <a href="#ch09lev1sec20">Section 9.20</a> introduces <code>static</code> class members and explains why the <code>this</code> pointer is not implicitly passed to <code>static</code> member functions.</p>&#13;
<h5 class="h5" id="ch09lev3sec53">Using the <code>this</code> Pointer to Avoid Naming Collisions</h5>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Member functions use the <code>this</code> pointer implicitly (as we’ve done so far) or explicitly to reference an object’s data members and other member functions. One explicit use of the <code>this</code> pointer is to avoid naming conflicts between a class’s data members and constructor or member-function parameters. If a member function uses a local variable and data member with the same name, the local variable is said to hide or shadow the data member. Using just the variable name in the member function’s body refers to the local variable rather than the data member.</p>&#13;
<p>You can access the data member explicitly by qualifying its name with <code>this-&gt;</code>. For instance, we could implement class <code>Time</code>’s <code>setHour</code> function as follows:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig20" id="aa09unfig20">Click here to view code image</a></p>&#13;
<pre class="pre">&#13;
<code><span class="lgreen">// set hour value</span></code>&#13;
<code><span class="blue">void</span> Time::setHour(<span class="blue">int</span> hour) {</code>&#13;
   <code><span class="blue">if</span> (hour &lt; <span class="green">0</span> || hour &gt;= <span class="green">24</span>) {</code>&#13;
      <code><span class="blue">throw</span> invalid_argument{<span class="green">"hour must be 0-23"</span>};</code>&#13;
   <code>}</code>&#13;
&#13;
   <code><span class="blue">this</span>-&gt;hour = hour; <span class="lgreen">// use this-&gt; to access data member</span></code>&#13;
<code>}</code></pre>&#13;
<p>where <code>this-&gt;hour</code> represents a data member called <code>hour</code>. You can avoid such naming collisions by naming your data members with the <code>"m_"</code> prefix, as shown in our classes so far.</p>&#13;
<h5 class="h5" id="ch09lev3sec54">Type of the <code>this</code> Pointer</h5>&#13;
<p>The <code>this</code> pointer’s type depends on the object’s type and whether the member function in which <code>this</code> is used is declared <code>const</code>:</p>&#13;
<p class="bull">• In a non-<code>const</code> member function of class <code>Time</code>, the <code>this</code> pointer is a <code>Time*</code>—a pointer to a <code>Time</code> object.</p>&#13;
<p class="bull">• In a <code>const</code> member function, <code>this</code> is a <code>const Time*</code>—a pointer to a <code>Time</code> constant.</p>&#13;
<h4 class="h4" id="ch09lev2sec18">9.19.1 Implicitly and Explicitly Using the <code>this</code> Pointer to Access an Object’s Data Members</h4>&#13;
<p><a href="#fig9_29">Figure 9.29</a> is a mechanical example that demonstrates implicit and explicit use of the <code>this</code> pointer in a member function to display the <code>private</code> data <code>m_x</code> of a <code>Test</code> object. In <a href="#ch09lev2sec19">Section 9.19.2</a> and in <a href="ch11.xhtml#ch11">Chapter 11</a>, we show some substantial and subtle examples of using <code>this</code>.</p>&#13;
<div class="group" id="fig9_29">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig29" id="aa09fig29">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_29.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Using the this pointer to refer to object members.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">6</span></strong>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">class</span> Test {</code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">public</span>:</code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="blue">explicit</span> Test(<span class="blue">int</span> value);</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code><span class="blue">void</span> print() <span class="blue">const</span>;</code>&#13;
<strong><span class="cviolet">11</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">12</span></strong>      <code><span class="blue">int</span> m_x{<span class="green">0</span>};</code>&#13;
<strong><span class="cviolet">13</span></strong>   <code>};</code>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>   <code><span class="lgreen">// constructor</span></code>&#13;
<strong><span class="cviolet">16</span></strong>   <code>Test::Test<span class="blue">(int</span> value) : m_x{value} {} <span class="lgreen">// initialize x to value</span></code>&#13;
<strong><span class="cviolet">17</span></strong>&#13;
<strong><span class="cviolet">18</span></strong>   <code><span class="lgreen">// print x using implicit then explicit this pointers;</span></code>&#13;
<strong><span class="cviolet">19</span></strong>   <code><span class="lgreen">// the parentheses around *this are required due to precedence</span></code>&#13;
<strong><span class="cviolet">20</span></strong>   <code><span class="blue">void</span> Test::print() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">21</span></strong>      <code><span class="lgreen">// implicitly use the this pointer to access the member x</span></code>&#13;
<strong><span class="cviolet">22</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"  x = {}\n", m_x)</span>;</code>&#13;
<strong><span class="cviolet">23</span></strong>&#13;
<strong><span class="cviolet">24</span></strong>      <code><span class="lgreen">// explicitly use the this pointer and the arrow operator</span></code>&#13;
<strong><span class="cviolet">25</span></strong>      <code><span class="lgreen">// to access the member x</span></code>&#13;
<strong><span class="cviolet">26</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"  this-&gt;x = {}\n"</span>, this-&gt;m_x);</code>&#13;
<strong><span class="cviolet">27</span></strong>&#13;
<strong><span class="cviolet">28</span></strong>      <code><span class="lgreen">// explicitly use the dereferenced this pointer and</span></code>&#13;
<strong><span class="cviolet">29</span></strong>      <code><span class="lgreen">// the dot operator to access the member x</span></code>&#13;
<strong><span class="cviolet">30</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"(*this).x = {}\n"</span>, (*<span class="blue">this</span>).m_x);</code>&#13;
<strong><span class="cviolet">31</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">32</span></strong>&#13;
<strong><span class="cviolet">33</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">34</span></strong>      <code><span class="blue">const</span> Test testObject{<span class="green">12</span>}; <span class="lgreen">// instantiate and initialize testObject</span></code>&#13;
<strong><span class="cviolet">35</span></strong>      <code>testObject.print();</code>&#13;
<strong><span class="cviolet">36</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1">        x = 12&#13;
  this-&gt;x = 12&#13;
(*this).x = 12</pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.29</strong></span> Using the <code>this</code> pointer to refer to object members.</p>&#13;
</div>&#13;
<p>For illustration purposes, member function <code>print</code> (lines 20–31) first displays <code>x</code> using the <code>this</code> pointer implicitly (line 22)—only the data member’s name is specified. Then <code>print</code> uses two different notations to access <code>x</code> through the <code>this</code> pointer:</p>&#13;
<p class="bull">• <code>this-&gt;m_x</code> (line 26) and</p>&#13;
<p class="bull">• <code>(*this).m_x</code> (line 30).</p>&#13;
<p>The parentheses around <code>*this</code> (line 30) are required because the dot operator (<code>.</code>) has higher precedence than the <code>*</code> pointer-dereferencing operator. Without the parentheses, the expression <code>*this.x</code> would be evaluated as if it were parenthesized as <code>*(this.x)</code>. The dot operator cannot be used with a pointer, so this would be a compilation error.</p>&#13;
<h4 class="h4" id="ch09lev2sec19">9.19.2 Using the <code>this</code> Pointer to Enable Cascaded Function Calls</h4>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Another use of the <code>this</code> pointer is to enable <strong><span class="violet">cascaded member-function calls</span></strong>—that is, invoking multiple functions sequentially in the same statement, as you’ll see in line 11 of <a href="#fig9_32">Fig. 9.32</a>. The program of <a href="#fig9_30">Figs. 9.30</a>–<a href="#fig9_32">9.32</a> modifies class <code>Time</code>’s <code>setTime</code>, <code>setHour</code>, <code>set-Minute</code> and <code>setSecond</code> functions such that each returns a reference to the <code>Time</code> object on which it’s called. This reference enables cascaded member-function calls. In <a href="#fig9_31">Fig. 9.31</a>, the last statement in each of these member functions’ bodies returns a reference to <code>*this</code> (lines 19, 29, 39 and 49).</p>&#13;
<div class="group" id="fig9_30">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig30" id="aa09fig30">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.30: Time.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Time class modified to enable cascaded member-function calls.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#pragma</span> <span class="green">once</span> <span class="lgreen">// prevent multiple inclusions of header</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">class</span> Time {</code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">public</span>:</code>&#13;
 <strong><span class="cviolet">8</span></strong>      <code><span class="lgreen">// default constructor because it can be called with no arguments</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="blue">explicit</span> Time(<span class="blue">int</span> hour = <span class="green">0</span>, <span class="blue">int</span> minute = <span class="green">0</span>, <span class="blue">int</span> second = <span class="green">0</span>);</code>&#13;
<strong><span class="cviolet">10</span></strong>&#13;
<strong><span class="cviolet">11</span></strong>      <code><span class="lgreen">// set functions</span></code>&#13;
<strong><span class="cviolet">12</span></strong>      <code>Time&amp; setTime(<span class="blue">int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second);</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code>Time&amp; setHour(<span class="blue">int</span> hour); <span class="lgreen">// set hour (after validation)</span></code>&#13;
<strong><span class="cviolet">14</span></strong>      <code>Time&amp; setMinute(<span class="blue">int</span> minute); <span class="lgreen">// set minute (after validation)</span></code>&#13;
<strong><span class="cviolet">15</span></strong>      <code>Time&amp; setSecond(<span class="blue">int</span> second); <span class="lgreen">// set second (after validation)</span></code>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>      <code><span class="blue">int</span> getHour() <span class="blue">const</span>; <span class="lgreen">// return hour</span></code>&#13;
<strong><span class="cviolet">18</span></strong>      <code><span class="blue">int</span> getMinute() <span class="blue">const</span>; <span class="lgreen">// return minute</span></code>&#13;
<strong><span class="cviolet">19</span></strong>      <code><span class="blue">int</span> getSecond() <span class="blue">const</span>; <span class="lgreen">// return second</span></code>&#13;
<strong><span class="cviolet">20</span></strong>      <code>std::string to24HourString() <span class="blue">const</span>; <span class="lgreen">// 24-hour time format string</span></code>&#13;
<strong><span class="cviolet">21</span></strong>      <code>std::string to12HourString() <span class="blue">const</span>; <span class="lgreen">// 12-hour time format string</span></code>&#13;
<strong><span class="cviolet">22</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">23</span></strong>      <code><span class="blue">int</span> m_hour{<span class="green">0</span>}; <span class="lgreen">// 0 - 23 (24-hour clock format)</span></code>&#13;
<strong><span class="cviolet">24</span></strong>      <code><span class="blue">int</span> m_minute{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span></code>&#13;
<strong><span class="cviolet">25</span></strong>      <code><span class="blue">int</span> m_second{<span class="green">0</span>}; <span class="lgreen">// 0 - 59</span></code>&#13;
<strong><span class="cviolet">26</span></strong>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.30</strong></span> <code>Time</code> class modified to enable cascaded member-function calls.</p>&#13;
</div>&#13;
<div class="group" id="fig9_31">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig31" id="aa09fig31">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.31: Time.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Time class member-function definitions.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;stdexcept&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"Time.h"</span> <span class="lgreen">// Time class definition</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="lgreen">// Time constructor initializes each data member</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code>Time::Time<span class="blue">(int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second) {</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>setHour(hour); <span class="lgreen">// validate and set private field m_hour</span></code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>setMinute(minute); <span class="lgreen">// validate and set private field m_minute</span></code>&#13;
<strong><span class="cviolet">12</span></strong>      <code>setSecond(second); <span class="lgreen">// validate and set private field m_second</span></code>&#13;
<strong><span class="cviolet">13</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>   <code><span class="lgreen">// set new Time value using 24-hour time</span></code>&#13;
<strong><span class="cviolet">16</span></strong>   <code>Time&amp; Time::setTime<span class="blue">(int</span> hour, <span class="blue">int</span> minute, <span class="blue">int</span> second) {</code>&#13;
<strong><span class="cviolet">17</span></strong>      <code>Time time{hour, minute, second}; <span class="green">// create a temporary Time object</span></code>&#13;
<strong><span class="cviolet">18</span></strong>      <code>*<span class="blue">this</span> = time; <span class="lgreen">// if time is valid, assign its members to current object</span></code>&#13;
<strong><span class="cviolet">19</span></strong>      <code><span class="blue">return</span> *<span class="blue">this</span>; <span class="lgreen">// enables cascading</span></code>&#13;
<strong><span class="cviolet">20</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">21</span></strong>&#13;
<strong><span class="cviolet">22</span></strong>   <code><span class="lgreen">// set hour value</span></code>&#13;
<strong><span class="cviolet">23</span></strong>   <code>Time&amp; Time::setHour<span class="blue">(int</span> hour) { <span class="lgreen">// note Time&amp; return</span></code>&#13;
<strong><span class="cviolet">24</span></strong>      <code><span class="blue">if</span> (hour &lt; <span class="green">0</span> || hour &gt;= <span class="green">24</span>) {</code>&#13;
<strong><span class="cviolet">25</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"hour must be 0-23"</span>};</code>&#13;
<strong><span class="cviolet">26</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">27</span></strong>&#13;
<strong><span class="cviolet">28</span></strong>      <code>m_hour = hour;</code>&#13;
<strong><span class="cviolet">29</span></strong>      <code><span class="blue">return</span> *<span class="blue">this</span>; <span class="lgreen">// enables cascading</span></code>&#13;
<strong><span class="cviolet">30</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">31</span></strong>&#13;
<strong><span class="cviolet">32</span></strong>   <code><span class="lgreen">// set minute value</span></code>&#13;
<strong><span class="cviolet">33</span></strong>   <code>Time&amp; Time::setMinute<span class="blue">(int</span> m) { <span class="lgreen">// note Time&amp; return</span></code>&#13;
<strong><span class="cviolet">34</span></strong>      <code><span class="blue">if</span> (m &lt; <span class="green">0</span> || m &gt;= <span class="green">60</span>) {</code>&#13;
<strong><span class="cviolet">35</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"minute must be 0-59"</span>};</code>&#13;
<strong><span class="cviolet">36</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">37</span></strong>&#13;
<strong><span class="cviolet">38</span></strong>      <code>m_minute = m;</code>&#13;
<strong><span class="cviolet">39</span></strong>      <code><span class="blue">return</span> *<span class="blue">this</span>; <span class="lgreen">// enables cascading</span></code>&#13;
<strong><span class="cviolet">40</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">41</span></strong>&#13;
<strong><span class="cviolet">42</span></strong>   <code><span class="lgreen">// set second value</span></code>&#13;
<strong><span class="cviolet">43</span></strong>   <code>Time&amp; Time::setSecond<span class="blue">(int</span> s) { <span class="lgreen">// note Time&amp; return</span></code>&#13;
<strong><span class="cviolet">44</span></strong>      <code><span class="blue">if</span> (s &lt; <span class="green">0</span> || s &gt;= <span class="green">60</span>) {</code>&#13;
<strong><span class="cviolet">45</span></strong>         <code><span class="blue">throw</span> invalid_argument{<span class="green">"second must be 0-59"</span>};</code>&#13;
<strong><span class="cviolet">46</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">47</span></strong>&#13;
<strong><span class="cviolet">48</span></strong>      <code>m_second = s;</code>&#13;
<strong><span class="cviolet">49</span></strong>      <code><span class="blue">return</span> *<span class="blue">this</span>; <span class="lgreen">// enables cascading</span></code>&#13;
<strong><span class="cviolet">50</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">51</span></strong>&#13;
<strong><span class="cviolet">52</span></strong>   <code><span class="lgreen">// get hour value</span></code>&#13;
<strong><span class="cviolet">53</span></strong>   <code><span class="blue">int</span> Time::getHour() <span class="blue">const</span> {<span class="blue">return</span> m_hour;}</code>&#13;
<strong><span class="cviolet">54</span></strong>&#13;
<strong><span class="cviolet">55</span></strong>   <code><span class="lgreen">// get minute value</span></code>&#13;
<strong><span class="cviolet">56</span></strong>   <code><span class="blue">int</span> Time::getMinute() <span class="blue">const</span> {<span class="blue">return</span> m_minute;}</code>&#13;
<strong><span class="cviolet">57</span></strong>&#13;
<strong><span class="cviolet">58</span></strong>   <code><span class="lgreen">// get second value</span></code>&#13;
<strong><span class="cviolet">59</span></strong>   <code><span class="blue">int</span> Time::getSecond() <span class="blue">const</span> {<span class="blue">return</span> m_second;}</code>&#13;
<strong><span class="cviolet">60</span></strong>&#13;
<strong><span class="cviolet">61</span></strong>   <code><span class="lgreen">// return Time as a string in 24-hour format (HH:MM:SS)</span></code>&#13;
<strong><span class="cviolet">62</span></strong>   <code>string Time::to24HourString() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">63</span></strong>      <code><span class="blue">return</span> fmt::format(<span class="green">"{:02d}:{:02d}:{:02d}"</span>,</code>&#13;
<strong><span class="cviolet">64</span></strong>                <code>getHour(), getMinute(), getSecond());</code>&#13;
<strong><span class="cviolet">65</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">66</span></strong>&#13;
<strong><span class="cviolet">67</span></strong>   <code><span class="lgreen">// return Time as string in 12-hour format (HH:MM:SS AM or PM)</span></code>&#13;
<strong><span class="cviolet">68</span></strong>   <code>string Time::to12HourString() <span class="blue">const</span> {</code>&#13;
<strong><span class="cviolet">69</span></strong>      <code><span class="blue">return</span> fmt::format(<span class="green">"{}:{:02d}:{:02d} {}"</span>,</code>&#13;
<strong><span class="cviolet">70</span></strong>         <code>((getHour() % <span class="green">12</span> == <span class="green">0</span>) ? <span class="green">12</span> : getHour() % <span class="green">12</span>),</code>&#13;
<strong><span class="cviolet">71</span></strong>         <code>getMinute(), getSecond(), (getHour() &lt; <span class="green">12</span> ? <span class="green">"AM"</span> : <span class="green">"PM"</span>));</code>&#13;
<strong><span class="cviolet">72</span></strong>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.31</strong></span> <code>Time</code> class member-function definitions modified to enable cascaded member-function calls.</p>&#13;
</div>&#13;
<div class="group" id="fig9_32">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig32" id="aa09fig32">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_32.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Cascading member-function calls with the this pointer.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"Time.h"</span> <span class="lgreen">// Time class definition</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code>Time t{}; <span class="lgreen">// create Time object</span></code>&#13;
<strong><span class="cviolet">10</span></strong>&#13;
<strong><span class="cviolet">11</span></strong>      <code>t.setHour(<span class="green">18</span>).setMinute(<span class="green">30</span>).setSecond(<span class="green">22</span>); <span class="lgreen">// cascaded function calls</span></code>&#13;
<strong><span class="cviolet">12</span></strong>&#13;
<strong><span class="cviolet">13</span></strong>       <code><span class="lgreen">// output time in 24-hour and 12-hour formats</span></code>&#13;
<strong><span class="cviolet">14</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"24-hour time: {}\n12-hour time: {}\n\n"</span>,</code>&#13;
<strong><span class="cviolet">15</span></strong>                 <code>t.to24HourString(), t.to12HourString());</code>&#13;
<strong><span class="cviolet">16</span></strong>&#13;
<strong><span class="cviolet">17</span></strong>      <code><span class="lgreen">// cascaded function calls</span></code>&#13;
<strong><span class="cviolet">18</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"New 12-hour time: {}\n"</span>,</code>&#13;
<strong><span class="cviolet">19</span></strong>                 <code>t.setTime(20, <span class="green">20</span>, <span class="green">20</span>).to12HourString());</code>&#13;
<strong><span class="cviolet">20</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>24-hour time: 18:30:22</code>&#13;
<code>12-hour time: 6:30:22 PM</code>&#13;
<code>New 12-hour time: 8:20:20 PM</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.32</strong></span> Cascading member-function calls with the <code>this</code> pointer.</p>&#13;
</div>&#13;
<p>Notice the elegant new implementation of member function <code>setTime</code>. Line 17 in <a href="#fig9_31">Fig. 9.31</a>, creates a local <code>Time</code> object called <code>time</code> using <code>setTime</code>’s arguments. While initializing this object, the constructor call will fail and throw an exception if any argument is out of range. Otherwise, <code>setTime</code>’s arguments are all valid, so line 18 assigns the <code>time</code> object’s members to <code>*this</code>—the <code>Time</code> object on which <code>setTime</code> was called.</p>&#13;
<p>In the next program (<a href="#fig9_32">Fig. 9.32</a>), we create <code>Time</code> object <code>t</code> (line 9), then use it in cascaded member-function calls (lines 11 and 19).</p>&#13;
<p>Why does the technique of returning <code>*this</code> as a reference work? The dot operator (<code>.</code>) groups left-to-right, so line 11</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig21" id="aa09unfig21">Click here to view code image</a></p>&#13;
<pre class="pre"><code>t.setHour(<span class="green">18</span>).setMinute(<span class="green">30</span>).setSecond(<span class="green">22</span>);</code></pre>&#13;
<p>first evaluates <code>t.setHour(18)</code>, which returns a reference to (the updated) object <code>t</code> as the value of this function call. The remaining expression is then interpreted as</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig22" id="aa09unfig22">Click here to view code image</a></p>&#13;
<pre class="pre"><code>t.setMinute(<span class="green">30</span>).setSecond(<span class="green">22</span>);</code></pre>&#13;
<p>The <code>t.setMinute(30)</code> call executes and returns a reference to the (further updated) object <code>t</code>. The remaining expression is interpreted as</p>&#13;
<pre class="pre"><code>t.setSecond(<span class="green">22</span>);</code></pre>&#13;
<p>Line 19 (<a href="#fig9_32">Fig. 9.32</a>) also uses cascading. Note that we cannot chain another <code>Time</code> member-function call after <code>to12HourString</code>, because it does not return a reference to a <code>Time</code> object. However, we could chain a call to a <code>string</code> member function, because <code>to12Hour-String</code> returns a <code>string</code>. <a href="ch11.xhtml#ch11">Chapter 11</a> presents several practical examples of using cascaded function calls.</p>&#13;
<h3 class="h3" id="ch09lev1sec20"><span class="violet">9.20</span> <code>static</code> Class Members—Classwide Data and Member Functions</h3>&#13;
<p>There is an important exception to the rule that each object of a class has its own copy of all the class’s data members. In certain cases, all objects of a class should share only one copy of a variable. A <code><strong><span class="violet">static</span></strong></code> <strong><span class="violet">data member</span></strong> is used for these and other reasons. Such a variable represents “classwide” information—that is, data shared by all objects of the class. You can use <code>static</code> data members to save storage when a single copy of the data for all objects of a class will suffice, such as a constant that can be shared by all objects of the class.</p>&#13;
<h5 class="h5" id="ch09lev3sec55">Motivating Classwide Data</h5>&#13;
<p>Let’s further motivate the need for <code>static</code> classwide data with an example. Suppose that we have a video game with <code>Martian</code>s and other space creatures. Each <code>Martian</code> tends to be brave and willing to attack other space creatures when the <code>Martian</code> is aware that at least five <code>Martian</code>s are present. If fewer than five are present, each <code>Martian</code> becomes cowardly. So each <code>Martian</code> needs to know the <code>martianCount</code>. We could endow each object of class <code>Martian</code> with <code>martianCount</code> as a data member. If we do, every <code>Martian</code> will have its own copy of the data member. Every time we create a new <code>Martian</code>, we’d have to update the data member <code>martianCount</code> in all <code>Martian</code> objects. Doing this would require every <code>Martian</code> object to know about all other <code>Martian</code> objects in memory. This wastes space with redundant <code>martianCount</code> copies and wastes time in updating the separate copies. Instead, we declare <code>martianCount</code> to be <code>static</code> to make it classwide data. Every <code>Martian</code> can access <code>martianCount</code> as if it were a data member of the <code>Martian</code>, but only one copy of the <code>static</code> variable <code>martianCount</code> is maintained in the program. This saves space. We havve the <code>Martian</code> constructor increment <code>static</code> variable <code>martianCount</code> and the <code>Martian</code> destructor decrement <code>martianCount</code>. Because there’s only one copy, we do not have to increment or decrement separate copies of <code>martianCount</code> for every <code>Martian</code> object.</p>&#13;
<h5 class="h5" id="ch09lev3sec56">Scope and Initialization of <code>static</code> Data Members</h5>&#13;
<p><span class="size"><small>17</small></span> A class’s <code>static</code> data members have class scope. A <code>static</code> data member must be initialized exactly once. Fundamental-type <code>static</code> data members are initialized by default to <code>0</code>. A <code>static const</code> data member can have an in-class initializer. As of C++17, you also may use in-class initializers for a non-<code>const static</code> data member by preceding its declaration with the <code>inline</code> keyword (as you’ll see momentarily in <a href="#fig9_33">Fig. 9.33</a>). If a <code>static</code> data member is an object of a class that provides a default constructor, the <code>static</code> data member need not be explicitly initialized because its default constructor will be called.</p>&#13;
<div class="group" id="fig9_33">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig33" id="aa09fig33">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.33: Employee.h</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Employee class definition with a static data member to</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="lgreen">// track the number of Employee objects in memory</span></code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#pragma</span> <span class="green">once</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> &lt;string_view&gt;</code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">class</span> Employee {</code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">public</span>:</code>&#13;
<strong><span class="cviolet">10</span></strong>      <code>Employee(std::string_view firstName, std::string_view lastName);</code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>~Employee(); <span class="lgreen">// destructor</span></code>&#13;
<strong><span class="cviolet">12</span></strong>      <code><span class="blue">const</span> std::string&amp; getFirstName() <span class="blue">const</span>; <span class="lgreen">// return first name</span></code>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="blue">const</span> std::string&amp; getLastName() <span class="blue">const</span>; <span class="lgreen">// return last name</span></code>&#13;
<strong><span class="cviolet">14</span></strong>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="lgreen">// static member function</span></code>&#13;
<strong><span class="cviolet">16</span></strong>      <code><span class="blue">static int</span> getCount(); <span class="lgreen">// return # of objects instantiated</span></code>&#13;
<strong><span class="cviolet">17</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">18</span></strong>      <code>std::string m_firstName;</code>&#13;
<strong><span class="cviolet">19</span></strong>      <code>std::string m_lastName;</code>&#13;
<strong><span class="cviolet">20</span></strong>&#13;
<strong><span class="cviolet">21</span></strong>      <code><span class="lgreen">// static data</span></code>&#13;
<strong><span class="cviolet">22</span></strong>      <code><span class="blue">inline static</span> <span class="blue">int</span> m_count{<span class="green">0</span>}; <span class="lgreen">// number of objects instantiated</span></code>&#13;
<strong><span class="cviolet">23</span></strong>   <code>};</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.33</strong></span> <code>Employee</code> class definition with a <code>static</code> data member to track the number of <code>Employee</code> objects in memory.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec57">Accessing <code>static</code> Data Members</h5>&#13;
<p>A class’s <code>static</code> members exist even when no objects of that class exist. To access a <code>public static</code> class data member or member function, simply prefix the class name and the scope resolution operator (<code>::</code>) to the member name. For example, if our <code>martianCount</code> variable is <code>public</code>, it can be accessed with <code>Martian::martianCount</code>, even when there are no <code>Martian</code> objects. (Of course, using <code>public</code> data is discouraged.)</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> A class’s <code>private</code> (and <code>protected</code>; <a href="ch10.xhtml#ch10">Chapter 10</a>) <code>static</code> members are normally accessed through the class’s <code>public</code> member functions or <code>friend</code>s. To access a <code>private static</code> or <code>protected static</code> data member when no objects of the class exist, provide a <code>public <strong><span class="violet">static</span></strong></code> <strong><span class="violet">member function</span></strong> and call the function by prefixing its name with the class name and scope resolution operator. A <code>static</code> member function is a service of the class as a whole, not of a specific object of the class.</p>&#13;
<h5 class="h5" id="ch09lev3sec58">Demonstrating <code>static</code> Data Members</h5>&#13;
<p>This example demonstrates a <code>private inline static</code> data member called <code>m_count</code> (<a href="#fig9_33">Fig. 9.33</a>, line 22), which is initialized to <code>0</code>, and a <code>public static</code> member function called <code>getCount</code> (<a href="#fig9_33">Fig. 9.33</a>, line 16). A <code>static</code> data member also can be initialized at file scope in the class’s implementation file. For instance, we could have placed the following statement in <code>Employee.cpp</code> (<a href="#fig9_34">Fig. 9.34</a>) after the <code>Employee.h</code> header is included:</p>&#13;
<pre class="pre"><code><span class="blue">int</span> Employee::count{<span class="green">0</span>};</code></pre>&#13;
<div class="group" id="fig9_34">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig34" id="aa09fig34">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// Fig. 9.34: Employee.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Employee class member-function definitions.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"Employee.h"</span> <span class="lgreen">// Employee class definition</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="lgreen">// define static member function that returns number of</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="lgreen">// Employee objects instantiated (declared static in Employee.h)</span></code>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="blue">int</span> Employee::getCount() {<span class="blue">return</span> m_count;}</code>&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>   <code><span class="lgreen">// constructor initializes non-static data members and</span></code>&#13;
<strong><span class="cviolet">13</span></strong>   <code><span class="lgreen">// increments static data member count</span></code>&#13;
<strong><span class="cviolet">14</span></strong>   <code>Employee::Employee(string_view firstName, string_view lastName)</code>&#13;
<strong><span class="cviolet">15</span></strong>      <code>: m_firstName(firstName), m_lastName(lastName) {</code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>++m_count; <span class="lgreen">// increment static count of employees</span></code>&#13;
<strong><span class="cviolet">17</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Employee constructor called for {} {}\n"</span>,</code>&#13;
<strong><span class="cviolet">18</span></strong>                 <code>m_firstName, m_lastName);</code>&#13;
<strong><span class="cviolet">19</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">20</span></strong>&#13;
<strong><span class="cviolet">21</span></strong>   <code><span class="lgreen">// destructor decrements the count</span></code>&#13;
<strong><span class="cviolet">22</span></strong>   <code>Employee::~Employee() {</code>&#13;
<strong><span class="cviolet">23</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"~Employee() called for {} {}\n"</span>,</code>&#13;
<strong><span class="cviolet">24</span></strong>                 <code>m_firstName, m_lastName);</code>&#13;
<strong><span class="cviolet">25</span></strong>      <code>--m_count; <span class="lgreen">// decrement static count of employees</span></code>&#13;
<strong><span class="cviolet">26</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">27</span></strong>&#13;
<strong><span class="cviolet">28</span></strong>   <code><span class="lgreen">// return first name of employee</span></code>&#13;
<strong><span class="cviolet">29</span></strong>   <code><span class="blue">const</span> string&amp; Employee::getFirstName() <span class="blue">const</span> {<span class="blue">return</span> m_firstName;}</code>&#13;
<strong><span class="cviolet">30</span></strong>&#13;
<strong><span class="cviolet">31</span></strong>   <code><span class="lgreen">// return last name of employee</span></code>&#13;
<strong><span class="cviolet">32</span></strong>   <code><span class="blue">const</span> string&amp; Employee::getLastName() <span class="blue">const</span> {<span class="blue">return</span> m_lastName;}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.34</strong></span> <code>Employee</code> class member-function definitions.</p>&#13;
</div>&#13;
<p>In <a href="#fig9_34">Fig. 9.34</a>, line 10 defines <code>static</code> member function <code>getCount</code>. Note that line 10 does not include the <code>static</code> keyword, which cannot be applied to a member definition that appears outside the class definition. In this program, data member <code>m_count</code> maintains a count of the number of <code>Employee</code> objects in memory at a given time. When <code>Employee</code> objects exist, member <code>m_count</code> can be referenced through any member function of an <code>Employee</code> object. In <a href="#fig9_34">Fig. 9.34</a>, <code>m_count</code> is referenced by both line 16 in the constructor and line 25 in the destructor.</p>&#13;
<p><a href="#fig9_35">Figure 9.35</a> uses <code>static</code> member function <code>getCount</code> to determine the number of <code>Employee</code> objects in memory at various points in the program. The program calls <code>Employee::getCount()</code>:</p>&#13;
<p class="bull">• before any <code>Employee</code> objects have been created (line 12),</p>&#13;
<p class="bull">• after two <code>Employee</code> objects have been created (line 23) and</p>&#13;
<p class="bull">• after those <code>Employee</code> objects have been destroyed (line 33).</p>&#13;
<div class="group" id="fig9_35">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig35" id="aa09fig35">Click here to view code image</a></p>&#13;
<pre class="pre2"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_35.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// static data member tracking the number of objects of a class.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> <span class="green">"Employee.h"</span> <span class="lgreen">// Employee class definition</span></code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">using namespace</span> std;</code>&#13;
 <strong><span class="cviolet">7</span></strong>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
 <strong><span class="cviolet">9</span></strong>      <code><span class="lgreen">// no objects exist; use class name and scope resolution</span></code>&#13;
<strong><span class="cviolet">10</span></strong>      <code><span class="lgreen">// operator to access static member function getCount</span></code>&#13;
<strong><span class="cviolet">11</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Initial employee count: {}\n"</span>,</code>&#13;
<strong><span class="cviolet">12</span></strong>                 <code>Employee::getCount()); <span class="lgreen">// use class name</span></code>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>      <code><span class="lgreen">// the following scope creates and destroys</span></code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="lgreen">// Employee objects before main terminates</span></code>&#13;
<strong><span class="cviolet">16</span></strong>      <code>{</code>&#13;
<strong><span class="cviolet">17</span></strong>         <code><span class="blue">const</span> Employee e1{<span class="green">"Susan"</span>, <span class="green">"Baker"</span>};</code>&#13;
<strong><span class="cviolet">18</span></strong>         <code><span class="blue">const</span> Employee e2{<span class="green">"Robert"</span>, <span class="green">"Jones"</span>};</code>&#13;
<strong><span class="cviolet">19</span></strong>&#13;
<strong><span class="cviolet">20</span></strong>         <code><span class="lgreen">// two objects exist; call static member function getCount again</span></code>&#13;
<strong><span class="cviolet">21</span></strong>         <code><span class="lgreen">// using the class name and the scope resolution operator</span></code>&#13;
<strong><span class="cviolet">22</span></strong>         <code>cout &lt;&lt; fmt::format(<span class="green">"Employee count after creating objects: {}\n\n"</span>,</code>&#13;
<strong><span class="cviolet">23</span></strong>                    <code>Employee::getCount());</code>&#13;
<strong><span class="cviolet">24</span></strong>&#13;
<strong><span class="cviolet">25</span></strong>         <code>cout &lt;&lt; fmt::format(<span class="green">"Employee 1: {} {}\nEmployee 2: {} {}\n\n"</span>,</code>&#13;
<strong><span class="cviolet">26</span></strong>                    <code>e1.getFirstName(), e1.getLastName(),</code>&#13;
<strong><span class="cviolet">27</span></strong>                    <code>e2.getFirstName(), e2.getLastName());</code>&#13;
<strong><span class="cviolet">28</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">29</span></strong>&#13;
<strong><span class="cviolet">30</span></strong>      <code><span class="lgreen">// no objects exist, so call static member function getCount again</span></code>&#13;
<strong><span class="cviolet">31</span></strong>      <code><span class="lgreen">// using the class name and the scope resolution operator</span></code>&#13;
<strong><span class="cviolet">32</span></strong>      <code>cout &lt;&lt; fmt::format(<span class="green">"Employee count after objects are deleted: {}\n"</span>,</code>&#13;
<strong><span class="cviolet">33</span></strong>                 <code>Employee::getCount());</code>&#13;
<strong><span class="cviolet">34</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Initial employee count: 0</code>&#13;
<code>Employee constructor called for Susan Baker</code>&#13;
<code>Employee constructor called for Robert Jones</code>&#13;
<code>Employee count after creating objects: 2</code>&#13;
&#13;
<code>Employee 1: Susan Baker</code>&#13;
<code>Employee 2: Robert Jones</code>&#13;
<code>~Employee() called for Robert Jones</code>&#13;
<code>~Employee() called for Susan Baker</code>&#13;
<code>Employee count after objects are deleted: 0</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.35</strong></span> <code>static</code> data member tracking the number of objects of a class.</p>&#13;
</div>&#13;
<p>Lines 16–28 in <code>main</code> define a nested scope. Recall that local variables exist until the scope in which they’re defined terminates. In this example, we create two <code>Employee</code> objects in the nested scope (lines 17–18). As each constructor executes, it increments class <code>Employee</code>’s <code>static</code> data member <code>count</code>. These <code>Employee</code> objects are destroyed when the program reaches line 28. At that point, each object’s destructor executes and decrements class <code>Employee</code>’s <code>static</code> data member <code>count</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec59"><code>static</code> Member Function Notes</h5>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> A member function should be declared <code>static</code> if it does not access the class’s non-<code>static</code> data members or non-<code>static</code> member functions. A <code>static</code> member function does not have a <code>this</code> pointer, because <code>static</code> data members and <code>static</code> member functions exist independently of any objects of a class. The <code>this</code> pointer must refer to a specific object, but a <code>static</code> member function can be called when there are no objects of its class in memory. So, using the <code>this</code> pointer in a <code>static</code> member function is a compilation error.</p>&#13;
<p><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> <img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <span class="size"><small>ERR</small></span> A <code>static</code> member function may not be declared <code>const</code>. The <code>const</code> qualifier indicates that a function cannot modify the contents of the object on which it operates, but <code>static</code> member functions exist and operate independently of any objects of the class. So, declaring a <code>static</code> member function <code>const</code> is a compilation error.</p>&#13;
<h3 class="h3" id="ch09lev1sec21"><span class="size"><small>20</small></span> <span class="violet">9.21</span> Aggregates in C++20</h3>&#13;
<p>According to Section 9.4.1 of the C++ standard document</p>&#13;
<pre class="pre"><code>http://wg21.link/n4861</code></pre>&#13;
<p>an <strong><span class="violet">aggregate type</span></strong> is a built-in array, an <code>array</code> object or an object of a class that:</p>&#13;
<p class="bull">• does not have user-declared constructors,</p>&#13;
<p class="bull">• does not have <code>private</code> or <code>protected</code> (<a href="ch10.xhtml#ch10">Chapter 10</a>) non-<code>static</code> data members,</p>&#13;
<p class="bull">• does not have virtual functions (<a href="ch10.xhtml#ch10">Chapter 10</a>) and</p>&#13;
<p class="bull">• does not have <code>virtual</code> (<a href="ch19.xhtml#ch19">Chapter 19</a>), <code>private</code> (<a href="ch10.xhtml#ch10">Chapter 10</a>) or <code>protected</code> (<a href="ch10.xhtml#ch10">Chapter 10</a>) base classes.</p>&#13;
<p><span class="size"><small>20</small></span> The requirement for no user-declared constructors was a C++20 change to the definition of aggregates. It prevents a case in which initializing an aggregate object could circumvent calling a user-declared constructor.<sup><a id="rch09fn28" href="ch09.xhtml#ch09fn28">28</a></sup></p>&#13;
<p class="footnote"><a id="ch09fn28" href="ch09.xhtml#rch09fn28">28</a>. “Prohibit aggregates with user-declared constructors.” Accessed July 12, 2020. <code><a href="http://wg21.link/p1008r1">http://wg21.link/p1008r1</a></code>.</p>&#13;
<p>You can define an aggregate using a class in which all the data is declared <code>public</code>. However, a <code><strong><span class="violet">struct</span></strong></code> is a class that contains only <code>public</code> members by default. The following <code>struct</code> defines an aggregate type named <code>Record</code> containing four <code>public</code> data members:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig23" id="aa09unfig23">Click here to view code image</a></p>&#13;
<pre class="pre"><code><span class="blue">struct</span> Record {</code>&#13;
   <code><span class="blue">int</span> account;</code>&#13;
   <code>string first;</code>&#13;
   <code>string last;</code>&#13;
   <code><span class="blue">double</span> balance;</code>&#13;
<code>};</code></pre>&#13;
<p><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size"><small>CG</small></span> The C++ Core Guidelines recommend using <code>class</code> rather than <code>struct</code> if any data member or member function needs to be non-<code>public</code>.<sup><a id="rch09fn29" href="ch09.xhtml#ch09fn29">29</a></sup></p>&#13;
<p class="footnote"><a id="ch09fn29" href="ch09.xhtml#rch09fn29">29</a>. C++ Core Guidelines. Accessed July 12. 2020. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-class">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-class</a></code>.</p>&#13;
<h4 class="h4" id="ch09lev2sec20">9.21.1 Initializing an Aggregate</h4>&#13;
<p>You can initialize an object of aggregate type <code>Record</code> as follows:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig24" id="aa09unfig24">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Record record{<span class="green">100</span>, <span class="green">"Brian"</span>, <span class="green">"Blue"</span>, <span class="green">123.45</span>};</code></pre>&#13;
<p><span class="size"><small>11</small></span> In C++11, you could not use a list initializer for an aggregate-type object if any of the type’s non-<code>static</code> data-member declarations contained in-class initializers. For example, the initialization above would have generated a compilation error if the aggregate type <code>Record</code> were defined with a default value for <code>balance</code>, as in:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig25" id="aa09unfig25">Click here to view code image</a></p>&#13;
<pre class="pre"><code><span class="blue">struct</span> Record {</code>&#13;
   <code><span class="blue">int</span> account;</code>&#13;
   <code>string first;</code>&#13;
   <code>string last;</code>&#13;
   <code><span class="blue">double</span> balance{<span class="green">0.0</span>};</code>&#13;
<code>};</code></pre>&#13;
<p><span class="size"><small>14</small></span> C++14 removed this restriction. Also, if you initialize an aggregate-type object with fewer initializers than there are data members in the object, as in</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig26" id="aa09unfig26">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Record record{<span class="green">0</span>, <span class="green">"Brian"</span>, <span class="green">"Blue"</span>};</code></pre>&#13;
<p>the remaining data members are initialized as follows:</p>&#13;
<p class="bull">• Data members with in-class initializers use those values—in the preceding case, <code>record</code>’s <code>balance</code> is set to <code>0.0</code>.</p>&#13;
<p class="bull">• Data members without in-class initializers are initialized with empty braces (<code>{}</code>). Empty-brace initialization sets fundamental-type variables to <code>0</code>, sets <code>bool</code>s to <code>false</code> and <strong><span class="violet">value initializes</span></strong> objects—that is, they’re zero initialized, then the default constructor is called for each object.</p>&#13;
<h4 class="h4" id="ch09lev2sec21"><span class="size"><small>20</small></span> 9.21.2 C++20: Designated Initializers</h4>&#13;
<p>As of C++20, aggregates now support <strong><span class="violet">designated initializers</span></strong> in which you can specify which data members to initialize by name. Using the preceding <code>struct Record</code> definition, we could initialize a <code>Record</code> object as follows:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig27" id="aa09unfig27">Click here to view code image</a></p>&#13;
<pre class="pre"><code>Record record{.first{<span class="green">"Sue"</span>}, .last{<span class="green">"Green"</span>}};</code></pre>&#13;
<p>explicitly initializing only a subset of the data members. Each explicitly named data member is preceded by a dot (<code>.</code>), and the identifiers that you specify must be listed in the same order as they’re declared in the aggregate type. The preceding statement initializes the data members <code>first</code> and <code>last</code> to <code>"Sue"</code> and <code>"Green"</code>, respectively. The remaining data members get their default initializer values:</p>&#13;
<p class="bull">• <code>account</code> is set to <code>0</code> and</p>&#13;
<p class="bull">• <code>balance</code> is set to its default value in the type definition—in this case, <code>0.0</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec60">Other Benefits of Designated Initializers<a id="rch09fn30" href="ch09.xhtml#ch09fn30"><sup>30</sup></a></h5>&#13;
<p class="footnote"><a id="ch09fn30" href="ch09.xhtml#rch09fn30">30</a>. “Designated Initialization.” Accessed July 12, 2020. <code><a href="http://wg21.link/p0329r0">http://wg21.link/p0329r0</a></code>.</p>&#13;
<p><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size"><small>SE</small></span> Adding new data members to an aggregate type will not break existing statements that use designated initializers. Any new data members that are not explicitly initialized simply receive their default initialization. Designated initializers also improve compatibility with the C programming language, which has had this feature since C99.</p>&#13;
<h3 class="h3" id="ch09lev1sec22"><span class="violet">9.22</span> Objects Natural Case Study: Serialization with JSON</h3>&#13;
<p>More and more computing today is done “in the cloud”—that is, distributed across the Internet. Many applications you use daily communicate over the Internet with <strong><span class="violet">cloud-based services</span></strong> that use massive clusters of computing resources (computers, processors, memory, disk drives, databases, etc.).</p>&#13;
<p>A service that provides access to itself over the Internet is known as a <strong><span class="violet">web service</span></strong>. Applications typically communicate with web services by sending and receiving JSON objects. <strong><span class="violet">JSON (JavaScript Object Notation)</span></strong> is a text-based, human-and-computer-readable, data-interchange format that represents objects as collections of name–value pairs. JSON has become the preferred data format for transmitting objects across platforms.</p>&#13;
<h5 class="h5" id="ch09lev3sec61">JSON Data Format</h5>&#13;
<p>Each JSON object contains a comma-separated list of property names and values in curly braces. For example, the following name–value pairs might represent a client record:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig28" id="aa09unfig28">Click here to view code image</a></p>&#13;
<pre class="pre"><code>{"account": 100, "name": "Jones", "balance": 24.98}</code></pre>&#13;
<p>JSON also supports arrays as comma-separated values in square brackets. For example, the following represents a JSON array of numbers:</p>&#13;
<pre class="pre"><code>[100, 200, 300]</code></pre>&#13;
<p>Values in JSON objects and arrays can be:</p>&#13;
<p class="bull">• strings in double-quotes (like <code>"Jones"</code>),</p>&#13;
<p class="bull">• numbers (like <code>100</code> or <code>24.98</code>),</p>&#13;
<p class="bull">• JSON Boolean values (represented as <code>true</code> or <code>false</code>),</p>&#13;
<p class="bull">• <code>null</code> (to represent no value),</p>&#13;
<p class="bull">• arrays of any valid JSON value, and</p>&#13;
<p class="bull">• other JSON objects.</p>&#13;
<p>JSON arrays may contain elements of the same or different types.</p>&#13;
<h5 class="h5" id="ch09lev3sec62">Serialization</h5>&#13;
<p>Converting an object into another format for storage or transmission over the Internet is known as <strong><span class="violet">serialization</span></strong>. Similarly, reconstructing an object from serialized data is known as <strong><span class="violet">deserialization</span></strong>. JSON is just one of several serialization formats. Other common formats include binary data and XML (eXtensible Markup Language).</p>&#13;
<h5 class="h5" id="ch09lev3sec63"><img class="inline" src="Images/sec.jpg" alt="Images" width="28" height="31"/> <span class="size"><small>SEC</small></span> Serialization Security</h5>&#13;
<p>Some programming languages have their own serialization mechanisms that use a language-native format. Deserializing objects using these native serialization formats is a source of various security issues. According to the Open Web Application Security Project (OWASP), these native mechanisms “can be repurposed for malicious effect when operating on untrusted data. Attacks against deserializers have been found to allow denial-of-service, access control, and remote code execution (RCE) attacks.”<sup><a id="rch09fn31" href="ch09.xhtml#ch09fn31">31</a></sup> OWASP also indicates that you can significantly reduce attack risk by avoiding language-native serialization formats in favor of “pure data” formats like JSON or XML.</p>&#13;
<p class="footnote"><a id="ch09fn31" href="ch09.xhtml#rch09fn31">31</a>. “Deserialization Cheat Sheet.” OWASP Cheat Sheet Series. <code>Accessed July 18, 2020. <a href="https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html</a></code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec64"><code>cereal</code> Header-Only Serialization Library</h5>&#13;
<p>The <code><strong><span class="violet">cereal</span></strong></code> <strong><span class="violet">header-only library</span></strong><sup><a id="rch09fn32" href="ch09.xhtml#ch09fn32">32</a></sup> serializes objects to and deserializes objects from JSON (which we’ll demonstrate), XML or binary formats. The library supports fundamental types and can handle most standard library types if you include each type’s appropriate <code>cereal</code> header. As you’ll see in the next section, <code>cereal</code> also supports custom types. The <code>cereal</code> documentation is available at:</p>&#13;
<p class="footnote"><a id="ch09fn32" href="ch09.xhtml#rch09fn32">32</a>. Copyright (c) 2017, Grant, W. Shane and Voorhies, Randolph. <code>cereal</code>—A C++11 library for serialization. URL: <code><a href="http://uscilab.github.io/cereal/">http://uscilab.github.io/cereal/</a></code>. All rights reserved.</p>&#13;
<pre class="pre"><code>https://uscilab.github.io/cereal/index.html</code></pre>&#13;
<p>We’ve included the cereal library for your convenience in the <code>libraries</code> folder with the book’s examples. You must point your IDE or compiler at the library’s <code>include</code> folder, as you’ve done in several earlier Objects Natural case studies.</p>&#13;
<h4 class="h4" id="ch09lev2sec22">9.22.1 Serializing a <code>vector</code> of Objects containing <code>public</code> Data</h4>&#13;
<p>Let’s begin by serializing objects containing only <code>public</code> data. In <a href="#fig9_36">Fig. 9.36</a>, we:</p>&#13;
<p class="bull">• create a <code>vector</code> of <code>Record</code> objects and display its contents,</p>&#13;
<p class="bull">• use <code>cereal</code> to serialize it to a text file, then</p>&#13;
<p class="bull">• deserialize the file’s contents into a <code>vector</code> of <code>Record</code> objects and display the deserialized <code>Record</code>s.</p>&#13;
<div class="group" id="fig9_36">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig36" id="aa09fig36">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_36.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Serializing and deserializing objects with the cereal library.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fstream&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;vector&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">#include</span> &lt;cereal/archives/json.hpp&gt;</code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">#include</span> &lt;cereal/types/vector.hpp&gt;</code>&#13;
 <strong><span class="cviolet">9</span></strong>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="blue">using</span> namespace std;</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.36</strong></span> Serializing and deserializing objects with the <code>cereal</code> library.</p>&#13;
</div>&#13;
<p>To perform JSON serialization, include the <code>cereal</code> header <code>json.hpp</code> (line 7). To serialize a <code>std::vector</code>, include the <code>cereal</code> header <code>vector.hpp</code> (line 8).</p>&#13;
<h5 class="h5" id="ch09lev3sec65">Aggregate Type <code>Record</code></h5>&#13;
<p><code>Record</code> is an aggregate type defined as a <code>struct</code>. Recall that an aggregate’s data must be <code>public</code>, which is the default for a <code>struct</code> definition:</p>&#13;
<div class="group" id="fig9_37">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig37" id="aa09fig37">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>   <code><span class="blue">struct</span> Record {</code>&#13;
<strong><span class="cviolet">13</span></strong>      <code><span class="blue">int</span> account{};</code>&#13;
<strong><span class="cviolet">14</span></strong>      <code>string first{};</code>&#13;
<strong><span class="cviolet">15</span></strong>      <code>string last{};</code>&#13;
<strong><span class="cviolet">16</span></strong>      <code><span class="blue">double</span> balance{};</code>&#13;
<strong><span class="cviolet">17</span></strong>   <code>};</code>&#13;
<strong><span class="cviolet">18</span></strong></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.37</strong></span></p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec66">Function <code>serialize</code> for <code>Record</code> Objects</h5>&#13;
<p>The <code>cereal</code> library allows you to designate how to perform serialization several ways. If the types you wish to serialize have all <code>public</code> data, you can simply define a function template <code>serialize</code> (lines 21–27) that receives an <code>Archive</code> as its first parameter and an object of your type as the second.<sup><a id="rch09fn33" href="ch09.xhtml#ch09fn33">33</a></sup> This function is called both for serializing and deserializing the <code>Record</code> objects. Using a function template enables you to choose among serialization and deserialization using JSON, XML or binary formats by passing an object of the appropriate <code>cereal</code> archive type. The library provides archive implementations for each case.</p>&#13;
<p class="footnote"><a id="ch09fn33" href="ch09.xhtml#rch09fn33">33</a>. Function <code>serialize</code> also may be defined as a member function template with only an <code>Archive</code> parameter. For details, see <code><a href="https://uscilab.github.io/cereal/serialization_functions.html">https://uscilab.github.io/cereal/serialization_functions.html</a></code>.</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig29" id="aa09unfig29">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">19</span></strong>   <code><span class="lgreen">// function template serialize is responsible for serializing and</span></code>&#13;
<strong><span class="cviolet">20</span></strong>   <code><span class="lgreen">// deserializing Record objects to/from the specified Archive</span></code>&#13;
<strong><span class="cviolet">21</span></strong>   <code><span class="blue">template</span> &lt;<span class="blue">typename</span> Archive&gt;</code>&#13;
<strong><span class="cviolet">22</span></strong>   <code><span class="blue">void</span> serialize(Archive&amp; archive, Record&amp; record) {</code>&#13;
<strong><span class="cviolet">23</span></strong>      <code>archive(cereal::make_nvp(<span class="green">"account"</span>, record.account),</code>&#13;
<strong><span class="cviolet">24</span></strong>         <code>cereal::make_nvp(<span class="green">"first"</span>, record.first),</code>&#13;
<strong><span class="cviolet">25</span></strong>         <code>cereal::make_nvp(<span class="green">"last"</span>, record.last),</code>&#13;
<strong><span class="cviolet">26</span></strong>         <code>cereal::make_nvp(<span class="green">"balance"</span>, record.balance));</code>&#13;
<strong><span class="cviolet">27</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">28</span></strong></pre>&#13;
<p>Each <code>cereal</code> archive type has an overloaded parentheses operator that enables you to use parameter archive objects as function names, as shown with parameter <code>archive</code> in lines 23–26. Depending on whether you’re serializing or deserializing a <code>Record</code>, this function will either:</p>&#13;
<p class="bull">• output the contents of the <code>Record</code> to a specified stream or</p>&#13;
<p class="bull">• input previously serialized data from a specified stream and create a <code>Record</code> object.</p>&#13;
<p>Each call to <code>cereal::make_nvp</code> (that is, “make name–value pair”), like line 23</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig30" id="aa09unfig30">Click here to view code image</a></p>&#13;
<pre class="pre"><code>cereal::make_nvp(<span class="green">"account"</span>, record.account)</code></pre>&#13;
<p>is primarily for the serialization step. It makes a name–value pair with the name in the first argument (in this case, <code>"account"</code>) and the value in the second argument (in this case, the <code>int</code> value <code>record.account</code>). Naming the values is not required but makes the JSON output more readable as you’ll soon see. Otherwise, cereal uses names like <code>value0</code>, <code>value1</code>, etc.</p>&#13;
<h5 class="h5" id="ch09lev3sec67">Function <code>displayRecords</code></h5>&#13;
<p>We provide function <code>displayRecords</code> to show you the contents of our <code>Record</code> objects before serialization and after deserialization. The function simply displays the contents of each <code>Record</code> in the <code>vector</code> it receives as an argument:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig31" id="aa09unfig31">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">29</span></strong>   <code><span class="lgreen">// display record at command line</span></code>&#13;
<strong><span class="cviolet">30</span></strong>   <code><span class="blue">void</span> displayRecords(<span class="blue">const</span> vector&lt;Record&gt;&amp; records) {</code>&#13;
<strong><span class="cviolet">31</span></strong>      <code><span class="blue">for</span> (<span class="blue">const auto</span>&amp; r : records) {</code>&#13;
<strong><span class="cviolet">32</span></strong>         <code>cout &lt;&lt; fmt::format("{} <span class="green">{} {} {:.2f}\n",</span></code>&#13;
<strong><span class="cviolet">33</span></strong>                    <code>r.account, r.first, r.last, r.balance);</code>&#13;
<strong><span class="cviolet">34</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">35</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">36</span></strong></pre>&#13;
<h5 class="h5" id="ch09lev3sec68">Creating <code>Record</code> Objects to Serialize</h5>&#13;
<p>Lines 38–41 in <code>main</code> create a <code>vector</code> and initialize it with two <code>Record</code>s (lines 39 and 40). The compiler determines the <code>vector</code>’s <code>Record</code> element type from the initializers. Line 44 outputs the <code>vector</code>’s contents to confirm that the two <code>Record</code>s were initialized properly:</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig32" id="aa09unfig32">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">37</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">38</span></strong>      <code>vector records{</code>&#13;
<strong><span class="cviolet">39</span></strong>         <code>Record{<span class="green">100</span>, <span class="green">"Brian"</span>, <span class="green">"Blue"</span>, <span class="green">123.45</span>},</code>&#13;
<strong><span class="cviolet">40</span></strong>         <code>Record{<span class="green">200</span>, <span class="green">"Sue"</span>, <span class="green">"Green"</span>, <span class="green">987.65</span>}</code>&#13;
<strong><span class="cviolet">41</span></strong>      <code>};</code>&#13;
<strong><span class="cviolet">42</span></strong>&#13;
<strong><span class="cviolet">43</span></strong>      <code>cout &lt;&lt; <span class="green">"Records to serialize:\n"</span>;</code>&#13;
<strong><span class="cviolet">44</span></strong>      <code>displayRecords(records);</code>&#13;
<strong><span class="cviolet">45</span></strong></pre>&#13;
<pre class="pre1"><code>Records to serialize:</code>&#13;
<code>100 Brian Blue 123.45</code>&#13;
<code>200 Sue Green 987.65</code></pre>&#13;
<h5 class="h5" id="ch09lev3sec69">Serializing <code>Record</code> Objects with <code>cereal::JSONOutputArchive</code></h5>&#13;
<p>A <code><strong><span class="violet">cereal::JSONOutputArchive</span></strong></code> serializes data in JSON format to a specified stream, such as the standard output stream or a stream representing a file. Line 47 attempts to open the file <code>records.json</code> for writing. If successful, line 48 creates a <code>cereal::JSONOutputArchive</code> object named <code>archive</code> and initializes it with the <code>output ofstream</code> object so <code>archive</code> can write the JSON data into a file. Line 49 uses the <code>archive</code> object to output a name–value pair with the name <code>"records"</code> and the <code>vector</code> of <code>Record</code>s as its value. Part of serializing the <code>vector</code> is serializing each of its elements. So line 49 also results in one call to <code>serialize</code> (lines 21–27) for each <code>Record</code> object in the <code>vector</code>.</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig33" id="aa09unfig33">Click here to view code image</a></p>&#13;
<pre class="pre3"><strong><span class="cviolet">46</span></strong>      <code><span class="lgreen">// serialize vector of Records to JSON and store in text file</span></code>&#13;
<strong><span class="cviolet">47</span></strong>      <code><span class="blue">if</span> (ofstream output{<span class="green">"records.json"</span>}) {</code>&#13;
<strong><span class="cviolet">48</span></strong>         <code>cereal::JSONOutputArchive archive{output};</code>&#13;
<strong><span class="cviolet">49</span></strong>         <code>archive(cereal::make_nvp(<span class="green">"records"</span>, records)); <span class="lgreen">// serialize records</span></code>&#13;
<strong><span class="cviolet">50</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">51</span></strong></pre>&#13;
<h5 class="h5" id="ch09lev3sec70">Contents of <code>records.json</code></h5>&#13;
<p>After line 49 executes, the file <code>records.json</code> contains the following JSON data:</p>&#13;
<div class="group">&#13;
<div class="images-p"><img src="Images/09unfig34.jpg" alt="Images" width="416" height="328"/></div>&#13;
</div>&#13;
<p>The outer braces represent the entire JSON document. The darker box highlights the document’s one name–value pair named <code>"records"</code>, which has as its value a JSON array containing the two JSON objects in the lighter boxes. The JSON array represents the <code>vector records</code> that we serialized in line 49. Each of the JSON objects in the array contains one <code>Record</code>’s four name–value pairs that were serialized by the <code>serialize</code> function.</p>&#13;
<h5 class="h5" id="ch09lev3sec71">Deserializing <code>Record</code> Objects with <code>cereal::JSONInputArchive</code></h5>&#13;
<p>Next, let’s deserialize the data and use it to fill a separate <code>vector</code> of <code>Record</code> objects. For <code>cereal</code> to recreate objects in memory, it must have access to each type’s default constructor. It will use that to create an object, then directly access that object’s data members to place the data into the object. Like classes, the compiler provides a <code>public</code> default constructor for <code>struct</code>s if you do not define a custom constructor.</p>&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09unfig35" id="aa09unfig35">Click here to view code image</a></p>&#13;
<pre class="pre2"><strong><span class="cviolet">52</span></strong>      <code><span class="lgreen">// deserialize JSON from text file into vector of Records</span></code>&#13;
<strong><span class="cviolet">53</span></strong>      <code><span class="blue">if</span> (ifstream input{<span class="green">"records.json"</span>}) {</code>&#13;
<strong><span class="cviolet">54</span></strong>         <code>cereal::JSONInputArchive archive{input};</code>&#13;
<strong><span class="cviolet">55</span></strong>         <code>vector&lt;Record&gt; deserializedRecords{};</code>&#13;
<strong><span class="cviolet">56</span></strong>         <code>archive(deserializedRecords); <span class="lgreen">// deserialize records</span></code>&#13;
<strong><span class="cviolet">57</span></strong>         <code>cout &lt;&lt; <span class="green">"\nDeserialized records:\n"</span>;</code>&#13;
<strong><span class="cviolet">58</span></strong>         <code>displayRecords(deserializedRecords);</code>&#13;
<strong><span class="cviolet">59</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">60</span></strong>   <code>}</code></pre>&#13;
<pre class="pre1"><code>Deserialized records:</code>&#13;
<code>100 Brian Blue 123.45</code>&#13;
<code>200 Sue Green 987.65</code></pre>&#13;
<p>A <code><strong><span class="violet">cereal::JSONInputArchive</span></strong></code> deserializes data in JSON format from a specified stream, such as the standard input stream or a stream representing a file. Line 53 attempts to open the file <code>records.json</code> for reading. If successful, line 54 creates the object <code>archive</code> of type <code>cereal::JSONInputArchive</code> and initializes it with the <code>input ifstream</code> object so <code>archive</code> can read JSON data from the <code>records.json</code> file. Line 55 creates an empty <code>vector</code> of <code>Record</code>s into which we’ll read the JSON data. Line 56 uses the <code>archive</code> object to deserialize the file’s data into the <code>deserializedRecords</code> object. Part of deserializing the <code>vector</code> is deserializing its elements. This again results in calls to <code>serialize</code> (lines 21–27), but because <code>archive</code> is a <code>cereal::JSONInputArchive</code>, each call to <code>serialize</code> reads one <code>Record</code>’s JSON data, creates a <code>Record</code> object then inserts the data into it.</p>&#13;
<h4 class="h4" id="ch09lev2sec23">9.22.2 Serializing a <code>vector</code> of Objects containing <code>private</code> Data</h4>&#13;
<p>It is also possible to serialize objects containing <code>private</code> data. To do so, you must declare the <code>serialize</code> function as a <code>friend</code> of the class, so it can access the class’s <code>private</code> data. To demonstrate serializing <code>private</code> data, we created a copy of <a href="#fig9_36">Fig. 9.36</a> and replaced the aggregate <code>Record</code> definition with the class <code>Record</code> definition (lines 14–37) in <a href="#fig9_38">Fig. 9.38</a>.</p>&#13;
<div class="group" id="fig9_38">&#13;
<p class="codelink"><a href="Images/ch09_images.xhtml#a09fig38" id="aa09fig38">Click here to view code image</a></p>&#13;
<pre class="pre3"> <strong><span class="cviolet">1</span></strong>   <code><span class="lgreen">// fig09_37.cpp</span></code>&#13;
 <strong><span class="cviolet">2</span></strong>   <code><span class="lgreen">// Serializing and deserializing objects containing private data.</span></code>&#13;
 <strong><span class="cviolet">3</span></strong>   <code><span class="blue">#include</span> &lt;iostream&gt;</code>&#13;
 <strong><span class="cviolet">4</span></strong>   <code><span class="blue">#include</span> &lt;fstream&gt;</code>&#13;
 <strong><span class="cviolet">5</span></strong>   <code><span class="blue">#include</span> &lt;string&gt;</code>&#13;
 <strong><span class="cviolet">6</span></strong>   <code><span class="blue">#include</span> &lt;string_view&gt;</code>&#13;
 <strong><span class="cviolet">7</span></strong>   <code><span class="blue">#include</span> &lt;vector&gt;</code>&#13;
 <strong><span class="cviolet">8</span></strong>   <code><span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// In C++20, this will be #include &lt;format&gt;</span></code>&#13;
 <strong><span class="cviolet">9</span></strong>   <code><span class="blue">#include</span> &lt;cereal/archives/json.hpp&gt;</code>&#13;
<strong><span class="cviolet">10</span></strong>   <code><span class="blue">#include</span> &lt;cereal/types/vector.hpp&gt;</code>&#13;
<strong><span class="cviolet">11</span></strong>&#13;
<strong><span class="cviolet">12</span></strong>   <code><span class="blue">using</span> namespace std;</code>&#13;
<strong><span class="cviolet">13</span></strong>&#13;
<strong><span class="cviolet">14</span></strong>   <code><span class="blue">class</span> Record {</code>&#13;
<strong><span class="cviolet">15</span></strong>      <code><span class="lgreen">// declare serialize as a friend for direct access to private data</span></code>&#13;
<strong><span class="cviolet">16</span></strong>      <code><span class="blue">template</span>&lt;<span class="blue">typename</span> Archive&gt;</code>&#13;
<strong><span class="cviolet">17</span></strong>      <code><span class="blue">friend void</span> serialize(Archive&amp; archive, Record&amp; record);</code>&#13;
<strong><span class="cviolet">18</span></strong>&#13;
<strong><span class="cviolet">19</span></strong>   <code><span class="blue">public</span>:</code>&#13;
<strong><span class="cviolet">20</span></strong>      <code><span class="lgreen">// constructor</span></code>&#13;
<strong><span class="cviolet">21</span></strong>      <code><span class="blue">explicit</span> Record(<span class="blue">int</span> account = <span class="green">0</span>, string_view first = <span class="green">""</span>,</code>&#13;
<strong><span class="cviolet">22</span></strong>         <code>string_view last = <span class="green">""</span>, <span class="blue">double</span> balance = <span class="green">0.0</span>)</code>&#13;
<strong><span class="cviolet">23</span></strong>         <code>: m_account{account}, m_first{first},</code>&#13;
<strong><span class="cviolet">24</span></strong>           <code>m_last{last}, m_balance{balance} {}</code>&#13;
<strong><span class="cviolet">25</span></strong>&#13;
<strong><span class="cviolet">26</span></strong>      <code><span class="lgreen">// get member functions</span></code>&#13;
<strong><span class="cviolet">27</span></strong>      <code><span class="blue">int</span> getAccount() <span class="blue">const</span> {<span class="blue">return</span> m_account;}</code>&#13;
<strong><span class="cviolet">28</span></strong>      <code><span class="blue">const</span> string&amp; getFirst() <span class="blue">const</span> {<span class="blue">return</span> m_first;}</code>&#13;
<strong><span class="cviolet">29</span></strong>      <code><span class="blue">const</span> string&amp; getLast() <span class="blue">const</span> {<span class="blue">return</span> m_last;}</code>&#13;
<strong><span class="cviolet">30</span></strong>      <code><span class="blue">double</span> getBalance() <span class="blue">const</span> {<span class="blue">return</span> m_balance;}</code>&#13;
<strong><span class="cviolet">31</span></strong>&#13;
<strong><span class="cviolet">32</span></strong>   <code><span class="blue">private</span>:</code>&#13;
<strong><span class="cviolet">33</span></strong>      <code><span class="blue">int</span> m_account{};</code>&#13;
<strong><span class="cviolet">34</span></strong>      <code>string m_first{};</code>&#13;
<strong><span class="cviolet">35</span></strong>      <code>string m_last{};</code>&#13;
<strong><span class="cviolet">36</span></strong>      <code><span class="blue">double</span> m_balance{};</code>&#13;
<strong><span class="cviolet">37</span></strong>   <code>};</code>&#13;
<strong><span class="cviolet">38</span></strong>&#13;
<strong><span class="cviolet">39</span></strong>   <code><span class="lgreen">// function template serialize is responsible for serializing and</span></code>&#13;
<strong><span class="cviolet">40</span></strong>   <code><span class="lgreen">// deserializing Record objects to/from the specified Archive</span></code>&#13;
<strong><span class="cviolet">41</span></strong>   <code><span class="blue">template</span> &lt;<span class="blue">typename</span> Archive&gt;</code>&#13;
<strong><span class="cviolet">42</span></strong>   <code><span class="blue">void</span> serialize(Archive&amp; archive, Record&amp; record) {</code>&#13;
<strong><span class="cviolet">43</span></strong>      <code>archive(cereal::make_nvp(<span class="green">"account"</span>, record.m_account),</code>&#13;
<strong><span class="cviolet">44</span></strong>         <code>cereal::make_nvp(<span class="green">"first"</span>, record.m_first),</code>&#13;
<strong><span class="cviolet">45</span></strong>         <code>cereal::make_nvp(<span class="green">"last"</span>, record.m_last),</code>&#13;
<strong><span class="cviolet">46</span></strong>         <code>cereal::make_nvp(<span class="green">"balance"</span>, record.m_balance));</code>&#13;
<strong><span class="cviolet">47</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">48</span></strong>&#13;
<strong><span class="cviolet">49</span></strong>   <code><span class="lgreen">// display record at command line</span></code>&#13;
<strong><span class="cviolet">50</span></strong>   <code><span class="blue">void</span> displayRecords(<span class="blue">const</span> vector&lt;Record&gt;&amp; records) {</code>&#13;
<strong><span class="cviolet">51</span></strong>      <code><span class="blue">for</span> (<span class="blue">auto</span>&amp; r : records) {</code>&#13;
<strong><span class="cviolet">52</span></strong>         <code>cout &lt;&lt; fmt::format("{} <span class="green">{} {} {:.2f}\n", r</span>.getAccount(),</code>&#13;
<strong><span class="cviolet">53</span></strong>                    <code>r.getFirst(), r.getLast(), r.getBalance());</code>&#13;
<strong><span class="cviolet">54</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">55</span></strong>   <code>}</code>&#13;
<strong><span class="cviolet">56</span></strong>&#13;
<strong><span class="cviolet">57</span></strong>   <code><span class="blue">int</span> main() {</code>&#13;
<strong><span class="cviolet">58</span></strong>      <code>vector records{</code>&#13;
<strong><span class="cviolet">59</span></strong>         <code>Record{<span class="green">100</span>, <span class="green">"Brian"</span>, <span class="green">"Blue"</span>, <span class="green">123.45</span>},</code>&#13;
<strong><span class="cviolet">60</span></strong>         <code>Record{<span class="green">200</span>, <span class="green">"Sue"</span>, <span class="green">"Green"</span>, <span class="green">987.65</span>}</code>&#13;
<strong><span class="cviolet">61</span></strong>      <code>};</code>&#13;
<strong><span class="cviolet">62</span></strong>&#13;
<strong><span class="cviolet">63</span></strong>      <code>cout &lt;&lt; <span class="green">"Records to serialize:\n"</span>;</code>&#13;
<strong><span class="cviolet">64</span></strong>      <code>displayRecords(records);</code>&#13;
<strong><span class="cviolet">65</span></strong>&#13;
<strong><span class="cviolet">66</span></strong>      <code><span class="lgreen">// serialize vector of Records to JSON and store in text file</span></code>&#13;
<strong><span class="cviolet">67</span></strong>      <code><span class="blue">if</span> (ofstream output{<span class="green">"records2.json"</span>}) {</code>&#13;
<strong><span class="cviolet">68</span></strong>         <code>cereal::JSONOutputArchive archive{output};</code>&#13;
<strong><span class="cviolet">69</span></strong>         <code>archive(cereal::make_nvp(<span class="green">"records"</span>, records)); <span class="lgreen">// serialize records</span></code>&#13;
<strong><span class="cviolet">70</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">71</span></strong>&#13;
<strong><span class="cviolet">72</span></strong>      <code><span class="lgreen">// deserialize JSON from text file into vector of Records</span></code>&#13;
<strong><span class="cviolet">73</span></strong>      <code><span class="blue">if</span> (ifstream input{<span class="green">"records2.json"</span>}) {</code>&#13;
<strong><span class="cviolet">74</span></strong>         <code>cereal::JSONInputArchive archive{input};</code>&#13;
<strong><span class="cviolet">75</span></strong>         <code>vector&lt;Record&gt; deserializedRecords{};</code>&#13;
<strong><span class="cviolet">76</span></strong>         <code>archive(deserializedRecords); <span class="lgreen">// deserialize records</span></code>&#13;
<strong><span class="cviolet">77</span></strong>         <code>cout &lt;&lt; <span class="green">"\nDeserialized records:\n"</span>;</code>&#13;
<strong><span class="cviolet">78</span></strong>         <code>displayRecords(deserializedRecords);</code>&#13;
<strong><span class="cviolet">79</span></strong>      <code>}</code>&#13;
<strong><span class="cviolet">80</span></strong>   <code>}</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 9.38</strong></span> Serializing and deserializing objects containing <code>private</code> data.</p>&#13;
</div>&#13;
<p>This <code>Record</code> class provides a constructor (21–24), <em>get</em> member functions (lines 27–30) and <code>private</code> data (lines 33–36). There are two key items to note about this class:</p>&#13;
<p class="bull">• Lines 16–17 declare the function template <code>serialize</code> as a <code>friend</code> of this class. This enables <code>serialize</code> to access directly the data members <code>account</code>, <code>first</code>, <code>last</code> and <code>balance</code>.</p>&#13;
<p class="bull">• The constructor’s parameters all have default arguments, which allows <code>cereal</code> to use this as the default constructor when deserializing <code>Record</code> objects.</p>&#13;
<p>The <code>serialize</code> function (lines 41–46) now accesses class <code>Record</code>’s <code>private</code> data members, and the <code>displayRecords</code> function (lines 50–55) now uses each <code>Record</code>’s <em>get</em> functions to access the data to display. The <code>main</code> function is identical to section <a href="#ch09lev2sec22">Section 9.22.1</a> and produces the same results, so we do not show the output here.</p>&#13;
<h3 class="h3" id="ch09lev1sec23"><span class="violet">9.23</span> Wrap-Up</h3>&#13;
<p>In this chapter, you created your own classes, created objects of those classes and called member functions of those objects to perform useful actions. You declared data members of a class to maintain data for each object of the class, and you defined member functions to operate on that data. You also learned how to use a class’s constructor to specify the initial values for an object’s data members.</p>&#13;
<p>We used a <code>Time</code> class case study to introduce various additional features. We showed how to engineer a class to separate its interface from its implementation. You used the arrow operator to access an object’s members via a pointer to an object. You saw that member functions have class scope—the member function’s name is known only to the class’s other member functions unless referred to by a client of the class via an object name, a reference to an object of the class, a pointer to an object of the class or the scope resolution operator. We also discussed access functions (commonly used to retrieve the values of data members or to test whether a condition is <em>true</em> or <em>false</em>), and utility functions (<code>private</code> member functions that support the operation of the class’s <code>public</code> member functions).</p>&#13;
<p>You saw that a constructor can specify default arguments that enable it to be called multiple ways. You also saw that any constructor that can be called with no arguments is a default constructor and that there can be at most one default constructor per class. We demonstrated how to share code among constructors with delegating constructors. We discussed destructors for performing termination housekeeping on an object before that object is destroyed, and demonstrated the order in which an object’s constructors and destructors are called.</p>&#13;
<p>We showed the problems that can occur when a member function returns a reference or a pointer to a <code>private</code> data member, which breaks the class’s encapsulation. We also showed that objects of the same type can be assigned to one another using the default assignment operator.</p>&#13;
<p>You learned how to specify <code>const</code> objects and <code>const</code> member functions to prevent modifications to objects, thus enforcing the principle of least privilege. You also learned that, through composition, a class can have objects of other classes as members. We demonstrated how to declare and use <code>friend</code> functions.</p>&#13;
<p>You saw that the <code>this</code> pointer is passed as an implicit argument to each of a class’s non-<code>static</code> member functions, allowing them to access the correct object’s data members and other non-<code>static</code> member functions. We used the <code>this</code> pointer explicitly to access the class’s members and to enable cascaded member-function calls. We motivated the notion of <code>static</code> data members and member functions and demonstrated how to declare and use them.</p>&#13;
<p>We introduced aggregate types and C++20’s designated initializers for aggregates. Finally, we presented our next “objects natural” case study on serializing objects with JSON (JavaScript Object Notation) using the <code>cereal</code> library.</p>&#13;
<p>In the next chapter, we continue our discussion of classes by introducing inheritance. We’ll see classes that share common attributes and behavior can inherit them from a common “base” class. Then, we build on our discussion of inheritance by introducing polymorphism. This object-oriented concept enables us to write programs that handle, in a more general manner, objects of classes related by inheritance.</p>&#13;
</div></body>
</html>