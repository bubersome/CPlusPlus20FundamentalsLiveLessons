<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><h2 class="h2" id="ch13">Chapter 13. Standard Library Containers and Iterators</h2>&#13;
<div class="image"><img src="Images/common.jpg" alt="Images" width="370" height="476"/></div>&#13;
<div class="objective">&#13;
<p class="objt">Objectives</p>&#13;
<p class="objp">In this chapter, you’ll:</p>&#13;
<p class="squ"><span class="red">■</span> Be introduced to the standard library containers, iterators and algorithms—a world of reusable software capabilities.</p>&#13;
<p class="squ"><span class="red">■</span> Understand how containers relate to C++20 ranges.</p>&#13;
<p class="squ"><span class="red">■</span> Use I/O stream iterators to read values from the standard input stream and write values to the standard output stream.</p>&#13;
<p class="squ"><span class="red">■</span> Use iterators to access container elements.</p>&#13;
<p class="squ"><span class="red">■</span> Use the <code>vector</code>, <code>list</code> and <code>deque</code> sequence containers.</p>&#13;
<p class="squ"><span class="red">■</span> Use <code>ostream_iterator</code>s with the <code>std::copy</code> and <code>std::ranges::copy</code> algorithms to output container elements.</p>&#13;
<p class="squ"><span class="red">■</span> Use the <code>set</code>, <code>multiset</code>, <code>map</code> and <code>multimap</code> ordered associative containers.</p>&#13;
<p class="squ"><span class="red">■</span> Understand the differences between the ordered and unordered associative containers.</p>&#13;
<p class="squ"><span class="red">■</span> Use the <code>stack</code>, <code>queue</code> and <code>priority_queue</code> container adaptors.</p>&#13;
<p class="squ"><span class="red">■</span> Understand how to use the <code>bitset</code> “near container” to manipulate a collection of bit flags.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="toct">Outline</p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_1"><span class="violet"><strong>13.1</strong></span> Introduction</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_2"><span class="violet"><strong>13.2</strong></span> Introduction to Containers</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_2_1">13.2.1 Common Nested Types in Sequence and Associative Containers</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_2_2">13.2.2 Common Container Member and Non-Member Functions</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_2_3">13.2.3 Requirements for Container Elements</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_3"><span class="violet"><strong>13.3</strong></span> Working with Iterators</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_3_1">13.3.1 Using <code>istream_iterator</code> for Input and <code>ostream_iterator</code> for Output</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_3_2">13.3.2 Iterator Categories</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_3_3">13.3.3 Container Support for Iterators</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_3_4">13.3.4 Predefined Iterator Type Names</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_4"><span class="violet"><strong>13.4</strong></span> A Brief Introduction to Algorithms</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_5"><span class="violet"><strong>13.5</strong></span> Sequence Containers</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_6"><span class="violet"><strong>13.6</strong></span> <code>vector</code> Sequence Container</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_6_1">13.6.1 Using <code>vector</code>s and Iterators</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_6_2">13.6.2  <code>vector</code> Element-Manipulation Functions</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_7"><span class="violet"><strong>13.7</strong></span> <code>list</code> Sequence Container</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_8"><span class="violet"><strong>13.8</strong></span> <code>deque</code> Sequence Container</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_9"><span class="violet"><strong>13.9</strong></span> Associative Containers</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_9_1">13.9.1  <code>multiset</code> Associative Container</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_9_2">13.9.2  <code>set</code> Associative Container</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_9_3">13.9.3  <code>multimap</code> Associative Container</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_9_4">13.9.4  <code>map</code> Associative Container</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_10"><span class="violet"><strong>13.10</strong></span> Container Adaptors</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_10_1">13.7.1  <code>stack</code> Adaptor</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_10_2">13.7.2  <code>queue</code> Adaptor</a></p>&#13;
<p class="chap-lev2"><a href="ch13.xhtml#sec13_10_3">13.7.3  <code>priority_queue</code> Adaptor</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_11"><span class="violet"><strong>13.11</strong></span> <code>bitset</code> Near Container</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_12"><span class="violet"><strong>13.12</strong></span> Optional: A Brief Intro to Big <em>O</em></a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_13"><span class="violet"><strong>13.13</strong></span> Optional: A Brief Intro to Hash Tables</a></p>&#13;
<p class="chap-lev1"><a href="ch13.xhtml#sec13_14"><span class="violet"><strong>13.14</strong></span> Wrap-Up</a></p>&#13;
</div>&#13;
<h3 class="h3" id="sec13_1"><span class="violet">13.1</span> Introduction</h3>&#13;
<p>The standard library defines powerful, template-based, reusable components that implement many common data structures and algorithms used to process those data structures. We began introducing templates in <a href="ch05.xhtml#ch05">Chapters 5</a>–<a href="ch06.xhtml#ch06">6</a> and use them extensively here and in <a href="ch14.xhtml#ch14">Chapters 14</a> and <a href="ch15.xhtml#ch15">15</a>. Historically, the features presented in this chapter were referred to as the <strong><span class="violet">Standard Template Library</span></strong> or <strong><span class="violet">STL</span></strong>.<sup><a id="ch13fn1a" href="ch13.xhtml#ch13fn1">1</a></sup> In the C++ standard document, they are simply referred to as part of the C++ standard library.</p>&#13;
<p class="footnote"><a id="ch13fn1" href="ch13.xhtml#ch13fn1a">1</a>. The STL was developed by Alexander Stepanov and Meng Lee at Hewlett Packard and is based on their generic programming research, with significant contributions from David Musser. Stepanove first proposed the STL for inclusion in C++ at the November 1993 ANSI/ISO C++ standardization committee meeting, and it was approved for inclusion in July 1994 (<code><a href="https://en.wikipedia.org/wiki/History_of_the_Standard_Template_Library">https://en.wikipedia.org/wiki/History_of_the_Standard_Template_Library</a></code>; accessed April 15, 2021).</p>&#13;
<h5 class="h5" id="ch13lev3sec1">Containers, Iterators and Algorithms</h5>&#13;
<p>This chapter introduces three key components of the standard library—<strong><span class="violet">containers</span></strong> (templatized data structures), iterators and algorithms. We’ll introduce <strong>containers</strong>, <strong>container adaptors</strong> and <strong>near containers</strong>.</p>&#13;
<h5 class="h5" id="ch13lev3sec2">Common Member Functions Among Containers</h5>&#13;
<p>Each container has associated member functions—a subset of these is defined in all containers. We illustrate most of this common functionality in our examples of <strong><code>array</code></strong> (introduced in <a href="ch06.xhtml#ch06">Chapter 6</a>), <strong><code>vector</code></strong> (also introduced in <a href="ch06.xhtml#ch06">Chapter 6</a> and covered in more depth here), <strong><code>list</code></strong> (<a href="ch13.xhtml#sec13_7">Section 13.7</a>) and <strong><code>deque</code></strong> (pronounced “deck”; <a href="ch13.xhtml#sec13_8">Section 13.8</a>).</p>&#13;
<h5 class="h5" id="ch13lev3sec3">Iterators</h5>&#13;
<p><strong><span class="violet">Iterators</span></strong>, which have properties similar to those of <strong>pointers</strong>, are used to manipulate container elements. <strong>Built-in arrays</strong> also can be manipulated by standard library algorithms, using pointers as iterators. We’ll see that manipulating containers with iterators is convenient and provides tremendous expressive power when combined with standard library algorithms—in some cases, reducing many lines of code to a single statement.</p>&#13;
<h5 class="h5" id="ch13lev3sec4">Algorithms</h5>&#13;
<p>Standard library <strong><span class="violet">algorithms</span></strong> (which we’ll cover in depth in <a href="ch14.xhtml#ch14">Chapter 14</a>) are function templates that perform common data manipulations, such as <strong>searching</strong>, <strong>sorting</strong>, <strong>copying</strong>, <strong>transforming</strong> and <strong>comparing elements or entire containers</strong>. The standard library provides scores of algorithms. There are:</p>&#13;
<p class="bull"><span class="size">20</span> • 90 in the <code>&lt;algorithms&gt;</code> header’s <code>std</code> namespace—82 also are overloaded in the <strong><code>std::ranges</code> namespace</strong> for use with C++20 ranges,</p>&#13;
<p class="bull">• 11 in the <code>&lt;numeric&gt;</code> header’s <code>std</code> namespace,</p>&#13;
<p class="bull"><span class="size">20</span> • 14 in the <code>&lt;memory&gt;</code> header’s <code>std</code> namespace—all 14 also are overloaded in the <code>std::ranges</code> namespace for use with C++20 ranges,</p>&#13;
<p class="bull">• 2 in the <code>&lt;cstdlib&gt;</code> header.</p>&#13;
<p>Many were added in C++11 and C++20, and a few in C++17. For the complete list of algorithms with links to their descriptions, visit:</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p693pro01" id="p693pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/algorithm</pre>&#13;
<p>Most algorithms use iterators to access container elements. Each algorithm has minimum requirements for the kinds of iterators that can be used with it. We’ll see that containers support specific kinds of iterators, some more powerful than others. The iterators a container supports determine whether the container can be used with a specific algorithm. Iterators encapsulate the mechanisms used to traverse containers and access their elements. This encapsulation enables many of the algorithms to be applied to various containers independently of the underlying container implementation. This also enables you to create new algorithms that can process the elements of multiple container types.</p>&#13;
<h5><span class="size">20</span> C++20 Ranges</h5>&#13;
<p><a href="ch06.xhtml#ch06">Chapter 6</a> introduced C++20’s new <strong>ranges</strong> and <strong>views</strong>. You saw that a <strong>range</strong> is a collection of elements you can iterate over. So, <strong><code>array</code></strong>s and <strong><code>vector</code></strong>s are ranges. You also used <strong>views</strong> to specify <strong>pipelines</strong> of operations that manipulate ranges of elements. Any container that has iterators representing its beginning and end can be treated as a C++20 range. In this chapter, we’ll use the new C++20 standard library algorithm <code>std::ranges::copy</code> and the older C++ standard library algorithm <code>std::copy</code> to demonstrate how ranges simplify your code. In <a href="ch14.xhtml#ch14">Chapter 14</a>, we’ll use many more C++20 algorithms from the <code>std::ranges</code> namespace to demonstrate additional <strong>ranges</strong> and <strong>views</strong> features.</p>&#13;
<h5 class="h5" id="ch13lev3sec5">Custom Templatized Data Structures</h5>&#13;
<p>Some popular data structures include linked lists, queues, stacks and binary trees:</p>&#13;
<p class="bull">• <strong><span class="violet"> Linked lists</span></strong> are collections of data items logically “lined up in a row”—insertions and removals are made anywhere in a linked list.</p>&#13;
<p class="bull">• <strong>Stacks</strong> are important in compilers and operating systems: Insertions and removals are made <strong>only</strong> at one end of a stack—its <strong>top</strong>.</p>&#13;
<p class="bull">• <strong><span class="violet"> Queues</span></strong> represent waiting lines; insertions are made at the back (also referred to as the <strong>tail</strong>) of a queue and removals are made from the front (also referred to as the <strong>head</strong>) of a queue.</p>&#13;
<p class="bull">• <strong><span class="violet"> Binary trees</span></strong> are nonlinear, hierarchical data structures that facilitate <strong>searching</strong> and <strong>sorting</strong> data, <strong>duplicate elimination</strong> and <strong>compiling</strong> expressions into machine code.</p>&#13;
<p>Each of these data structures has many other interesting applications. We can carefully weave linked objects together with pointers. Pointer-based code is complex and can be error prone—the slightest omissions or oversights can lead to serious <strong>memory-access violations</strong> and <strong>memory leaks</strong> with no forewarning from the compiler. If many programmers on a large project implement custom containers and algorithms for different tasks, the code becomes difficult to modify, maintain and debug.</p>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <span class="size">SE</span><img class="inline" src="Images/se.jpg" alt="Images" width="36" height="30"/> <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Avoid reinventing the wheel. When possible, program with the C++ standard library’s preexisting containers, iterators and algorithms.<sup><a id="ch13fn2a" href="ch13.xhtml#ch13fn2">2</a></sup> The prepackaged standard library container classes provide the data structures you need for most applications. Using the standard library’s proven containers, iterators and algorithms helps you reduce testing and debugging time. The containers, iterators and algorithms were conceived and designed for performance and flexibility.</p>&#13;
<p class="footnote"><a id="ch13fn2" href="ch13.xhtml#ch13fn2a">2</a>. “SL.1: Use libraries wherever possible.” Accessed April 16, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-lib">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-lib</a></code>.</p>&#13;
<h3 class="h3" id="sec13_2"><span class="violet">13.2</span> Introduction to Containers<sup><a id="ch13fn3a" href="ch13.xhtml#ch13fn3">3</a></sup></h3>&#13;
<p class="footnote"><a id="ch13fn3" href="ch13.xhtml#ch13fn3a">3</a>. This section is intended as an introduction to a reference-oriented chapter. You may want to read it quickly and refer back to it as necessary when reading the chapter’s live-code examples.</p>&#13;
<p>The standard library containers are divided into four major categories:</p>&#13;
<p class="bull">• <strong>sequence containers</strong>,</p>&#13;
<p class="bull">• <strong>ordered associative containers</strong>,</p>&#13;
<p class="bull">• <strong>unordered associative containers</strong> and</p>&#13;
<p class="bull">• <strong>container adaptors</strong>.</p>&#13;
<p>We briefly summarize the containers here and show live-code examples of many of them in the following sections.</p>&#13;
<h5 class="h5" id="ch13lev3sec6">Sequence Containers</h5>&#13;
<p>The <strong><span class="violet">sequence containers</span></strong> represent linear data structures with all of their elements conceptually “lined up in a row,” such as <strong><code>array</code></strong>s, <strong><code>vector</code></strong>s and linked lists. The five <strong>sequence containers</strong> are:</p>&#13;
<p class="bull">• <strong><code>array</code></strong> (<a href="ch06.xhtml#ch06">Chapter 6</a>)—Fixed size. Direct access to any element.</p>&#13;
<p class="bull">• <strong><code>deque</code></strong> (<a href="ch13.xhtml#sec13_8">Section 13.8</a>)—Rapid insertions and deletions at front or back. Direct access to any element.</p>&#13;
<p class="bull"><span class="size">11</span> • <strong><code>forward_list</code></strong>—Singly linked list, rapid insertion and deletion anywhere.</p>&#13;
<p class="bull">• <strong><code>list</code></strong> (<a href="ch13.xhtml#sec13_7">Section 13.7</a>)—Doubly linked list, rapid insertion and deletion anywhere.</p>&#13;
<p class="bull">• <strong><code>vector</code></strong> (<a href="ch13.xhtml#sec13_6">Section 13.6</a>)—Rapid insertions and deletions at back. Direct access to any element.</p>&#13;
<p>Class <code>string</code> supports the same functionality as a <strong>sequence container</strong>, but stores only character data.</p>&#13;
<h5 class="h5" id="ch13lev3sec7">Associative Containers</h5>&#13;
<p><strong><span class="violet">Associative containers</span></strong> are nonlinear data structures that typically can locate elements stored in the containers quickly. Such containers can store sets of values or <strong><span class="violet">key–value pairs</span></strong> in which each key has an associated value—for example, a program might associate employee IDs with <code>Employee</code> objects. As you’ll see, some associative containers allow multiple values for each key. The keys in associative containers are <strong>immutable</strong>—they cannot be modified unless you first remove them from the container. The four <strong>ordered associative containers</strong> are:</p>&#13;
<p class="bull">• <strong><code>set</code></strong> (<a href="ch13.xhtml#sec13_9_2">Section 13.9.2</a>)—Rapid lookup, no duplicates allowed.</p>&#13;
<p class="bull">• <strong><code>multiset</code></strong> (<a href="ch13.xhtml#sec13_9_1">Section 13.9.1</a>)—Rapid lookup, duplicates allowed.</p>&#13;
<p class="bull">• <strong><code>map</code></strong> (<a href="ch13.xhtml#sec13_9_4">Section 13.9.4</a>)—One-to-one mapping, no duplicates allowed, rapid key-based lookup.</p>&#13;
<p class="bull">• <strong><code>multimap</code></strong> (<a href="ch13.xhtml#sec13_9_3">Section 13.9.3</a>)—One-to-many mapping, duplicates allowed, rapid key-based lookup.</p>&#13;
<p>The four <strong>unordered associative containers</strong> are:</p>&#13;
<p class="bull">• <strong><code>unordered_set</code></strong>—Rapid lookup, no duplicates allowed.</p>&#13;
<p class="bull">• <strong><code>unordered_multiset</code></strong>—Rapid lookup, duplicates allowed.</p>&#13;
<p class="bull">• <strong><code>unordered_map</code></strong>—One-to-one mapping, no duplicates allowed, rapid key-based lookup.</p>&#13;
<p class="bull">• <strong><code>unordered_multimap</code></strong>—One-to-many mapping, duplicates allowed, rapid key-based lookup.</p>&#13;
<h5 class="h5" id="ch13lev3sec8">Container Adaptors</h5>&#13;
<p>Stacks and queues are typically constrained versions of sequence containers. For this reason, the standard library implements <strong><code>stack</code></strong>, <strong><code>queue</code></strong> and <strong><code>priority_queue</code></strong> as <strong><span class="violet">container adaptors</span></strong> that enable a program to view a sequence container in a constrained manner. The three <strong>container adaptors</strong> are:</p>&#13;
<p class="bull">• <strong><code>stack</code></strong>—Last-in, first-out (LIFO) data structure.</p>&#13;
<p class="bull">• <strong><code>queue</code></strong>—First-in, first-out (FIFO) data structure.</p>&#13;
<p class="bull">• <strong><code>priority_queue</code></strong>—Highest-priority element is always the first element out.</p>&#13;
<h5 class="h5" id="ch13lev3sec9">Near Containers</h5>&#13;
<p>There are other container types that are considered <strong><span class="violet">near containers</span></strong>—built-in arrays (<a href="ch07.xhtml#ch07">Chapter 7</a>), <code>bitset</code>s (<a href="ch13.xhtml#sec13_11">Section 13.11</a>) for maintaining sets of flag values and <code>valarray</code>s for performing high-speed mathematical vector operations<sup><a id="ch13fn4a" href="ch13.xhtml#ch13fn4">4</a></sup>—not to be confused with the <code>vector</code> container. These types are considered <strong>near containers</strong> because they exhibit some, but not all, capabilities of the <strong>sequence</strong> and <strong>associative containers</strong>.</p>&#13;
<p class="footnote"><a id="ch13fn4" href="ch13.xhtml#ch13fn4a">4</a>. For overviews of <code>valarray</code> and its mathematical capabilities, see its documentation at <code><a href="https://en.cppreference.com/w/cpp/numeric/valarray">https://en.cppreference.com/w/cpp/numeric/valarray</a></code> and check out the article “std:: <code>valarray</code> class in C++” at <code><a href="https://www.geeksforgeeks.org/std-valarray-class-c/">https://www.geeksforgeeks.org/std-valarray-class-c/</a></code>.</p>&#13;
&#13;
<h4 class="h4" id="sec13_2_1">13.2.1 Common Nested Types in Sequence and Associative Containers</h4>&#13;
<p>The following table shows the common <strong><span class="violet">nested types</span></strong> defined inside each sequence container and associative container class definition. These are used in template-based variables declarations, parameters to functions and return values from functions, as you’ll see in this chapter and <a href="ch14.xhtml#ch14">Chapter 14</a>. For example, the <code>value_type</code> in each container always represents the container’s element type.</p>&#13;
<div class="image"><img src="Images/696tab01.jpg" alt="Images" width="757" height="782"/></div>&#13;
<h4 class="h4" id="sec13_2_2">13.2.2 Common Container Member and Non-Member Functions</h4>&#13;
<p>Most containers provide similar functionality. Many operations apply to all containers, and other operations apply to subsets of similar containers. The following tables describe the functions that are commonly available in most, but not all, standard library containers. Before using any container, you should study its capabilities. For a complete list of all the container member functions and which containers support them, see the <strong>member function table</strong> at <code>cppreference.com</code>.<sup><a id="ch13fn5a" href="ch13.xhtml#ch13fn5">5</a></sup> Several of the member functions that we do not list in this section are covered throughout the chapter as we present various sequence containers, associative containers and container adaptors.</p>&#13;
<p class="footnote"><a id="ch13fn5" href="ch13.xhtml#ch13fn5a">5</a>. “Container library—Member functions table.” Accessed April 16, 2021. <code><a href="https://en.cppreference.com/w/cpp/container">https://en.cppreference.com/w/cpp/container</a></code>.</p>&#13;
<h5 class="h5" id="ch13lev3sec10">Container Special Member Functions</h5>&#13;
<p>The following table describes the container special member functions provided by each container. In addition, each container class typically provides many overloaded constructors for initializing containers and container adaptors in various ways. For example, each sequence and associative container can be initialized from an <code>initializer_list</code>.</p>&#13;
<div class="image"><img src="Images/697tab01.jpg" alt="Images" width="755" height="386"/></div>&#13;
<h5 class="h5" id="ch13lev3sec11">Non-Member Relational and Equality Operators</h5>&#13;
<p><span class="size">20</span> The following table shows the relational and equality operators supported by most containers. In C++17 and earlier, the <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code> and <code>!=</code> operators are overloaded as non-member functions. In C++20, the sequence containers and associative containers replace these overloaded operator functions with the new <strong>three-way comparison operator <code>&lt;=&gt;</code></strong>. As we showed in <a href="ch11.xhtml#sec11_7">Section 11.7</a>, the C++ compiler can use <code>&lt;=&gt;</code> to implement each relational and equality comparison by rewriting it in terms of <code>&lt;=&gt;</code>. For example, the compiler rewrites</p>&#13;
<pre class="pre">x == y</pre>&#13;
<p>as</p>&#13;
<pre class="pre">(x &lt;=&gt; y) == 0</pre>&#13;
<p>The unordered associative containers do not support <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>. The relational and equality operators are not supported for <code>priority_queue</code>s.</p>&#13;
<div class="image"><img src="Images/698tab01.jpg" alt="Images" width="789" height="408"/></div>&#13;
<h5 class="h5" id="ch13lev3sec12">Member Functions That Return Iterators</h5>&#13;
<p>The following table shows container member functions that return iterators. The <strong><code>forward_list</code></strong> container does have the member functions <code>rbegin</code>, <code>rend</code>, <code>crbegin</code> and <code>crend</code>.</p>&#13;
<div class="image"><img src="Images/698tab02.jpg" alt="Images" width="816" height="509"/></div>&#13;
<h5 class="h5" id="ch13lev3sec13">Other Member Functions</h5>&#13;
<p>The following table lists various additional container member functions. If a function is not supported for all containers, we specify the containers that do or do not support it.</p>&#13;
<div class="image"><img src="Images/699tab01.jpg" alt="Images" width="817" height="635"/></div>&#13;
<h4 class="h4" id="sec13_2_3">13.2.3 Requirements for Container Elements</h4>&#13;
<p>Before using a standard library container, it’s important to ensure that the type of objects being stored in the container supports a minimum set of functionality. For example:</p>&#13;
<p class="bull">• If inserting an item into a container requires a <strong>copy</strong> of the object, the object type should provide a <strong>copy constructor</strong> and <strong>copy assignment operator</strong>.</p>&#13;
<p class="bull">• If inserting an item into a container requires <strong>moving</strong> the object, the object type should provide a <strong>move constructor</strong> and <strong>move assignment operator</strong>—<a href="ch11.xhtml#ch11">Chapter 11</a> discussed <strong>move semantics</strong>.</p>&#13;
<p class="bull">• The <strong>ordered associative containers</strong> and many algorithms require elements to be compared—for this reason, the object type should support comparisons.</p>&#13;
<p>As you review the documentation for each container, whether in the C++ standard document itself or on sites like <code>cppreference.com</code>, you’ll see various <strong><span class="violet">named requirements</span></strong>, such as <strong>CopyConstructible</strong>, <strong>MoveAssignable</strong> or <strong>EqualityComparable</strong>. These help you determine whether your types are compatible with various C++ standard library containers and algorithms. You can view a list of named requirements and their descriptions at:</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p699pro01" id="p699pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/named_req</pre>&#13;
<p><span class="size">20</span> In C++20, many named requirements are formalized as <strong>concepts</strong>, which we’ll say more about in <a href="ch14.xhtml#ch14">Chapters 14</a> and <a href="ch15.xhtml#ch15">15</a>.</p>&#13;
<h3 class="h3" id="sec13_3"><span class="violet">13.3</span> Working with Iterators</h3>&#13;
<p><strong>Iterators</strong> have many similarities to pointers. Iterators point to elements in sequence containers and associative containers. Iterators hold state information sensitive to the particular containers on which they operate; thus, iterators are implemented for each type of container. Certain iterator operations are uniform across containers. For example, the <strong>dereferencing operator (<code>*</code>)</strong> dereferences an iterator so that you can use the element to which it points. The <strong><code>++</code> operation on an iterator</strong> moves it to the container’s next element.</p>&#13;
<p>Sequence containers and associative containers provide member functions <code>begin</code> and <code>end</code>. Function <span class="violet"><strong><code>begin</code></strong></span> returns an iterator pointing to the first element of the container. Function <span class="violet"><strong><code>end</code></strong></span> returns an iterator pointing to the <strong>first element past the end of the container</strong> (one past the end)—a non-existent element that’s frequently used to determine when the end of a container is reached. This is typically used in an equality or inequality comparison to determine whether a “moving iterator” reached the end of the container.</p>&#13;
<p>An object of a container’s <strong><code>iterator</code></strong> type refers to a container element that can be modified, and an object of a container’s <strong><code>const_iterator</code></strong> type refers to a container element that cannot be modified.</p>&#13;
<h4 class="h4" id="sec13_3_1">13.3.1 Using <code>istream_iterator</code> for Input and <code>ostream_iterator</code> for Output</h4>&#13;
<p>We use iterators with <strong><span class="violet">sequences</span></strong> (also called <strong><span class="violet">ranges</span></strong>). These can be in containers, or they can be <strong><span class="violet">input sequences</span></strong> or <strong><span class="violet">output sequences</span></strong>. <a href="ch13.xhtml#fig13_1">Figure 13.1</a> demonstrates input from the standard input (a sequence of data for program input), using an <span class="violet"><strong><code>istream_iterator</code></strong></span>, and output to the standard output (a sequence of data for program output), using an <span class="violet"><strong><code>ostream_iterator</code></strong></span>. The program inputs two integers from the user and displays their sum. As you’ll see later in this chapter, <code>istream_iterator</code>s and <code>ostream_iterator</code>s can be used with the standard library algorithms to create powerful statements. For example, subsequent examples will use an <code>ostream_iterator</code> with the <code>copy</code> algorithm to copy a container’s elements to the standard output stream with a single statement.</p>&#13;
<div class="group" id="fig13_1">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro01" id="p13pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_01.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Demonstrating input and output with iterators.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator and istream_iterator</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>7</strong></span>      std::cout &lt;&lt; <span class="green">"Enter two integers: "</span>;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// create istream_iterator for reading int values from cin</span>&#13;
<span class="cviolet"><strong>10</strong></span>      std::istream_iterator&lt;<span class="blue">int</span>&gt; inputInt{std::cin};&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="blue">const int</span> number1{*inputInt}; <span class="lgreen">// read int from standard input</span>&#13;
<span class="cviolet"><strong>13</strong></span>      ++inputInt; <span class="lgreen">// move iterator to next input value</span>&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">const int</span> number2{*inputInt}; <span class="lgreen">// read int from standard input</span>&#13;
<span class="cviolet"><strong>15</strong></span>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="lgreen">// create ostream_iterator for writing int values to cout</span>&#13;
<span class="cviolet"><strong>17</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; outputInt{std::cout};&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      std::cout &lt;&lt; <span class="green">"The sum is: "</span>;&#13;
<span class="cviolet"><strong>20</strong></span>      *outputInt = number1 + number2; <span class="lgreen">// output result to cout</span>&#13;
<span class="cviolet"><strong>21</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>22</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Enter two integers:</code> <strong><code>12</code></strong> <strong><code>25</code></strong>&#13;
<code>The sum is: 37</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.1</strong></span> | Demonstrating input and output with iterators. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h5><code>istream_iterator</code></h5>&#13;
<p>Line 10 creates an <code>istream_iterator</code> that’s capable of <strong>extracting</strong> (inputting) <code>int</code> values from the standard input object <code>cin</code>. Line 12 <strong>dereferences</strong> iterator <code>inputInt</code> to read the first integer from <code>cin</code> and assigns that integer to <code>number1</code>. The dereferencing operator <code>*</code> applied to iterator <code>inputInt</code> gets the value from the stream associated with <code>inputInt</code>; this is similar to dereferencing a pointer. Line 13 positions iterator <code>inputInt</code> to the next value in the input stream. Line 14 inputs the next integer from <code>inputInt</code> and assigns it to <code>number2</code>.</p>&#13;
<h5><code>ostream_iterator</code></h5>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Line 17 creates an <code>ostream_iterator</code> that’s capable of <strong>inserting</strong> (outputting) <code>int</code> values in the standard output object <code>cout</code>. Line 20 outputs an integer to <code>cout</code> by assigning to <code>*outputInt</code> the sum of <code>number1</code> and <code>number2</code>. Notice that we use the dereferenced <code>outputInt</code> iterator as an <em>lvalue</em> in the assignment statement. If you want to output another value using <code>outputInt</code>, the iterator first must be incremented with <code>++</code>. Either the prefix or postfix increment can be used—we use the prefix form for performance reasons because it does not create a temporary object.</p>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> The <code>*</code> (dereferencing) operator when applied to a <code>const</code> iterator returns a reference to</p>&#13;
<p><code>const</code> for the container element, disallowing the use of non-<code>const</code> member functions.</p>&#13;
<h4 class="h4" id="sec13_3_2">13.3.2 Iterator Categories</h4>&#13;
<p>The following table describes the iterator categories. Each provides a specific set of functionality.</p>&#13;
<div class="image"><img src="Images/701tab01.jpg" alt="Images" width="831" height="586"/></div>&#13;
<p>Throughout this chapter, we discuss which iterator category each container supports. In <a href="ch14.xhtml#ch14">Chapter 14</a>, you’ll see that each algorithm specifies minimum iterator requirements. Only containers that support those requirements can be used with that algorithm.</p>&#13;
<h4 class="h4" id="sec13_3_3">13.3.3 Container Support for Iterators</h4>&#13;
<p>The iterator category that each container supports determines whether that container can be used with specific algorithms. <strong>Containers that support random-access iterators can be used with all standard library algorithms</strong><em>—</em>with the exception that if an algorithm requires changes to a container’s size, the algorithm can’t be used on built-in arrays or <strong><code>array</code></strong> objects<em>.</em> Pointers into built-in arrays can be used in place of iterators with most algorithms. The following table shows the iterator category of each container. Sequence containers, associative containers, <code>string</code>s and built-in arrays are all traversable with iterators.</p>&#13;
<div class="image"><img src="Images/702tab01.jpg" alt="Images" width="753" height="393"/></div>&#13;
<h4 class="h4" id="sec13_3_4">13.3.4 Predefined Iterator Type Names</h4>&#13;
<p>The following table shows the predefined iterator type names found in the standard library container class definitions. Not every iterator type name is defined for every container. <strong>The <code>const</code> iterators are for traversing <code>const</code> containers or non-<code>const</code> containers that should not be modified</strong>. <strong>Reverse iterators</strong> traverse containers in the reverse direction.</p>&#13;
<div class="image"><img src="Images/703tab01.jpg" alt="Images" width="653" height="191"/></div>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> <strong>Operations performed on a <code>const_iterator</code> return references to <code>const</code> to prevent modifying elements of the container</strong>. Using <code>const_iterator</code>s where appropriate is another example of the <strong>principle of least privilege</strong>.</p>&#13;
<h4 class="h4" id="sec13_3_5">13.3.5 Iterator Operations</h4>&#13;
<p>The following table shows operations that can be performed on each iterator type. In addition to the operators shown for all iterators, iterators must provide <strong>default constructors</strong>, <strong>copy constructors</strong> and <strong>copy assignment operators</strong>.<sup><a id="ch13fn6a" href="ch13.xhtml#ch13fn6">6</a></sup> A <strong>forward iterator</strong> supports <code>++</code> and all of the <strong>input and output iterator</strong> capabilities. A <strong>bidirectional</strong> iterator supports <code>--</code> and all the capabilities of <strong>forward</strong> iterators. <strong>Random-access</strong> iterators and <strong>contiguous</strong> iterators support all of the operations shown in the table. For input iterators and output iterators, it’s not possible to save the iterator, then use the saved value later.</p>&#13;
<p class="footnote"><a id="ch13fn6" href="ch13.xhtml#ch13fn6a">6</a>. You’ll see in <a href="ch14.xhtml#ch14">Chapter 14</a> that iterators can be wrapped as <code>move_iterator</code>s to enable move semantics for the referenced elements.</p>&#13;
<div class="image"><img src="Images/703tab02.jpg" alt="Images" width="787" height="1047"/></div>&#13;
<h3 class="h3" id="sec13_4"><span class="violet">13.4</span> A Brief Introduction to Algorithms</h3>&#13;
<p><span class="size">20</span> The standard library provides scores of <strong>algorithms</strong> you can use to manipulate a wide variety of containers. <strong>Inserting</strong>, <strong>deleting</strong>, <strong>searching</strong>, <strong>sorting</strong> and others are appropriate for some or all of the sequence and associative containers. <strong>The algorithms operate on container elements only indirectly through iterators.</strong> Many algorithms operate on sequences of elements defined by iterators pointing to the <strong>first element</strong> of the sequence and to <strong>one element past the last element</strong> and many support C++20 ranges. It’s also possible to create your own new algorithms that operate in a similar fashion so they can be used with the standard library containers and iterators. In this chapter, we’ll use the <strong><code>copy</code> algorithm</strong> in many examples to copy a container’s contents to the standard output. We discuss many standard library algorithms in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>&#13;
<h3 class="h3" id="sec13_5"><span class="violet">13.5</span> Sequence Containers</h3>&#13;
<p>The C++ Standard Template Library provides five <strong>sequence containers</strong>—<strong><code>array</code></strong>, <strong><code>vector</code></strong>, <strong><code>deque</code></strong>, <strong><code>list</code></strong> and <strong><code>forward_list</code></strong>. The <strong><code>array</code></strong>, <strong><code>vector</code></strong> and <strong><code>deque</code></strong> containers are typically based on built-in arrays. The <strong><code>list</code></strong> and <strong><code>forward_list</code></strong> containers implement linked-list data structures. We’ve already discussed and used <strong><code>array</code></strong> extensively in <a href="ch06.xhtml#ch06">Chapter 6</a>, so we do not cover it again here. We’ve also already introduced <strong><code>vector</code></strong> in <a href="ch06.xhtml#ch06">Chapter 6</a>—and we discuss it in more detail here.</p>&#13;
<h5 class="h5" id="ch13lev3sec14"><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Performance and Choosing the Appropriate Container</h5>&#13;
<p><span class="size">CG</span><img class="inline" src="Images/cg.jpg" alt="Images" width="31" height="31"/> <a href="ch13.xhtml#sec13_2_2">Section 13.2.2</a> presented the operations common to most of the standard library containers. Beyond these operations, each container typically provides a variety of other capabilities. Many of these are common to several containers, but they’re not always equally efficient for each container. <strong><code>vector</code> is satisfactory for most applications.</strong><sup><a id="ch13fn7a" href="ch13.xhtml#ch13fn7">7</a></sup></p>&#13;
<p class="footnote"><a id="ch13fn7" href="ch13.xhtml#ch13fn7a">7</a>. “SL.con.2: Prefer using STL <code>vector</code> by default unless you have a reason to use a different container.” Accessed April 16, 2021. <code><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-vector">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-vector</a></code>.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Insertion at the back of a <strong><code>vector</code></strong> is efficient. The <strong><code>vector</code></strong> simply grows, if necessary, to accommodate the new item. It’s expensive to insert (or delete) an element in the middle of a <strong><code>vector</code></strong>—the entire portion of the <strong><code>vector</code></strong> after the insertion (or deletion) point must be moved, because <strong><code>vector</code></strong> elements occupy contiguous cells in memory.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Applications that require frequent insertions and deletions at both ends of a container normally use a <strong><code>deque</code></strong> rather than a <strong><code>vector</code></strong>. Although we can insert and delete elements at the front and back of both a <strong><code>vector</code></strong> and a <strong><code>deque</code></strong>, class <strong><code>deque</code></strong> is <strong><em>O</em>(1)</strong> for insertions and deletions at the front,<sup><a id="ch13fn8a" href="ch13.xhtml#ch13fn8">8</a></sup> making it more efficient than <strong><code>vector</code></strong>, which is <strong><em>O</em>(<em>n</em>)</strong> for those operations.<sup><a id="ch13fn9a" href="ch13.xhtml#ch13fn9">9</a></sup> If you’re not familiar with the <strong>Big O notation</strong> used here, see <a href="ch13.xhtml#sec13_12">Section 13.12</a> for a friendly introduction.</p>&#13;
<p class="footnote"><a id="ch13fn8" href="ch13.xhtml#ch13fn8a">8</a>. “<code>std::deque</code>.” Accessed April 11, 2021. <code><a href="https://en.cppreference.com/w/cpp/container/deque">https://en.cppreference.com/w/cpp/container/deque</a></code>.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Applications with frequent insertions and deletions in the middle and/or at the extremes of a container normally use a <strong><code>list</code></strong>, due to its efficient implementation of insertion and deletion anywhere in the data structure.</p>&#13;
<h3 class="h3" id="sec13_6"><span class="violet">13.6</span> <code>vector</code> Sequence Container</h3>&#13;
<p>The <strong><code>vector</code></strong> container, which we introduced in <a href="ch06.xhtml#ch06lev1sec15">Section 6.15</a>, provides a dynamic data structure with contiguous memory locations. This enables efficient, direct access to any element of a <strong><code>vector</code></strong> via the subscript operator <code>[]</code>, exactly as with a built-in array. A <strong><code>vector</code></strong> is most commonly used when the data in the container must be easily accessible via a subscript or will be sorted, and when the number of elements may need to grow. When a <strong><code>vector</code></strong>’s memory is exhausted, the <strong><code>vector</code></strong></p>&#13;
<p class="bull">• <strong>allocates</strong> a larger built-in array,</p>&#13;
<p class="bull">• <strong>copies</strong> or <strong>moves</strong> (depending on what the element type supports) the original elements into the new built-in array, and</p>&#13;
<p class="bull">• <strong>deallocates</strong> the old built-in array.</p>&#13;
<p class="footnote"><a id="ch13fn9" href="ch13.xhtml#ch13fn9a">9</a>. “<code>std::vector</code>.” Accessed April 11, 2021. <code><a href="https://en.cppreference.com/w/cpp/container/vector">https://en.cppreference.com/w/cpp/container/vector</a></code>.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <strong><code>vector</code></strong>s provide rapid indexed access with the overloaded subscript operator <code>[]</code> because they’re stored in contiguous memory like a built-in array or an <strong><code>array</code></strong> object. <strong>Choose the <code>vector</code> container for the best random-access performance in a container that can grow.</strong></p>&#13;
<h4 class="h4" id="sec13_6_1">13.6.1 Using <code>vector</code>s and Iterators</h4>&#13;
<p><a href="ch13.xhtml#fig13_2">Figure 13.2</a> illustrates several <strong><code>vector</code></strong> member functions. Many of these are available in every <strong>sequence container</strong> and <strong>associative container</strong>. You must include header <code>&lt;vector&gt;</code> to use a <strong><code>vector</code></strong>. As we add items to a <strong><code>vector</code></strong><code>&lt;int&gt;</code> in this example, we call our <code>showResult</code> function (lines 9–12) to display the added value as well as the <code>vector</code>’s</p>&#13;
<p class="bull">• size—the number of elements the <strong><code>vector</code></strong> currently contains, and</p>&#13;
<p class="bull">• <strong><span class="violet"> capacity</span></strong>—the number of elements that the <strong><code>vector</code></strong> can store before it needs to <strong>dynamically resize itself</strong> to accommodate more elements.</p>&#13;
<div class="group" id="fig13_2">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro02" id="p13pro02a">Click here to view code image</a></p>&#13;
<p class="codelink"><a href="Images/ch02_images.xhtml#aa02fig04" id="a02fig04">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_02.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library vector class template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// C++20: This will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;ranges&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;vector&gt; <span class="lgreen">// vector class-template definition</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="lgreen">// display value appended to vector and updated vector size and capacity</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">void</span> showResult(<span class="blue">int</span> value, <span class="blue">size_t</span> size, <span class="blue">size_t</span> capacity) {&#13;
<span class="cviolet"><strong>10</strong></span>     std::cout &lt;&lt; fmt::format(<span class="green">"appended: {}; size: {}; capacity: {}\n"</span>,&#13;
<span class="cviolet"><strong>11</strong></span>                     <code>value, size, capacity);</code>&#13;
<span class="cviolet"><strong>12</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>13</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.2</strong></span> | Standard library <code>vector</code> class template.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec15">Creating a <code>vector</code> and Displaying Its Initial Size and Capacity</h5>&#13;
<p>Line 15 defines the <strong><code>vector</code></strong><code>&lt;int&gt;</code> object called <code>integers</code>. <strong><code>vector</code></strong>’s default constructor creates an empty <strong><code>vector</code></strong> with no elements (i.e., its size is 0) and no storage for elements (i.e., its capacity is 0, so the <strong><code>vector</code></strong> will have to allocate memory when elements are added to it).</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p706pro01" id="p706pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>14</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>15</strong></span>      std::vector&lt;<span class="blue">int</span>&gt; integers{}; <span class="lgreen">// create vector of ints</span>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      std::cout &lt;&lt; <span class="green">"Size of integers: "</span> &lt;&lt; integers.size()&#13;
<span class="cviolet"><strong>18</strong></span>         &lt;&lt; <span class="green">"\nCapacity of integers: "</span> &lt;&lt; integers.capacity() &lt;&lt; <span class="green">"\n\n"</span>;&#13;
<span class="cviolet"><strong>19</strong></span></pre>&#13;
<pre class="pre1"><code>Size of integers: 0</code>&#13;
<code>Capacity of integers: 0</code></pre>&#13;
</div>&#13;
<p>Lines 17–18 demonstrate the <code>size</code> and <code>capacity</code> member functions—each initially returns 0 for <code>integers</code>. Function <code>size</code>—available in every container except <strong><code>forward_List</code></strong>—returns the number of elements currently stored in the container. Function <span class="violet"><strong><code>capacity</code></strong></span> (specific to <strong><code>vector</code></strong> and <strong><code>deque</code></strong>) returns <strong><code>vector</code></strong>’s current capacity.</p>&#13;
<h5><code>vector</code> Member Function <strong><code>push_back</code></strong></h5>&#13;
<p>Lines 21–24 use function <span class="violet"><strong><code>push_back</code></strong></span> to append an element to the <strong><code>vector</code></strong>, then call our function <code>showResult</code> to display the item that was added to the <strong><code>vector</code></strong> and the new <strong><code>size</code></strong> and <strong><code>capacity</code></strong>. This function is available in <strong>sequence containers</strong> other than <strong><code>array</code></strong> and <strong><code>forward_list</code></strong>. Sequence containers other than <strong><code>array</code></strong> and <strong><code>vector</code></strong> also provide a <span class="violet"><strong><code>push_-front</code></strong></span> function. If the <strong><code>vector</code></strong>’s <strong><code>size</code></strong> equals its <strong><code>capacity</code></strong>, the <strong><code>vector</code></strong> is full so it increases its size.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p707pro01" id="p707pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>20</strong></span>   <span class="lgreen">// append 1-10 to integers and display updated size and capacity</span>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">for</span> (<span class="blue">int</span> i : std::views::iota(<span class="green">1</span>, <span class="green">11</span>)) {&#13;
<span class="cviolet"><strong>22</strong></span>      integers.push_back(i); <span class="lgreen">// push_back is in vector, deque and list</span>&#13;
<span class="cviolet"><strong>23</strong></span>      <code>showResult(i, integers.size(), integers.capacity());</code>&#13;
<span class="cviolet"><strong>24</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>25</strong></span></pre>&#13;
<pre class="pre1"><code>appended: 1; size: 1; capacity: 1</code>&#13;
<code>appended: 2; size: 2; capacity: 2</code>&#13;
<code>appended: 3; size: 3; capacity: 3</code>&#13;
<code>appended: 4; size: 4; capacity: 4</code>&#13;
<code>appended: 5; size: 5; capacity: 6</code>&#13;
<code>appended: 6; size: 6; capacity: 6</code>&#13;
<code>appended: 7; size: 7; capacity: 9</code>&#13;
<code>appended: 8; size: 8; capacity: 9</code>&#13;
<code>appended: 9; size: 9; capacity: 9</code>&#13;
<code>appended: 10; size: 10; capacity: 13</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec16">Updated <code>size</code> and <strong><code>capacity</code></strong> After Modifying a <strong><code>vector</code></strong></h5>&#13;
<p>The manner in which a <strong><code>vector</code></strong> grows to accommodate more elements—a time-consuming operation—is not specified by the C++ Standard. Some implementations double the <strong><code>vector</code></strong>’s <strong>capacity</strong>. Others increase the capacity by 1.5 times, as shown in the output from <strong>Visual C++</strong>. This becomes apparent starting when the size and capacity are both 4:</p>&#13;
<p class="bull">• When we appended 5, the <strong><code>vector</code></strong> increased the capacity from 4 to 6, and the size became 5, leaving room for one more element.</p>&#13;
<p class="bull">• When we appended 6, the capacity remained at 6, and the size became 6.</p>&#13;
<p class="bull">• When we appended 7, the <strong><code>vector</code></strong> increased the capacity from 6 to 9, and the size became 7, leaving room for two more elements.</p>&#13;
<p class="bull">• When we appended 8, the capacity remained at 9, and the size became 8.</p>&#13;
<p class="bull">• When we appended 9, the capacity remained at 9, and the size became 9.</p>&#13;
<p class="bull">• When we appended 10, the <strong><code>vector</code></strong> increased the <strong>capacity</strong> from 9 to 13 (1.5 times 9 rounded down to the nearest integer), and the <strong>size</strong> became 10, leaving room for three more elements before the <strong><code>vector</code></strong> will need to allocate more space.</p>&#13;
<h5><code>vector</code> Growth</h5>&#13;
<p>C++ library implementers use various schemes to minimize <strong><code>vector</code></strong> resizing overhead, so this program’s output may vary, based on your compiler’s <strong><code>vector</code></strong> growth implementation. <strong>GNU <code>g++</code></strong>, for example, doubles a <strong><code>vector</code></strong>’s capacity when more room is needed, producing the following output:</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p708pro01" id="p708pro01a">Click here to view code image</a></p>&#13;
<pre class="pre1"><code>appended: 1; size: 1; capacity: 1</code>&#13;
<code>appended: 2; size: 2; capacity: 2</code>&#13;
<code>appended: 3; size: 3; capacity: 4</code>&#13;
<code>appended: 4; size: 4; capacity: 4</code>&#13;
<code>appended: 5; size: 5; capacity: 8</code>&#13;
<code>appended: 6; size: 6; capacity: 8</code>&#13;
<code>appended: 7; size: 7; capacity: 8</code>&#13;
<code>appended: 8; size: 8; capacity: 8</code>&#13;
<code>appended: 9; size: 9; capacity: 16</code>&#13;
<code>appended: 10; size: 10; capacity: 16</code></pre>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Some programmers allocate a large initial <strong>capacity</strong>. If a <strong><code>vector</code></strong> stores a small number of elements, such <strong>capacity</strong> may be a waste of space. However, it can greatly improve performance if a program adds many elements to a <strong><code>vector</code></strong> and does not have to reallocate memory to accommodate those elements. This is a classic <strong><span class="violet">space–time trade-off</span></strong>. Library implementors must balance the amount of memory used against the amount of time required to perform various <strong><code>vector</code></strong> operations.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> It can be wasteful to double a <strong><code>vector</code></strong>’s size when more space is needed. For example, in a <strong><code>vector</code></strong> implementation that doubles the allocated memory when space is needed, a full <strong><code>vector</code></strong> of 1,000,000 elements resizes to accommodate 2,000,000 elements even when only one new element is added. This leaves 999,999 unused elements. You can use member functions <strong><code>resize</code></strong> and <strong><code>reserve</code></strong> to control space usage better.</p>&#13;
<h5 class="h5" id="ch13lev3sec17">Outputting <code>vector</code> Contents with Iterators</h5>&#13;
<p>Lines 28–31 output the <strong><code>vector</code></strong>’s contents. Line 28 initializes the control variable <code>const-Iterator</code> using <strong><code>vector</code></strong> member function <span class="violet"><strong><code>cbegin</code></strong></span>, which returns a <strong><code>const_iterator</code></strong> to the <strong><code>vector</code></strong>’s first element. We infer the control variable’s type (<strong><code>vector</code></strong><code>&lt;int&gt;::const_iterator</code>) using the <strong><code>auto</code></strong> keyword—this saves time and reduces errors when working with this more complex types.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p708pro02" id="p708pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>26</strong></span>   std::cout &lt;&lt; <span class="green">"\nOutput integers using iterators: "</span>;&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>   <span class="blue">for</span> (<span class="blue">auto</span> constIterator{integers.cbegin()};&#13;
<span class="cviolet"><strong>29</strong></span>      <code>constIterator != integers.cend(); ++constIterator) {</code>&#13;
<span class="cviolet"><strong>30</strong></span>      std::cout &lt;&lt; *constIterator &lt;&lt; <span class="green">' '</span>;&#13;
<span class="cviolet"><strong>31</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>32</strong></span></pre>&#13;
<pre class="pre1"><code>Output integers using iterators: 1 2 3 4 5 6 7 8 9</code></pre>&#13;
</div>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> The loop continues as long as <code>constIterator</code> has not reached the end of the <strong><code>vector</code></strong>. This is determined by comparing <code>constIterator</code> to the result of calling the <strong><code>vector</code></strong>’s <span class="violet"><strong><code>cend</code></strong></span> member function, which returns a <strong><code>const_iterator</code></strong> indicating the location past the last element of the <strong><code>vector</code></strong>. If <code>constIterator</code> is equal to this value, the end of the <strong><code>vector</code></strong> has been reached. <strong>Attempting to dereference an iterator positioned outside its container is a runtime logic error—the iterator returned by <code>end</code> or <code>cend</code> should never be dereferenced or incremented.</strong></p>&#13;
<p>The loop body dereferences <code>constIterator</code> to get the current element’s value. Remember that the iterator acts like a pointer to the element and that operator <code>*</code> is overloaded to return a reference to the element. The expression <code>++constIterator</code> (line 29) positions the iterator to the <strong><code>vector</code></strong>’s next element. Note that you can replace this loop with the following range-based <code>for</code> statement:</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p709pro01" id="p709pro01a">Click here to view code image</a></p>&#13;
<pre class="pre"><span class="blue">for</span> (<span class="blue">auto</span> <span class="blue">const</span>&amp; item : integers) {&#13;
   cout &lt;&lt; item &lt;&lt; <span class="green">' '</span>;&#13;
}</pre>&#13;
<p>The range-based <code>for</code> uses iterators “behind the scenes.”</p>&#13;
<h5 class="h5" id="ch13lev3sec18">Displaying the <code>vector</code>’s Contents in Reverse with <strong><code>const_reverse_iterator</code></strong>s</h5>&#13;
<p>Lines 36–39 use a <code>for</code> statement (similar to the one in <code>printVector</code>) to iterate through the <strong><code>vector</code></strong> in reverse. The <strong><code>vector</code></strong> member functions <span class="violet"><strong><code>crbegin</code></strong></span> and <span class="violet"><strong><code>crend</code></strong></span> each return <strong><code>const_reverse_iterator</code>s</strong> that represent the starting and ending points when iterating through a container in reverse. Most sequence containers and associative containers support this type of iterator. Class <strong><code>vector</code></strong> also provides member functions <span class="violet"><strong><code>rbegin</code></strong></span> and <span class="violet"><strong><code>rend</code></strong></span> to obtain <strong>non-<code>const reverse_iterator</code>s</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p709pro02" id="p709pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>33</strong></span>      std::cout &lt;&lt; <span class="green">"\nOutput integers in reverse using iterators: "</span>;&#13;
<span class="cviolet"><strong>34</strong></span>&#13;
<span class="cviolet"><strong>35</strong></span>      <span class="lgreen">// display vector in reverse order using const_reverse_iterator</span>&#13;
<span class="cviolet"><strong>36</strong></span>      <span class="blue">for</span> (<span class="blue">auto</span> reverseIterator{integers.crbegin()};&#13;
<span class="cviolet"><strong>37</strong></span>         <code>reverseIterator != integers.crend(); ++reverseIterator) {</code>&#13;
<span class="cviolet"><strong>38</strong></span>         std::cout &lt;&lt; *reverseIterator &lt;&lt; <span class="green">' '</span>;&#13;
<span class="cviolet"><strong>39</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>40</strong></span>&#13;
<span class="cviolet"><strong>41</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>42</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Output integers in reverse using iterators: 9 8 7 6 5 4 3 2 1</code></pre>&#13;
</div>&#13;
<h5><span class="size">11</span> C++11: <strong><code>shrink_to_fit</code></strong></h5>&#13;
<p>As of C++11, you can call member function <span class="violet"><strong><code>shrink_to_fit</code></strong></span> to request that a <strong><code>vector</code></strong> or <strong><code>deque</code></strong> return unneeded memory to the system, reducing its capacity to the container’s current number of elements. According to the C++ standard, implementations can ignore this request so that they can perform implementation-specific optimizations.</p>&#13;
<h4 class="h4" id="sec13_6_2">13.6.2 <code>vector</code> Element-Manipulation Functions</h4>&#13;
<p><a href="ch13.xhtml#fig13_3">Figure 13.3</a> illustrates functions for retrieving and manipulating <strong><code>vector</code></strong> elements. Line 12 initializes a <strong><code>vector</code></strong><code>&lt;int&gt;</code> with the <strong><code>vector</code></strong> constructor that receives a braced initializer. In this case, we declared the <strong><code>vector</code></strong>’s type as <code>std::</code><strong><code>vector</code></strong> and the compiler inferred the element type from the <code>int</code> values in the initializer list. Allowing the compiler to infer the element type is known as <strong><span class="violet">class template argument deduction (CTAD)</span></strong>. Line 13 uses a <strong><code>vector</code></strong> constructor that takes two iterators as arguments to initialize <code>integers</code> with a copy of the elements from the beginning (<strong><code>values.cbegin()</code></strong>) up to, but not including, the end (<strong><code>values.cend()</code></strong>) of the <strong><code>vector</code></strong> <code>values</code>.</p>&#13;
<div class="group" id="fig13_3">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro03" id="p13pro03a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_03.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Testing standard library vector class template</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="lgreen">// element-manipulation functions.</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt; <span class="lgreen">// copy algorithm</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// C++20: This will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;ranges&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator iterator</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>12</strong></span>      std::vector values{<span class="green">1</span>, <span class="green">2</span>, <span class="green">3</span>, <span class="green">4</span>, <span class="green">5</span>}; <span class="lgreen">// class template argument deduction</span>&#13;
<span class="cviolet"><strong>13</strong></span>      std::vector&lt;<span class="blue">int</span>&gt; integers{values.cbegin(), values.cend()};&#13;
<span class="cviolet"><strong>14</strong></span>      std::ostream_iterator&lt;<span class="blue">int</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>15</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.3</strong></span> | <code>vector</code> container element-manipulation functions.</p>&#13;
</div>&#13;
<h5><code>ostream_iterator</code></h5>&#13;
<p>Line 14 defines an <strong><code>ostream_iterator</code></strong> called <code>output</code> that can be used to output integers separated by single spaces via <code>cout</code>. An <strong><code>ostream_iterator&lt;int&gt;</code></strong> outputs only values of type <code>int</code> or a compatible type. The first argument to the constructor specifies the output stream, and the second argument is a string specifying the separator for the values output—in this case, the string contains a space character. We use the <strong><code>ostream_iterator</code></strong> (defined in header <strong><code>&lt;iterator&gt;</code></strong>) to output the contents of the <strong><code>vector</code></strong> in this example.</p>&#13;
<h5><code>copy</code> Algorithm</h5>&#13;
<p>Line 17 uses standard library algorithm <span class="violet"><strong><code>copy</code></strong></span> (from header <span class="violet"><strong><code>&lt;algorithm&gt;</code></strong></span>) to output the entire contents of <code>integers</code> to the standard output. This version of the algorithm takes three arguments. The first two are iterators that specify the elements to copy from <strong><code>vector</code></strong> <code>integers</code>—from its beginning (<strong><code>integers.cbegin()</code></strong>) up to, but not including, its end (<strong><code>integers.cend()</code></strong>). These two arguments must satisfy <strong>input iterator</strong> requirements, enabling values to be read from a container, such as <strong><code>const_iterator</code>s</strong>. They must also represent a elements in the same container such that applying <code>++</code> to the first iterator repeatedly eventually causes it to reach the second iterator argument. The elements are copied to the location specified by the third argument, which must be an <strong>output iterator</strong> through which a value can be stored or output. In this case, the output iterator is an <strong>ostream_iterator</strong> attached to <code>cout</code>, so the elements are copied to the standard output.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p710pro01" id="p710pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>16</strong></span>   std::cout &lt;&lt; <span class="green">"integers contains: "</span>;&#13;
<span class="cviolet"><strong>17</strong></span>   <code>std::copy(integers.cbegin(), integers.cend(), output);</code>&#13;
<span class="cviolet"><strong>18</strong></span></pre>&#13;
<pre class="pre1"><code>integers contains: 1 2 3 4 5</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec19">Common Ranges</h5>&#13;
<p>Prior to C++20, a “range” of container elements to process was described by iterators specifying the starting position and the one-past-the-end position. Such a range often is specified with calls to a container’s <code>begin</code> and <code>end</code> (or similar) member functions, as in line 17. As of C++20, the C++ standard refers to this as a <strong><span class="violet">common range</span></strong>, so that it is not confused by the new C++20 ranges capabilities. From this point forward, we’ll use this the term “common range” when discussing ranges determined by two iterators, and we’ll use the term “range” when discussing C++20 ranges.</p>&#13;
<h5><code>vector</code> Member Functions <strong><code>front</code></strong> and <strong><code>back</code></strong></h5>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Lines 19–20 get the <strong><code>vector</code></strong>’s first and last elements via member functions <span class="violet"><strong><code>front</code></strong></span> and <span class="violet"><strong><code>back</code></strong></span>, which are available in most <strong>sequence containers</strong>. Notice the difference between functions <code>front</code> and <code>begin</code>. Function <code>front</code> returns a reference to the <strong><code>vector</code></strong>’s first element, while function <code>begin</code> returns a <strong>random-access iterator</strong> pointing to the <strong><code>vector</code></strong>’s first element. Similarly, notice the difference between <strong><code>back</code></strong> and <strong><code>end</code></strong>. Function <strong><code>back</code></strong> returns a reference to the <strong><code>vector</code></strong>’s last element, whereas <strong><code>end</code></strong> returns a <strong>random-access iterator</strong> pointing to the location after the last element. The results of <strong><code>front</code></strong> and <strong><code>back</code></strong> are undefined when called on an empty <strong><code>vector</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p711pro01" id="p711pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>19</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"\nfront: {}\nback: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>20</strong></span>                   <code>integers.front(), integers.back());</code>&#13;
<span class="cviolet"><strong>21</strong></span></pre>&#13;
<pre class="pre1"><code>front: 1</code>&#13;
<code>back: 5</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec20">Accessing <code>vector</code> Elements</h5>&#13;
<p>Lines 22–23 illustrate two ways to access <strong><code>vector</code></strong> elements. These can also be used with <strong><code>deque</code></strong> containers. Line 22 uses the subscript operator that’s overloaded to return either a reference to the value at the specified location or a reference to that <code>const</code> value, depending on whether the container is <code>const</code>. Function <code>at</code> (line 23) performs the same operation, but with <strong>bounds checking</strong>. The <code>at</code> member function first checks its argument and determines whether it’s in the <strong><code>vector</code></strong>’s bounds. If not, function <code>at</code> throws an <strong><code>out_of_range</code></strong> exception (which we demonstrated in Section 6.17).</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p711pro02" id="p711pro02a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"><strong>22</strong></span>   integers[<span class="green">0</span>] = <span class="green">7</span>; <span class="lgreen">// set first element to 7</span>&#13;
<span class="cviolet"><strong>23</strong></span>   integers.at(<span class="green">2</span>) = <span class="green">10</span>; <span class="lgreen">// set element at position 2 to 10</span>&#13;
<span class="cviolet"><strong>24</strong></span></pre>&#13;
</div>&#13;
<h5><code>vector</code> Member Function <strong><code>insert</code></strong></h5>&#13;
<p>Line 26 uses one of the several overloaded <span class="violet"><strong><code>insert</code></strong></span> <strong><span class="violet">member functions</span></strong> provided by each <strong>sequence container</strong> (except <strong><code>array</code></strong>, which has a fixed size, and <strong><code>forward_list</code></strong>, which has the function <code>insert_after</code> instead). Line 26 inserts the value 22 before the element at the location specified by the iterator in the first argument. Here, the iterator points to the <strong><code>vector</code></strong>’s second element, so 22 is inserted as the second element and the original second element becomes the third element. Other versions of <code>insert</code> allow</p>&#13;
<p class="bull">• inserting multiple copies of the same value starting at a particular position, or</p>&#13;
<p class="bull">• inserting a range of values from another container, starting at a particular position.</p>&#13;
<p>The version of member function <strong><code>insert</code></strong> in line 26 returns an iterator pointing to the item that was inserted.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p712pro01" id="p712pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>25</strong></span>   <span class="lgreen">// insert 22 as 2nd element</span>&#13;
<span class="cviolet"><strong>26</strong></span>   integers.insert(integers.cbegin() + <span class="green">1</span>, <span class="green">22</span>);&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>   std::cout &lt;&lt; <span class="green">"Contents of vector integers after changes: "</span>;&#13;
<span class="cviolet"><strong>29</strong></span>   <code>std::ranges::copy(integers, output);</code>&#13;
<span class="cviolet"><strong>30</strong></span></pre>&#13;
<pre class="pre1"><code>Contents of vector integers after changes: 7 22 2 10 4 5</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec21"><span class="size">20</span> C++20 Ranges Algorithm <code>copy</code></h5>&#13;
<p>Line 29 uses the C++20 <span class="violet"><strong><code>copy</code></strong></span><strong><span class="violet"> algorithm</span></strong> from the <span class="violet"><strong><code>std::ranges</code></strong></span> <strong><span class="violet">namespace</span></strong> to copy the elements of integers to the standard output. This version of <strong>C++20 ranges</strong> version of <code>copy</code> receives only the range to copy and the output iterator representing where to copy the range’s elements. The first argument is an <strong>object that represents a range of elements</strong> and has <strong>input iterators</strong> representing its beginning and end—in this case, a <strong><code>vector</code></strong>. Most of the pre-C++20 algorithms in the <strong><code>&lt;algorithm&gt;</code></strong> header now have versions in the <strong><code>std</code></strong> namespace and in the <strong><code>std::ranges</code></strong> namespace. The <strong><code>std::ranges</code></strong> algorithms typically are overloaded with a version that takes a <strong>range object</strong> and a version that takes an iterator and a sentinel. In the context of C++20 ranges, a <strong><span class="violet">sentinel</span></strong> is an object that represents when the end of the container has been reached. Though many of the standard library algorithms now have C++20 ranges versions, <strong>some common-ranges algorithms were not overloaded with C++20 ranges versions for C++20</strong>. We’ll demonstrate many C++20 ranges algorithms in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>&#13;
<h5><code>vector</code> Member Function <strong><code>erase</code></strong></h5>&#13;
<p>Lines 31 and 36 use the two <span class="violet"><strong><code>erase</code></strong></span> member functions that are available in most <strong>sequence containers</strong> and <strong>associative containers</strong>—except <strong><code>array</code></strong>, which has a fixed size, and <strong><code>forward_list</code></strong>, which has the function <strong><code>erase_after</code></strong> instead. Line 31 erases the element at the location specified by its iterator argument—in this case, the first element. Line 36 specifies that all elements in the range specified by the two iterator arguments should be erased— in this case, all the elements are erased. Line 38 uses member function <span class="violet"><strong><code>empty</code></strong></span> (available for all containers and adaptors) to confirm that the <strong><code>vector</code></strong> is empty.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p712pro02" id="p712pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>31</strong></span>   integers.erase(integers.cbegin()); <span class="lgreen">// erase first element</span>&#13;
<span class="cviolet"><strong>32</strong></span>   std::cout &lt;&lt; <span class="green">"\n\nintegers after erasing first element: "</span>;&#13;
<span class="cviolet"><strong>33</strong></span>   <code>std::ranges::copy(integers, output);</code>&#13;
<span class="cviolet"><strong>34</strong></span>&#13;
<span class="cviolet"><strong>35</strong></span>   <span class="lgreen">// erase remaining elements</span>&#13;
<span class="cviolet"><strong>36</strong></span>   <code>integers.erase(integers.cbegin(), integers.cend());</code>&#13;
<span class="cviolet"><strong>37</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"\nErased all elements: integers {} empty\n"</span>,&#13;
<span class="cviolet"><strong>38</strong></span>                   integers.empty() ? <span class="green">"is"</span> : <span class="green">"is not"</span>);&#13;
<span class="cviolet"><strong>39</strong></span></pre>&#13;
<pre class="pre1"><code>integers after erasing first element: 22 2 10 4 5</code>&#13;
<code>Erased all elements: integers is empty</code></pre>&#13;
</div>&#13;
<p><span class="size">Err</span><img class="inline" src="Images/err.jpg" alt="Images" width="30" height="30"/> Normally <code>erase</code> destroys the objects that are erased from a container. However, <strong>erasing an element that is a pointer to a dynamically allocated object does not <code>delete</code> the object, potentially causing a memory leak</strong>. If the element is a <strong><code>unique_ptr</code></strong> (<a href="ch11.xhtml#sec11_5">Section 11.5</a>), the <strong><code>unique_ptr</code></strong> would be destroyed and the dynamically allocated memory would be deleted. If the element is a <strong><code>shared_ptr</code></strong> (<a href="ch19.xhtml#ch19">Chapter 19</a>), the reference count to the dynamically allocated object would be decremented and the memory would be deleted only if the reference count reached <code>0</code>.</p>&#13;
<h5><code>vector</code> Member Function <strong><code>insert</code></strong> with Three Arguments (Range <strong><code>insert</code></strong>)</h5>&#13;
<p>Line 41 demonstrates the version of function <strong><code>insert</code></strong> that uses the second and third arguments to specify the starting location and ending location in a sequence of values (in this case, from the <strong><code>vector</code></strong> <code>values</code>) that should be inserted into the <strong><code>vector</code></strong>. Remember that the ending location specifies the position in the sequence <strong>after</strong> the last element to be inserted; copying occurs up to, but not including, this location. This version of member function <strong><code>insert</code></strong> returns an iterator pointing to the first item that was inserted—if nothing was inserted, the function returns its first argument.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p713pro01" id="p713pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>40</strong></span>   <span class="lgreen">// insert elements from the vector values</span>&#13;
<span class="cviolet"><strong>41</strong></span>   <code>integers.insert(integers.cbegin(), values.cbegin(), values.cend());</code>&#13;
<span class="cviolet"><strong>42</strong></span>   std::cout &lt;&lt; <span class="green">"\nContents of vector integers before clear: "</span>;&#13;
<span class="cviolet"><strong>43</strong></span>   <code>std::ranges::copy(integers, output);</code>&#13;
<span class="cviolet"><strong>44</strong></span></pre>&#13;
<pre class="pre1"><code>Contents of vector integers before clear: 1 2 3 4 5</code></pre>&#13;
</div>&#13;
<h5><code>vector</code> Member Function <strong><code>clear</code></strong></h5>&#13;
<p>Finally, line 46 uses member function <span class="violet"><strong><code>clear</code></strong></span> to empty the <strong><code>vector</code></strong>. All sequence containers and associative containers except <strong><code>array</code></strong>, which is fixed in size, provide member function <strong><code>clear</code></strong>. <strong>This does not reduce the <code>vector</code>’s capacity.</strong></p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p713pro02" id="p713pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>45</strong></span>   <span class="lgreen">// empty integers; clear calls erase to empty a collection</span>&#13;
<span class="cviolet"><strong>46</strong></span>   <code>integers.clear();</code>&#13;
<span class="cviolet"><strong>47</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"\nAfter clear, integers {} empty\n"</span>,&#13;
<span class="cviolet"><strong>48</strong></span>                   integers.empty() ? <span class="green">"is"</span> : <span class="green">"is not"</span>);&#13;
<span class="cviolet"><strong>49</strong></span>   }</pre>&#13;
<pre class="pre1"><code>After clear, integers is empty</code></pre>&#13;
</div>&#13;
<h3 class="h3" id="sec13_7"><span class="violet">13.7</span> <code>list</code> Sequence Container</h3>&#13;
<p>The <span class="violet"><strong><code>list</code></strong></span> <strong>sequence container</strong> (from header <span class="violet"><strong><code>&lt;list&gt;</code></strong></span>) allows insertion and deletion operations at any location in the container. If most of the insertions and deletions occur at the ends of the container, the <strong><code>deque</code></strong> data structure (<a href="ch13.xhtml#sec13_8">Section 13.8</a>) provides a more efficient implementation of inserting at the front, which is <strong><em>O</em>(1)</strong> for <strong><code>deque</code></strong> vs. <strong><em>O</em>(<em>n</em>)</strong> for <strong><code>vector</code>.</strong> The <strong><code>list</code></strong> container is implemented as a <strong>doubly linked list</strong><sup><a id="ch13fn10a" href="ch13.xhtml#ch13fn10">10</a></sup>—every node in the <strong><code>list</code></strong> contains a pointer to the previous node in the <strong><code>list</code></strong> and to the next node in the <strong><code>list</code></strong>. This enables <strong><code>list</code></strong>s to support <strong>bidirectional iterators</strong> that allow the container to be traversed both forward and backward. Any algorithm that requires <strong>input</strong>, <strong>output</strong>, <strong>forward</strong> or <strong>bidirectional iterators</strong> can operate on a <strong><code>list</code></strong>. Many <strong><code>list</code></strong> member functions manipulate the elements of the container as an ordered set of elements.</p>&#13;
<p class="footnote"><a id="ch13fn10" href="ch13.xhtml#ch13fn10a">10</a>. “<code>std::list</code>.” Accessed April 11, 2021. <code><a href="https://en.cppreference.com/w/cpp/container/list">https://en.cppreference.com/w/cpp/container/list</a></code>.</p>&#13;
<h5><code>forward_list</code> Container</h5>&#13;
<p>The <span class="violet"><strong><code>forward_list</code></strong></span> sequence container (<strong>header <code>&lt;forward_list&gt;</code></strong>; added in C++11) is implemented as a <strong>singly linked list</strong>—every node contains a pointer to the next node in the <strong><code>forward_list</code></strong>. This enables a <strong><code>forward_list</code></strong> to support <strong>forward iterators</strong> that allow the container to be traversed in the forward direction. Any algorithm that requires <strong>input</strong>, <strong>output</strong> or <strong>forward iterators</strong> can operate on a <strong><code>forward_list</code></strong>.</p>&#13;
<h5><code>list</code> Member Functions</h5>&#13;
<p>In addition to the member functions in <a href="ch11.xhtml#fig11_2">Fig. 11.2</a> and the common member functions of all <strong>sequence containers</strong> discussed in <a href="ch13.xhtml#sec13_5">Section 13.5</a>, the <strong><code>list</code></strong> container provides other member functions, including <strong><code>splice</code></strong>, <strong><code>push_front</code></strong>, <strong><code>pop_front</code></strong>, <strong><code>remove</code></strong>, <strong><code>remove_if</code></strong>, <strong><code>unique</code></strong>, <strong><code>merge</code></strong>, <strong><code>reverse</code></strong> and <strong><code>sort</code></strong>. Several of these member functions are <strong><code>list</code></strong>-optimized implementations of the standard library algorithms presented in <a href="ch14.xhtml#ch14">Chapter 14</a>. Both <strong><code>push_front</code></strong> and <strong><code>pop_front</code></strong> are also supported by <strong><code>forward_list</code></strong> and <strong><code>deque</code></strong>. <a href="ch13.xhtml#fig13_4">Figure 13.4</a> demonstrates several features of class <strong><code>list</code></strong>. Remember that many of the functions presented in Figs. 13.2–13.3 can be used with the <strong><code>list</code></strong> container, so we focus on the new features in this example’s discussion.</p>&#13;
<div class="group" id="fig13_4">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro04" id="p13pro04a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_04.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library list class template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt; <span class="lgreen">// copy algorithm</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator</span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;list&gt; <span class="lgreen">// list class-template definition</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="lgreen">// printList function template definition; uses</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="lgreen">// ostream_iterator and copy algorithm to output list elements</span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">template</span> &lt;<span class="blue">typename</span> T&gt;&#13;
<span class="cviolet"><strong>12</strong></span>   <span class="blue">void</span> printList(<span class="blue">const</span> std::list&lt;T&gt;&amp; items) {&#13;
<span class="cviolet"><strong>13</strong></span>      <span class="blue">if</span> (items.empty()) { <span class="lgreen">// list is empty</span>&#13;
<span class="cviolet"><strong>14</strong></span>         std::cout &lt;&lt; <span class="green">"List is empty"</span>;&#13;
<span class="cviolet"><strong>15</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>16</strong></span>      <span class="blue">else</span> {&#13;
<span class="cviolet"><strong>17</strong></span>         std::ostream_iterator&lt;T&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>18</strong></span>         <code>std::ranges::copy(items, output);</code>&#13;
<span class="cviolet"><strong>19</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>20</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>21</strong></span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.4</strong></span> | Standard library <code>list</code> class template.</p>&#13;
</div>&#13;
<p>Function template <code>printList</code> (lines 11–20) checks whether its <strong><code>list</code></strong> argument is <code>empty</code> (line 13) and, if so, displays an appropriate message. Otherwise, <code>printList</code> uses an <strong><code>ostream_iterator</code></strong> and the <strong><code>std::ranges::copy</code></strong> algorithm to copy the <strong><code>list</code></strong>’s elements to the standard output, as shown in <a href="ch13.xhtml#fig13_3">Fig. 13.3</a>.</p>&#13;
<h5 class="h5" id="ch13lev3sec22">Creating a <code>list</code> Object</h5>&#13;
<p>Line 23 creates a <strong><code>list</code></strong> object capable of storing <code>int</code>s. Lines 26–27 use <strong><code>list</code></strong> member function <span class="violet"><strong><code>push_front</code></strong></span> to insert integers at the beginning of <code>values</code>. This member function is specific to classes <strong><code>forward_list</code></strong>, <strong><code>list</code></strong> and <strong><code>deque</code></strong>. Lines 28–29 use <strong><code>push_back</code></strong> to append integers to <code>values</code>. <strong>Function <code>push_back</code> is common to all sequence containers</strong>, except <strong><code>array</code></strong> and <strong><code>forward_list</code></strong>. Lines 31–32 show the current contents of <code>values</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p715pro01" id="p715pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>22</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>23</strong></span>      std::list&lt;<span class="blue">int</span>&gt; values{}; <span class="lgreen">// create list of ints</span>&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>      <span class="lgreen">// insert items in values</span>&#13;
<span class="cviolet"><strong>26</strong></span>      values.push_front(<span class="green">1</span>);&#13;
<span class="cviolet"><strong>27</strong></span>      values.push_front(<span class="green">2</span>);&#13;
<span class="cviolet"><strong>28</strong></span>      values.push_back(<span class="green">4</span>);&#13;
<span class="cviolet"><strong>29</strong></span>      values.push_back(<span class="green">3</span>);&#13;
<span class="cviolet"><strong>30</strong></span>   &#13;
<span class="cviolet"><strong>31</strong></span>      std::cout &lt;&lt; <span class="green">"values contains: "</span>;&#13;
<span class="cviolet"><strong>32</strong></span>      <code>printList(values);</code>&#13;
<span class="cviolet"><strong>33</strong></span></pre>&#13;
<pre class="pre1"><code>values contains: 2 1 4 3</code></pre>&#13;
</div>&#13;
<h5><code>list</code> Member Function <strong><code>sort</code></strong></h5>&#13;
<p>Line 34 uses <strong><code>list</code></strong> member function <span class="violet"><strong><code>sort</code></strong></span> to arrange the elements in the <strong><code>list</code></strong> in ascending order. A second version of function <code>sort</code> allows you to supply a <strong>binary predicate function</strong> that takes two arguments (values in the <strong><code>list</code></strong>), performs a comparison and returns a <code>bool</code> value indicating whether the first argument should come before the second in the sorted contents. This function determines the order in which the elements of the <strong><code>list</code></strong> are sorted. This version could be particularly useful for a <strong><code>list</code></strong> that stores pointers rather than values.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p715pro02" id="p715pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>34</strong></span>   values.sort(); <span class="lgreen">// sort values</span>&#13;
<span class="cviolet"><strong>35</strong></span>   std::cout &lt;&lt; <span class="green">"\nvalues after sorting contains: "</span>;&#13;
<span class="cviolet"><strong>36</strong></span>   <code>printList(values);</code>&#13;
<span class="cviolet"><strong>37</strong></span>   &#13;
<span class="cviolet"><strong>38</strong></span></pre>&#13;
<pre class="pre1"><code>values after sorting contains: 1 2 3 4</code></pre>&#13;
</div>&#13;
<h5><code>list</code> Member Function <strong><code>splice</code></strong></h5>&#13;
<p>Line 37 uses <strong><code>list</code></strong> member function <span class="violet"><strong><code>splice</code></strong></span> to remove the elements in <code>otherValues</code> and insert them into <code>values</code> before the iterator position specified as the first argument. Function <strong><code>splice</code></strong> with three arguments allows one element to be removed from the container specified as the second argument from the location specified by the iterator in the third argument. Function <strong><code>splice</code></strong> with four arguments uses the last two arguments to specify a range of locations that should be removed from the container in the second argument and placed at the location specified in the first argument. A <strong><code>forward_list</code></strong> provides a similar member function named <strong><code>splice_after</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p716pro01" id="p716pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>39</strong></span>   <span class="lgreen">// insert elements of ints into otherValues</span>&#13;
<span class="cviolet"><strong>40</strong></span>   std::vector ints{<span class="green">2</span>, <span class="green">6</span>, <span class="green">4</span>, <span class="green">8</span>};&#13;
<span class="cviolet"><strong>41</strong></span>   std::list&lt;<span class="blue">int</span>&gt; otherValues{}; <span class="lgreen">// create list of ints</span>&#13;
<span class="cviolet"><strong>42</strong></span>   <code>otherValues.insert(otherValues.cbegin(), ints.cbegin(), ints.cend());</code>&#13;
<span class="cviolet"><strong>43</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter insert, otherValues contains: "</span>;&#13;
<span class="cviolet"><strong>44</strong></span>   <code>printList(otherValues);</code>&#13;
<span class="cviolet"><strong>45</strong></span>&#13;
<span class="cviolet"><strong>46</strong></span>   <span class="lgreen">// remove otherValues elements and insert at end of values</span>&#13;
<span class="cviolet"><strong>47</strong></span>   <code>values.splice(values.cend(), otherValues);</code>&#13;
<span class="cviolet"><strong>48</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter splice, values contains: "</span>;&#13;
<span class="cviolet"><strong>49</strong></span>   printList(values);</pre>&#13;
<pre class="pre1"><code>After insert, otherValues contains: 2 6 4 8</code>&#13;
<code>After splice, values contains: 1 2 3 4 2 6 4 8</code></pre>&#13;
</div>&#13;
<h5><code>list</code> Member Function <strong><code>merge</code></strong></h5>&#13;
<p>After inserting more elements in <code>otherValues</code> and sorting both <code>values</code> and <code>otherValues</code>, line 61 uses <strong><code>list</code></strong> member function <span class="violet"><strong><code>merge</code></strong></span> to remove all elements of <code>otherValues</code> and insert them in sorted order into <code>values</code>. Both <strong><code>list</code></strong>s must be sorted in the same order before this operation is performed. A second version of <strong><code>merge</code></strong> enables you to supply a <strong>binary predicate function</strong> that takes two arguments (values in the <strong><code>list</code></strong>) and returns a <code>bool</code> value. The predicate function specifies the sorting order used by <strong><code>merge</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p716pro02" id="p716pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>50</strong></span>   values.sort(); <span class="lgreen">// sort values</span>&#13;
<span class="cviolet"><strong>51</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter sort, values contains: "</span>;&#13;
<span class="cviolet"><strong>52</strong></span>   <code>printList(values);</code>&#13;
<span class="cviolet"><strong>53</strong></span>&#13;
<span class="cviolet"><strong>54</strong></span>   <span class="lgreen">// insert elements of ints into otherValues</span>&#13;
<span class="cviolet"><strong>55</strong></span>   <code>otherValues.insert(otherValues.cbegin(), ints.cbegin(), ints.cend());</code>&#13;
<span class="cviolet"><strong>56</strong></span>   otherValues.sort(); <span class="lgreen">// sort the list</span>&#13;
<span class="cviolet"><strong>57</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter insert and sort, otherValues contains: "</span>;&#13;
<span class="cviolet"><strong>58</strong></span>   <code>printList(otherValues);</code>&#13;
<span class="cviolet"><strong>59</strong></span>   &#13;
<span class="cviolet"><strong>60</strong></span>   <span class="lgreen">// remove otherValues elements and insert into values in sorted order</span>&#13;
<span class="cviolet"><strong>61</strong></span>   <code>values.merge(otherValues);</code>&#13;
<span class="cviolet"><strong>62</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter merge:\n values contains: ";</span>&#13;
<span class="cviolet"><strong>63</strong></span>   <code>printList(values);</code>&#13;
<span class="cviolet"><strong>64</strong></span>   std::cout &lt;&lt; <span class="green">"\n otherValues contains: ";</span>&#13;
<span class="cviolet"><strong>65</strong></span>   <code>printList(otherValues);</code>&#13;
<span class="cviolet"><strong>66</strong></span></pre>&#13;
<pre class="pre1"><code>After sort, values contains: 1 2 2 3 4 4 6 8</code>&#13;
<code>After insert and sort, otherValues contains: 2 4 6 8 After merge:</code>&#13;
<code>   values contains: 1 2 2 2 3 4 4 4 6 6 8 8</code>&#13;
<code>   otherValues contains: List is empty</code></pre>&#13;
</div>&#13;
<h5><code>list</code> Member Function <strong><code>pop_front</code></strong> and <strong><code>pop_back</code></strong></h5>&#13;
<p>Line 67 uses <strong><code>list</code></strong> member function <span class="violet"><strong><code>pop_front</code></strong></span> to remove the first element in the <strong><code>list</code></strong>. Line 68 uses function <span class="violet"><strong><code>pop_back</code></strong></span> to remove the last element in the <strong><code>list</code></strong>. This function is available for <strong>sequence containers</strong> other than <strong><code>array</code></strong> and <strong><code>forward_list</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p717pro01" id="p717pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>67</strong></span>   values.pop_front(); <span class="lgreen">// remove element from front</span>&#13;
<span class="cviolet"><strong>68</strong></span>   values.pop_back(); <span class="lgreen">// remove element from back</span>&#13;
<span class="cviolet"><strong>69</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter pop_front and pop_back:\n values contains: ";</span>&#13;
<span class="cviolet"><strong>70</strong></span>   <code>printList(values);</code>&#13;
<span class="cviolet"><strong>71</strong></span></pre>&#13;
<pre class="pre1"><code>After pop_front and pop_back:</code>&#13;
<code>   values contains: 2 2 2 3 4 4 4 6 6 8</code></pre>&#13;
</div>&#13;
<h5><code>list</code> Member Function <strong><code>unique</code></strong></h5>&#13;
<p>Line 72 uses <strong><code>list</code></strong> function <span class="violet"><strong><code>unique</code></strong></span> to <strong>remove duplicate elements</strong> in the <strong><code>list</code></strong>. The <strong><code>list</code></strong> should be in sorted order (so that all duplicates are side by side) before this operation is performed, to <strong>guarantee that all duplicates are eliminated</strong>. A second version of <strong><code>unique</code></strong> enables you to supply a <strong>predicate function</strong> that takes two arguments (values in the <strong><code>list</code></strong>) and returns a <code>bool</code> value specifying whether two elements are equal.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p717pro02" id="p717pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>72</strong></span>   values.unique(); <span class="lgreen">// remove duplicate elements</span>&#13;
<span class="cviolet"><strong>73</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter unique, values contains: "</span>;&#13;
<span class="cviolet"><strong>74</strong></span>   <code>printList(values);</code>&#13;
<span class="cviolet"><strong>75</strong></span></pre>&#13;
<pre class="pre1"><code>After unique, values contains: 2 3 4 6 8</code></pre>&#13;
</div>&#13;
<h5><code>list</code> Member Function <strong><code>swap</code></strong></h5>&#13;
<p>Line 76 uses <strong><code>list</code></strong> member function <span class="violet"><strong><code>swap</code></strong></span> to exchange the contents of <code>values</code> with the contents of <code>otherValues</code>. This function is available to all <strong>sequence containers</strong> and <strong>associative containers</strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p717pro03" id="p717pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>76</strong></span>   values.swap(otherValues); <span class="lgreen">// swap elements of values and otherValues</span>&#13;
<span class="cviolet"><strong>77</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter swap:\n values contains: ";</span>&#13;
<span class="cviolet"><strong>78</strong></span>   <code>printList(values);</code>&#13;
<span class="cviolet"><strong>79</strong></span>   std::cout &lt;&lt; <span class="green">"\n otherValues contains: ";</span>&#13;
<span class="cviolet"><strong>80</strong></span>   <code>printList(otherValues);</code>&#13;
<span class="cviolet"><strong>81</strong></span></pre>&#13;
<pre class="pre1"><code>After swap:</code>&#13;
<code>   values contains: List is empty</code>&#13;
<code>   otherValues contains: 2 3 4 6 8</code></pre>&#13;
</div>&#13;
<h5><code>list</code> Member Functions <strong><code>assign</code></strong> and <strong><code>remove</code></strong></h5>&#13;
<p>Line 83 uses <strong><code>list</code></strong> member function <span class="violet"><strong><code>assign</code></strong></span> (available to all <strong>sequence containers</strong>) to replace the contents of <code>values</code> with the contents of <code>otherValues</code> in the range specified by the two iterator arguments. A second version of <strong><code>assign</code></strong> replaces the original contents with copies of the value specified in the second argument. The first argument of the function specifies the number of copies. Line 92 uses <strong><code>list</code></strong> member function <span class="violet"><strong><code>remove</code></strong></span> to delete all copies of the value <code>4</code> from the <strong><code>list</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p718pro01" id="p718pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>82</strong></span>      <span class="lgreen">// replace contents of values with elements of otherValues</span>&#13;
<span class="cviolet"><strong>83</strong></span>      <code>values.assign(otherValues.cbegin(), otherValues.cend());</code>&#13;
<span class="cviolet"><strong>84</strong></span>      std::cout &lt;&lt; <span class="green">"\nAfter assign, values contains: "</span>;&#13;
<span class="cviolet"><strong>85</strong></span>      <code>printList(values);</code>&#13;
<span class="cviolet"><strong>86</strong></span>&#13;
<span class="cviolet"><strong>87</strong></span>      <span class="lgreen">// remove otherValues elements and insert into values in sorted order</span>&#13;
<span class="cviolet"><strong>88</strong></span>      <code>values.merge(otherValues);</code>&#13;
<span class="cviolet"><strong>89</strong></span>      std::cout &lt;&lt; <span class="green">"\nAfter merge, values contains: "</span>;&#13;
<span class="cviolet"><strong>90</strong></span>      <code>printList(values);</code>&#13;
<span class="cviolet"><strong>91</strong></span>      &#13;
<span class="cviolet"><strong>92</strong></span>      values.remove(<span class="green">4</span>); <span class="lgreen">// remove all 4s</span>&#13;
<span class="cviolet"><strong>93</strong></span>      std::cout &lt;&lt; <span class="green">"\nAfter remove(4), values contains: "</span>;&#13;
<span class="cviolet"><strong>94</strong></span>      <code>printList(values);</code>&#13;
<span class="cviolet"><strong>95</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>96</strong></span>   }</pre>&#13;
<pre class="pre1"><code>After assign, values contains: 2 3 4 6 8</code>&#13;
<code>After merge, values contains: 2 2 3 3 4 4 6 6 8 8</code>&#13;
<code>After remove(4), values contains: 2 2 3 3 6 6 8 8</code></pre>&#13;
</div>&#13;
<h3 class="h3" id="sec13_8"><span class="violet">13.8</span> <code>deque</code> Sequence Container</h3>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Class <span class="violet"><strong><code>deque</code></strong></span> provides many of the benefits of a <strong><code>vector</code></strong> and a <strong><code>list</code></strong> in one container. The term <strong><code>deque</code></strong> is short for “double-ended queue.” Class <strong><code>deque</code></strong> is implemented to provide efficient indexed access (using subscripting) for reading and modifying its elements, much like a <strong><code>vector</code></strong>. Class <strong><code>deque</code></strong> is also implemented for <strong>efficient insertion and deletion operations at its front and back</strong>, much like a <strong><code>list</code></strong> (although a <strong><code>list</code></strong> is also capable of efficient insertions and deletions in the middle). Class <strong><code>deque</code></strong> provides support for <strong>random-access iterators</strong>, so <strong><code>deque</code></strong>s can be used with all standard library algorithms. One of the most common uses of a <strong><code>deque</code></strong> is to maintain a first-in, first-out queue of elements. In fact, a <strong><code>deque</code></strong> is the default underlying implementation for the <strong><code>queue</code></strong> adaptor<sup><a id="ch13fn11a" href="ch13.xhtml#ch13fn11">11</a></sup> (<a href="ch13.xhtml#sec13_10_2">Section 13.10.2</a>).</p>&#13;
<p class="footnote"><a id="ch13fn11" href="ch13.xhtml#ch13fn11a">11</a>. “<code>std::queue</code>.” Accessed April 11, 2021. <code><a href="https://en.cppreference.com/w/cpp/container/queue">https://en.cppreference.com/w/cpp/container/queue</a></code>.</p>&#13;
<p>Additional storage for a <strong><code>deque</code></strong> can be allocated at either end in blocks of memory that are typically maintained as a <strong>built-in array of pointers to those blocks</strong>.<sup><a id="ch13fn12a" href="ch13.xhtml#ch13fn12">12</a></sup> Due to a <strong><code>deque</code>’s noncontiguous memory layout</strong>, its iterators must be more “intelligent” than the pointers that are used to iterate through <strong><code>vector</code></strong>s, <strong><code>array</code></strong>s or built-in arrays. A <strong><code>deque</code></strong> provides the same basic operations as <strong><code>vector</code></strong>, but like <strong><code>list</code></strong> adds member functions <span class="violet"><strong><code>push_front</code></strong></span> and <span class="violet"><strong><code>pop_front</code></strong></span> for efficient insertion and deletion at the beginning of the <strong><code>deque</code></strong>.</p>&#13;
<p class="footnote"><a id="ch13fn12" href="ch13.xhtml#ch13fn12a">12</a>. This is an implementation-specific detail, not a requirement of the C++ standard.</p>&#13;
<p><a href="ch13.xhtml#fig13_5">Figure 13.5</a> demonstrates features of class <strong><code>deque</code></strong>. Remember that many of the functions presented in Figs. 13.2–<a href="ch13.xhtml#fig13_4">Fig. 13.4</a> also can be used with class <strong><code>deque</code></strong>. Header <span class="violet"><strong><code>&lt;deque&gt;</code></strong></span> must be included to use class <strong><code>deque</code></strong>.</p>&#13;
<div class="group" id="fig13_5">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro05" id="p13pro05a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_05.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library deque class template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt; <span class="lgreen">// copy algorithm</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;deque&gt; <span class="lgreen">// deque class-template definition</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator</span>&#13;
<span class="cviolet"> <strong>7</strong></span>&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>9</strong></span>      std::deque&lt;<span class="blue">double</span>&gt; values; <span class="lgreen">// create deque of doubles</span>&#13;
<span class="cviolet"><strong>10</strong></span>      std::ostream_iterator&lt;<span class="blue">double</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="lgreen">// insert elements in values</span>&#13;
<span class="cviolet"><strong>13</strong></span>      values.push_front(<span class="green">2.2</span>);&#13;
<span class="cviolet"><strong>14</strong></span>      values.push_front(<span class="green">3.5)</span>;&#13;
<span class="cviolet"><strong>15</strong></span>      values.push_back(<span class="green">1.1</span>);&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>      std::cout &lt;&lt; <span class="green">"values contains: "</span>;&#13;
<span class="cviolet"><strong>18</strong></span>&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="lgreen">// use subscript operator to obtain elements of values</span>&#13;
<span class="cviolet"><strong>20</strong></span>      <span class="blue">for</span> (<span class="blue">size_t</span> i{<span class="green">0</span>}; i &lt; values.size(); ++i) {&#13;
<span class="cviolet"><strong>21</strong></span>      std::cout &lt;&lt; values[i] &lt;&lt; <span class="green">' '</span>;&#13;
<span class="cviolet"><strong>22</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>23</strong></span>&#13;
<span class="cviolet"><strong>24</strong></span>      values.pop_front(); <span class="lgreen">// remove first element</span>&#13;
<span class="cviolet"><strong>25</strong></span>      std::cout &lt;&lt; <span class="green">"\nAfter pop_front, values contains: "</span>;&#13;
<span class="cviolet"><strong>26</strong></span>      <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>27</strong></span>&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="lgreen">// use subscript operator to modify element at location 1</span>&#13;
<span class="cviolet"><strong>29</strong></span>      values[<span class="green">1</span>] = <span class="green">5.4</span>;&#13;
<span class="cviolet"><strong>30</strong></span>      std::cout &lt;&lt; <span class="green">"\nAfter values[1] = 5.4, values contains: "</span>;&#13;
<span class="cviolet"><strong>31</strong></span>      <code>std::ranges::copy(values, output);</code>&#13;
<span class="cviolet"><strong>32</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>33</strong></span>   }</pre>&#13;
<pre class="pre1"><code>values contains: 3.5 2.2 1.1</code>&#13;
<code>After pop_front, values contains: 2.2 1.1</code>&#13;
<code>After values[1] = 5.4, values contains: 2.2 5.4</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.5</strong></span> | Standard library <code>deque</code> class template.</p>&#13;
</div>&#13;
<p>Line 9 instantiates a <strong><code>deque</code></strong> that can store <code>double</code> values. Lines 13–15 use member functions <strong><code>push_front</code></strong> and <strong><code>push_back</code></strong> to insert elements at the beginning and end of the <strong><code>deque</code></strong>.</p>&#13;
<p>Lines 20–22 use the subscript operator to retrieve the value in each element of the <strong><code>deque</code></strong> for output. The condition uses member function <strong><code>size</code></strong> to ensure that we do not attempt to access an element outside the bounds of the <strong><code>deque</code></strong>. We use a counter-controlled <code>for</code> loop here only to demonstrate the <code>[]</code> operator—generally, you should use the range-based <code>for</code> to process all the elements of a container.</p>&#13;
<p>Line 24 uses member function <strong><code>pop_front</code></strong> to demonstrate removing the first element of the <strong><code>deque</code></strong>. Line 29 uses the subscript operator to obtain an <em>lvalue</em>, which we use to assign a new value to element <code>1</code> of the <strong><code>deque</code></strong>.</p>&#13;
<h3 class="h3" id="sec13_9"><span class="violet">13.9</span> Associative Containers</h3>&#13;
<p>The <strong>associative containers</strong> provide <strong>direct access</strong> to store and retrieve elements via <strong><span class="violet">keys</span></strong> (also called <strong><span class="violet">search keys</span></strong>). The four <strong>ordered associative containers</strong> are <strong><code>multiset</code></strong>, <strong><code>set</code></strong>, <strong><code>multimap</code></strong> and <strong><code>map</code></strong>. Each of these maintains its keys in sorted order. There are also four corresponding <strong>unordered associative containers</strong>—<strong><code>unordered_multiset</code></strong>, <strong><code>unordered_set</code></strong>, <strong><code>unordered_multimap</code></strong> and <strong><code>unordered_map</code></strong>—that offer the most of the same capabilities as their ordered counterparts. The primary difference between the ordered and unordered associative containers is that the unordered ones do not maintain their keys in sorted order. In this section, we focus on the <strong>ordered associative containers</strong>.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> For cases in which it’s not necessary to maintain keys in sorted order, the <strong>unordered associative containers</strong> offer better search performance via <strong>hashing</strong>—<strong><em>O</em>(1)</strong> with a worst case of <strong><em>O</em>(<em>n</em>)</strong> vs. <strong><em>O</em>(log <em>n</em>)</strong> for the ordered associative containers.<sup><a id="ch13fn13a" href="ch13.xhtml#ch13fn13">13</a></sup> For an introduction to hashing, see <a href="ch13.xhtml#sec13_13">Section 13.13</a>.</p>&#13;
<p class="footnote"><a id="ch13fn13" href="ch13.xhtml#ch13fn13a">13</a>. “Containers library.” Accessed April 16, 2021. <code><a href="https://en.cppreference.com/w/cpp/container">https://en.cppreference.com/w/cpp/container</a></code>.</p>&#13;
<p><span class="size">17</span> Iterating through an <strong>ordered associative container</strong> traverses it in the sort order for that container. Classes <span class="violet"><strong><code>multiset</code></strong></span> and <span class="violet"><strong><code>set</code></strong></span> provide operations for manipulating sets of values where the values themselves are the keys. <strong>The primary difference between a <code>multiset</code> and a <code>set</code> is that a <code>multiset</code> allows duplicate keys and a <code>set</code> does not.</strong> Classes <span class="violet"><strong><code>multimap</code></strong></span> and <span class="violet"><strong><code>map</code></strong></span> provide operations for manipulating values associated with keys (these values are sometimes referred to as <strong><span class="violet">mapped values</span></strong>). <strong>The primary difference between a <code>multimap</code> and a <code>map</code> is that a <code>multimap</code> allows duplicate keys with associated values to be stored and a <code>map</code> allows only unique keys with associated values.</strong> In addition to the common container member functions, <strong>ordered associative containers</strong> also support several member functions that are specific to associative containers. Like <strong><code>list</code></strong> and <strong><code>forward_list</code></strong>, you can combine the contents of associative containers of the same type using the <strong><code>merge</code></strong> function (added in C++17). Examples of each of the <strong>ordered associative containers</strong> and their common member functions are presented in the next several subsections.</p>&#13;
<h4 class="h4" id="sec13_9_1">13.9.1 <code>multiset</code> Associative Container</h4>&#13;
<p>The <strong><code>multiset</code> ordered associative container</strong> (from header <span class="violet"><strong><code>&lt;set&gt;</code></strong></span>) provides fast storage and retrieval of keys and allows duplicate keys. The elements’ ordering is determined by a <strong><span class="violet">comparator function object</span></strong>. A <strong><span class="violet">function object</span></strong> is an instance of a class that has an overloaded parentheses operator, allowing the object to be “called” like a function. For example, in an integer <strong><code>multiset</code></strong>, elements can be sorted in ascending order by ordering the keys with <strong><span class="violet">comparator function object</span></strong> <span class="violet"><strong><code>less&lt;int&gt;</code></strong></span>, which knows how to compare two <code>int</code> values to determine whether the first is less than the second. This enables an integer <strong><code>multiset</code></strong> to order its elements in ascending order. We discuss function objects in detail in <a href="ch14.xhtml#sec14_5">Section 14.5</a>. For this chapter, we’ll simply show how to use <strong><code>less&lt;int&gt;</code></strong> when declaring ordered associative containers.</p>&#13;
<p>The data type of the keys in all <strong>ordered associative containers</strong> must support comparison based on the <strong>comparator function object</strong>—keys sorted with <strong><code>less&lt;T&gt;</code></strong> must support comparison with <strong><code>operator&lt;</code></strong>. If the keys used in the <strong>ordered associative containers</strong> are of user-defined data types, those types must supply the appropriate comparison operators. A <strong><code>multiset</code></strong> supports <strong>bidirectional iterators</strong> (but not <strong>random-access iterators</strong>). If the order of the keys is not important, use <strong><code>unordered_multiset</code></strong> (header <code>&lt;unordered_set&gt;</code>).</p>&#13;
<h5 class="h5" id="ch13lev3sec23">Creating a <code>multiset</code></h5>&#13;
<p><a href="ch13.xhtml#fig13_6">Figure 13.6</a> demonstrates the <strong><code>multiset</code> ordered associative container</strong> with <code>int</code> keys that are sorted in ascending order. Containers <strong><code>multiset</code></strong> and <strong><code>set</code></strong> (<a href="ch13.xhtml#sec13_9_2">Section 13.9.2</a>) provide the same basic functionality. Line 12 creates the <strong><code>multiset</code></strong>, using the function object <code>less&lt;int&gt;</code> to specify the keys’ sort order. Ascending order is the default for a <strong><code>multiset</code></strong>, so line 12 can be written as</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p721pro01" id="p721pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">std::multiset&lt;<span class="blue">int</span>&gt; ints{}; <span class="lgreen">// multiset of int values</span></pre>&#13;
<div class="group" id="fig13_6">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro06" id="p13pro06a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_06.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library multiset class template</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt; <span class="lgreen">// copy algorithm</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// C++20: This will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;ranges&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>   <span class="blue">#include</span> &lt;set&gt; <span class="lgreen">// multiset class-template definition</span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">#include</span> &lt;vector&gt;&#13;
<span class="cviolet"><strong>10</strong></span>&#13;
<span class="cviolet"><strong>11</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>12</strong></span>      std::multiset&lt;<span class="blue">int</span>, std::less&lt;<span class="blue">int</span>&gt;&gt; ints{}; <span class="lgreen">// multiset of int values</span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.6</strong></span> | Standard library <code>multiset</code> class template.</p>&#13;
</div>&#13;
<h5><code>multiset</code> Member Function <strong><code>count</code></strong></h5>&#13;
<p>Line 13 uses function <span class="violet"><strong><code>count</code></strong></span> (available to all <strong>associative containers</strong>) to count the number of occurrences of the value <code>15</code> currently in the <strong><code>multiset</code></strong>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p721pro02" id="p721pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>13</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"15s in ints: {}\n"</span>, ints.count(<span class="green">15</span>));&#13;
<span class="cviolet"><strong>14</strong></span></pre>&#13;
<pre class="pre1"><code>15s in ints: 0</code></pre>&#13;
</div>&#13;
<h5><code>multiset</code> Member Function <strong><code>insert</code></strong></h5>&#13;
<p>Lines 16–17 use one of the several overloaded versions of member function <strong><code>insert</code></strong> to add the value <code>15</code> to the <strong><code>multiset</code></strong> twice. A second version of <strong><code>insert</code></strong> takes an iterator and a value as arguments and begins the search for the insertion point from the iterator position specified. A third version of <strong><code>insert</code></strong> takes two iterators as arguments that specify a range of values to add to the <strong><code>multiset</code></strong> from another container. For several other overloads, see</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p721pro03" id="p721pro03a">Click here to view code image</a></p>&#13;
<pre class="pre">https://en.cppreference.com/w/cpp/container/multiset/insert</pre>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p721pro04" id="p721pro04a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>15</strong></span>   std::cout &lt;&lt; <span class="green">"\nInserting two 15s into ints\n"</span>;&#13;
<span class="cviolet"><strong>16</strong></span>   ints.insert(<span class="green">15</span>); <span class="lgreen">// insert 15 in ints</span>&#13;
<span class="cviolet"><strong>17</strong></span>   ints.insert(<span class="green">15</span>); <span class="lgreen">// insert 15 in ints</span>&#13;
<span class="cviolet"><strong>18</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"15s in ints: {}\n\n"</span>, ints.count(<span class="green">15</span>));&#13;
<span class="cviolet"><strong>19</strong></span></pre>&#13;
<pre class="pre1"><code>Inserting two 15s into ints</code>&#13;
<code>15s in ints: 2</code></pre>&#13;
</div>&#13;
<h5><code>multiset</code> Member Function <strong><code>find</code></strong></h5>&#13;
<p>Lines 21–28 use member function <span class="violet"><strong><code>find</code></strong></span> (line 22), which is available to all <strong>associative containers</strong>, to search for the values <code>15</code> and 20 in the <strong><code>multiset</code></strong>. The range-based <code>for</code> loop iterates through each item in <code>{15, 20}</code>. Function <strong><code>find</code></strong> returns either an <strong><code>iterator</code></strong> or a <strong><code>const_iterator</code></strong>, depending on whether the <strong><code>multiset</code></strong> is <code>const</code>. The iterator points to the location at which the value is found. If the value is not found, <strong><code>find</code></strong> returns an <strong><code>iterator</code></strong> or a <strong><code>const_iterator</code></strong> equal to the value returned by the container’s <strong><code>end</code></strong> member function.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p722pro01" id="p722pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>20</strong></span>   <span class="lgreen">// search for 15 and 20 in ints; find returns an iterator</span>&#13;
<span class="cviolet"><strong>21</strong></span>   <span class="blue">for</span> (<span class="blue">int</span> i : {<span class="green">15</span>, <span class="green">20</span>}) {&#13;
<span class="cviolet"><strong>22</strong></span>      <span class="blue">if</span> (<span class="blue">auto</span> result{ints.find(i)}; result != ints.end()) {&#13;
<span class="cviolet"><strong>23</strong></span>         std::cout &lt;&lt; fmt::format("Found <span class="green">{} in ints\n", i);</span>&#13;
<span class="cviolet"><strong>24</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>25</strong></span>      <span class="blue">else</span> {&#13;
<span class="cviolet"><strong>26</strong></span>         std::cout &lt;&lt; fmt::format("Did n<span class="green">ot find {} in ints\n", i);</span>&#13;
<span class="cviolet"><strong>27</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>28</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>29</strong></span></pre>&#13;
<pre class="pre1"><code>Found 15 in ints</code>&#13;
<code>Did not find 20 in ints</code></pre>&#13;
</div>&#13;
<h5><span class="size">20</span> <code>multiset</code> Member Function <strong><code>contains</code></strong> (C++20)</h5>&#13;
<p>Lines 31–39 use the new C++20 member function <span class="violet"><strong><code>contains</code></strong></span> (line 22) to determine whether the values <code>15</code> and 20 are in the <strong><code>multiset</code></strong>. This function, which is available to all <strong>associative containers</strong>, returns a <code>bool</code> indicating whether the value is present in the container. The range-based <code>for</code> loop iterates through each item in <code>{15, 20}</code>. Function <strong><code>find</code></strong> returns either an <strong><code>iterator</code></strong> or a <strong><code>const_iterator</code></strong>, depending on whether the <strong><code>multiset</code></strong> is <code>const</code>. The iterator points to the location at which the value is found. If the value is not found, <strong><code>find</code></strong> returns an <strong><code>iterator</code></strong> or a <strong><code>const_iterator</code></strong> equal to the value returned by the container’s <strong><code>end</code></strong> member function.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p722pro02" id="p722pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>30</strong></span>   <span class="lgreen">// search for 15 and 20 in ints; contains returns a bool</span>&#13;
<span class="cviolet"><strong>31</strong></span>   <span class="blue">for</span> (<span class="blue">int</span> i : {<span class="green">15</span>, <span class="green">20</span>}) {&#13;
<span class="cviolet"><strong>32</strong></span>      <span class="blue">if</span> (ints.contains(i)) {&#13;
<span class="cviolet"><strong>33</strong></span>         std::cout &lt;&lt; fmt::format("Found <span class="green">{} in ints\n", i);</span>&#13;
<span class="cviolet"><strong>34</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>35</strong></span>      <span class="blue">else</span> {&#13;
<span class="cviolet"><strong>36</strong></span>         std::cout &lt;&lt; fmt::format("Did n<span class="green">ot find {} in ints\n", i);</span>&#13;
<span class="cviolet"><strong>37</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>38</strong></span>   <code>}</code>&#13;
<span class="cviolet"><strong>39</strong></span></pre>&#13;
<pre class="pre1"><code>Found 15 in ints</code>&#13;
<code>Did not find 20 in ints</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec24">Inserting Elements of Another Container into a <code>multiset</code></h5>&#13;
<p>Line 42 uses member function <span class="violet"><strong><code>insert</code></strong></span> to insert a <strong><code>vector</code></strong>’s elements into the <strong><code>multiset</code></strong>, then line 44 copies the <strong><code>multiset</code>’s</strong> elements to the standard output. The values display in ascending order because the <strong><code>multiset</code></strong> is an ordered container that maintains its elements in ascending order by default. In line 44, note the expression:</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p723pro01" id="p723pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">std::ostream_iterator&lt;<span class="blue">int</span>&gt;{std::cout, <span class="green">" "</span>}</pre>&#13;
<p>This creates an <strong><code>ostream_iterator</code></strong> and immediately passes it to the <strong><code>copy</code> algorithm</strong>. We chose this approach because the <strong><code>ostream_iterator</code></strong> is used only once in this example.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p723pro02" id="p723pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>40</strong></span>   <span class="lgreen">// insert elements of vector values into ints</span>&#13;
<span class="cviolet"><strong>41</strong></span>   <span class="blue">const</span> std::vector values{<span class="green">7</span>, <span class="green">22</span>, <span class="green">9</span>, <span class="green">1</span>, <span class="green">18</span>, <span class="green">30</span>, <span class="green">100</span>, <span class="green">22</span>, <span class="green">85</span>, <span class="green">13</span>};&#13;
<span class="cviolet"><strong>42</strong></span>   <code>ints.insert(values.cbegin(), values.cend());</code>&#13;
<span class="cviolet"><strong>43</strong></span>   std::cout &lt;&lt; <span class="green">"\nAfter insert, ints contains:\n"</span>;&#13;
<span class="cviolet"><strong>44</strong></span>   std::ranges::copy(ints, std::ostream_iterator&lt;<span class="blue">int</span>&gt;{std::cout, <span class="green">" "</span>});&#13;
<span class="cviolet"><strong>45</strong></span></pre>&#13;
<pre class="pre1"><code>After insert, ints contains:</code>&#13;
<code>1 7 9 13 15 15 18 22 22 30 85 100</code></pre>&#13;
</div>&#13;
<h5><code>multiset</code> Member Functions <strong><code>lower_bound</code></strong> and <strong><code>upper_bound</code></strong></h5>&#13;
<p>Line 49 uses functions <span class="violet"><strong><code>lower_bound</code></strong></span> and <span class="violet"><strong><code>upper_bound</code></strong></span>, available in all <strong>associative containers</strong>, to locate the earliest occurrence of the value <code>22</code> in the <strong><code>multiset</code></strong> and the element after the last occurrence of the value <code>22</code> in the <strong><code>multiset</code></strong>. Both functions return <strong><code>iterator</code></strong>s or <strong><code>const_iterator</code></strong>s pointing to the appropriate location or the iterator returned by <code>end</code> if the value is not in the <strong><code>multiset</code></strong>. Together, the lower bound and upper bound represent the <strong>common range</strong> of elements containing the value <code>22</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p723pro03" id="p723pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>46</strong></span>   <span class="lgreen">// determine lower and upper bound of 22 in ints</span>&#13;
<span class="cviolet"><strong>47</strong></span>   <code>std::cout &lt;&lt; fmt::format(</code>&#13;
<span class="cviolet"><strong>48</strong></span>                   <span class="green">"\n\nlower_bound(22): {}\nupper_bound(22): {}\n\n",</span>&#13;
<span class="cviolet"><strong>49</strong></span>                   *(ints.lower_bound(22)), *(ints.upp<span class="green">er</span>_bound(22)));&#13;
<span class="cviolet"><strong>50</strong></span></pre>&#13;
<pre class="pre1"><code>lower_bound(22): 22</code>&#13;
<code>upper_bound(22): 30</code></pre>&#13;
</div>&#13;
<h5><code>pair</code> Objects and <strong><code>multiset</code></strong> Member Function <strong><code>equal_range</code></strong></h5>&#13;
<p>Line 52 creates and initializes a <span class="violet"><strong><code>pair</code></strong></span> object called <code>p</code>. We use <code>auto</code> to infer the variable’s type from its initializer—in this case, the return value of <strong><code>multiset</code></strong> member function <strong><code>equal_range</code></strong>, which is a <strong><code>pair</code></strong> object. Such objects associate pairs of values. In this case, the contents of <code>p</code> will be two <strong><code>iterator</code>s</strong> or <strong><code>const_iterator</code>s</strong>, depending on whether the <strong><code>multiset</code></strong> is <code>const</code>. The <strong><code>multiset</code></strong> function <span class="violet"><strong><code>equal_range</code></strong></span> returns a <code>pair</code> containing the results of calling both <strong><code>lower_bound</code></strong> and <strong><code>upper_bound</code></strong>. Class template <strong><code>pair</code></strong> contains two <code>public</code> data members called <span class="violet"><strong><code>first</code></strong></span> and <span class="violet"><strong><code>second</code></strong></span>—their types depend on the <strong><code>pair</code></strong>’s initializers.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p724pro01" id="p724pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>51</strong></span>   <span class="lgreen">// use sequal_range to determine lower and upper bound of 22 in ints</span>&#13;
<span class="cviolet"><strong>52</strong></span>   <span class="blue">auto</span> p{ints.equal_range(<span class="green">22</span>)};&#13;
<span class="cviolet"><strong>53</strong></span>   <code>std::cout &lt;&lt; fmt::format(</code>&#13;
<span class="cviolet"><strong>54</strong></span>                   <span class="green">"lower_bound(22): {}\nupper_bound(22): {}\n",</span>&#13;
<span class="cviolet"><strong>55</strong></span>                   <code>*(p.first), *(p.second));</code>&#13;
<span class="cviolet"><strong>56</strong></span>   }</pre>&#13;
<pre class="pre1"><code>lower_bound(22): 22</code>&#13;
<code>upper_bound(22): 30</code></pre>&#13;
</div>&#13;
<p>Line 52 uses function <strong><code>equal_range</code></strong> to determine the <strong><code>lower_bound</code></strong> and <strong><code>upper_bound</code></strong> of <code>22</code> in the <strong><code>multiset</code></strong>. Line 55 uses <code>p.first</code> and <code>p.second</code> to access the <strong><code>lower_bound</code></strong> and <strong><code>upper_bound</code></strong>. We dereferenced the iterators to output the values at the locations returned from <strong><code>equal_range</code></strong>. Though we did not do so here, you should always ensure that the iterators returned by <strong><code>lower_bound</code></strong>, <strong><code>upper_bound</code></strong> and <strong><code>equal_range</code></strong> are not equal to the container’s end iterator before dereferencing the iterators.</p>&#13;
<h5 class="h5" id="ch13lev3sec25">Variadic Class Template <code>tuple</code></h5>&#13;
<p>C++ also includes class template <strong><code>tuple</code></strong> (added in C++11), which is similar to <strong><code>pair</code></strong>, but can hold any number of items of various types. Class template <strong><code>tuple</code></strong> is implemented using <strong>variadic templates</strong>—templates that can receive a variable number of arguments. We discuss <code>tuple</code> and variadic templates in <a href="ch15.xhtml#ch15">Chapter 15</a>, Templates, C++20 Concepts and Metaprogramming.</p>&#13;
<h5 class="h5" id="ch13lev3sec26"><span class="size">14</span> C++14: Heterogeneous Lookup</h5>&#13;
<p>Prior to C++14, when searching for a key in an associative container, the argument provided to a search function like <strong><code>find</code></strong> was required to have the container’s key type. For example, if the key type were <code>string</code>, you could pass <strong><code>find</code></strong> a pointer-based string to locate in the container. In this case, the argument would be converted into a temporary object of the key type (<code>string</code>), then passed to <strong><code>find</code></strong>. In C++14 and higher, the argument to <strong><code>find</code></strong> (and other similar functions) can be of any type, provided that there are overloaded comparison operators that can compare values of the argument’s type to values of the container’s key type. If there are, no temporary objects will be created. This is known as <strong><span class="violet">heterogeneous lookup</span></strong>.</p>&#13;
<h4 class="h4" id="sec13_9_2">13.9.2 <code>set</code> Associative Container</h4>&#13;
<p>The <strong><code>set</code> associative container</strong> (from <strong>header <code>&lt;set&gt;</code></strong>) is used for fast storage and retrieval of unique keys. The implementation of a <strong><code>set</code></strong> is identical to that of a <strong><code>multiset</code></strong>, except that a <strong><code>set</code></strong> must have unique keys. Therefore, if an attempt is made to insert a duplicate key into a <strong><code>set</code></strong>, the duplicate is ignored—this is the intended mathematical behavior of a set, so it’s not considered an error. A <strong><code>set</code></strong> supports <strong>bidirectional iterators</strong> (but not <strong>random-access iterators</strong>). If the order of the keys is not important, you can use <strong><code>unordered_set</code></strong> (header <code>&lt;unordered_set&gt;</code>) instead.</p>&#13;
<h5 class="h5" id="ch13lev3sec27">Creating a <code>set</code></h5>&#13;
<p><a href="ch13.xhtml#fig13_7">Figure 13.7</a> demonstrates a <strong><code>set</code></strong> of <code>double</code>s. Line 10 creates the <strong><code>set</code></strong>, using class template argument deduction (CTAD) to infer the <strong><code>set</code></strong>’s type. Line 10 is equivalent to:</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p724pro02" id="p724pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">std::set&lt;<span class="blue">double</span>, std::less&lt;<span class="blue">double</span>&gt;&gt; doubles{<span class="green">2.1</span>, <span class="green">4.2</span>, <span class="green">9.5</span>, <span class="green">2.1</span>, <span class="green">3.7</span>};</pre>&#13;
<p><span class="size">20</span> The <strong><code>set</code>’s <code>initializer_list</code></strong> constructor inserts all the elements into the <strong><code>set</code></strong>. Line 14 uses the <strong><code>std::ranges</code> algorithm <code>copy</code></strong> to output the <strong><code>set</code></strong>’s contents. Notice that the value <code>2.1</code>, which appeared twice in the initializer list, appears only once in <code>doubles</code>, because <strong>a <code>set</code> does not allow duplicates</strong>.</p>&#13;
<div class="group" id="fig13_7">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro07" id="p13pro07a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_07.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library set class template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;algorithm&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// C++20: This will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;iterator&gt; <span class="lgreen">// ostream_iterator</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;set&gt;&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>10</strong></span>      std::set doubles{<span class="green">2.1</span>, <span class="green">4.2</span>, <span class="green">9.5</span>, <span class="green">2.1</span>, <span class="green">3.7</span>}; <span class="lgreen">// CTAD</span>&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      std::ostream_iterator&lt;<span class="blue">double</span>&gt; output{std::cout, <span class="green">" "</span>};&#13;
<span class="cviolet"><strong>13</strong></span>      std::cout &lt;&lt; <span class="green">"doubles contains: "</span>;&#13;
<span class="cviolet"><strong>14</strong></span>      <code>std::ranges::copy(doubles, output);</code>&#13;
<span class="cviolet"><strong>15</strong></span></pre>&#13;
<pre class="pre1"><code>doubles contains: 2.1 3.7 4.2 9.5</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.7</strong></span> | Standard library <code>set</code> class template.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec28">Inserting a New Value into a <code>set</code></h5>&#13;
<p>Line 19 defines and initializes a <strong><code>pair</code></strong> to store the result of calling <strong><code>set</code></strong> member function <strong><code>insert</code></strong>. The <strong><code>pair</code></strong> contains an <strong><code>iterator</code></strong> pointing to the item in the <strong><code>set</code></strong> and a <code>bool</code> indicating whether the item was inserted—<code>true</code> if the item was not previously in the <strong><code>set</code></strong> and <code>false</code> otherwise. In this case, line 19 uses function <strong><code>insert</code></strong> to place the value <code>13.8</code> in the <strong><code>set</code></strong> and returns a <strong><code>pair</code></strong> in which <code>p.first</code> points to the value <code>13.8</code> in the <strong><code>set</code></strong> and <code>p.second</code> is <code>true</code> because the value was inserted.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p725pro01" id="p725pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>16</strong></span>   <span class="lgreen">// insert 13.8 in doubles; insert returns pair in which</span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// p.first represents location of 13.8 in doubles and</span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="lgreen">// p.second represents whether 13.8 was inserted</span>&#13;
<span class="cviolet"><strong>19</strong></span>   <span class="blue">auto</span> p{doubles.insert(<span class="green">13.8</span>)}; <span class="lgreen">// value not in set</span>&#13;
<span class="cviolet"><strong>20</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"\n{} {} inserted\n"</span>, *(p.first),&#13;
<span class="cviolet"><strong>21</strong></span>                   (p.second ? <span class="green">"was"</span> : <span class="green">"was not"</span>));&#13;
<span class="cviolet"><strong>22</strong></span>   std::cout &lt;&lt; <span class="green">"doubles contains: "</span>;&#13;
<span class="cviolet"><strong>23</strong></span>   <code>std::ranges::copy(doubles, output);</code>&#13;
<span class="cviolet"><strong>24</strong></span></pre>&#13;
<pre class="pre1"><code>13.8 was inserted</code>&#13;
<code>doubles contains: 2.1 3.7 4.2 9.5 13.8</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec29">Inserting an Existing Value into a <code>set</code></h5>&#13;
<p>Line 26 attempts to insert <code>9.5</code>, which is already in the <strong><code>set</code></strong>. The output shows that <code>9.5</code> was not inserted because <strong><code>set</code>s don’t allow duplicate keys</strong>. In this case, <code>p.first</code> in the returned <strong><code>pair</code></strong> points to the existing <code>9.5</code> in the <strong><code>set</code></strong> and <code>p.second</code> is <code>false</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p726pro01" id="p726pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>25</strong></span>      <span class="lgreen">// insert 9.5 in doubles</span>&#13;
<span class="cviolet"><strong>26</strong></span>      p = doubles.insert(<span class="green">9.5</span>); <span class="lgreen">// value already in set</span>&#13;
<span class="cviolet"><strong>27</strong></span>      std::cout &lt;&lt; fmt::format(<span class="green">"\n{} {} inserted\n"</span>, *(p.first),&#13;
<span class="cviolet"><strong>28</strong></span>                      (p.second ? <span class="green">"was"</span> : <span class="green">"was not"</span>));&#13;
<span class="cviolet"><strong>29</strong></span>      std::cout &lt;&lt; <span class="green">"doubles contains: "</span>;&#13;
<span class="cviolet"><strong>30</strong></span>      <code>std::ranges::copy(doubles, output);</code>&#13;
<span class="cviolet"><strong>31</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>32</strong></span>   }</pre>&#13;
<pre class="pre1"><code>9.5 was not inserted doubles contains:</code>&#13;
<code>2.1 3.7 4.2 9.5 13.8</code></pre>&#13;
</div>&#13;
<h4 class="h4" id="sec13_9_3">13.9.3 <code>multimap</code> Associative Container</h4>&#13;
<p>The <strong><code>multimap</code> associative container</strong> is used for fast storage and retrieval of keys and associated values (often called <strong><span class="violet">key–value pairs</span></strong>). Many of the functions used with <strong><code>multiset</code>s</strong> and <strong><code>set</code>s</strong> are also used with <strong><code>multimap</code>s</strong> and <strong><code>map</code>s</strong>. The elements of <strong><code>multimap</code>s</strong> and <strong><code>map</code>s</strong> are <strong><code>pair</code>s</strong> of keys and values instead of individual values. When inserting into a <strong><code>multimap</code></strong> or <strong><code>map</code></strong>, you use a <strong><code>pair</code></strong> object containing the key and the value. The ordering of the keys is determined by a <strong>comparator function object</strong>. For example, in a <strong><code>multimap</code></strong> that uses integers as the key type, keys can be sorted in <strong>ascending order</strong> by ordering them with <strong>comparator function object <code>less&lt;int&gt;</code></strong>.</p>&#13;
<p>Duplicate keys are allowed in a <strong><code>multimap</code></strong>, so multiple values can be associated with a single key. This is called a <strong><span class="violet">one-to-many relationship</span></strong>. For example, in a credit-card transaction-processing system, one credit-card account can have many associated transactions; in a university, one student can take many courses, and one professor can teach many students; in the military, one rank (like “private”) has many people. A <strong><code>multimap</code></strong> supports <strong>bidirectional iterators</strong>, but not <strong>random-access iterators</strong>.</p>&#13;
<h5 class="h5" id="ch13lev3sec30">Creating a <code>multimap</code> Containing Key–Value Pairs</h5>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> <a href="ch13.xhtml#fig13_8">Figure 13.8</a> demonstrates the <strong><code>multimap</code> associative container</strong>. Header <span class="violet"><strong><code>&lt;map&gt;</code></strong></span> must be included to use class <strong><code>multimap</code></strong>. If the order of the keys is not important, you can use <strong><code>unordered_multimap</code></strong> (<strong>header <code>&lt;unordered_map&gt;</code></strong>) instead. A <strong><code>multimap</code></strong> is implemented to efficiently locate all values paired with a given key. Line 8 creates a <strong><code>multimap</code></strong> in which the key type is <code>int</code>, the type of a key’s associated value is <code>double</code> and the elements are ordered in ascending order by default. This is equivalent to:</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p726pro02" id="p726pro02a">Click here to view code image</a></p>&#13;
<pre class="pre">std::multimap&lt;<span class="blue">int</span>, <span class="blue">double</span>, std::less&lt;<span class="blue">int</span>&gt;&gt; pairs{};</pre>&#13;
<div class="group" id="fig13_8">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro08" id="p13pro08a">Click here to view code image</a></p>&#13;
<pre class="pre3"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_08.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library multimap class template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// C++20: This will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;map&gt; <span class="lgreen">// multimap class-template definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>8</strong></span>      std::multimap&lt;<span class="blue">int</span>, <span class="blue">double</span>, std::less&lt;<span class="blue">int</span>&gt;&gt; pairs{}; <span class="lgreen">// create multimap</span></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.8</strong></span> | Standard library <code>multimap</code> class template.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec31">Counting the Number of Key–Value Pairs for a Specific Key</h5>&#13;
<p>Line 10 uses member function <strong><code>count</code></strong> to determine the number of key–value pairs with a key of <code>15</code>—in this case, <code>0</code> since the container is currently empty.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p727pro01" id="p727pro01a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>9</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"Number of 15 keys in pairs: {}\n"</span>,&#13;
<span class="cviolet"><strong>10</strong></span>                   pairs.count(<span class="green">15</span>));&#13;
<span class="cviolet"><strong>11</strong></span></pre>&#13;
<pre class="pre1"><code>There are currently 0 pairs with key 15 in the multimap</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec32">Inserting Key–Value Pairs</h5>&#13;
<p>Line 13 uses member function <strong><code>insert</code></strong> to add a new key–value pair to the <strong><code>multimap</code></strong>. Standard library function <span class="violet"><strong><code>make_pair</code></strong></span> creates a <strong><code>pair</code></strong> object—in this case <code>first</code> represents a key (<code>15</code>) of type <code>int</code> and <code>second</code> represents a value (<code>99.3</code>) of type <code>double</code>. Function <strong><code>make_pair</code></strong> automatically uses the types that you specified for the keys and values in the <strong><code>multimap</code>’s</strong> declaration (line 8). Line 14 inserts another <strong><code>pair</code></strong> object with the key <code>15</code> and the value <code>2.7</code>. Then lines 15–16 output the number of <strong><code>pair</code>s</strong> with key <code>15</code>.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p727pro02" id="p727pro02a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>12</strong></span>   <span class="lgreen">// insert two pairs</span>&#13;
<span class="cviolet"><strong>13</strong></span>   pairs.insert(std::make_pair(<span class="green">15</span>, <span class="green">99.3</span>));&#13;
<span class="cviolet"><strong>14</strong></span>   pairs.insert(std::make_pair(<span class="green">15</span>, <span class="green">2.7)</span>);&#13;
<span class="cviolet"><strong>15</strong></span>   std::cout &lt;&lt; fmt::format(<span class="green">"Number of 15 keys in pairs: {}\n\n"</span>,&#13;
<span class="cviolet"><strong>16</strong></span>                   pairs.count(<span class="green">15</span>));&#13;
<span class="cviolet"><strong>17</strong></span></pre>&#13;
<pre class="pre1"><code>After inserts, there are 2 pairs with key 15</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec33">Inserting Key–Value Pairs with Braced Initializers Rather Than <code>make_pair</code></h5>&#13;
<p>You can use braced initalization for <strong><code>pair</code></strong> objects, so lines 13–14 can be simplified as</p>&#13;
<pre class="pre">pairs.insert({<span class="green">15</span>, <span class="green">99.3</span>});&#13;
pairs.insert({<span class="green">15</span>, <span class="green">2.7</span>});</pre>&#13;
<p>Similarly, you can use braced initialization to initialize an object being returned from a function. For example, the following returns a <strong><code>pair</code></strong> containing an <code>int</code> and a <code>double</code></p>&#13;
<pre class="pre"><span class="blue">return</span> {<span class="green">15</span>, <span class="green">2.7</span>};</pre>&#13;
<p>Lines 19–23 insert five additional <strong><code>pair</code>s</strong> into the <strong><code>multimap</code></strong>. The range-based <code>for</code> statement in lines 28–30 outputs the <strong><code>multimap</code></strong>’s keys and values. We infer the type of the loop’s control variable—in this case, a <strong><code>pair</code></strong> containing an <code>int</code> key and a <code>double</code> value. Line 29 accesses each <strong><code>pair</code>’s</strong> members. Notice that the keys appear in ascending order because the <strong><code>multimap</code></strong> maintains the keys in ascending order.</p>&#13;
<div class="group">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p727pro03" id="p727pro03a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"><strong>18</strong></span>      <span class="lgreen">// insert five pairs</span>&#13;
<span class="cviolet"><strong>19</strong></span>      pairs.insert({<span class="green">30</span>, <span class="green">111.11</span>});&#13;
<span class="cviolet"><strong>20</strong></span>      pairs.insert({<span class="green">10</span>, <span class="green">22.22</span>});&#13;
<span class="cviolet"><strong>21</strong></span>      pairs.insert({<span class="green">25</span>, <span class="green">33.333</span>});&#13;
<span class="cviolet"><strong>22</strong></span>      pairs.insert({<span class="green">20</span>, <span class="green">9.345</span>});&#13;
<span class="cviolet"><strong>23</strong></span>      pairs.insert({<span class="green">5</span>, <span class="green">77.54</span>});&#13;
<span class="cviolet"><strong>24</strong></span>      &#13;
<span class="cviolet"><strong>25</strong></span>      std::cout &lt;&lt; <span class="green">"Multimap pairs contains:\nKey\tValue\n"</span>;&#13;
<span class="cviolet"><strong>26</strong></span>      &#13;
<span class="cviolet"><strong>27</strong></span>      <span class="lgreen">// walk through elements of pairs</span>&#13;
<span class="cviolet"><strong>28</strong></span>      <span class="blue">for</span> (<span class="blue">const auto</span>&amp; mapItem : pairs) {&#13;
<span class="cviolet"><strong>29</strong></span>         std::cout &lt;&lt; fmt::format("{}<span class="green">\t{}\n", m</span>apItem.first, mapItem.second);&#13;
<span class="cviolet"><strong>30</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>31</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Multimap pairs contains:</code>&#13;
<code>Key     Value</code>&#13;
<code>5       77.54</code>&#13;
<code>10      22.22</code>&#13;
<code>15      99.3</code>&#13;
<code>15      2.7</code>&#13;
<code>20      9.345</code>&#13;
<code>25      33.333</code>&#13;
<code>30      111.11</code></pre>&#13;
</div>&#13;
<h5 class="h5" id="ch13lev3sec34"><span class="size">11</span> C++11: Brace Initializing a Key–Value Pair Container</h5>&#13;
<p>This example used separate calls to member function <strong><code>insert</code></strong> to place key–value pairs in a <strong><code>multimap</code></strong>. If you know the key–value pairs in advance, you can use braced initialization when you create the <strong><code>multimap</code></strong>. For example, the following statement initializes a <strong><code>multimap</code></strong> with three key–value <strong><code>pair</code>s</strong> that are represented by the sublists in the main initializer list:</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p728pro01" id="p728pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">std::multimap&lt;<span class="blue">int</span>, <span class="blue">double</span>&gt; pairs{&#13;
   {<span class="green">10</span>, <span class="green">22.22</span>}, {<span class="green">20</span>, <span class="green">9.345</span>}, {<span class="green">5</span>, <span class="green">77.54</span>}};</pre>&#13;
<h4 class="h4" id="sec13_9_4">13.9.4 <code>map</code> Associative Container</h4>&#13;
<p>The <strong><code>map</code> associative container</strong> (from <strong>header <code>&lt;map&gt;</code></strong>) performs fast storage and retrieval of unique keys and associated values. Duplicate keys are not allowed—a single value can be associated with each key. This is called a <strong><span class="violet">one-to-one mapping</span></strong>. For example, a company that uses unique employee numbers, such as 100, 200 and 300, might have a <strong><code>map</code></strong> that associates employee numbers with their telephone extensions—4321, 4115 and 5217, respectively. Providing the key in a <strong><code>map</code></strong>’s subscript operator <code>[]</code> locates the value associated with that key in the <strong><code>map</code></strong>. Insertions and deletions can be made anywhere in a <strong><code>map</code></strong>. If the order of the keys is not important, you can use <strong><code>unordered_map</code></strong> (<strong>header <code>&lt;unordered_map&gt;</code></strong>) instead.</p>&#13;
<p><a href="ch13.xhtml#fig13_9">Figure 13.9</a> demonstrates a <strong><code>map</code></strong> (created at lines 8–9) and uses many of the same features as <a href="ch13.xhtml#fig13_8">Fig. 13.8</a>. Note that only six of the initial eight key–value pairs are inserted because two have duplicate keys. Unlike similar data structures in some programming languages, inserting two key–value pairs with the same key does not replace first key’s value with that of the second. If you insert a key–value pair for which the key is already in the <strong><code>map</code></strong>, the key–value pair is ignored.</p>&#13;
<div class="group" id="fig13_9">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro09" id="p13pro09a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_09.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library class map class template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;fmt/format.h&gt; <span class="lgreen">// C++20: This will be #include &lt;format&gt;</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;map&gt; <span class="lgreen">// map class-template definition</span>&#13;
<span class="cviolet"> <strong>6</strong></span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>8</strong></span>      <span class="lgreen">// create a map; duplicate keys are ignored</span>&#13;
<span class="cviolet"> <strong>9</strong></span>      std::map&lt;<span class="blue">int</span>, <span class="blue">double</span>&gt; pairs{{<span class="green">15</span>, <span class="green">2.7</span>}, {<span class="green">30</span>, <span class="green">111.11</span>}, {<span class="green">5</span>, <span class="green">1010.1</span>},&#13;
<span class="cviolet"><strong>10</strong></span>         {10, <span class="green"/><span class="green">22.22</span>}, {<span class="green">25</span>, <span class="green">33.333</span>}, {<span class="green">5</span>, <span class="green">77.54</span>}, {<span class="green">20</span>, <span class="green">9.345</span>}, {<span class="green">15</span>, <span class="green">99.3</span>}};&#13;
<span class="cviolet"><strong>11</strong></span>&#13;
<span class="cviolet"><strong>12</strong></span>      <span class="lgreen">// walk through elements of pairs</span>&#13;
<span class="cviolet"><strong>13</strong></span>      std::cout &lt;&lt; <span class="green">"pairs contains:\nKey\tValue\n"</span>;&#13;
<span class="cviolet"><strong>14</strong></span>      <span class="blue">for</span> (<span class="blue">const auto</span>&amp; pair : pairs) {&#13;
<span class="cviolet"><strong>15</strong></span>         std::cout &lt;&lt; fmt::format("{}<span class="green">\t{}\n", p</span>air.first, pair.second);&#13;
<span class="cviolet"><strong>16</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>17</strong></span>   &#13;
<span class="cviolet"><strong>18</strong></span>      pairs[<span class="green">25</span>] = <span class="green">9999.99</span>; <span class="lgreen">// use subscripting to change value for key 25</span>&#13;
<span class="cviolet"><strong>19</strong></span>      pairs[<span class="green">40</span>] = <span class="green">8765.43</span>; <span class="lgreen">// use subscripting to insert value for key 40</span>&#13;
<span class="cviolet"><strong>20</strong></span>&#13;
<span class="cviolet"><strong>21</strong></span>      <span class="lgreen">// use const_iterator to walk through elements of pairs</span>&#13;
<span class="cviolet"><strong>22</strong></span>      std::cout &lt;&lt; <span class="green">"\nAfter updates, pairs contains:\nKey\tValue\n"</span>;&#13;
<span class="cviolet"><strong>23</strong></span>      <span class="blue">for</span> (<span class="blue">const auto</span>&amp; pair : pairs) {&#13;
<span class="cviolet"><strong>24</strong></span>         std::cout &lt;&lt; fmt::format("{}<span class="green">\t{}\n", p</span>air.first, pair.second);&#13;
<span class="cviolet"><strong>25</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>26</strong></span>   }</pre>&#13;
<pre class="pre1"><code>pairs contains:</code>&#13;
<code>Key     Value</code>&#13;
<code>5       1010.1</code>&#13;
<code>10      22.22</code>&#13;
<code>15      2.7</code>&#13;
<code>20      9.345</code>&#13;
<code>25      33.333</code>&#13;
<code>30      111.11</code>&#13;
<code>After updates, pairs contains:</code>&#13;
<code>Key     Value</code>&#13;
<code>5       1010.1</code>&#13;
<code>10      22.22</code>&#13;
<code>15      2.7</code>&#13;
<code>20      9.345</code>&#13;
<code>25      9999.99</code>&#13;
<code>30      111.11</code>&#13;
<code>40      8765.43</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.9</strong></span> | Standard library <code>map</code> class template.</p>&#13;
</div>&#13;
<p>Lines 18–19 use the <strong><code>map</code></strong> subscript operator. When the subscript is a key that’s in the <strong><code>map</code></strong>, the operator returns a reference to the associated value. When the subscript is a key that’s not in the <strong><code>map</code></strong>, the subscript operator inserts a new key–value pair in the <strong><code>map</code></strong>, consisting of the specified key and the default value for the container’s value type. Line 18 replaces the value for the key <code>25</code> (previously <code>33.333</code>, as specified in line 10) with a new value, <code>9999.99</code>. Line 19 inserts a new key–value <strong><code>pair</code></strong> in the <strong><code>map</code></strong>. This is known as <strong><span class="violet">creating an association</span></strong>.</p>&#13;
<h3 class="h3" id="sec13_10"><span class="violet">13.10</span> Container Adaptors</h3>&#13;
<p>The three <strong><span class="violet">container adaptors</span></strong> are <strong><code>stack</code></strong>, <strong><code>queue</code></strong> and <strong><code>priority_queue</code></strong>. Container adaptors do not provide a data-structure implementation in which elements can be stored and <strong>do not support iterators</strong>. With an adaptor class, you can choose the underlying sequence container or use the adaptor’s default choice—<strong><code>deque</code></strong> for <strong><code>stack</code></strong>s and <strong><code>queue</code></strong>s, or <strong><code>vector</code></strong> for <strong><code>priority_queue</code></strong>. The adaptor classes provide member functions <code>push</code> and <code>pop</code>:</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>push</code></strong></span> properly inserts an element into an adaptor’s underlying container.</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>pop</code></strong></span> properly removes an element from an adaptor’s underlying container.</p>&#13;
<p>Let’s see examples of the adaptor classes.</p>&#13;
<h4 class="h4" id="sec13_10_1">13.10.1 <code>stack</code> Adaptor</h4>&#13;
<p>Class <span class="violet"><strong><code>stack</code></strong></span> (from header <span class="violet"><strong><code>&lt;stack&gt;</code></strong></span>) enables insertions into and deletions from the underlying container at one end called the <strong>top</strong>, so a <strong><code>stack</code></strong> is commonly referred to as a <strong>last-in, first-out</strong> data structure. A <strong><code>stack</code></strong> can be implemented with a <strong><code>vector</code></strong>, <strong><code>list</code></strong> or <strong><code>deque</code></strong>. By default, a <strong><code>stack</code></strong> is implemented with a <strong><code>deque</code></strong>.<sup><a id="ch13fn14a" href="ch13.xhtml#ch13fn14">14</a></sup> The <strong><code>stack</code></strong> operations are:</p>&#13;
<p class="footnote"><a id="ch13fn14" href="ch13.xhtml#ch13fn14a">14</a>. “<code>std::stack</code>.” Accessed April 11, 2021. <code><a href="https://en.cppreference.com/w/cpp/container/stack">https://en.cppreference.com/w/cpp/container/stack</a></code>.</p>&#13;
<p class="bull">• <strong><code>push</code></strong> to insert an element at the <strong><code>stack</code></strong>’s <strong>top</strong>—implemented by calling the underlying container’s <strong><code>push_back</code></strong> member function,</p>&#13;
<p class="bull">• <strong><code>pop</code></strong> to remove the <strong><code>stack</code>’s top</strong> element—implemented by calling the underlying container’s <strong><code>pop_back</code></strong> member function,</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>top</code></strong></span> to get a reference to the <strong><code>stack</code>’s</strong> top element—implemented by calling the underlying container’s <strong><code>back</code></strong> member function,</p>&#13;
<p class="bull">• <strong><code>empty</code></strong> to determine whether the <strong><code>stack</code></strong> is empty—implemented by calling the underlying container’s <strong><code>empty</code></strong> member function, and</p>&#13;
<p class="bull">• <strong><code>size</code></strong> to get the <strong><code>stack</code>’s</strong> number of elements—implemented by calling the underlying container’s <strong><code>size</code></strong> member function.</p>&#13;
<p><a href="ch13.xhtml#fig13_10">Figure 13.10</a> demonstrates the <strong><code>stack</code> adaptor class</strong>. To demonstrate that the <strong><code>stack</code></strong> adaptor works with each <strong>sequence container</strong>, this example creates three <strong><code>stack</code>s</strong> of <code>int</code>s, using a <strong><code>deque</code></strong> (line 26), a <strong><code>vector</code></strong> (line 27) and a <strong><code>list</code></strong> (line 28) as the underlying data structure.</p>&#13;
<div class="group" id="fig13_10">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro10" id="p13pro10a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_10.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library stack adaptor class.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;list&gt; <span class="lgreen">// list class-template definition</span>&#13;
<span class="cviolet"> <strong>5</strong></span>   <span class="blue">#include</span> &lt;ranges&gt;&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">#include</span> &lt;stack&gt; <span class="lgreen">// stack adaptor definition</span>&#13;
<span class="cviolet"> <strong>7</strong></span>   <span class="blue">#include</span> &lt;vector&gt; <span class="lgreen">// vector class-template definition</span>&#13;
<span class="cviolet"> <strong>8</strong></span>&#13;
<span class="cviolet"> <strong>9</strong></span>   <span class="lgreen">// pushElements generic lambda to push values onto a stack</span>&#13;
<span class="cviolet"><strong>10</strong></span>   <span class="blue">auto</span> pushElements = [](<span class="blue">auto</span>&amp; stack) {&#13;
<span class="cviolet"><strong>11</strong></span>      <span class="blue">for</span> (<span class="blue">auto</span> i : std::views::iota(<span class="green">0</span>, <span class="green">10</span>)) {&#13;
<span class="cviolet"><strong>12</strong></span>         stack.push(i); <span class="lgreen">// push element onto stack</span>&#13;
<span class="cviolet"><strong>13</strong></span>         std::cout &lt;&lt; stack.top() &lt;&lt; <span class="green">' '</span>; <span class="lgreen">// view (and display) top element</span>&#13;
<span class="cviolet"><strong>14</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>15</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>16</strong></span>&#13;
<span class="cviolet"><strong>17</strong></span>   <span class="lgreen">// popElements generic lambda to pop elements off a stack</span>&#13;
<span class="cviolet"><strong>18</strong></span>   <span class="blue">auto</span> popElements = [](<span class="blue">auto</span>&amp; stack) {&#13;
<span class="cviolet"><strong>19</strong></span>      <span class="blue">while</span> (!stack.empty()) {&#13;
<span class="cviolet"><strong>20</strong></span>         std::cout &lt;&lt; stack.top() &lt;&lt; <span class="green">' '</span>; <span class="lgreen">// view (and display) top element</span>&#13;
<span class="cviolet"><strong>21</strong></span>         stack.pop(); <span class="lgreen">// remove top element</span>&#13;
<span class="cviolet"><strong>22</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>23</strong></span>   <code>};</code>&#13;
<span class="cviolet"><strong>24</strong></span>&#13;
<span class="cviolet"><strong>25</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"><strong>26</strong></span>      std::stack&lt;<span class="blue">int</span>&gt; dequeStack{}; <span class="lgreen">// uses a deque by default</span>&#13;
<span class="cviolet"><strong>27</strong></span>      std::stack&lt;<span class="blue">int</span>, std::vector&lt;<span class="blue">int</span>&gt;&gt; vectorStack{}; <span class="lgreen">// use a vector</span>&#13;
<span class="cviolet"><strong>28</strong></span>      std::stack&lt;<span class="blue">int</span>, std::list&lt;<span class="blue">int</span>&gt;&gt; listStack{}; <span class="lgreen">// use a list</span>&#13;
<span class="cviolet"><strong>29</strong></span>&#13;
<span class="cviolet"><strong>30</strong></span>      <span class="lgreen">// push the values 0-9 onto each stack</span>&#13;
<span class="cviolet"><strong>31</strong></span>      std::cout &lt;&lt; <span class="green">"Pushing onto dequeStack: "</span>;&#13;
<span class="cviolet"><strong>32</strong></span>      <code>pushElements(dequeStack);</code>&#13;
<span class="cviolet"><strong>33</strong></span>      std::cout &lt;&lt; <span class="green">"\nPushing onto vectorStack: "</span>;&#13;
<span class="cviolet"><strong>34</strong></span>      <code>pushElements(vectorStack);</code>&#13;
<span class="cviolet"><strong>35</strong></span>      std::cout &lt;&lt; <span class="green">"\nPushing onto listStack: "</span>;&#13;
<span class="cviolet"><strong>36</strong></span>      <code>pushElements(listStack);</code>&#13;
<span class="cviolet"><strong>37</strong></span>&#13;
<span class="cviolet"><strong>38</strong></span>      <span class="lgreen">// display and remove elements from each stack</span>&#13;
<span class="cviolet"><strong>39</strong></span>      std::cout &lt;&lt; <span class="green">"\n\nPopping from dequeStack: "</span>;&#13;
<span class="cviolet"><strong>40</strong></span>      <code>popElements(dequeStack);</code>&#13;
<span class="cviolet"><strong>41</strong></span>      std::cout &lt;&lt; <span class="green">"\nPopping from vectorStack: "</span>;&#13;
<span class="cviolet"><strong>42</strong></span>      <code>popElements(vectorStack);</code>&#13;
<span class="cviolet"><strong>43</strong></span>      std::cout &lt;&lt; <span class="green">"\nPopping from listStack: "</span>;&#13;
<span class="cviolet"><strong>44</strong></span>      <code>popElements(listStack);</code>&#13;
<span class="cviolet"><strong>45</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>46</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Pushing onto dequeStack: 0 1 2 3 4 5 6 7 8 9</code>&#13;
<code>Pushing onto vectorStack: 0 1 2 3 4 5 6 7 8 9</code>&#13;
<code>Pushing onto listStack: 0 1 2 3 4 5 6 7 8 9</code>&#13;
&#13;
<code>Popping from dequeStack: 9 8 7 6 5 4 3 2 1 0</code>&#13;
<code>Popping from vectorStack: 9 8 7 6 5 4 3 2 1 0</code>&#13;
<code>Popping from listStack: 9 8 7 6 5 4 3 2 1 0</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.10</strong></span> | Standard library <code>stack</code> adaptor class. (Part 2 of 2.)</p>&#13;
</div>&#13;
<p>The generic lambda <code>pushElements</code> (lines 10–15) pushes the values 0–9 onto a <strong><code>stack</code></strong>. Lines 32, 34 and 36 call this lambda for each <strong><code>stack</code></strong>. Line 12 uses function <strong><code>push</code></strong> (available in each adaptor class) to place an integer on top of the <strong><code>stack</code></strong>. Line 13 uses <strong><code>stack</code></strong> function <strong><code>top</code></strong> to retrieve the <strong><code>stack</code></strong>’s <strong>top</strong> element for output. <strong>Function <code>top</code> does not remove the top element.</strong></p>&#13;
<p>Function <code>popElements</code> (lines 18–23) pops the elements off each <strong><code>stack</code></strong>. Lines 40, 42 and 44 call this lambda for each <strong><code>stack</code></strong>. Line 20 uses <strong><code>stack</code></strong> function <strong><code>top</code></strong> to retrieve the <strong><code>stack</code>’s top</strong> element for output. Line 21 uses function <strong><code>pop</code></strong>, available in each adaptor class, to remove the <strong><code>stack</code>’s top</strong> element. <strong>Function <code>pop</code> does not return a value. So, you must call <code>top</code> to obtain the top element’s value before you <code>pop</code> that element from the stack</strong>.</p>&#13;
<h4 class="h4" id="sec13_10_2">13.10.2 <code>queue</code> Adaptor</h4>&#13;
<p>A queue is similar to a waiting line. The item in the queue the longest is the next one removed. So, a queue is referred to as a <strong><span class="violet">first-in, first-out (FIFO)</span></strong> data structure. Class <span class="violet"><strong><code>queue</code></strong></span> (from header <span class="violet"><strong><code>&lt;queue&gt;</code></strong></span>) enables insertions only at the <strong>back</strong> of the underlying data structure and deletions only from the <strong>front</strong>. A <code>queue</code> stores its elements in objects of the <strong><code>list</code></strong> or <strong><code>deque</code></strong> sequence containers—<strong><code>deque</code></strong> is the default. The common <code>queue</code> operations are:</p>&#13;
<p class="bull">• <strong><code>push</code></strong> to insert an element at the <strong><code>queue</code>’s</strong> back—implemented by calling the underlying container’s <strong><code>push_back</code></strong> member function,</p>&#13;
<p class="bull">• <strong><code>pop</code></strong> to remove the element at the <strong><code>queue</code>’s</strong> front—implemented by calling the underlying container’s <strong><code>pop_front</code></strong> member function,</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>front</code></strong></span> to get a reference to the <strong><code>queue</code>’s</strong> first element—implemented by calling the underlying container’s <strong><code>front</code></strong> member function,</p>&#13;
<p class="bull">• <span class="violet"> <strong><code>back</code></strong></span> to get a reference to the <strong><code>queue</code>’s</strong> last element—implemented by calling the underlying container’s <strong><code>back</code></strong> member function,</p>&#13;
<p class="bull">• <strong><code>empty</code></strong> to determine whether the <strong><code>queue</code></strong> is empty—this calls the underlying container’s <strong><code>empty</code></strong> member function, and</p>&#13;
<p class="bull">• <strong><code>size</code></strong> to get the <strong><code>queue</code>’s</strong> number of elements—this calls the underlying container’s <strong><code>size</code></strong> member function.</p>&#13;
<p><a href="ch13.xhtml#fig13_11">Figure 13.11</a> demonstrates the <strong><code>queue</code></strong> adaptor class. Line 7 instantiates a <strong><code>queue</code></strong> of <code>double</code>s. Lines 10–12 use function <strong><code>push</code></strong> to add elements to the <strong><code>queue</code></strong>. The <code>while</code> statement in lines 17–20 uses function <strong><code>empty</code></strong> (available in all containers) to determine whether the <strong><code>queue</code></strong> is empty (line 17). While there are more elements in the <strong><code>queue</code></strong>, line 18 uses <strong><code>queue</code></strong> function <strong><code>front</code></strong> to read (but not remove) the <strong><code>queue</code>’s</strong> first element for output. Line 19 removes the <strong><code>queue</code>’s</strong> first element with function <strong><code>pop</code></strong>, available in all adaptor classes.</p>&#13;
<div class="group" id="fig13_11">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro11" id="p13pro11a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_11.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library queue adaptor class template.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;queue&gt; <span class="lgreen">// queue adaptor definition</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>7</strong></span>      std::queue&lt;<span class="blue">double</span>&gt; values{}; <span class="lgreen">// queue with doubles</span>&#13;
<span class="cviolet"> <strong>8</strong></span>      &#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// push elements onto queue values</span>&#13;
<span class="cviolet"><strong>10</strong></span>      values.push(<span class="green">3.2</span>);&#13;
<span class="cviolet"><strong>11</strong></span>      values.push(<span class="green">9.8</span>);&#13;
<span class="cviolet"><strong>12</strong></span>      values.push(<span class="green">5.4</span>);&#13;
<span class="cviolet"><strong>13</strong></span>      &#13;
<span class="cviolet"><strong>14</strong></span>      std::cout &lt;&lt; <span class="green">"Popping from values: "</span>;&#13;
<span class="cviolet"><strong>15</strong></span>      &#13;
<span class="cviolet"><strong>16</strong></span>      <span class="lgreen">// pop elements from queue</span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">while</span> (!values.empty()) {&#13;
<span class="cviolet"><strong>18</strong></span>         std::cout &lt;&lt; values.front() &lt;&lt; <span class="green">' '</span>; <span class="lgreen">// view front element</span>&#13;
<span class="cviolet"><strong>19</strong></span>         values.pop(); <span class="lgreen">// remove element</span>&#13;
<span class="cviolet"><strong>20</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>23</strong></span>   }<br/></pre>&#13;
<pre class="pre1"><code>Popping from values: 3.2 9.8 5.4</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.11</strong></span> | Standard library <code>queue</code> adaptor class template. (Part 2 of 2.)</p>&#13;
</div>&#13;
<h4 class="h4" id="sec13_10_3">13.10.3 <code>priority_queue</code> Adaptor</h4>&#13;
<p>Class <span class="violet"><strong><code>priority_queue</code></strong></span> (from header <code>&lt;queue&gt;</code>) provides functionality that enables insertions in sorted order into the underlying data structure and deletions from the front of the underlying data structure. By default, a <strong><code>priority_queue</code></strong> stores its elements in a <strong><code>vector</code></strong>.<sup><a id="ch13fn15a" href="ch13.xhtml#ch13fn15">15</a></sup> Elements added to a <strong><code>priority_queue</code></strong> are inserted in <strong>priority order</strong>, such that the highest-priority element (i.e., the largest value) will be the first element removed. This is usually accomplished by arranging the elements in a data structure called a <strong><span class="violet">heap</span></strong>—not to be confused with the heap for dynamically allocated memory—that always maintains its largest value (i.e., highest-priority element) at the front of the data structure. Element comparisons are performed with <strong>comparator function object <code>less&lt;T&gt;</code></strong> by default.</p>&#13;
<p class="footnote"><a id="ch13fn15" href="ch13.xhtml#ch13fn15a">15</a>. <code>“std::priority_queue</code>.<code>”</code> Access April 15, 2021. <code><a href="https://en.cppreference.com/w/cpp/container/priority_queue">https://en.cppreference.com/w/cpp/container/priority_queue</a></code>.</p>&#13;
<p>The <strong><code>priority_queue</code></strong> operations include:</p>&#13;
<p class="bull">• Function <strong><code>push</code></strong> inserts an element at the appropriate location based on <strong>priority order</strong>.</p>&#13;
<p class="bull">• Function <strong><code>pop</code></strong> removes the <strong><code>priority_queue</code>’s highest-priority</strong> element.</p>&#13;
<p class="bull">• Function <span class="violet"><strong><code>top</code></strong></span> gets a reference to the <strong><code>priority_queue</code>’s top</strong> element—implemented by calling the underlying container’s <strong><code>front</code></strong> member function.</p>&#13;
<p class="bull">• Function <strong><code>empty</code></strong> determines whether the <strong><code>priority_queue</code></strong> is empty—implemented by calling the underlying container’s <strong><code>empty</code></strong> member function.</p>&#13;
<p class="bull">• Function <strong><code>size</code></strong> gets the <strong><code>priority_queue</code>’s</strong> number of elements—implemented by calling the underlying container’s <strong><code>size</code></strong> member function.</p>&#13;
<p><a href="ch13.xhtml#fig13_12">Figure 13.12</a> demonstrates the <strong><code>priority_queue</code></strong> adaptor. Line 7 instantiates a <strong><code>prior-ity_queue</code></strong> that stores <code>double</code> values and uses a <strong><code>vector</code></strong> as the underlying data structure. Lines 10–12 use member function <strong><code>push</code></strong> to add elements to the <strong><code>priority_queue</code></strong>. Lines 17–20 use member function <code>empty</code> (available in all containers) to determine whether the <strong><code>priority_queue</code></strong> is empty (line 17). If not, line 18 uses <strong><code>priority_queue</code></strong> function <strong><code>top</code></strong> to retrieve the <strong>highest-priority</strong> element (i.e., the largest value) in the <strong><code>priority_queue</code></strong> for output. Line 19 calls <strong><code>pop</code></strong>, available in all adaptor classes, to remove the <strong><code>priority_queue</code>’s highest-priority</strong> element.</p>&#13;
<div class="group" id="fig13_12">&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p13pro12" id="p13pro12a">Click here to view code image</a></p>&#13;
<pre class="pre2"><span class="cviolet"> <strong>1</strong></span>   <span class="lgreen">// fig13_12.cpp</span>&#13;
<span class="cviolet"> <strong>2</strong></span>   <span class="lgreen">// Standard library priority_queue adaptor class.</span>&#13;
<span class="cviolet"> <strong>3</strong></span>   <span class="blue">#include</span> &lt;iostream&gt;&#13;
<span class="cviolet"> <strong>4</strong></span>   <span class="blue">#include</span> &lt;queue&gt; <span class="lgreen">// priority_queue adaptor definition</span>&#13;
<span class="cviolet"> <strong>5</strong></span>&#13;
<span class="cviolet"> <strong>6</strong></span>   <span class="blue">int</span> main() {&#13;
<span class="cviolet"> <strong>7</strong></span>      std::priority_queue&lt;<span class="blue">double</span>&gt; priorities; <span class="lgreen">// create priority_queue</span>&#13;
<span class="cviolet"> <strong>8</strong></span><strong/>&#13;
<span class="cviolet"> <strong>9</strong></span>      <span class="lgreen">// push elements onto priorities</span>&#13;
<span class="cviolet"><strong>10</strong></span>      priorities.push(<span class="green">3.2</span>);&#13;
<span class="cviolet"><strong>11</strong></span>      priorities.push(<span class="green">9.8</span>);&#13;
<span class="cviolet"><strong>12</strong></span>      priorities.push(<span class="green">5.4</span>);&#13;
<span class="cviolet"><strong>13</strong></span>&#13;
<span class="cviolet"><strong>14</strong></span>      std::cout &lt;&lt; <span class="green">"Popping from priorities: "</span>;&#13;
<span class="cviolet"><strong>15</strong></span>      &#13;
<span class="cviolet"><strong>16</strong></span>      <span class="lgreen">// pop element from priority_queue</span>&#13;
<span class="cviolet"><strong>17</strong></span>      <span class="blue">while</span> (!priorities.empty()) {&#13;
<span class="cviolet"><strong>18</strong></span>         std::cout &lt;&lt; priorities.top() &lt;&lt; <span class="green">' '</span>; <span class="lgreen">// view top element</span>&#13;
<span class="cviolet"><strong>19</strong></span>         priorities.pop(); <span class="lgreen">// remove top element</span>&#13;
<span class="cviolet"><strong>20</strong></span>      <code>}</code>&#13;
<span class="cviolet"><strong>21</strong></span>&#13;
<span class="cviolet"><strong>22</strong></span>      std::cout &lt;&lt; <span class="green">"\n"</span>;&#13;
<span class="cviolet"><strong>23</strong></span>   }</pre>&#13;
<pre class="pre1"><code>Popping from priorities: 9.8 5.4 3.2</code></pre>&#13;
<p class="fig-caption"><span class="red"><strong>Fig. 13.12</strong></span> | Standard library <code>priority_queue</code> adaptor class.</p>&#13;
</div>&#13;
<h3 class="h3" id="sec13_11"><span class="violet">13.11</span> <code>bitset</code> Near Container</h3>&#13;
<p>Class <span class="violet"><strong><code>bitset</code></strong></span> makes it easy to create and manipulate <strong><span class="violet">bit sets</span></strong>, which are useful for representing a set of bit flags. <code>bitset</code>s are fixed in size at compile time. Class <code>bitset</code> is an alternate tool for bit manipulation, discussed in Appendix E.</p>&#13;
<p>The declaration</p>&#13;
<pre class="pre">bitset&lt;size&gt; b;</pre>&#13;
<p>creates <code>bitset b</code>, in which every one of the <code>size</code> bits is initially <code>0</code> (“off”).</p>&#13;
<p>The statement</p>&#13;
<pre class="pre">b.set(bitNumber);</pre>&#13;
<p>sets bit <code>bitNumber</code> of <code>bitset b</code> “on.” The expression <code>b.set()</code> sets all bits in <code>b</code> “on.”</p>&#13;
<p>The statement</p>&#13;
<pre class="pre">b.reset(bitNumber);</pre>&#13;
<p>sets bit <code>bitNumber</code> of <code>bitset b</code> “off.” The expression <code>b.reset()</code> sets all bits in <code>b</code> “off.”</p>&#13;
<p>The statement</p>&#13;
<pre class="pre">b.flip(bitNumber);</pre>&#13;
<p>“flips” bit <code>bitNumber</code> of <code>bitset b</code> (e.g., if the bit is “on”, <code>flip</code> sets it “off”). The expression <code>b.flip()</code> flips all bits in <code>b</code>.</p>&#13;
<p>The statement</p>&#13;
<pre class="pre">b[bitNumber];</pre>&#13;
<p>returns a reference to the <code>bool</code> at position <code>bitNumber</code> of <code>bitset b</code>. Similarly,</p>&#13;
<pre class="pre">b.at(bitNumber);</pre>&#13;
<p>performs range checking on <code>bitNumber</code> first. Then, if <code>bitNumber</code> is in range (based on the number of bits in the <code>bitset</code>), <code>at</code> returns a reference to the bit. Otherwise, <code>at</code> throws an <code>out_of_range</code> exception.</p>&#13;
<p>The statement</p>&#13;
<pre class="pre">b.test(bitNumber);</pre>&#13;
<p>performs range checking on <code>bitNumber</code> first. If <code>bitNumber</code> is in range (based on the number of bits in the <code>bitset</code>), <code>test</code> returns <code>true</code> if the bit is on, <code>false</code> it’s off. Otherwise, <code>test</code> throws an <code>out_of_range</code> exception.</p>&#13;
<p>The expression</p>&#13;
<pre class="pre">b.size()</pre>&#13;
<p>returns the number of bits in <code>bitset b</code>.</p>&#13;
<p>The expression</p>&#13;
<pre class="pre">b.count()</pre>&#13;
<p>returns the number of bits that are set (<code>true</code>) in <code>bitset b</code>.</p>&#13;
<p>The expression</p>&#13;
<pre class="pre">b.any()</pre>&#13;
<p>returns <code>true</code> if any bit is set in <code>bitset b</code>.</p>&#13;
<p>The expression</p>&#13;
<pre class="pre">b.all()</pre>&#13;
<p><span class="size">11</span> (added in C++11) returns <code>true</code> if all of the bits are set (<code>true</code>) in <code>bitset b</code>.</p>&#13;
<p>The expression</p>&#13;
<pre class="pre">b.none()</pre>&#13;
<p>returns <code>true</code> if none of the bits is set in <code>bitset b</code> (that is, all the bits are <code>false</code>).</p>&#13;
<p>The expressions</p>&#13;
<pre class="pre">b == b1&#13;
b != b1</pre>&#13;
<p>compare the two <code>bitset</code>s for equality and inequality, respectively.</p>&#13;
<p>Each of the bitwise assignment operators <code>&amp;=</code>, <code>|=</code> and <code>^=</code> (discussed in detail in Section E.5) can be used to combine <code>bitset</code>s. For example,</p>&#13;
<pre class="pre">b &amp;= b1;</pre>&#13;
<p>performs a bit-by-bit logical AND between <code>bitset</code>s <code>b</code> and <code>b1</code>. The result is stored in <code>b</code>. Bitwise logical OR and bitwise logical XOR are performed by</p>&#13;
<pre class="pre">b |= b1;&#13;
b ^= b2;</pre>&#13;
<p>The expression</p>&#13;
<pre class="pre">b &gt;&gt;= n;</pre>&#13;
<p>shifts the bits in <code>bitset b</code> right by <code>n</code> positions.</p>&#13;
<p>The expression</p>&#13;
<pre class="pre">b &lt;&lt;= n;</pre>&#13;
<p>shifts the bits in <code>bitset b</code> left by <code>n</code> positions.</p>&#13;
<p>The expressions</p>&#13;
<pre class="pre">b.to_string()&#13;
b.to_ulong()</pre>&#13;
<p>convert <code>bitset b</code> to a <code>string</code> and an <code>unsigned long</code>, respectively.</p>&#13;
<h3 class="h3" id="sec13_12"><span class="violet">13.12</span> Optional: A Brief Intro to Big <em>O</em></h3>&#13;
<p>In this chapter, you’ve seen Big <em>O</em> notations of <strong><em>O</em>(1)</strong>, <strong><em>O</em>(<em>n</em>)</strong> and <strong><em>O</em>(log <em>n</em>)</strong>. In this section, we’ll explain what those mean and introduce two others—<strong><em>O</em>(<em>n</em><sup>2</sup>)</strong> and <strong><em>O</em>(<em>n</em> log <em>n</em>)</strong>. All of these “Big <em>O</em>” expressions characterize the amount of work an algorithm must do when processing <em>n</em> items. On today’s desktop computers, which may process a few billion operations-per-second, that translates to whether a program will run almost instantaneously or take seconds, minutes, hours, days, months, years or even more to complete. Obviously, you’d prefer algorithms that complete quickly, even though the number of items <em>n</em> that they may be processing is large. This is especially true in today’s world of Big Data computing applications. In the implementation of the standard library containers and algorithms, Big <em>O</em>s of <strong><em>O</em>(1)</strong>, <strong><em>O</em>(<em>n</em>)</strong>, <strong><em>O</em>(log <em>n</em>)</strong> and even <strong><em>O</em>(<em>n</em> log <em>n</em>)</strong>—which is common for relatively good sorting algorithms—are considered to be reasonably efficient. Algorithms categorized by <strong><em>O</em>(<em>n</em><sup>2</sup>)</strong> or worse, such as <strong><em>O</em></strong>(2<strong><em><sup>n</sup></em>)</strong> or <strong><em>O</em>(<em>n</em>!)</strong>, could run on a modest number of items for centuries, millennia or longer. So you’ll want to avoid writing such algorithms.</p>&#13;
<p>Searching algorithms all accomplish the same goal—finding in a container (which for this discussion we’ll assume is an <strong><code>array</code></strong> container) an element matching a given search key, if such an element does, in fact, exist. There are, however, a number of things that differentiate search algorithms from one another. <strong>The major difference is the amount of effort they require to complete the search, based on the number of items they must search through.</strong> One way to describe this effort is with <strong><span class="violet">Big O notation</span></strong>, which indicates how hard an algorithm may have to work to solve a problem. For searching and sorting algorithms, this depends particularly on how many data elements there are.</p>&#13;
<h5><em>O</em>(1) Algorithms</h5>&#13;
<p>Suppose an algorithm is designed to test whether the first element of an <strong><code>array</code></strong> is equal to the second. If the <strong><code>array</code></strong> has 10 elements, this algorithm requires one comparison. If the <strong><code>array</code></strong> has 1000 elements, it still requires one comparison. In fact, the algorithm is completely independent of the number, <em>n</em>, of elements in the <strong><code>array</code></strong>. This algorithm is said to have <strong><span class="violet">constant run time</span></strong>, which is represented in Big O notation as <span class="violet"><em><strong>O</strong></em></span><strong><span class="violet">(1)</span></strong> and pronounced as “order one.” An algorithm that’s <strong><em>O</em>(1)</strong> does not necessarily require only one comparison. <strong><em>O</em>(1)</strong> just means that the number of comparisons is <em>constant</em>—it does not grow as the size of the <strong><code>array</code></strong> increases. An algorithm that tests whether the first element of an <strong><code>array</code></strong> is equal to any of the next three elements is still <strong><em>O</em>(1)</strong> even though it requires three comparisons.</p>&#13;
<h5><em>O</em>(<em>n</em>) Algorithms</h5>&#13;
<p>An algorithm that tests whether the first <strong><code>array</code></strong> element is equal to <em>any</em> of the other <strong><code>array</code></strong> elements will require at most <em>n</em> – 1 comparisons, where <em>n</em> is the number of <strong><code>array</code></strong> elements. If the <strong><code>array</code></strong> has 10 elements, this algorithm requires up to nine comparisons. If the <strong><code>array</code></strong> has 1000 elements, it requires up to 999 comparisons. As <em>n</em> grows larger, the <em>n</em> part of the expression <em>n</em> – 1 “dominates,” and subtracting one becomes inconsequential. Big O is designed to highlight these dominant terms and ignore terms that become unimportant as <em>n</em> grows. For this reason, an algorithm that requires a total of <em>n</em> – 1 comparisons (such as the one we described earlier) is said to be <span class="violet"><em><strong>O</strong></em></span><strong><span class="violet">(</span></strong><span class="violet"><em><strong>n</strong></em></span><strong><span class="violet">)</span></strong>. An <strong><em>O</em>(<em>n</em>)</strong> algorithm is referred to as having a <strong><span class="violet">linear run time</span></strong>. <strong><em>O</em>(<em>n</em>)</strong> is often pronounced “on the order of <em>n</em>” or simply “order <em>n</em>.”</p>&#13;
<h5><em>O</em>(<em>n</em><sup>2</sup>) Algorithms</h5>&#13;
<p>Computer science students learn that, unfortunately, it is easy to write simple sorting algorithms that are <em>O</em>(<em>n</em><sup>2</sup>). In Data Structures and Algorithms courses, the students learn that with clever algorithm design it’s possible to write sorting algorithms that are <em>O</em>(<em>n</em> log <em>n</em>)— these are far more efficient than <em>O</em>(<em>n</em><sup>2</sup>) algorithms.</p>&#13;
<h5 class="h5" id="ch13lev3sec35">Efficiency of the Linear Search <em>O</em>(<em>n</em>)</h5>&#13;
<p>The linear search algorithm, which is typically used for searching an unsorted <strong><code>array</code></strong>, runs in <strong><em>O</em>(<em>n</em>)</strong> time. The worst case in this algorithm is that every element must be checked to determine whether the search key exists in the <strong><code>array</code></strong>. If the size of the <strong><code>array</code></strong> is doubled, the number of comparisons that the algorithm must perform is also doubled. Linear search can provide outstanding performance if the element matching the search key happens to be at or near the front of the <strong><code>array</code></strong>. But we seek algorithms that perform well, on average, across all searches, including those where the element matching the search key is near the end of the <strong><code>array</code></strong>.</p>&#13;
<p>Linear search is easy to program, but it can be slow compared to other search algorithms, especially as <em>n</em> gets large. If a program needs to perform many searches on large <strong><code>array</code></strong>s, it’s better to implement a more efficient algorithm, such as the <code>binary_search</code> algorithm, which we’ll use in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> Sometimes the simplest algorithms perform poorly. Their virtue often is that they’re easy to program, test and debug. Sometimes more complex algorithms are required to realize maximum performance.</p>&#13;
<h5 class="h5" id="ch13lev3sec36">Efficiency of the Binary Search <em>O</em>(log <em>n</em>)</h5>&#13;
<p>In the worst-case scenario, searching a <em>sorted</em> <strong><code>array</code></strong> of 1023 elements (2<sup>10</sup> – 1) takes <em>only 10 comparisons</em> when using a binary search. The binary search algorithm compares the search key to the value in the middle of the sorted <strong><code>array</code></strong>. If it’s a match, the search is over. More likely the search key will be larger or smaller than the middle element. If it’s larger, we can eliminate the first half of the <strong><code>array</code></strong> from consideration. If it’s smaller than the middle element we can eliminate the second half of the <strong><code>array</code></strong> from consideration. This creates a halving effect so that on subsequent searches, we have to search only 511, 255, 127, 63, 31, 15, 7, 3 and 1 elements. The number 1023 (2<sup>10</sup> – 1) needs to be halved only 10 times to either find the key or determine that it’s not in the <strong><code>array</code></strong>. Dividing by 2 is equivalent to one comparison in the binary search algorithm. Thus, an <strong><code>array</code></strong> of 1,048,575 (2<sup>20</sup> – 1) elements takes a <em>maximum of 20 comparisons</em> to find the key, and an <strong><code>array</code></strong> of about one billion elements takes a <em>maximum of 30 comparisons</em> to find the key. This is a tremendous improvement in performance over the linear search. For a one-billion-element <strong><code>array</code></strong>, this is a difference between an average of 500 million comparisons for the linear search and a maximum of only 30 comparisons for the binary search! The maximum number of comparisons needed for the binary search of any sorted <strong><code>array</code></strong> is the exponent of the first power of 2 greater than the number of elements in the <strong><code>array</code></strong>, which is represented as log<sub>2</sub> <em>n</em>. All logarithms grow at “roughly the same rate,” so for Big <em>O</em> comparison purposes the base can be omitted. This results in a Big <em>O</em> of <span class="violet"><em><strong>O</strong></em></span><strong><span class="violet">(log</span></strong><span class="violet"> <em><strong>n</strong></em></span><strong><span class="violet">)</span></strong> for a binary search, which is also known as <strong><span class="violet">logarithmic run time</span></strong> and pronounced as “order log <em>n</em>.”</p>&#13;
<h5 class="h5" id="ch13lev3sec37">Common Big <em>O</em> Notations</h5>&#13;
<p>The following table lists various common Big <em>O</em> notations along with a number of values for <em>n</em> to highlight the differences in the growth rates. If you interpret the values in the table as seconds of calculation, you can easily see why <em>O</em>(<em>n</em><sup>2</sup>) algorithms are to be avoided!</p>&#13;
<div class="image"><img src="Images/738tab01.jpg" alt="Images" width="751" height="331"/></div>&#13;
<h3 class="h3" id="sec13_13"><span class="violet">13.13</span> Optional: A Brief Intro to Hash Tables</h3>&#13;
<p>When a program creates objects, it may need to store and retrieve them efficiently. Storing and retrieving information with <strong><code>array</code></strong>s is efficient if some aspect of your data directly matches a numerical key value and if the <em>keys are unique</em> and tightly packed. If you have 100 employees with nine-digit social security numbers and you want to store and retrieve employee data by using the social security number as an <strong><code>array</code></strong> index, the task will require an <strong><code>array</code></strong> with over 800 million elements, because nine-digit Social Security numbers must begin with 001–899 (excluding 666) as per the Social Security Administration’s website:</p>&#13;
<p class="codelink"><a href="Images/ch13_images.xhtml#p738pro01" id="p738pro01a">Click here to view code image</a></p>&#13;
<pre class="pre">https://www.ssa.gov/employer/randomization.html</pre>&#13;
<p>This is impractical for most applications that use social security numbers as keys. A program having so large an <strong><code>array</code></strong> could achieve high performance for both storing and retrieving employee records by simply using the social security number as the <strong><code>array</code></strong> index.</p>&#13;
<p>Numerous applications have this problem—namely, that either the keys are of the wrong type (e.g., not positive integers that correspond to <strong><code>array</code></strong> subscripts) or they’re of the right type, but <em>sparsely</em> spread over a <em>huge range</em>, such as social-security numbers for all the employees in a small company. What is needed is a high-speed scheme for converting keys such as social-security numbers, inventory part numbers and the like into unique <strong><code>array</code></strong> indices over a modest-size <strong><code>array</code></strong>. Then, when an application needs to store something, the scheme can convert the application’s key rapidly into an <strong><code>array</code></strong> index (a process called <strong><span class="violet">hashing</span></strong>), and the data can be stored at that slot in the <strong><code>array</code></strong>. Retrieval is accomplished the same way: Once the application has a key for which it wants to retrieve the data, the application simply applies the conversion to the key (again, called hashing)—this produces the <strong><code>array</code></strong> index where the data is stored and retrieved.</p>&#13;
<p>Why the name hashing? When we convert a key into an <strong><code>array</code></strong> index, we literally scramble the bits, forming a kind of “mishmashed,” or hashed, number. The number actually has no real significance beyond its usefulness in storing and retrieving particular data.</p>&#13;
<p>A glitch in the scheme is called a <strong><span class="violet">collision</span></strong>—this occurs when two different keys “hash into” the same cell (or element) in the <strong><code>array</code></strong>. We cannot store two values in the same space, so we need to find an alternative home for all values beyond the first that hash to the same <strong><code>array</code></strong> index. There are many schemes for doing this. One is to “hash again”— that is, to apply another hashing transformation to the previous hash result to provide the next candidate cell in the <strong><code>array</code></strong>. The hashing process is designed to distribute the values throughout the table, so hopefully an available cell will be found with one or a few hashes.</p>&#13;
<p>Another scheme uses one hash to locate the first candidate cell. If that cell is occupied, adjacent cells are searched sequentially until an available cell is found. Retrieval works the same way: The key is hashed once to determine the initial location and check whether it contains the desired data. If it does, the search is finished; otherwise, successive cells are searched sequentially until the desired data is found. A popular solution to hash-table collisions is to have each cell of the table be a <strong><span class="violet">hash bucket</span></strong>—typically a linked list of all the key–value pairs that hash to that cell.</p>&#13;
<p>A hash table’s <strong><span class="violet">load factor</span></strong> affects the performance of hashing schemes<em>.</em> The load factor is the ratio of the number of occupied cells in the hash table to the total number of cells in the hash table. The closer this ratio gets to 1.0, the greater the chance of collisions, which slow data insertion and retrieval.</p>&#13;
<p><span class="size">Perf</span><img class="inline" src="Images/perf.jpg" alt="Images" width="31" height="27"/> The load factor in a hash table is a classic example of a memory-space/execution-time trade-off: By increasing the load factor, we get better memory utilization, but the program runs slower, due to increased hashing collisions. By decreasing the load factor, we get better program speed, because of reduced hashing collisions, but we get poorer memory utilization, because a larger portion of the hash table remains empty.</p>&#13;
<p>C++’s <strong><code>unordered_set</code></strong>, <strong><code>unordered_multiset</code></strong>, <strong><code>unordered_map</code></strong> and <strong><code>unordered_multimap</code></strong> associative containers are implemented as hash tables “under the hood.” When you use those containers, you get the benefit of high-speed data storage and retrieval without having to build your own hash-table mechanisms—a classic example of reuse. This concept is profoundly important in our study of object-oriented programming. As discussed in earlier chapters, classes encapsulate and hide complexity (i.e., implementation details) and offer user-friendly interfaces. Properly crafting classes to exhibit such behavior is one of the most valued skills in the field of object-oriented programming.</p>&#13;
<h3 class="h3" id="sec13_14"><span class="violet">13.14</span> Wrap-Up</h3>&#13;
<p>In this chapter, we introduced three key components of the standard library—containers, iterators and algorithms. You learned about the linear <strong>sequence containers</strong>, <strong><code>array</code></strong> (<a href="ch06.xhtml#ch06">Chapter 6</a>), <strong><code>vector</code></strong>, <strong><code>deque</code></strong>, <strong><code>forward_list</code></strong> and <strong><code>list</code></strong>, which all represent linear data structures. We discussed the nonlinear <strong>associative containers</strong>, <strong><code>set</code></strong>, <strong><code>multiset</code></strong>, <strong><code>map</code></strong> and <strong><code>multi-map</code></strong> and their unordered versions. You also saw that the <strong>container adaptors <code>stack</code></strong>, <strong><code>queue</code></strong> and <strong><code>priority_queue</code></strong> can be used to restrict the operations of the sequence containers <strong><code>vector</code></strong>, <strong><code>deque</code></strong> and <strong><code>list</code></strong> for the purpose of implementing the specialized data structures represented by the container adaptors. You learned the categories of iterators and that each algorithm can be used with any container that supports the minimum iterator functionality the algorithm requires. We distinguished between common ranges and C++20 ranges and demonstrated the <code>std::ranges::copy</code> algorithm. You also learned the features of class <code>bitset</code>, which makes it easy to create and manipulate bit sets as a container.</p>&#13;
<p><a href="ch14.xhtml#ch14">Chapter 14</a> continues our discussion of the standard library’s containers, iterators and algorithms with a detailed treatment of algorithms. You’ll see that C++20 concepts have been used extensively in the latest version of the standard library. We’ll discuss the minimum iterator requirements that determine which containers can be used with each algorithm. We’ll continue our discussion of lambda expressions and see that function pointers and function objects (instances of classes that overload the parentheses operator) can be passed to algorithms. In <a href="ch15.xhtml#ch15">Chapter 15</a>, you’ll see how C++20 concepts come into play when we build a custom container and a custom iterator.</p>&#13;
</div></body>
</html>